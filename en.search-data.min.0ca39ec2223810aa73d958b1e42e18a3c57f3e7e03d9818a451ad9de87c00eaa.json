[{"id":0,"href":"/docs/linux/linux-kernel/net/ipv6/inet6/","title":"Inet6","section":"ipv6/ ipv6的处理部分","content":" 一、总述 # 1. 关键结构体关系 # @startuml xxx class socket { struct sock *sk; } class sock {} class inet_sock implements sock { struct sock sk; } note left of inet_sock inet_sock是在sock基础上做了一些拓展 创建时申请的是inet_sock但是使用sock结构体指针赋值给socket 在inet里面的操作做强转使用 end note class inet_connection_sock implements inet_sock { struct inet_sock icsk_inet; } note left of inet_connection_sock inet_connection_sock是拓展了inet_sock 同样复用sock的指针 end note socket \u0026lt;|-- sock @enduml 二、socket创建过程 inet6_create # 初始化注册inet6_family_ops 1// net/ipv6/af_inet6.c 2 3static const struct net_proto_family inet6_family_ops = { 4\t.family = PF_INET6, 5\t.create = inet6_create, 6\t.owner\t= THIS_MODULE, 7}; 8 9static int __init inet6_init(void) 10{ 11 ... 12\t/* Register the family here so that the init calls below will 13\t* be able to create sockets. (?? is this dangerous ??) 14\t*/ 15\terr = sock_register(\u0026amp;inet6_family_ops); 16\tif (err) 17\tgoto out_sock_register_fail; 18 ... 19} 20module_init(inet6_init); 创建调用pf-\u0026gt;create也就是inet6_create 1// net/ipv6/af_inet6.c 2static int inet6_create(struct net *net, struct socket *sock, int protocol, 3\tint kern) 4{ 5\tstruct inet_sock *inet; 6\tstruct ipv6_pinfo *np; 7\tstruct sock *sk; 8\tstruct inet_protosw *answer; 9\tstruct proto *answer_prot; 10\tunsigned char answer_flags; 11\tint try_loading_module = 0; 12\tint err; 13 14\tif (protocol \u0026lt; 0 || protocol \u0026gt;= IPPROTO_MAX) 15\treturn -EINVAL; 16 17\t/* Look for the requested type/protocol pair. */ 18lookup_protocol: 19\terr = -ESOCKTNOSUPPORT; 20\trcu_read_lock(); 21 // 从inetsw6中找到对应协议的结构体，赋值给answer变量 22\tlist_for_each_entry_rcu(answer, \u0026amp;inetsw6[sock-\u0026gt;type], list) { 23 24\terr = 0; 25\t/* Check the non-wild match. */ 26\tif (protocol == answer-\u0026gt;protocol) { 27\tif (protocol != IPPROTO_IP) 28\tbreak; 29\t} else { 30\t/* Check for the two wild cases. */ 31\tif (IPPROTO_IP == protocol) { 32\tprotocol = answer-\u0026gt;protocol; 33\tbreak; 34\t} 35\tif (IPPROTO_IP == answer-\u0026gt;protocol) 36\tbreak; 37\t} 38\terr = -EPROTONOSUPPORT; 39\t} 40 41\tif (err) { 42\tif (try_loading_module \u0026lt; 2) { 43\trcu_read_unlock(); 44\t/* 45\t* Be more specific, e.g. net-pf-10-proto-132-type-1 46\t* (net-pf-PF_INET6-proto-IPPROTO_SCTP-type-SOCK_STREAM) 47\t*/ 48\tif (++try_loading_module == 1) 49\trequest_module(\u0026#34;net-pf-%d-proto-%d-type-%d\u0026#34;, 50\tPF_INET6, protocol, sock-\u0026gt;type); 51\t/* 52\t* Fall back to generic, e.g. net-pf-10-proto-132 53\t* (net-pf-PF_INET6-proto-IPPROTO_SCTP) 54\t*/ 55\telse 56\trequest_module(\u0026#34;net-pf-%d-proto-%d\u0026#34;, 57\tPF_INET6, protocol); 58\tgoto lookup_protocol; 59\t} else 60\tgoto out_rcu_unlock; 61\t} 62 63\terr = -EPERM; 64\tif (sock-\u0026gt;type == SOCK_RAW \u0026amp;\u0026amp; !kern \u0026amp;\u0026amp; 65\t!ns_capable(net-\u0026gt;user_ns, CAP_NET_RAW)) 66\tgoto out_rcu_unlock; 67 68 // 将对应协议的操作放到sock里面 69\tsock-\u0026gt;ops = answer-\u0026gt;ops; 70\tanswer_prot = answer-\u0026gt;prot; 71\tanswer_flags = answer-\u0026gt;flags; 72\trcu_read_unlock(); 73 74\tWARN_ON(!answer_prot-\u0026gt;slab); 75 76\terr = -ENOBUFS; 77 // 给struct sock *sk申请内存 78 // 同时把sk-\u0026gt;sk_prot = answer_prot也就是对应的inetsw6[proto]-\u0026gt;prot 79\tsk = sk_alloc(net, PF_INET6, GFP_KERNEL, answer_prot, kern); 80\tif (!sk) 81\tgoto out; 82 83\tsock_init_data(sock, sk); 84 85\terr = 0; 86\tif (INET_PROTOSW_REUSE \u0026amp; answer_flags) 87\tsk-\u0026gt;sk_reuse = SK_CAN_REUSE; 88 89\tinet = inet_sk(sk); 90\tinet-\u0026gt;is_icsk = (INET_PROTOSW_ICSK \u0026amp; answer_flags) != 0; 91 92\tif (SOCK_RAW == sock-\u0026gt;type) { 93\tinet-\u0026gt;inet_num = protocol; 94\tif (IPPROTO_RAW == protocol) 95\tinet-\u0026gt;hdrincl = 1; 96\t} 97 98\tsk-\u0026gt;sk_destruct\t= inet_sock_destruct; // sk设置析构函数 99\tsk-\u0026gt;sk_family\t= PF_INET6; 100\tsk-\u0026gt;sk_protocol\t= protocol; 101 102\tsk-\u0026gt;sk_backlog_rcv\t= answer-\u0026gt;prot-\u0026gt;backlog_rcv; 103 104\tinet_sk(sk)-\u0026gt;pinet6 = np = inet6_sk_generic(sk); 105\tnp-\u0026gt;hop_limit\t= -1; 106\tnp-\u0026gt;mcast_hops\t= IPV6_DEFAULT_MCASTHOPS; 107\tnp-\u0026gt;mc_loop\t= 1; 108\tnp-\u0026gt;mc_all\t= 1; 109\tnp-\u0026gt;pmtudisc\t= IPV6_PMTUDISC_WANT; 110\tnp-\u0026gt;repflow\t= net-\u0026gt;ipv6.sysctl.flowlabel_reflect \u0026amp; FLOWLABEL_REFLECT_ESTABLISHED; 111\tsk-\u0026gt;sk_ipv6only\t= net-\u0026gt;ipv6.sysctl.bindv6only; 112 113\t/* Init the ipv4 part of the socket since we can have sockets 114\t* using v6 API for ipv4. 115\t*/ 116\tinet-\u0026gt;uc_ttl\t= -1; 117 118\tinet-\u0026gt;mc_loop\t= 1; 119\tinet-\u0026gt;mc_ttl\t= 1; 120\tinet-\u0026gt;mc_index\t= 0; 121\tRCU_INIT_POINTER(inet-\u0026gt;mc_list, NULL); 122\tinet-\u0026gt;rcv_tos\t= 0; 123 124\tif (READ_ONCE(net-\u0026gt;ipv4.sysctl_ip_no_pmtu_disc)) 125\tinet-\u0026gt;pmtudisc = IP_PMTUDISC_DONT; 126\telse 127\tinet-\u0026gt;pmtudisc = IP_PMTUDISC_WANT; 128\t/* 129\t* Increment only the relevant sk_prot-\u0026gt;socks debug field, this changes 130\t* the previous behaviour of incrementing both the equivalent to 131\t* answer-\u0026gt;prot-\u0026gt;socks (inet6_sock_nr) and inet_sock_nr. 132\t* 133\t* This allows better debug granularity as we\u0026#39;ll know exactly how many 134\t* UDPv6, TCPv6, etc socks were allocated, not the sum of all IPv6 135\t* transport protocol socks. -acme 136\t*/ 137\tsk_refcnt_debug_inc(sk); 138 139\tif (inet-\u0026gt;inet_num) { 140\t/* It assumes that any protocol which allows 141\t* the user to assign a number at socket 142\t* creation time automatically shares. 143\t*/ 144\tinet-\u0026gt;inet_sport = htons(inet-\u0026gt;inet_num); 145\terr = sk-\u0026gt;sk_prot-\u0026gt;hash(sk); 146\tif (err) { 147\tsk_common_release(sk); 148\tgoto out; 149\t} 150\t} 151 // 找对应传输层协议调用init 152\tif (sk-\u0026gt;sk_prot-\u0026gt;init) { 153\terr = sk-\u0026gt;sk_prot-\u0026gt;init(sk); 154\tif (err) { 155\tsk_common_release(sk); 156\tgoto out; 157\t} 158\t} 159 160\tif (!kern) { 161\terr = BPF_CGROUP_RUN_PROG_INET_SOCK(sk); 162\tif (err) { 163\tsk_common_release(sk); 164\tgoto out; 165\t} 166\t} 167out: 168\treturn err; 169out_rcu_unlock: 170\trcu_read_unlock(); 171\tgoto out; 172} inetsw6的定义 1// net/ipv6/af_inet6.c 2/* The inetsw6 table contains everything that inet6_create needs to 3 * build a new socket. 4 */ 5static struct list_head inetsw6[SOCK_MAX]; 6static DEFINE_SPINLOCK(inetsw6_lock); 7// 使用下面函数注册inetsw6 8int inet6_register_protosw(struct inet_protosw *p) 9{ 10\tstruct list_head *lh; 11\tstruct inet_protosw *answer; 12\tstruct list_head *last_perm; 13\tint protocol = p-\u0026gt;protocol; 14\tint ret; 15 16\tspin_lock_bh(\u0026amp;inetsw6_lock); 17 18\tret = -EINVAL; 19\tif (p-\u0026gt;type \u0026gt;= SOCK_MAX) 20\tgoto out_illegal; 21 22\t/* If we are trying to override a permanent protocol, bail. */ 23\tanswer = NULL; 24\tret = -EPERM; 25\tlast_perm = \u0026amp;inetsw6[p-\u0026gt;type]; 26\tlist_for_each(lh, \u0026amp;inetsw6[p-\u0026gt;type]) { 27\tanswer = list_entry(lh, struct inet_protosw, list); 28 29\t/* Check only the non-wild match. */ 30\tif (INET_PROTOSW_PERMANENT \u0026amp; answer-\u0026gt;flags) { 31\tif (protocol == answer-\u0026gt;protocol) 32\tbreak; 33\tlast_perm = lh; 34\t} 35 36\tanswer = NULL; 37\t} 38\tif (answer) 39\tgoto out_permanent; 40 41\t/* Add the new entry after the last permanent entry if any, so that 42\t* the new entry does not override a permanent entry when matched with 43\t* a wild-card protocol. But it is allowed to override any existing 44\t* non-permanent entry. This means that when we remove this entry, the 45\t* system automatically returns to the old behavior. 46\t*/ 47\tlist_add_rcu(\u0026amp;p-\u0026gt;list, last_perm); 48\tret = 0; 49out: 50\tspin_unlock_bh(\u0026amp;inetsw6_lock); 51\treturn ret; 52 53out_permanent: 54\tpr_err(\u0026#34;Attempt to override permanent protocol %d\\n\u0026#34;, protocol); 55\tgoto out; 56 57out_illegal: 58\tpr_err(\u0026#34;Ignoring attempt to register invalid socket type %d\\n\u0026#34;, 59\tp-\u0026gt;type); 60\tgoto out; 61} 62EXPORT_SYMBOL(inet6_register_protosw); 注册地方 1// net/ipv6/tcp_ipv6.c 2int __init tcpv6_init(void) 3{ 4 ... 5\t/* register inet6 protocol */ 6\tret = inet6_register_protosw(\u0026amp;tcpv6_protosw); 7\tif (ret) 8\tgoto out_tcpv6_protocol; 9 ... 10} 11 12// net/ipv6/udp.c 13int __init udpv6_init(void) 14{ 15 ... 16\tret = inet6_register_protosw(\u0026amp;udpv6_protosw); 17\tif (ret) 18\tgoto out_udpv6_protocol; 19 ... 20} "},{"id":1,"href":"/docs/linux/linux-kernel/kernel/sched/","title":"/kernel/sched/ 进程调度","section":"/kernel/ 内核运行主要代码","content":" Linux完全公平调度算法原理与实现 CFS调度器 - 进程与线程（二十二） Linux内核锁 —— 进程调度 load_balance函数代码详解\n"},{"id":2,"href":"/docs/leetcode/simple/leetcode1/","title":"1. Two Sum","section":"简单","content":" 题目 # Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\n思路1 # 暴力遍历，每个数字都向后找自己的另一半 思路2 # 每个数字向前找自己的另一半，比上一种遍历少一点 思路3 # 在思路2的基础上，找另一半的算法加上优化，使用hashmap进行查找 1func TwoSum(nums []int, target int) []int { 2\thashMap := make(map[int]int) 3\tfor i, v := range nums { 4\texpect := target - v 5\tindex1, ok := hashMap[expect] 6\tif ok { 7\treturn []int{index1, i} 8\t} 9\thashMap[v] = i 10\t} 11\treturn nil 12} "},{"id":3,"href":"/docs/c++/","title":"C++源码分析记录","section":"Docs","content":" Introduction # 使用的是c++ 12.2.0编译器\n"},{"id":4,"href":"/docs/linux/linux-kernel/data-structures/container_of/","title":"container_of() 根据成员地址找其所在结构体","section":"数据结构","content":" 一、源码 # 1// include/linux/kernel.h 2 3/** 4 * container_of - cast a member of a structure out to the containing structure 5 * @ptr:\tthe pointer to the member. 6 * @type:\tthe type of the container struct this is embedded in. 7 * @member:\tthe name of the member within the struct. 8 * 9 */ 10#define container_of(ptr, type, member) ({\t\\ 11\tvoid *__mptr = (void *)(ptr);\t\\ 12\tBUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)-\u0026gt;member) \u0026amp;\u0026amp;\t\\ 13\t!__same_type(*(ptr), void),\t\\ 14\t\u0026#34;pointer type mismatch in container_of()\u0026#34;);\t\\ 15\t((type *)(__mptr - offsetof(type, member))); }) 二、分析 # 这个东西看了好久才看懂，不过真的很强大 考虑一个场景，我们定义树需要怎么写，类似下面这样 1struct treeNode { 2 treeNode *left; 3 treeNode *right; 4 void *value; 5}; 这时发现这个value每次都要定义，并且每个treeNode都需要新建地址 linux的这群大佬就开始搞事情，如果treeNode的地址和value的地址结合一下，不用每次创建两个地址，一个地址搞定 这时候就出现一种定义方式 1struct treeNode { 2 treeNode *left; 3 treeNode *right; 4}; 5 6struct valueTemplate { 7 treeNode node; 8 int value; 9} 这样写，对树操作时不用关心value是啥，只需要关心自己的数据结构实现就好了 但是怎么找到value呢，container_of就出现了 1#define container_of(ptr, type, member) \\ 2 (type *)((char *)(ptr) - (char *) \u0026amp;((type *)0)-\u0026gt;member) 3 4// 示例用法 5void func(treeNode *node) { 6 valueTemplate *value = container_of(node, struct valueTemplate, node) 7} 展开一下 1valueTemplate *value = (valueTemplate *)((char *)node - (char *)\u0026amp;((valueTemplate *)0)-\u0026gt;node) 加地址是向后偏移，减地址是向前偏移，所以这句话意思是通过成员变量找到结构体指针 使用0地址的成员变量的地址偏移来计算结构体指针到成员变量的偏移量，然后用成员变量地址向前偏移去查找value 这个想法是真的强大 "},{"id":5,"href":"/docs/linux/linux-kernel/","title":"linux内核源码分析记录","section":"linux","content":" Introduction # 内核源码版本: 5.19-arch1\n编译 # 1. 文档 # 1# 生成html方式的文档 2make htmldocs "},{"id":6,"href":"/docs/nginx/nginx/","title":"nginx","section":"nginx与openresty源码分析记录","content":"nginx版本1.22.0\n"},{"id":7,"href":"/docs/nginx/nginx/common/","title":"nginx结构综述","section":"nginx","content":" 一、nginx处理的几个阶段 # "},{"id":8,"href":"/docs/linux/linux-kernel/net/socket/socket/","title":"socket总述","section":"socket","content":" 一、总述 # 1. socket 相关内核结构体 # @startuml xxx namespace 用户空间 { class fd } namespace 内核空间 { class socket { socket_state\tstate; struct file\t*file; struct sock\t*sk; const struct proto_ops\t*ops; } enum socket_state { SS_FREE = 0,\t/* not allocated\t*/ SS_UNCONNECTED,\t/* unconnected to any socket\t*/ SS_CONNECTING,\t/* in process of connecting\t*/ SS_CONNECTED,\t/* connected to socket\t*/ SS_DISCONNECTING\t/* in process of disconnecting\t*/ } class file {} class sock { struc sock_common __sk_common; } class sock_common { volatile unsigned char skc_state; struct proto\t*skc_prot; } note right of sock sk_state =\u0026gt; __sk_common.skc_state\ttcp状态存在这里 sk_prot =\u0026gt; __sk_common.skc_prot\t传输层特殊操作在这里 end note sock \u0026lt;|-- sock_common class proto_ops { int\tfamily; int\t(*release) (struct socket *sock); int\t(*bind)\t(struct socket *sock, struct sockaddr *myaddr, int sockaddr_len); int\t(*connect) (struct socket *sock, struct sockaddr *vaddr, int sockaddr_len, int flags); int\t(*socketpair)(struct socket *sock1, struct socket *sock2); int\t(*accept) (struct socket *sock, struct socket *newsock, int flags, bool kern); int\t(*getname) (struct socket *sock, struct sockaddr *addr, int peer); __poll_t (*poll)\t(struct file *file, struct socket *sock, struct poll_table_struct *wait); int\t(*ioctl) (struct socket *sock, unsigned int cmd, unsigned long arg); int\t(*gettstamp) (struct socket *sock, void __user *userstamp, bool timeval, bool time32); int\t(*listen) (struct socket *sock, int len); int\t(*shutdown) (struct socket *sock, int flags); int\t(*setsockopt)(struct socket *sock, int level, int optname, sockptr_t optval, unsigned int optlen); int\t(*getsockopt)(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen); void\t(*show_fdinfo)(struct seq_file *m, struct socket *sock); int\t(*sendmsg) (struct socket *sock, struct msghdr *m, size_t total_len); int\t(*recvmsg) (struct socket *sock, struct msghdr *m, size_t total_len, int flags); int\t(*mmap)\t(struct file *file, struct socket *sock, struct vm_area_struct * vma); ssize_t\t(*sendpage) (struct socket *sock, struct page *page, int offset, size_t size, int flags); ssize_t (*splice_read)(struct socket *sock, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags); int\t(*set_peek_off)(struct sock *sk, int val); int\t(*peek_len)(struct socket *sock); int\t(*read_sock)(struct sock *sk, read_descriptor_t *desc, sk_read_actor_t recv_actor); int\t(*sendpage_locked)(struct sock *sk, struct page *page, int offset, size_t size, int flags); int\t(*sendmsg_locked)(struct sock *sk, struct msghdr *msg, size_t size); int\t(*set_rcvlowat)(struct sock *sk, int val); } socket \u0026lt;|-- file socket \u0026lt;|-- sock socket \u0026lt;|-- proto_ops socket \u0026lt;|-- socket_state class net_families { net_proto_family[] } class net_proto_family { int\tfamily; int\t(*create)(struct net *net, struct socket *sock, int protocol, int kern); } net_families \u0026lt;|-- net_proto_family net_proto_family --\u0026gt; socket: 根据family调用create创建 class inet_family_ops implements net_proto_family { .family = PF_INET, .create = inet_create, } class unix_family_ops implements net_proto_family { .family = PF_UNIX, .create = unix_create, } } 用户空间.fd ..\u0026gt; 内核空间.file @enduml 1.1. socket # socket_state仅代表socket自己的状态，和tcp状态图没关系 1// include/linux/net.h 2/** 3 * struct socket - general BSD socket 4 * @state: socket state (%SS_CONNECTED, etc) 5 * @type: socket type (%SOCK_STREAM, etc) 6 * @flags: socket flags (%SOCK_NOSPACE, etc) 7 * @ops: protocol specific socket operations 8 * @file: File back pointer for gc 9 * @sk: internal networking protocol agnostic socket representation 10 * @wq: wait queue for several uses 11 */ 12struct socket { 13\tsocket_state\tstate; 14 15\tshort\ttype; 16 17\tunsigned long\tflags; 18 19\tstruct file\t*file; 20\tstruct sock\t*sk; 21\tconst struct proto_ops\t*ops; 22 23\tstruct socket_wq\twq; 24}; proto_ops # 1// include/linux/net.h 2struct proto_ops { 3\tint\tfamily; 4\tstruct module\t*owner; 5\tint\t(*release) (struct socket *sock); 6\tint\t(*bind)\t(struct socket *sock, 7\tstruct sockaddr *myaddr, 8\tint sockaddr_len); 9\tint\t(*connect) (struct socket *sock, 10\tstruct sockaddr *vaddr, 11\tint sockaddr_len, int flags); 12\tint\t(*socketpair)(struct socket *sock1, 13\tstruct socket *sock2); 14\tint\t(*accept) (struct socket *sock, 15\tstruct socket *newsock, int flags, bool kern); 16\tint\t(*getname) (struct socket *sock, 17\tstruct sockaddr *addr, 18\tint peer); 19\t__poll_t\t(*poll)\t(struct file *file, struct socket *sock, 20\tstruct poll_table_struct *wait); 21\tint\t(*ioctl) (struct socket *sock, unsigned int cmd, 22\tunsigned long arg); 23#ifdef CONFIG_COMPAT 24\tint\t(*compat_ioctl) (struct socket *sock, unsigned int cmd, 25\tunsigned long arg); 26#endif 27\tint\t(*gettstamp) (struct socket *sock, void __user *userstamp, 28\tbool timeval, bool time32); 29\tint\t(*listen) (struct socket *sock, int len); 30\tint\t(*shutdown) (struct socket *sock, int flags); 31\tint\t(*setsockopt)(struct socket *sock, int level, 32\tint optname, sockptr_t optval, 33\tunsigned int optlen); 34\tint\t(*getsockopt)(struct socket *sock, int level, 35\tint optname, char __user *optval, int __user *optlen); 36\tvoid\t(*show_fdinfo)(struct seq_file *m, struct socket *sock); 37\tint\t(*sendmsg) (struct socket *sock, struct msghdr *m, 38\tsize_t total_len); 39\t/* Notes for implementing recvmsg: 40\t* =============================== 41\t* msg-\u0026gt;msg_namelen should get updated by the recvmsg handlers 42\t* iff msg_name != NULL. It is by default 0 to prevent 43\t* returning uninitialized memory to user space. The recvfrom 44\t* handlers can assume that msg.msg_name is either NULL or has 45\t* a minimum size of sizeof(struct sockaddr_storage). 46\t*/ 47\tint\t(*recvmsg) (struct socket *sock, struct msghdr *m, 48\tsize_t total_len, int flags); 49\tint\t(*mmap)\t(struct file *file, struct socket *sock, 50\tstruct vm_area_struct * vma); 51\tssize_t\t(*sendpage) (struct socket *sock, struct page *page, 52\tint offset, size_t size, int flags); 53\tssize_t (*splice_read)(struct socket *sock, loff_t *ppos, 54\tstruct pipe_inode_info *pipe, size_t len, unsigned int flags); 55\tint\t(*set_peek_off)(struct sock *sk, int val); 56\tint\t(*peek_len)(struct socket *sock); 57 58\t/* The following functions are called internally by kernel with 59\t* sock lock already held. 60\t*/ 61\tint\t(*read_sock)(struct sock *sk, read_descriptor_t *desc, 62\tsk_read_actor_t recv_actor); 63\tint\t(*sendpage_locked)(struct sock *sk, struct page *page, 64\tint offset, size_t size, int flags); 65\tint\t(*sendmsg_locked)(struct sock *sk, struct msghdr *msg, 66\tsize_t size); 67\tint\t(*set_rcvlowat)(struct sock *sk, int val); 68}; 1.2. sock # 1// include/net/sock.h 2/** 3 *\tstruct sock - network layer representation of sockets 4 *\t@__sk_common: shared layout with inet_timewait_sock 5 *\t@sk_shutdown: mask of %SEND_SHUTDOWN and/or %RCV_SHUTDOWN 6 *\t@sk_userlocks: %SO_SNDBUF and %SO_RCVBUF settings 7 *\t@sk_lock:\tsynchronizer 8 *\t@sk_kern_sock: True if sock is using kernel lock classes 9 *\t@sk_rcvbuf: size of receive buffer in bytes 10 *\t@sk_wq: sock wait queue and async head 11 *\t@sk_rx_dst: receive input route used by early demux 12 *\t@sk_rx_dst_ifindex: ifindex for @sk_rx_dst 13 *\t@sk_rx_dst_cookie: cookie for @sk_rx_dst 14 *\t@sk_dst_cache: destination cache 15 *\t@sk_dst_pending_confirm: need to confirm neighbour 16 *\t@sk_policy: flow policy 17 *\t@sk_receive_queue: incoming packets 18 *\t@sk_wmem_alloc: transmit queue bytes committed 19 *\t@sk_tsq_flags: TCP Small Queues flags 20 *\t@sk_write_queue: Packet sending queue 21 *\t@sk_omem_alloc: \u0026#34;o\u0026#34; is \u0026#34;option\u0026#34; or \u0026#34;other\u0026#34; 22 *\t@sk_wmem_queued: persistent queue size 23 *\t@sk_forward_alloc: space allocated forward 24 *\t@sk_reserved_mem: space reserved and non-reclaimable for the socket 25 *\t@sk_napi_id: id of the last napi context to receive data for sk 26 *\t@sk_ll_usec: usecs to busypoll when there is no data 27 *\t@sk_allocation: allocation mode 28 *\t@sk_pacing_rate: Pacing rate (if supported by transport/packet scheduler) 29 *\t@sk_pacing_status: Pacing status (requested, handled by sch_fq) 30 *\t@sk_max_pacing_rate: Maximum pacing rate (%SO_MAX_PACING_RATE) 31 *\t@sk_sndbuf: size of send buffer in bytes 32 *\t@__sk_flags_offset: empty field used to determine location of bitfield 33 *\t@sk_padding: unused element for alignment 34 *\t@sk_no_check_tx: %SO_NO_CHECK setting, set checksum in TX packets 35 *\t@sk_no_check_rx: allow zero checksum in RX packets 36 *\t@sk_route_caps: route capabilities (e.g. %NETIF_F_TSO) 37 *\t@sk_gso_disabled: if set, NETIF_F_GSO_MASK is forbidden. 38 *\t@sk_gso_type: GSO type (e.g. %SKB_GSO_TCPV4) 39 *\t@sk_gso_max_size: Maximum GSO segment size to build 40 *\t@sk_gso_max_segs: Maximum number of GSO segments 41 *\t@sk_pacing_shift: scaling factor for TCP Small Queues 42 *\t@sk_lingertime: %SO_LINGER l_linger setting 43 *\t@sk_backlog: always used with the per-socket spinlock held 44 *\t@sk_callback_lock: used with the callbacks in the end of this struct 45 *\t@sk_error_queue: rarely used 46 *\t@sk_prot_creator: sk_prot of original sock creator (see ipv6_setsockopt, 47 *\tIPV6_ADDRFORM for instance) 48 *\t@sk_err: last error 49 *\t@sk_err_soft: errors that don\u0026#39;t cause failure but are the cause of a 50 *\tpersistent failure not just \u0026#39;timed out\u0026#39; 51 *\t@sk_drops: raw/udp drops counter 52 *\t@sk_ack_backlog: current listen backlog 53 *\t@sk_max_ack_backlog: listen backlog set in listen() 54 *\t@sk_uid: user id of owner 55 *\t@sk_prefer_busy_poll: prefer busypolling over softirq processing 56 *\t@sk_busy_poll_budget: napi processing budget when busypolling 57 *\t@sk_priority: %SO_PRIORITY setting 58 *\t@sk_type: socket type (%SOCK_STREAM, etc) 59 *\t@sk_protocol: which protocol this socket belongs in this network family 60 *\t@sk_peer_lock: lock protecting @sk_peer_pid and @sk_peer_cred 61 *\t@sk_peer_pid: \u0026amp;struct pid for this socket\u0026#39;s peer 62 *\t@sk_peer_cred: %SO_PEERCRED setting 63 *\t@sk_rcvlowat: %SO_RCVLOWAT setting 64 *\t@sk_rcvtimeo: %SO_RCVTIMEO setting 65 *\t@sk_sndtimeo: %SO_SNDTIMEO setting 66 *\t@sk_txhash: computed flow hash for use on transmit 67 *\t@sk_txrehash: enable TX hash rethink 68 *\t@sk_filter: socket filtering instructions 69 *\t@sk_timer: sock cleanup timer 70 *\t@sk_stamp: time stamp of last packet received 71 *\t@sk_stamp_seq: lock for accessing sk_stamp on 32 bit architectures only 72 *\t@sk_tsflags: SO_TIMESTAMPING flags 73 *\t@sk_bind_phc: SO_TIMESTAMPING bind PHC index of PTP virtual clock 74 *\tfor timestamping 75 *\t@sk_tskey: counter to disambiguate concurrent tstamp requests 76 *\t@sk_zckey: counter to order MSG_ZEROCOPY notifications 77 *\t@sk_socket: Identd and reporting IO signals 78 *\t@sk_user_data: RPC layer private data 79 *\t@sk_frag: cached page frag 80 *\t@sk_peek_off: current peek_offset value 81 *\t@sk_send_head: front of stuff to transmit 82 *\t@tcp_rtx_queue: TCP re-transmit queue [union with @sk_send_head] 83 *\t@sk_security: used by security modules 84 *\t@sk_mark: generic packet mark 85 *\t@sk_cgrp_data: cgroup data for this cgroup 86 *\t@sk_memcg: this socket\u0026#39;s memory cgroup association 87 *\t@sk_write_pending: a write to stream socket waits to start 88 *\t@sk_state_change: callback to indicate change in the state of the sock 89 *\t@sk_data_ready: callback to indicate there is data to be processed 90 *\t@sk_write_space: callback to indicate there is bf sending space available 91 *\t@sk_error_report: callback to indicate errors (e.g. %MSG_ERRQUEUE) 92 *\t@sk_backlog_rcv: callback to process the backlog 93 *\t@sk_validate_xmit_skb: ptr to an optional validate function 94 *\t@sk_destruct: called at sock freeing time, i.e. when all refcnt == 0 95 *\t@sk_reuseport_cb: reuseport group container 96 *\t@sk_bpf_storage: ptr to cache and control for bpf_sk_storage 97 *\t@sk_rcu: used during RCU grace period 98 *\t@sk_clockid: clockid used by time-based scheduling (SO_TXTIME) 99 *\t@sk_txtime_deadline_mode: set deadline mode for SO_TXTIME 100 *\t@sk_txtime_report_errors: set report errors mode for SO_TXTIME 101 *\t@sk_txtime_unused: unused txtime flags 102 *\t@ns_tracker: tracker for netns reference 103 */ 104struct sock { 105\t/* 106\t* Now struct inet_timewait_sock also uses sock_common, so please just 107\t* don\u0026#39;t add nothing before this first member (__sk_common) --acme 108\t*/ 109\tstruct sock_common\t__sk_common; 110#define sk_node\t__sk_common.skc_node 111#define sk_nulls_node\t__sk_common.skc_nulls_node 112#define sk_refcnt\t__sk_common.skc_refcnt 113#define sk_tx_queue_mapping\t__sk_common.skc_tx_queue_mapping 114#ifdef CONFIG_SOCK_RX_QUEUE_MAPPING 115#define sk_rx_queue_mapping\t__sk_common.skc_rx_queue_mapping 116#endif 117 118#define sk_dontcopy_begin\t__sk_common.skc_dontcopy_begin 119#define sk_dontcopy_end\t__sk_common.skc_dontcopy_end 120#define sk_hash\t__sk_common.skc_hash 121#define sk_portpair\t__sk_common.skc_portpair 122#define sk_num\t__sk_common.skc_num 123#define sk_dport\t__sk_common.skc_dport 124#define sk_addrpair\t__sk_common.skc_addrpair 125#define sk_daddr\t__sk_common.skc_daddr 126#define sk_rcv_saddr\t__sk_common.skc_rcv_saddr 127#define sk_family\t__sk_common.skc_family 128#define sk_state\t__sk_common.skc_state 129#define sk_reuse\t__sk_common.skc_reuse 130#define sk_reuseport\t__sk_common.skc_reuseport 131#define sk_ipv6only\t__sk_common.skc_ipv6only 132#define sk_net_refcnt\t__sk_common.skc_net_refcnt 133#define sk_bound_dev_if\t__sk_common.skc_bound_dev_if 134#define sk_bind_node\t__sk_common.skc_bind_node 135#define sk_prot\t__sk_common.skc_prot 136#define sk_net\t__sk_common.skc_net 137#define sk_v6_daddr\t__sk_common.skc_v6_daddr 138#define sk_v6_rcv_saddr\t__sk_common.skc_v6_rcv_saddr 139#define sk_cookie\t__sk_common.skc_cookie 140#define sk_incoming_cpu\t__sk_common.skc_incoming_cpu 141#define sk_flags\t__sk_common.skc_flags 142#define sk_rxhash\t__sk_common.skc_rxhash 143 144\t/* early demux fields */ 145\tstruct dst_entry __rcu\t*sk_rx_dst; 146\tint\tsk_rx_dst_ifindex; 147\tu32\tsk_rx_dst_cookie; 148 149\tsocket_lock_t\tsk_lock; 150\tatomic_t\tsk_drops; 151\tint\tsk_rcvlowat; 152\tstruct sk_buff_head\tsk_error_queue; 153\tstruct sk_buff_head\tsk_receive_queue; 154\t/* 155\t* The backlog queue is special, it is always used with 156\t* the per-socket spinlock held and requires low latency 157\t* access. Therefore we special case it\u0026#39;s implementation. 158\t* Note : rmem_alloc is in this structure to fill a hole 159\t* on 64bit arches, not because its logically part of 160\t* backlog. 161\t*/ 162\tstruct { 163\tatomic_t\trmem_alloc; 164\tint\tlen; 165\tstruct sk_buff\t*head; 166\tstruct sk_buff\t*tail; 167\t} sk_backlog; 168 169#define sk_rmem_alloc sk_backlog.rmem_alloc 170 171\tint\tsk_forward_alloc; 172\tu32\tsk_reserved_mem; 173#ifdef CONFIG_NET_RX_BUSY_POLL 174\tunsigned int\tsk_ll_usec; 175\t/* ===== mostly read cache line ===== */ 176\tunsigned int\tsk_napi_id; 177#endif 178\tint\tsk_rcvbuf; 179 180\tstruct sk_filter __rcu\t*sk_filter; 181\tunion { 182\tstruct socket_wq __rcu\t*sk_wq; 183\t/* private: */ 184\tstruct socket_wq\t*sk_wq_raw; 185\t/* public: */ 186\t}; 187#ifdef CONFIG_XFRM 188\tstruct xfrm_policy __rcu *sk_policy[2]; 189#endif 190 191\tstruct dst_entry __rcu\t*sk_dst_cache; 192\tatomic_t\tsk_omem_alloc; 193\tint\tsk_sndbuf; 194 195\t/* ===== cache line for TX ===== */ 196\tint\tsk_wmem_queued; 197\trefcount_t\tsk_wmem_alloc; 198\tunsigned long\tsk_tsq_flags; 199\tunion { 200\tstruct sk_buff\t*sk_send_head; 201\tstruct rb_root\ttcp_rtx_queue; 202\t}; 203\tstruct sk_buff_head\tsk_write_queue; 204\t__s32\tsk_peek_off; 205\tint\tsk_write_pending; 206\t__u32\tsk_dst_pending_confirm; 207\tu32\tsk_pacing_status; /* see enum sk_pacing */ 208\tlong\tsk_sndtimeo; 209\tstruct timer_list\tsk_timer; 210\t__u32\tsk_priority; 211\t__u32\tsk_mark; 212\tunsigned long\tsk_pacing_rate; /* bytes per second */ 213\tunsigned long\tsk_max_pacing_rate; 214\tstruct page_frag\tsk_frag; 215\tnetdev_features_t\tsk_route_caps; 216\tint\tsk_gso_type; 217\tunsigned int\tsk_gso_max_size; 218\tgfp_t\tsk_allocation; 219\t__u32\tsk_txhash; 220 221\t/* 222\t* Because of non atomicity rules, all 223\t* changes are protected by socket lock. 224\t*/ 225\tu8\tsk_gso_disabled : 1, 226\tsk_kern_sock : 1, 227\tsk_no_check_tx : 1, 228\tsk_no_check_rx : 1, 229\tsk_userlocks : 4; 230\tu8\tsk_pacing_shift; 231\tu16\tsk_type; 232\tu16\tsk_protocol; 233\tu16\tsk_gso_max_segs; 234\tunsigned long\tsk_lingertime; 235\tstruct proto\t*sk_prot_creator; 236\trwlock_t\tsk_callback_lock; 237\tint\tsk_err, 238\tsk_err_soft; 239\tu32\tsk_ack_backlog; 240\tu32\tsk_max_ack_backlog; 241\tkuid_t\tsk_uid; 242\tu8\tsk_txrehash; 243#ifdef CONFIG_NET_RX_BUSY_POLL 244\tu8\tsk_prefer_busy_poll; 245\tu16\tsk_busy_poll_budget; 246#endif 247\tspinlock_t\tsk_peer_lock; 248\tint\tsk_bind_phc; 249\tstruct pid\t*sk_peer_pid; 250\tconst struct cred\t*sk_peer_cred; 251 252\tlong\tsk_rcvtimeo; 253\tktime_t\tsk_stamp; 254#if BITS_PER_LONG==32 255\tseqlock_t\tsk_stamp_seq; 256#endif 257\tu16\tsk_tsflags; 258\tu8\tsk_shutdown; 259\tatomic_t\tsk_tskey; 260\tatomic_t\tsk_zckey; 261 262\tu8\tsk_clockid; 263\tu8\tsk_txtime_deadline_mode : 1, 264\tsk_txtime_report_errors : 1, 265\tsk_txtime_unused : 6; 266 267\tstruct socket\t*sk_socket; 268\tvoid\t*sk_user_data; 269#ifdef CONFIG_SECURITY 270\tvoid\t*sk_security; 271#endif 272\tstruct sock_cgroup_data\tsk_cgrp_data; 273\tstruct mem_cgroup\t*sk_memcg; 274\tvoid\t(*sk_state_change)(struct sock *sk); 275\tvoid\t(*sk_data_ready)(struct sock *sk); 276\tvoid\t(*sk_write_space)(struct sock *sk); 277\tvoid\t(*sk_error_report)(struct sock *sk); 278\tint\t(*sk_backlog_rcv)(struct sock *sk, 279\tstruct sk_buff *skb); 280#ifdef CONFIG_SOCK_VALIDATE_XMIT 281\tstruct sk_buff*\t(*sk_validate_xmit_skb)(struct sock *sk, 282\tstruct net_device *dev, 283\tstruct sk_buff *skb); 284#endif 285\tvoid (*sk_destruct)(struct sock *sk); 286\tstruct sock_reuseport __rcu\t*sk_reuseport_cb; 287#ifdef CONFIG_BPF_SYSCALL 288\tstruct bpf_local_storage __rcu\t*sk_bpf_storage; 289#endif 290\tstruct rcu_head\tsk_rcu; 291\tnetns_tracker\tns_tracker; 292}; sock_common # 1// include/net/sock.h 2/** 3 *\tstruct sock_common - minimal network layer representation of sockets 4 *\t@skc_daddr: Foreign IPv4 addr 5 *\t@skc_rcv_saddr: Bound local IPv4 addr 6 *\t@skc_addrpair: 8-byte-aligned __u64 union of @skc_daddr \u0026amp; @skc_rcv_saddr 7 *\t@skc_hash: hash value used with various protocol lookup tables 8 *\t@skc_u16hashes: two u16 hash values used by UDP lookup tables 9 *\t@skc_dport: placeholder for inet_dport/tw_dport 10 *\t@skc_num: placeholder for inet_num/tw_num 11 *\t@skc_portpair: __u32 union of @skc_dport \u0026amp; @skc_num 12 *\t@skc_family: network address family 13 *\t@skc_state: Connection state 14 *\t@skc_reuse: %SO_REUSEADDR setting 15 *\t@skc_reuseport: %SO_REUSEPORT setting 16 *\t@skc_ipv6only: socket is IPV6 only 17 *\t@skc_net_refcnt: socket is using net ref counting 18 *\t@skc_bound_dev_if: bound device index if != 0 19 *\t@skc_bind_node: bind hash linkage for various protocol lookup tables 20 *\t@skc_portaddr_node: second hash linkage for UDP/UDP-Lite protocol 21 *\t@skc_prot: protocol handlers inside a network family 22 *\t@skc_net: reference to the network namespace of this socket 23 *\t@skc_v6_daddr: IPV6 destination address 24 *\t@skc_v6_rcv_saddr: IPV6 source address 25 *\t@skc_cookie: socket\u0026#39;s cookie value 26 *\t@skc_node: main hash linkage for various protocol lookup tables 27 *\t@skc_nulls_node: main hash linkage for TCP/UDP/UDP-Lite protocol 28 *\t@skc_tx_queue_mapping: tx queue number for this connection 29 *\t@skc_rx_queue_mapping: rx queue number for this connection 30 *\t@skc_flags: place holder for sk_flags 31 *\t%SO_LINGER (l_onoff), %SO_BROADCAST, %SO_KEEPALIVE, 32 *\t%SO_OOBINLINE settings, %SO_TIMESTAMPING settings 33 *\t@skc_listener: connection request listener socket (aka rsk_listener) 34 *\t[union with @skc_flags] 35 *\t@skc_tw_dr: (aka tw_dr) ptr to \u0026amp;struct inet_timewait_death_row 36 *\t[union with @skc_flags] 37 *\t@skc_incoming_cpu: record/match cpu processing incoming packets 38 *\t@skc_rcv_wnd: (aka rsk_rcv_wnd) TCP receive window size (possibly scaled) 39 *\t[union with @skc_incoming_cpu] 40 *\t@skc_tw_rcv_nxt: (aka tw_rcv_nxt) TCP window next expected seq number 41 *\t[union with @skc_incoming_cpu] 42 *\t@skc_refcnt: reference count 43 * 44 *\tThis is the minimal network layer representation of sockets, the header 45 *\tfor struct sock and struct inet_timewait_sock. 46 */ 47struct sock_common { 48\tunion { 49\t__addrpair\tskc_addrpair; 50\tstruct { 51\t__be32\tskc_daddr; 52\t__be32\tskc_rcv_saddr; 53\t}; 54\t}; 55\tunion { 56\tunsigned int\tskc_hash; 57\t__u16\tskc_u16hashes[2]; 58\t}; 59\t/* skc_dport \u0026amp;\u0026amp; skc_num must be grouped as well */ 60\tunion { 61\t__portpair\tskc_portpair; 62\tstruct { 63\t__be16\tskc_dport; 64\t__u16\tskc_num; 65\t}; 66\t}; 67 68\tunsigned short\tskc_family; 69\tvolatile unsigned char\tskc_state; 70\tunsigned char\tskc_reuse:4; 71\tunsigned char\tskc_reuseport:1; 72\tunsigned char\tskc_ipv6only:1; 73\tunsigned char\tskc_net_refcnt:1; 74\tint\tskc_bound_dev_if; 75\tunion { 76\tstruct hlist_node\tskc_bind_node; 77\tstruct hlist_node\tskc_portaddr_node; 78\t}; 79\tstruct proto\t*skc_prot; 80\tpossible_net_t\tskc_net; 81 82#if IS_ENABLED(CONFIG_IPV6) 83\tstruct in6_addr\tskc_v6_daddr; 84\tstruct in6_addr\tskc_v6_rcv_saddr; 85#endif 86 87\tatomic64_t\tskc_cookie; 88 89\t/* following fields are padding to force 90\t* offset(struct sock, sk_refcnt) == 128 on 64bit arches 91\t* assuming IPV6 is enabled. We use this padding differently 92\t* for different kind of \u0026#39;sockets\u0026#39; 93\t*/ 94\tunion { 95\tunsigned long\tskc_flags; 96\tstruct sock\t*skc_listener; /* request_sock */ 97\tstruct inet_timewait_death_row *skc_tw_dr; /* inet_timewait_sock */ 98\t}; 99\t/* 100\t* fields between dontcopy_begin/dontcopy_end 101\t* are not copied in sock_copy() 102\t*/ 103\t/* private: */ 104\tint\tskc_dontcopy_begin[0]; 105\t/* public: */ 106\tunion { 107\tstruct hlist_node\tskc_node; 108\tstruct hlist_nulls_node skc_nulls_node; 109\t}; 110\tunsigned short\tskc_tx_queue_mapping; 111#ifdef CONFIG_SOCK_RX_QUEUE_MAPPING 112\tunsigned short\tskc_rx_queue_mapping; 113#endif 114\tunion { 115\tint\tskc_incoming_cpu; 116\tu32\tskc_rcv_wnd; 117\tu32\tskc_tw_rcv_nxt; /* struct tcp_timewait_sock */ 118\t}; 119 120\trefcount_t\tskc_refcnt; 121\t/* private: */ 122\tint skc_dontcopy_end[0]; 123\tunion { 124\tu32\tskc_rxhash; 125\tu32\tskc_window_clamp; 126\tu32\tskc_tw_snd_nxt; /* struct tcp_timewait_sock */ 127\t}; 128\t/* public: */ 129}; 1.3. minisock 缩减版本的socket # 部分场景下不需要sock那么大的结构体，需要缩减一下使用，所以内核定义了两个应对部分场景的结构体 但是在部分处理时（如netfilter的钩子）中，拿到的是struct sock *sk，但是使用sock中的一些值会出问题，因为含义完全不同 但是minisock中均定义了sock_common结构体，在sock_common中的成员含义是一致的，只是部分声明为了union，对不同sock有不同的使用 判断是否为完整sock而非minisock的函数，处理就是判断sk_state，两个场景都有特定的sk_state 1// include/net/sock.h 2/* This helper checks if a socket is a full socket, 3 * ie _not_ a timewait or request socket. 4 */ 5static inline bool sk_fullsock(const struct sock *sk) 6{ 7\treturn (1 \u0026lt;\u0026lt; sk-\u0026gt;sk_state) \u0026amp; ~(TCPF_TIME_WAIT | TCPF_NEW_SYN_RECV); 8} 1) request_sock 结构体 # 服务端监听的socket接受到第一个syn包后，建立一个request_sock然后发送syn/ack，状态为TCP_NEW_SYN_RECV 1// include/net/request_sock.h 2/* struct request_sock - mini sock to represent a connection request 3 */ 4struct request_sock { 5\tstruct sock_common\t__req_common; 6#define rsk_refcnt\t__req_common.skc_refcnt 7#define rsk_hash\t__req_common.skc_hash 8#define rsk_listener\t__req_common.skc_listener 9#define rsk_window_clamp\t__req_common.skc_window_clamp 10#define rsk_rcv_wnd\t__req_common.skc_rcv_wnd 11 12\tstruct request_sock\t*dl_next; 13\tu16\tmss; 14\tu8\tnum_retrans; /* number of retransmits */ 15\tu8\tsyncookie:1; /* syncookie: encode tcpopts in timestamp */ 16\tu8\tnum_timeout:7; /* number of timeouts */ 17\tu32\tts_recent; 18\tstruct timer_list\trsk_timer; 19\tconst struct request_sock_ops\t*rsk_ops; 20\tstruct sock\t*sk; 21\tstruct saved_syn\t*saved_syn; 22\tu32\tsecid; 23\tu32\tpeer_secid; 24\tu32\ttimeout; 25}; 创建时sk_state即为TCP_NEW_SYN_RECV，判断状态是否为此可以判断是否为request_sock 1// net/ipv4/tcp_input.c 2struct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops, 3\tstruct sock *sk_listener, 4\tbool attach_listener) 5{ 6\tstruct request_sock *req = reqsk_alloc(ops, sk_listener, 7\tattach_listener); 8 9\tif (req) { 10\tstruct inet_request_sock *ireq = inet_rsk(req); 11 12\tireq-\u0026gt;ireq_opt = NULL; 13#if IS_ENABLED(CONFIG_IPV6) 14\tireq-\u0026gt;pktopts = NULL; 15#endif 16\tatomic64_set(\u0026amp;ireq-\u0026gt;ir_cookie, 0); 17\tireq-\u0026gt;ireq_state = TCP_NEW_SYN_RECV; 18\twrite_pnet(\u0026amp;ireq-\u0026gt;ireq_net, sock_net(sk_listener)); 19\tireq-\u0026gt;ireq_family = sk_listener-\u0026gt;sk_family; 20\treq-\u0026gt;timeout = TCP_TIMEOUT_INIT; 21\t} 22 23\treturn req; 24} 25EXPORT_SYMBOL(inet_reqsk_alloc); 2) inet_timewait_sock 结构体 # 内核处理tcp在TCP_FIN_WAIT2状态收到一个FIN包后发送完ACK，会创建一个inet_timewait_sock处理TCP_TIME_WAIT状态，而原始的sock就直接CLOSE了 1// include/net/inet_timewait_sock.h 2/* 3 * This is a TIME_WAIT sock. It works around the memory consumption 4 * problems of sockets in such a state on heavily loaded servers, but 5 * without violating the protocol specification. 6 */ 7struct inet_timewait_sock { 8\t/* 9\t* Now struct sock also uses sock_common, so please just 10\t* don\u0026#39;t add nothing before this first member (__tw_common) --acme 11\t*/ 12\tstruct sock_common\t__tw_common; 13#define tw_family\t__tw_common.skc_family 14#define tw_state\t__tw_common.skc_state 15#define tw_reuse\t__tw_common.skc_reuse 16#define tw_reuseport\t__tw_common.skc_reuseport 17#define tw_ipv6only\t__tw_common.skc_ipv6only 18#define tw_bound_dev_if\t__tw_common.skc_bound_dev_if 19#define tw_node\t__tw_common.skc_nulls_node 20#define tw_bind_node\t__tw_common.skc_bind_node 21#define tw_refcnt\t__tw_common.skc_refcnt 22#define tw_hash\t__tw_common.skc_hash 23#define tw_prot\t__tw_common.skc_prot 24#define tw_net\t__tw_common.skc_net 25#define tw_daddr __tw_common.skc_daddr 26#define tw_v6_daddr\t__tw_common.skc_v6_daddr 27#define tw_rcv_saddr __tw_common.skc_rcv_saddr 28#define tw_v6_rcv_saddr __tw_common.skc_v6_rcv_saddr 29#define tw_dport\t__tw_common.skc_dport 30#define tw_num\t__tw_common.skc_num 31#define tw_cookie\t__tw_common.skc_cookie 32#define tw_dr\t__tw_common.skc_tw_dr 33 34\t__u32\ttw_mark; 35\tvolatile unsigned char\ttw_substate; 36\tunsigned char\ttw_rcv_wscale; 37 38\t/* Socket demultiplex comparisons on incoming packets. */ 39\t/* these three are in inet_sock */ 40\t__be16\ttw_sport; 41\t/* And these are ours. */ 42\tunsigned int\ttw_transparent : 1, 43\ttw_flowlabel\t: 20, 44\ttw_pad\t: 3,\t/* 3 bits hole */ 45\ttw_tos\t: 8; 46\tu32\ttw_txhash; 47\tu32\ttw_priority; 48\tstruct timer_list\ttw_timer; 49\tstruct inet_bind_bucket\t*tw_tb; 50}; 构造时，状态就是TCP_TIME_WAIT 1// net/ipv4/inet_timewait_sock.c 2struct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk, 3\tstruct inet_timewait_death_row *dr, 4\tconst int state) 5{ 6\tstruct inet_timewait_sock *tw; 7 8\tif (refcount_read(\u0026amp;dr-\u0026gt;tw_refcount) - 1 \u0026gt;= 9\tREAD_ONCE(dr-\u0026gt;sysctl_max_tw_buckets)) 10\treturn NULL; 11 12\ttw = kmem_cache_alloc(sk-\u0026gt;sk_prot_creator-\u0026gt;twsk_prot-\u0026gt;twsk_slab, 13\tGFP_ATOMIC); 14\tif (tw) { 15\tconst struct inet_sock *inet = inet_sk(sk); 16 17\ttw-\u0026gt;tw_dr\t= dr; 18\t/* Give us an identity. */ 19\ttw-\u0026gt;tw_daddr\t= inet-\u0026gt;inet_daddr; 20\ttw-\u0026gt;tw_rcv_saddr = inet-\u0026gt;inet_rcv_saddr; 21\ttw-\u0026gt;tw_bound_dev_if = sk-\u0026gt;sk_bound_dev_if; 22\ttw-\u0026gt;tw_tos\t= inet-\u0026gt;tos; 23\ttw-\u0026gt;tw_num\t= inet-\u0026gt;inet_num; 24\ttw-\u0026gt;tw_state\t= TCP_TIME_WAIT; 25\ttw-\u0026gt;tw_substate\t= state; 26\ttw-\u0026gt;tw_sport\t= inet-\u0026gt;inet_sport; 27\ttw-\u0026gt;tw_dport\t= inet-\u0026gt;inet_dport; 28\ttw-\u0026gt;tw_family\t= sk-\u0026gt;sk_family; 29\ttw-\u0026gt;tw_reuse\t= sk-\u0026gt;sk_reuse; 30\ttw-\u0026gt;tw_reuseport = sk-\u0026gt;sk_reuseport; 31\ttw-\u0026gt;tw_hash\t= sk-\u0026gt;sk_hash; 32\ttw-\u0026gt;tw_ipv6only\t= 0; 33\ttw-\u0026gt;tw_transparent = inet-\u0026gt;transparent; 34\ttw-\u0026gt;tw_prot\t= sk-\u0026gt;sk_prot_creator; 35\tatomic64_set(\u0026amp;tw-\u0026gt;tw_cookie, atomic64_read(\u0026amp;sk-\u0026gt;sk_cookie)); 36\ttwsk_net_set(tw, sock_net(sk)); 37\ttimer_setup(\u0026amp;tw-\u0026gt;tw_timer, tw_timer_handler, TIMER_PINNED); 38\t/* 39\t* Because we use RCU lookups, we should not set tw_refcnt 40\t* to a non null value before everything is setup for this 41\t* timewait socket. 42\t*/ 43\trefcount_set(\u0026amp;tw-\u0026gt;tw_refcnt, 0); 44 45\t__module_get(tw-\u0026gt;tw_prot-\u0026gt;owner); 46\t} 47 48\treturn tw; 49} 50EXPORT_SYMBOL_GPL(inet_twsk_alloc); 4. 相关系统调用 # 1SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol); 2SYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol, int __user *, usockvec); 3SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen); 4SYSCALL_DEFINE2(listen, int, fd, int, backlog); 5SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen, int, flags); 6SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr, int __user *, upeer_addrlen); 7SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr, int, addrlen); 8SYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len); 9SYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr, int __user *, usockaddr_len); 10SYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len, unsigned int, flags, struct sockaddr __user *, addr, int, addr_len); 11SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len, unsigned int, flags); 12SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags, struct sockaddr __user *, addr, int __user *, addr_len); 13SYSCALL_DEFINE4(recv, int, fd, void __user *, ubuf, size_t, size, unsigned int, flags); 14SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname, char __user *, optval, int, optlen); 15SYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname, char __user *, optval, int __user *, optlen); 16SYSCALL_DEFINE2(shutdown, int, fd, int, how); 17SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags); 18SYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg, unsigned int, vlen, unsigned int, flags); 19SYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags); 20SYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg, unsigned int, vlen, unsigned int, flags, struct __kernel_timespec __user *, timeout); 21SYSCALL_DEFINE5(recvmmsg_time32, int, fd, struct mmsghdr __user *, mmsg, unsigned int, vlen, unsigned int, flags, struct old_timespec32 __user *, timeout); 22SYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args); 二、socket创建过程 # socket创建需要使用family、type和protocol 在底层socket可以说相当于一个基类，将底层不同类型封装成统一的接口 @startuml class net_families { net_proto_family[NPROTO] } class net_proto_family { int\tfamily; int\t(*create)(struct net *net, struct socket *sock, int protocol, int kern); struct module\t*owner; } class socket() {} class inet_init() {} class inet6_init() {} class af_unix_init() {} \u0026#34;inet_init()\u0026#34; -up-\u0026gt; net_families : sock_register注册AF_INET \u0026#34;inet6_init()\u0026#34; -up-\u0026gt; net_families : sock_register注册AF_INET6 \u0026#34;af_unix_init()\u0026#34; -up-\u0026gt; net_families : sock_register注册AF_UNIX \u0026#34;socket()\u0026#34; -down-\u0026gt; net_proto_family : 调用create \u0026#34;socket()\u0026#34; -down-\u0026gt; net_families : 根据不同的family获取对应的net_proto_family net_proto_family \u0026lt;-left- net_families @enduml 1. 根据family找到对应的socket家族 # 内部使用rcu维护一个net_families的指针数组，每个元素是一个net_proto_family结构体 1// net/socket.c 2static const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly; 3// include/linux/net.h 4struct net_proto_family { 5 int\tfamily; 6 int\t(*create)(struct net *net, struct socket *sock, 7 int protocol, int kern); 8 struct module\t*owner; 9}; NPROTO暂时最大为45，后续还会拓展新的家族 1// include/uapi/linux/net.h 2#define NPROTO\tAF_MAX 3// include/linux/socket.h 4#define AF_MAX\t46\t/* For now.. */ net_families由下面两个函数进行维护 1// net/socket.c 2/** 3 *\tsock_register - add a socket protocol handler 4 *\t@ops: description of protocol 5 * 6 *\tThis function is called by a protocol handler that wants to 7 *\tadvertise its address family, and have it linked into the 8 *\tsocket interface. The value ops-\u0026gt;family corresponds to the 9 *\tsocket system call protocol family. 10 */ 11int sock_register(const struct net_proto_family *ops) { 12 ... 13} 14EXPORT_SYMBOL(sock_register); 15 16/** 17 *\tsock_unregister - remove a protocol handler 18 *\t@family: protocol family to remove 19 * 20 *\tThis function is called by a protocol handler that wants to 21 *\tremove its address family, and have it unlinked from the 22 *\tnew socket creation. 23 * 24 *\tIf protocol handler is a module, then it can use module reference 25 *\tcounts to protect against new references. If protocol handler is not 26 *\ta module then it needs to provide its own protection in 27 *\tthe ops-\u0026gt;create routine. 28 */ 29void sock_unregister(int family) { 30 ... 31} 32EXPORT_SYMBOL(sock_unregister); 不同的socket家族自己进行注册，比如AF_INET、AF_INET6、AF_UNIX等 1// net/ipv4/af_inet.c 2static int __init inet_init(void) { 3 ... 4 (void)sock_register(\u0026amp;inet_family_ops); 5 ... 6} 7 8// net/ipv6/af_inet6.c 9static int __init inet6_init(void) { 10 ... 11 err = sock_register(\u0026amp;inet6_family_ops); 12 ... 13} 14 15// net/unix/af_unix.c 16static int __init af_unix_init(void) { 17 ... 18 sock_register(\u0026amp;unix_family_ops); 19 ... 20} 找到自己的家族后，就调用对应的create函数进行创建socket 1// net/socket.c 2// socket() -call-\u0026gt; __sys_socket() -call-\u0026gt; sock_create() -call-\u0026gt; __sock_create() 3int __sock_create(struct net *net, int family, int type, int protocol, 4 struct socket **res, int kern) { 5\tint err; 6\tstruct socket *sock; 7\tconst struct net_proto_family *pf; 8 ... 9\t// 给socket结构体申请内存 10\t/* 11\t*\tAllocate the socket and allow the family to set things up. if 12\t*\tthe protocol is 0, the family is instructed to select an appropriate 13\t*\tdefault. 14\t*/ 15\tsock = sock_alloc(); 16\tif (!sock) { 17\tnet_warn_ratelimited(\u0026#34;socket: no more sockets\\n\u0026#34;); 18\treturn -ENFILE;\t/* Not exactly a match, but its the 19\tclosest posix thing */ 20\t} 21 22\tsock-\u0026gt;type = type; 23\t... 24 // 使用rcu锁锁定net_families结构体，取对应家族的pf结构体 25 rcu_read_lock(); 26\tpf = rcu_dereference(net_families[family]); 27\terr = -EAFNOSUPPORT; 28\tif (!pf) 29\tgoto out_release; 30 31\t/* 32\t* We will call the -\u0026gt;create function, that possibly is in a loadable 33\t* module, so we have to bump that loadable module refcnt first. 34\t*/ 35\tif (!try_module_get(pf-\u0026gt;owner)) 36\tgoto out_release; 37 38\t/* Now protected by module ref count */ 39\trcu_read_unlock(); 40 41 // 调用对应的create函数创建 42 err = pf-\u0026gt;create(net, sock, protocol, kern); 43 if (err \u0026lt; 0) 44 goto out_module_put; 45 ... 46} ipv4的create调用inet_create，查看 ipv4创建socket ipv6的create调用inet6_create，查看 ipv6创建socket unix看 unix创建socket 2. 创建socket后，创建fd，并将socket和fd绑定 # 设置file的操作集为socket_file_ops 1// net/socket.c 2int __sys_socket(int family, int type, int protocol) { 3 ... 4 return sock_map_fd(sock, flags \u0026amp; (O_CLOEXEC | O_NONBLOCK)); 5} 6 7// net/socket.c 8// sock_map_fd() -call-\u0026gt; sock_alloc_file() 9/** 10 *\tsock_alloc_file - Bind a \u0026amp;socket to a \u0026amp;file 11 *\t@sock: socket 12 *\t@flags: file status flags 13 *\t@dname: protocol name 14 * 15 *\tReturns the \u0026amp;file bound with @sock, implicitly storing it 16 *\tin sock-\u0026gt;file. If dname is %NULL, sets to \u0026#34;\u0026#34;. 17 *\tOn failure the return is a ERR pointer (see linux/err.h). 18 *\tThis function uses GFP_KERNEL internally. 19 */ 20struct file *sock_alloc_file(struct socket *sock, int flags, const char *dname) { 21\tstruct file *file; 22 23\tif (!dname) 24\tdname = sock-\u0026gt;sk ? sock-\u0026gt;sk-\u0026gt;sk_prot_creator-\u0026gt;name : \u0026#34;\u0026#34;; 25 26\tfile = alloc_file_pseudo(SOCK_INODE(sock), sock_mnt, dname, 27\tO_RDWR | (flags \u0026amp; O_NONBLOCK), 28\t\u0026amp;socket_file_ops); 29\tif (IS_ERR(file)) { 30\tsock_release(sock); 31\treturn file; 32\t} 33 34\tsock-\u0026gt;file = file; 35\tfile-\u0026gt;private_data = sock; 36\tstream_open(SOCK_INODE(sock), file); 37\treturn file; 38} 39EXPORT_SYMBOL(sock_alloc_file); 三、socket销毁过程 # 1. struct sock *sk的销毁过程 # 1-\u0026gt; void sk_free(struct sock *sk) 2\t-\u0026gt; static void __sk_free(struct sock *sk) 3\t-\u0026gt; void sk_destruct(struct sock *sk) 4\t-\u0026gt; static void __sk_destruct(struct rcu_head *head) 5\t-\u0026gt; sk-\u0026gt;sk_destruct(sk); ipv4和ipv6的sk-\u0026gt;sk_destruct都定义为inet_sock_destruct，查看 ipv4的struct sock *sk销毁 四、阻塞进程的socket唤醒操作 # init时注册data_ready函数 1// net/core/sock.c 2void sock_init_data(struct socket *sock, struct sock *sk) 3{ 4 ... 5\tsk-\u0026gt;sk_state_change\t=\tsock_def_wakeup; 6\tsk-\u0026gt;sk_data_ready\t=\tsock_def_readable; // 注册可读函数，当有数据时调用 7\tsk-\u0026gt;sk_write_space\t=\tsock_def_write_space; 8\tsk-\u0026gt;sk_error_report\t=\tsock_def_error_report; 9\tsk-\u0026gt;sk_destruct\t=\tsock_def_destruct; 10 ... 11} 12EXPORT_SYMBOL(sock_init_data); 13 14// net/core/sock.c 15void sock_def_readable(struct sock *sk) 16{ 17\tstruct socket_wq *wq; 18 19\trcu_read_lock(); 20\twq = rcu_dereference(sk-\u0026gt;sk_wq); 21 // 唤醒队列上的线程 22\tif (skwq_has_sleeper(wq)) 23\twake_up_interruptible_sync_poll(\u0026amp;wq-\u0026gt;wait, EPOLLIN | EPOLLPRI | 24\tEPOLLRDNORM | EPOLLRDBAND); 25\tsk_wake_async(sk, SOCK_WAKE_WAITD, POLL_IN); 26\trcu_read_unlock(); 27} 各自协议内部有数据后进行调用 五、bind 绑定地址 # 端口传0会自动分配一个没有占用的端口给socket 1. 系统调用定义 # 1// net/socket.c 2/* 3 *\tBind a name to a socket. Nothing much to do here since it\u0026#39;s 4 *\tthe protocol\u0026#39;s responsibility to handle the local address. 5 * 6 *\tWe move the socket address to kernel space before we call 7 *\tthe protocol layer (having also checked the address is ok). 8 */ 9 10int __sys_bind(int fd, struct sockaddr __user *umyaddr, int addrlen) 11{ 12\tstruct socket *sock; 13\tstruct sockaddr_storage address; 14\tint err, fput_needed; 15 16\t// fd找socket结构体 17\tsock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); 18\tif (sock) { 19\t// 地址拷贝到内核空间 20\terr = move_addr_to_kernel(umyaddr, addrlen, \u0026amp;address); 21\tif (!err) { 22\terr = security_socket_bind(sock, 23\t(struct sockaddr *)\u0026amp;address, 24\taddrlen); 25\tif (!err) 26\t// 调用真正的bind函数 27\terr = sock-\u0026gt;ops-\u0026gt;bind(sock, 28\t(struct sockaddr *) 29\t\u0026amp;address, addrlen); 30\t} 31\tfput_light(sock-\u0026gt;file, fput_needed); 32\t} 33\treturn err; 34} 35 36SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen) 37{ 38\treturn __sys_bind(fd, umyaddr, addrlen); 39} 调用ops中的bind，ops在各个协议内部进行设置 ipv4的bind看 bind 绑定地址 六、listen 监听 # 1. 系统调用 # 1/* 2 *\tPerform a listen. Basically, we allow the protocol to do anything 3 *\tnecessary for a listen, and if that works, we mark the socket as 4 *\tready for listening. 5 */ 6 7int __sys_listen(int fd, int backlog) 8{ 9\tstruct socket *sock; 10\tint err, fput_needed; 11\tint somaxconn; 12 13\tsock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); 14\tif (sock) { 15\tsomaxconn = sock_net(sock-\u0026gt;sk)-\u0026gt;core.sysctl_somaxconn; 16\tif ((unsigned int)backlog \u0026gt; somaxconn) 17\tbacklog = somaxconn; 18 19\terr = security_socket_listen(sock, backlog); 20\tif (!err) 21\terr = sock-\u0026gt;ops-\u0026gt;listen(sock, backlog); 22 23\tfput_light(sock-\u0026gt;file, fput_needed); 24\t} 25\treturn err; 26} 27 28SYSCALL_DEFINE2(listen, int, fd, int, backlog) 29{ 30\treturn __sys_listen(fd, backlog); 31} sock-\u0026gt;ops-\u0026gt;listen调用到具体的 ipv4调用inet_listen 、 unix 、 ipv6 "},{"id":9,"href":"/docs/linux/linux-kernel/arch/x86/boot/","title":"x86启动过程","section":"x86/ x86体系","content":" 一、启动过程 # "},{"id":10,"href":"/docs/linux/linux-kernel/intterupt/common/","title":"上半部和下半部","section":"中断","content":" 一、上半部实现 # 二、下半部实现 # 1. 软中断 # 软中断触发时机：\n从中断返回时触发调用软中断，这时候在中断上下文中，但是是允许响应中断的 在ksoftirqd线程中，处于进程上下文中 在显示调用软中断的代码中，比如网络子系统 由于软中断调用时机即可能是中断上下文，也可能是进程上下文，所以软中断按照最严格的上下文处理，也就是中断上下文，不允许睡眠。\n2. tasklet # tasklet是使用软中断实现的，存在高优先级和普通优先级两个tasklet\n1// include/linux/intterupt.h 3. 工作队列 # 工作队列是运行在进程上下文中，本身优先级很低 工作队列线程在每个cpu都有一个，默认的为event/n "},{"id":11,"href":"/docs/linux/linux-kernel/kernel/sched/schedule/","title":"主调度器","section":"/kernel/sched/ 进程调度","content":" 一、数据结构 # 1. struct rq运行队列（每个cpu一个） # "},{"id":12,"href":"/docs/linux/linux-kernel/arch/common/","title":"公共处理方式","section":"/arch/ cpu体系架构","content":" 一、linux启动步骤 # x86架构下Linux初始化流程中GDT、IDT建立和切换\n"},{"id":13,"href":"/docs/examination/system-architect/large-concurrency/common/","title":"前言和综述","section":"大并发架构","content":" 名词解释 # DFX（Design For X）: 面向产品生命周期设计以及面向来自客户对产品的要求的设计，X可以指产品生命周期内的某一个环节或特性 RAMS: 广义可靠性 Reliability － 可靠性 Availability － 可用性 Maintainability － 可维护性 Safety － 安全性（人身安全） 可维护性: 产品在规定的条件下和规定的时间内，按规定的程序和方法进行维护时，保持或恢复到规定状态的能力。 可用性: 是产品在任意一个随机时刻处于可用状态的能力。可用性＝可用时间/（可用时间＋不可用时间） 一、大型架构演进 # 1. 系统处理能力提升途径 # 垂直伸缩 水平伸缩 伸缩途径 单机性能提升 增加机器组建集群 行业 传统行业，如银行 互联网行业 成本 增加处理能力到某个程度后，会需要更多的钱来进行更高的提升 增加服务器的成本为线性的 极限 物理处理存在极限\n操作系统或应用程序处理存在极限 增加服务器就可以提升性能\n应用程序和系统在不同服务器运行，不会达到极限 2. 架构演进 # 用户数 方案 解决瓶颈 当前性能瓶颈 少量 单机系统处理 数据在业务层处理复杂度 万级 使用数据库处理数据，业务读取数据库 应用处理瓶颈 单机数据库读写瓶颈以及应用的cpu处理瓶颈 十万级 需要增加缓存改善，应用服务分布式集群 单机cpu处理瓶颈 数据库io瓶颈 百万级 使用cdn和反向代理进行加速响应\n数据库进行读写分离 数据库处理速度，减少静态资源处理消耗 文件系统和数据库处理瓶颈 千万级 分布式文件系统，分布式数据库系统 文件系统和数据库处理瓶颈 数据量大了之后，硬件性能、数据库、处理数据的能力都是瓶颈 亿级 使用搜索引擎、NoSQL、消息队列与分布式服务 业务增加的复杂度 数据库应用分离 缓存改进性能 应用服务集群，使用负载均衡调度到不同的应用服务器 数据库读写分离 反向代理和CDN加速响应 分布式文件系统和分布式数据库系统 使用消息队列与分布式服务 "},{"id":14,"href":"/docs/examination/system-architect/book-study/reliability/","title":"可靠性设计","section":"读书和学习笔记","content":" 1. 基本概念 # 可靠性工程（Reliability Engineering）: 是在产品寿命周期全过程（论证、方案、工程研制、生产和使用）中同产品故障作斗争的一门学科 1.1. 可靠性: 产品在规定的条件下、规定的时间内完成规定的功能的能力，即业界所说的三规。是产品的一种固有属性 # 1) 规定的条件：产品的运行环境 # 环境条件：温度，湿度，压力，振动，冲击，电磁场，电磁辐射等等 工作条件：工作应力，系统负载，业务模型，人员操作等等 2) 规定的时间：产品的生命周期 # 工作时间：时长（小时）、频次（次数）、距离（公里），例如交换机寿命20年，手机寿命5年，手机划盖工作寿命6万次，汽车寿命30万公里 非工作时间：待机状态，储存状态等 3) 规定的功能：产品的技术性指标 # 指产品标准或产品技术条件中所规定的各项技术性能（技术指标） 1.2. 故障（Fault）：系统内的对象实体相对正常状态的偏离（站在这个对象的外部来看）的一种静态状态。例如进程挂死，硬盘坏道，CPU降频，网络丢包，文件系统只读，配置文件丢失等等 # 偏离的表现形式称之为故障模式 = 故障对象（主语）+ 故障表现（谓语） 故障对象：保证系统运行以及提供业务能力的物理（硬盘、网卡等等）或者逻辑实体（进程、文件、数据等），可以是一个单一实体，也可以是多个单一实体组成的综合实体（主机、集群、站点等），其本质是系统的组成成分，类似于一座房子的墙面，房梁、房檐、砖头、瓦片；也类似于一个人的四肢、眼睛、耳朵、嘴巴等 故障表现：偏离于正常状态的表达，一般是动词、形容词来表示，比如只读、退出、掉电、卡慢、崩溃、坏道、高温、泄漏、过载、损坏、丢失、抢占、重启、失败、空间满等等 系统是由软件和硬件构成的，所以系统的故障对象就是软件和硬件，其中硬件包含主机（主机本身如主板、机箱等；以及主机上的硬件部件如硬盘、网卡、CPU、电源、风扇、内存、PCIE接口等等）以及网络设备（用于主机之间的连接，例如交换机、路由器、光纤网线、网卡/光模块等），软件包含操作系统（内核、驱动、系统服务等）、系统业务软件（包含进程、服务、容器、虚拟机、数据、文件、开源中间件等等） 故障被激活（Active）的时候会产生错误（Error），未被激活的故障就是休眠的/静默的（Dormant） 故障来源： 对象实体内部自然产生的：例如软件缺陷，硬件的自然损坏等。也叫作内源性故障 对象实体外部交互产生的：例如配置类故障（配置项不正确），误操作类故障（误删文件）、交互类故障等、也叫作外源性故障 1.3. 错误（Error）：是故障被激活后的一种动态状态，也是会直接导致业务失效的某种状态（State）。典型的错误如消息发送超时（网络丢包被激活导致的），请求无响应（对端进程挂死被激活导致的），配置文件读失败（配置文件丢失被激活导致的），硬盘写超时（硬盘坏道被激活导致的），硬盘读写慢（硬盘坏道被激活导致的）等等 # 激活：业务操作路径经过了某个存在故障的对象实体，从而导致该对象实体的某个故障被激活（也就是说故障只有被激活才会对系统产生影响，静默故障是无害的） 错误检测：当某个错误信息或者错误信号（Error message or Error signal）未被感知到，该错误就叫做静默错误（Latent Error），例如未感知到超时等 错误未被检测或者检测到而未有容错处理的话，就会产生业务失效（中断、性能下降等） 错误模式：类似于故障模式，区别是错误对象通常是业务操作而不是系统内部组件，错误表现和故障表现基本上是一样的 1.4. 失效（Failure）：系统当前的业务偏离正常业务（Correct Service ）的事件 # 偏离的表现：未按照规格要求实现或者规格要求本身不完整，通常称之为业务中断（Service Outage） 偏离正常业务的表现形式称之为失效模式（Failure Mode） = 失效对象 + 失效表现 失效对象：与故障对象不同的是，失效是基于外部客户业务的角度进行描述的，因此失效对象主要为客户的业务类型/模型或者抽象表达，所以描述为业务（数据面-用户业务）、数据（数据面-用户数据）、控制台（管控面）、扩容（运维面）、升级（运维面）、更换（运维面）等等诸如此类 失效表现：相对于故障表现而言，会更加聚焦一些，一般也是动词、形容词来表达，主要有中断，卡慢，超时，丢失/错误，失败等 失效的行为规律： 持续性失效：一直失效直到人为恢复 间歇性/周期性失效：周期性或者无规律隔段时间出现一次然后自我恢复 偶然性失效：偶然出现一次然后自我恢复 失效对客户业务不同的影响程度的等级叫做失效严重程度（ Failure Severities ），也叫失效严酷度 失效对象对于客户而言就有重要性之分（不同的业务类型有着不同的重要性，比如说数据面业务重要性要大于管控面业务），同时对象本身还隐含着范围的概念（主要是指影响的用户数量，比如是影响了所有用户，还是影响了少部分用户，影响的用户数据范围等） 失效表现的角度来看也会有所区分，从两个维度来看，一是失效表现本身对客户的影响大小（比如数据丢失就是业务中断要影响大，中断要比卡慢影响大等等），二是失效表现的关键特征（包括持续时间例如时间越长对客户影响越大、出现次数例如次数越多则对客户影响越大） 在其他条件同等下，业务越重要、影响用户越多、影响越深、持续时间越长、发生次数越多则严重程度越高 可以是部分业务失效也可以是全部业务失效。部分失效也叫作降级工作状态，表现为业务降速，业务受限，应急状态等 失效是在系统的边界处体现出来的非正常的输出表现 1.5. MTBF（Mean Time Between Failure）平均失效间隔时间 # $$ MTBF = \\frac{累计工作时间}{累计故障次数} $$\n仅适用于可维修产品 一般大于设计寿命 1.6. MTTF（Mean Time To Failure）平均无故障工作时间 # $$ MTTF = \\frac{总工作时间}{故障数量} $$\n针对不可修产品 2. 度量体系 # 2.1. 业务零中断 # 2.2. 数据零丢失 # 2.3. 抗百倍过载 # 2.4. 故障秒级检测与自愈 # 2.5. 事故分钟级恢复 # 2.6. 测试指标 # 故障自动检测率 故障自动恢复率 故障自动检测时长、故障自动恢复时长 故障人工恢复时长 过载保护评估: 过载倍数下保障正常负载的成功率，如5倍负载保障1倍负载的98%可用 3. 系统可靠性设计 # 3.1. 故障预防 # 1) 人因差错 # 防用户出错：例如硬件防用户插反，软件上阻止用户的错误操作（系统不支持的操作），删除操作光标默认在取消键 防出错影响：例如硬盘插错服务器了，IP地址冲突了 改错误结果：例如用户配置错了，能够修改正确 2) 高危操作 # 风险预警：风险说明，用户确认，必要时输入管理员密码 3) 失效检查：导致后续失败的条件，尽早检查，在入口检查 # 兼容检查：对于不兼容的软件，硬件，运行环境，给用户提示，不允许下一步操作 失败检查：例如升级前检查，导致升级失败的不让升级；文件复制前的存储空间检查 3.2. 故障检测\u0026amp;定位 # 1) 故障检测：将系统内的故障通过业务程序本身或者公共程序感知出来 # 业务路径上的故障（Error）：业务流程直接感知的会导致业务出现失败的故障，例如消息超时无响应，空间不足，读写错误，发送失败等 非业务路径的故障（Fault）：业务流程不可直接感知的，但是会潜在的或者直接的导致业务失败的故障，例如进程挂死，网络断开，资源过载、电源损坏，SSD寿命到期等等 2) 故障定位：故障发生的位置 # 软件故障：定位到可管理单元（FMU），软件模块（进程，服务，文件等等） 硬件故障：定位到可更换单元（FRU），硬盘，网口，光模块，内存（物理位置信息） 3.3. 故障隔离：在软件模块，硬件部件、网络冗余部署的情况下，隔离机制才有效。 # 硬件部件：硬件出现整体或者局部的损坏（变慢等），特别是局部的损坏（比如内存有局部损坏，将局部区域隔离，该内存条可以继续使用）价值更大，将该硬件整体或者局部区域（硬件还可以使用）不再使用 软件模块：软件模块出现整体无法运行或者频繁启停或者运行缓慢，将该软件模块停止运行并从软件模块集群中分离出来 网络连接：网络连接出现中断，闪断、丢包、延迟等现象，将该网络连接断开或者让软件不使用该网络连接 3.4. 故障上报：需要用户介入处理的故障才要上报告警 # 故障预警：当前还未产生影响，但是如果不处理，后续可能产生影响。比如资源过载，容量过载，寿命到期之类的故障 自动容错：该故障系统有容错措施，未对用户产生业务影响，但是系统无法自动修复该故障本身，需要人工介入恢复，比如进程无法启动，网络断开，硬件损坏等 业务失效：该故障已经对用户业务造成了影响，系统无法自动恢复该故障，比如数据损坏，主备倒换失败，主备机同时故障 3.5. 故障恢复\u0026amp;修复 # 1) 业务恢复：用户业务的恢复，包括自动和手动两种方式 # 软件模块：自动的机制如故障对象自动重启，故障对象自动切换（双机、集群等），发送方自动重试，发送方重新选择发送路径或者发送对象，备份恢复；手动的机制就是应急处理（人工介入） 硬件模块：自动的机制就是切换到另一个冗余部件上去，或者采用隔离技术将局部硬件故障隔离。手动的机制同软件模块 2) 故障修复：故障本身的恢复，也可能会直接产生业务恢复 # 软件模块：通过备份进行恢复（文件，数据）；升级补丁等 硬件模块：硬件维修，硬件更换、硬件拔插 3.6. 冗余设计 # 冗余设计是设备故障自动恢复的条件之一 软件上的冗余意义不大，同样条件下切换了软件还是会出现问题 一般冗余是主机冗余和网络冗余 硬件通过冗余可以提升可靠性，但是软件无法通过冗余提升可靠性 1) 主机冗余 # 主机冗余一般是两台主机做主备 对于主机内部一般是电源、风险、系统盘做冗余，cpu、内存等不做冗余 主机冗余一般是考虑故障率和成本的平衡 2) 网络冗余 # 一般是网口、交换机等设备的冗余 3.7. 故障管理 # 1) 总体框架 # 系统可靠性服务不能耦合被管理对象 可靠性服务需要比被管理服务简单，否则无法保障可靠性 2) 故障隔离 # 网络平面隔离 物理隔离: 不同网络平面采取不同的物理接口 逻辑隔离: 使用vlan进行隔离，单平面故障不影响其他平面 集群隔离 每个集群内部故障只影响本集群的问题，不影响其他集群节点 业务平面隔离 管理面、控制面和数据面隔离，数据面卡死不影响管理面访问 逃生通道、BMC 数据隔离 用户数据: 不同数据分布在不同硬盘、不同主机、不同站点等 系统数据: 配置数据和日志数据放在不同的磁盘分区；配置数据支持备份到第三方系统；元数据和数据放在不同存储介质 资源隔离 物理隔离: cpu和内存的物理绑定，硬盘分区 逻辑隔离: QoS控制机制，cgroup机制，目录配额 3) 过载保护 # (1) 熔断 # 定义目标服务调用慢或超时的熔断阈值，超过阈值定义熔断机制，隔离服务或者其他跳过机制 低于阈值后恢复调用 熔断是防止雪崩，存在关闭、半熔断、开启三种状态 (2) 限流 # 限流是在已有的条件下，最大限度发挥系统效能 限流阈值需要基于现有业务和系统进行确定 量化限流阈值 确定限流策略、算法 被限制流量的处理 限流算法业界推荐【两窗两桶】：固定窗口、滑动窗口、漏桶、令牌桶 实现原则 对于进程、服务消耗的资源，需要有约束机制，避免异常超额消耗和超长时间占用 要实时监控各种资源的占用情况，在达到即将饱和之前，对接入业务量进行控制 发生过载时建议考虑业务/客户优先级，保证高优先级业务/客户优先获得资源 控制要尽早，在源头控制，在第一个能识别流量的模块开始控制 如果一个业务有多个消息，只要第一个消息进入系统了，后面的消息不要被流控掉 4. 特性可靠性设计 # 4.1. FMEA （Failure Mode and Effects Analysis）失效模式及后果 # 通过对可能发生的失效模式进行分析与判断其可能造成的后果而产生风险程度的一种量化的定性分析计算方法，并根据风险的大小，采取有针对性的改进，从而了解产品设计能力，达成一种事先预防并实施改进措施进行改进的方法工具\n1) 行动优先级 AP Action Priority # 行动优先级: 评估每一种失效原因的风险等级以便确定实施改建措施的顺序，AP = S * O * D\n严重度S（Severity）：也叫严酷度，假定失效模式出现后造成的潜在后多程度，对客户业务的影响程度 频度O（Occurrence） 探测度D（Detection） AP分为低中高三个级别\n2) 总体步骤 # 功能定义 =\u0026gt; 失效分析 =\u0026gt; 行动排序 =\u0026gt; 改进措施\n知识补充 # 1. 内存错误 # CE（Correctable Error）：可恢复错误 UE（Uncorrectable Error）：不可恢复错误 2. 网络 # 2.1. Bond网络模式 # 将多张网卡虚拟为一张，对外显示为一张，共用ip和mac地址。用于做网络硬件层面的冗余，防止单网口应用的单点故障\n3. 主机 # 3.1. BMC（Baseboard Management Controller） 板级控制管理器 # BMC自有硬件接口（LAN/Serial）和软件（Firmware/Linux）； 遵循 IPMI 协议，对外提供统一的访问接口； 作为服务器特有模块，提供温度，电压，风扇，总线监控；提供管理接口，便于进行远程管理服务器; BMC使用独立的Power，在系统关机时依然处于工作状态. 4. 可靠性 # 基本可靠性：是指产品在规定的条件下和规定的时间内，无故障工作的能力 任务可靠性：是指按要求完成该任务的可能性 使用可靠性：是指产品在实际的环境中使用时所呈现的可靠性 固有可靠性：计算机控制系统在制造过程中需要进行材料和元件的选择、设计、制造、组装，环境实验等。由这一过程所决定的可靠性是系统的内在可靠性，称为系统的固有可靠性。系统的固有可靠性决定于生产厂家。 "},{"id":15,"href":"/docs/ai/keywords/","title":"名词解释和学习大纲","section":"AI相关","content":" 一、人工智能通识 # 1. 数学基础 # 1.1. 归一化 # 对数据范围缩小到(0, 1)范围内 为什么做归一化 # 会对准确率造成影响。不对数据进行归一化的话，如果你的网络层数又比较多的话，很有可能会造成梯度消失或梯度爆炸，而这会对你的权重的更新会造成很大的影响进而会影响模型的性能。 另外，如果你的特征之间因为量纲的影响而造成数据之间的数量级差别很大的话也会对训练出的模型的性能造成影响\n1.2. 梯度消失和梯度爆炸 # 梯度消失: 在反向传播过程中，随着算法向下传播到较低层，梯度通常会越来越小。结果梯度下降更新使较低层的连接权重保持不变，训练不能收敛到一个好的最优解 梯度爆炸: 在某些情况下，可能会出现相反的情况：梯度可能会越来越大，各层需要更新很大的权重直到算法发散为止 1.3. 精确度、准确率、召回率 # TP (True Positives): 真实的为1的样本（样本为true，预测准确，预测为true） TN (True Negatives): 真实的为0的样本（样本为false，预测准确，预测为false） FP (False Positives): 错误预测为1的样本（样本为false，预测错误，预测为true） FN (False Negatives): 错误预测为0的样本（样本为true，预测错误，预测为false）\n精确度 precision # $$ P = \\frac{TP}{TP+FP} = \\frac{实际为1被判定正确的数量}{预测为1的样本总数} $$\n主要反映对于0的误判率，如恶意文件扫描，精确度反映了对于恶意文件的扫描精确程度 换成一杯水，代表水中真实可以喝的水占整体水的总量 为1代表预测的正样本都是对的 准确率 accuracy # $$ A = \\frac{TP+TN}{TP+TN+FP+FN} = \\frac{实际为1判定正确的数量+实际为0判定正确的数量}{样本总数} $$\n准确率就是展示模型是否准确的基本数值 召回率 recall # $$ R = \\frac{TP}{TP+FN} = \\frac{实际为1被判定正确的数量}{实际为1的样本总数} $$\n主要反映误判的概率，如恶意文件扫描，召回率可以展示误杀的情况 换成一杯水，代表杯子里面水占杯子容积的大小 为1代表所有正样本都被预测出来了 2. 机器学习 # 2.1. 生成学习算法 # 朴素贝叶斯算法\n2.2. 分类与回归算法 # 决策树算法/支持向量机算法\n1) XGBoost算法 # 调参: https://blog.csdn.net/qq_36535820/article/details/120507280 2.3. 监督学习 # 神经网络算法/迁移学习\n2.4. 无监督学习 # 自编码器(Auto-Encoder)/变分自编码器(VAE)/PCA主成分分析算法/聚类算法\n2.5. 强化学习 # 马尔科夫链/蒙特卡洛模型/价值学习(Value-Based Learning)/策略学习(Value-Based Learning)\n3. 深度学习 # 二、NLP: Natural language processing 自然语言处理 # 1. 应用场景 # 互联网舆情监测 检索问答系统 基于transformer+crf的信息抽取 2. 语言模型基础 # 2.1. 自然语言处理基础 # 语言模型评价标准/文本生成方式\n2.2. N-Gram模型 # HMM模型/MEMM模型/CRF模型\n2.3. 概率图模型 # 2.4. 文本预处理 # 文本分词/停用词过滤/拼写纠错/词性还原\n2.5. 基于统计的文本表示 # 词袋模型/TF IDF模型\n2.6. 基于神经网络的文本表示 # One-Hot表示/Word2Vec表示/Glove模型 /SkipGram/层次Softmax\n3. 前沿语言模型 # 3.1. RNN: Recurrent Neural Network 循环神经网络 # 3.2. RNN改进模型 # 1) LSTM: Long Short Term Memory 长短时记忆神经网络 # 2) GRU: Gated Recurrent Unit 门控循环单元网络 # 3) 双层RNN模型 # 4) 多层RNN模型 # 3.3. Seq2Seq模型 # 1) Encoder-Decoder # 2) RNN+Seq2Seq场景 # 3) Attention+Seq2Seq场景 # 3.4. Transformer模型 # 1) Encoding-Decoder架构 # 2) Self-Attention 自注意力机制 # 3) Masking for Encoder\u0026amp;Decoder # 4) 前馈神经网络 # 5) Layer Normal # 3.5. Bert模型 # 3.6. GPT模型 # 3.7. Prompt Learning # 1) Pre-training范式 # 2) Fine-Tuning范式 # 三、CV: Computer Vision 计算机视觉 # 1. 应用场景 # 基于U-Net医学语义分割 狗的品种识别 基于YoloV5的漫画任务检测 基于生成网络的图像生成 2. 基础 # 经典卷积神经网络(CNN) AlexNeti ZFNet GoogLeNet VGGNeti ResNet DenseNeti SENet MobileNeti ShuffleNeti EfficientNeti 3. 进阶 # 3.1. 图片识别 # Transformer/CNN/MLP\n3.2. 语义分割 # U-Net\n3.3. 目标检测 # Yolo\n3.4. 图像生成 # GAN\nhttps://zhuanlan.zhihu.com/p/392406205 https://zhuanlan.zhihu.com/p/59483058 https://www.xjx100.cn/news/550822.html?action=onClick https://www.modb.pro/db/99980 https://www.fx361.com/page/2022/0712/14907807.shtml https://www.cnblogs.com/LHWorldBlog/p/9195623.html https://xz.aliyun.com/t/10522 https://zhuanlan.zhihu.com/p/562983875\n"},{"id":16,"href":"/docs/linux/linux-kernel/fs/common/","title":"文件系统总述","section":"/fs/ 文件部分","content":" 一、内核文件系统数据结构 # 1. 各个结构体关系 # 1.1. 常规文件 # 2. file # 每个被打开的文件对应一个file结构体，跟fd关联 1// include/linux/fs.h 2struct file { 3\tunion { 4\tstruct llist_node\tfu_llist; 5\tstruct rcu_head fu_rcuhead; 6\t} f_u; 7\tstruct path\tf_path; 8\tstruct inode\t*f_inode;\t/* cached value */ 9\tconst struct file_operations\t*f_op; 10 11\t/* 12\t* Protects f_ep, f_flags. 13\t* Must not be taken from IRQ context. 14\t*/ 15\tspinlock_t\tf_lock; 16\tatomic_long_t\tf_count; 17\tunsigned int f_flags; 18\tfmode_t\tf_mode; 19\tstruct mutex\tf_pos_lock; 20\tloff_t\tf_pos; 21\tstruct fown_struct\tf_owner; 22\tconst struct cred\t*f_cred; 23\tstruct file_ra_state\tf_ra; 24 25\tu64\tf_version; 26#ifdef CONFIG_SECURITY 27\tvoid\t*f_security; 28#endif 29\t/* needed for tty driver, and maybe others */ 30\tvoid\t*private_data; // epoll等特殊文件会将自己的结构体指针放到这里 31 32#ifdef CONFIG_EPOLL 33\t/* Used by fs/eventpoll.c to link all the hooks to this file */ 34\tstruct hlist_head\t*f_ep; 35#endif /* #ifdef CONFIG_EPOLL */ 36\tstruct address_space\t*f_mapping; 37\terrseq_t\tf_wb_err; 38\terrseq_t\tf_sb_err; /* for syncfs */ 39} __randomize_layout 40 __attribute__((aligned(4)));\t/* lest something weird decides that 2 is OK */ 2.1. inode # 1// include/linux/fs.h 2/* 3 * Keep mostly read-only and often accessed (especially for 4 * the RCU path lookup and \u0026#39;stat\u0026#39; data) fields at the beginning 5 * of the \u0026#39;struct inode\u0026#39; 6 */ 7struct inode { 8\tumode_t\ti_mode; 9\tunsigned short\ti_opflags; 10\tkuid_t\ti_uid; 11\tkgid_t\ti_gid; 12\tunsigned int\ti_flags; 13 14#ifdef CONFIG_FS_POSIX_ACL 15\tstruct posix_acl\t*i_acl; 16\tstruct posix_acl\t*i_default_acl; 17#endif 18 19\tconst struct inode_operations\t*i_op; 20\tstruct super_block\t*i_sb; 21\tstruct address_space\t*i_mapping; 22 23#ifdef CONFIG_SECURITY 24\tvoid\t*i_security; 25#endif 26 27\t/* Stat data, not accessed from path walking */ 28\tunsigned long\ti_ino; 29\t/* 30\t* Filesystems may only read i_nlink directly. They shall use the 31\t* following functions for modification: 32\t* 33\t* (set|clear|inc|drop)_nlink 34\t* inode_(inc|dec)_link_count 35\t*/ 36\tunion { 37\tconst unsigned int i_nlink; 38\tunsigned int __i_nlink; 39\t}; 40\tdev_t\ti_rdev; 41\tloff_t\ti_size; 42\tstruct timespec64\ti_atime; 43\tstruct timespec64\ti_mtime; 44\tstruct timespec64\ti_ctime; 45\tspinlock_t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */ 46\tunsigned short i_bytes; 47\tu8\ti_blkbits; 48\tu8\ti_write_hint; 49\tblkcnt_t\ti_blocks; 50 51#ifdef __NEED_I_SIZE_ORDERED 52\tseqcount_t\ti_size_seqcount; 53#endif 54 55\t/* Misc */ 56\tunsigned long\ti_state; 57\tstruct rw_semaphore\ti_rwsem; 58 59\tunsigned long\tdirtied_when;\t/* jiffies of first dirtying */ 60\tunsigned long\tdirtied_time_when; 61 62\tstruct hlist_node\ti_hash; 63\tstruct list_head\ti_io_list;\t/* backing dev IO list */ 64#ifdef CONFIG_CGROUP_WRITEBACK 65\tstruct bdi_writeback\t*i_wb;\t/* the associated cgroup wb */ 66 67\t/* foreign inode detection, see wbc_detach_inode() */ 68\tint\ti_wb_frn_winner; 69\tu16\ti_wb_frn_avg_time; 70\tu16\ti_wb_frn_history; 71#endif 72\tstruct list_head\ti_lru;\t/* inode LRU list */ 73\tstruct list_head\ti_sb_list; 74\tstruct list_head\ti_wb_list;\t/* backing dev writeback list */ 75\tunion { 76\tstruct hlist_head\ti_dentry; 77\tstruct rcu_head\ti_rcu; 78\t}; 79\tatomic64_t\ti_version; 80\tatomic64_t\ti_sequence; /* see futex */ 81\tatomic_t\ti_count; 82\tatomic_t\ti_dio_count; 83\tatomic_t\ti_writecount; 84#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING) 85\tatomic_t\ti_readcount; /* struct files open RO */ 86#endif 87\tunion { 88\tconst struct file_operations\t*i_fop;\t/* former -\u0026gt;i_op-\u0026gt;default_file_ops */ 89\tvoid (*free_inode)(struct inode *); 90\t}; 91\tstruct file_lock_context\t*i_flctx; 92\tstruct address_space\ti_data; 93\tstruct list_head\ti_devices; 94\tunion { 95\tstruct pipe_inode_info\t*i_pipe; 96\tstruct cdev\t*i_cdev; 97\tchar\t*i_link; 98\tunsigned\ti_dir_seq; 99\t}; 100 101\t__u32\ti_generation; 102 103#ifdef CONFIG_FSNOTIFY 104\t__u32\ti_fsnotify_mask; /* all events this inode cares about */ 105\tstruct fsnotify_mark_connector __rcu\t*i_fsnotify_marks; 106#endif 107 108#ifdef CONFIG_FS_ENCRYPTION 109\tstruct fscrypt_info\t*i_crypt_info; 110#endif 111 112#ifdef CONFIG_FS_VERITY 113\tstruct fsverity_info\t*i_verity_info; 114#endif 115 116\tvoid\t*i_private; /* fs or device private pointer */ 117} __randomize_layout; 1) inode_operations # 1// include/linux/fs.h 2struct inode_operations { 3\tstruct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int); 4\tconst char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *); 5\tint (*permission) (struct user_namespace *, struct inode *, int); 6\tstruct posix_acl * (*get_acl)(struct inode *, int, bool); 7 8\tint (*readlink) (struct dentry *, char __user *,int); 9 10\tint (*create) (struct user_namespace *, struct inode *,struct dentry *, 11\tumode_t, bool); 12\tint (*link) (struct dentry *,struct inode *,struct dentry *); 13\tint (*unlink) (struct inode *,struct dentry *); 14\tint (*symlink) (struct user_namespace *, struct inode *,struct dentry *, 15\tconst char *); 16\tint (*mkdir) (struct user_namespace *, struct inode *,struct dentry *, 17\tumode_t); 18\tint (*rmdir) (struct inode *,struct dentry *); 19\tint (*mknod) (struct user_namespace *, struct inode *,struct dentry *, 20\tumode_t,dev_t); 21\tint (*rename) (struct user_namespace *, struct inode *, struct dentry *, 22\tstruct inode *, struct dentry *, unsigned int); 23\tint (*setattr) (struct user_namespace *, struct dentry *, 24\tstruct iattr *); 25\tint (*getattr) (struct user_namespace *, const struct path *, 26\tstruct kstat *, u32, unsigned int); 27\tssize_t (*listxattr) (struct dentry *, char *, size_t); 28\tint (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start, 29\tu64 len); 30\tint (*update_time)(struct inode *, struct timespec64 *, int); 31\tint (*atomic_open)(struct inode *, struct dentry *, 32\tstruct file *, unsigned open_flag, 33\tumode_t create_mode); 34\tint (*tmpfile) (struct user_namespace *, struct inode *, 35\tstruct dentry *, umode_t); 36\tint (*set_acl)(struct user_namespace *, struct inode *, 37\tstruct posix_acl *, int); 38\tint (*fileattr_set)(struct user_namespace *mnt_userns, 39\tstruct dentry *dentry, struct fileattr *fa); 40\tint (*fileattr_get)(struct dentry *dentry, struct fileattr *fa); 41} ____cacheline_aligned; 2.2. path # 1// include/linux/path.h 2struct path { 3\tstruct vfsmount *mnt; 4\tstruct dentry *dentry; 5} __randomize_layout; 2.3. file_operations # 1// include/linux/fs.h 2struct file_operations { 3\tstruct module *owner; 4\tloff_t (*llseek) (struct file *, loff_t, int); 5\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *); 6\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); 7\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *); 8\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *); 9\tint (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *, 10\tunsigned int flags); 11\tint (*iterate) (struct file *, struct dir_context *); 12\tint (*iterate_shared) (struct file *, struct dir_context *); 13\t__poll_t (*poll) (struct file *, struct poll_table_struct *); 14\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); 15\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long); 16\tint (*mmap) (struct file *, struct vm_area_struct *); 17\tunsigned long mmap_supported_flags; 18\tint (*open) (struct inode *, struct file *); 19\tint (*flush) (struct file *, fl_owner_t id); 20\tint (*release) (struct inode *, struct file *); 21\tint (*fsync) (struct file *, loff_t, loff_t, int datasync); 22\tint (*fasync) (int, struct file *, int); 23\tint (*lock) (struct file *, int, struct file_lock *); 24\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); 25\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); 26\tint (*check_flags)(int); 27\tint (*flock) (struct file *, int, struct file_lock *); 28\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); 29\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); 30\tint (*setlease)(struct file *, long, struct file_lock **, void **); 31\tlong (*fallocate)(struct file *file, int mode, loff_t offset, 32\tloff_t len); 33\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f); 34#ifndef CONFIG_MMU 35\tunsigned (*mmap_capabilities)(struct file *); 36#endif 37\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *, 38\tloff_t, size_t, unsigned int); 39\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in, 40\tstruct file *file_out, loff_t pos_out, 41\tloff_t len, unsigned int remap_flags); 42\tint (*fadvise)(struct file *, loff_t, loff_t, int); 43\tint (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags); 44} __randomize_layout; 3. files_struct # 进程结构体中持有的管理文件的结构体 1// include/linux/fdtable.h 2/* 3 * Open file table structure 4 */ 5struct files_struct { 6 /* 7 * read mostly part 8 */ 9\tatomic_t count; 10\tbool resize_in_progress; 11\twait_queue_head_t resize_wait; 12 13\tstruct fdtable __rcu *fdt; 14\tstruct fdtable fdtab; 15 /* 16 * written part on a separate cache line in SMP 17 */ 18\tspinlock_t file_lock ____cacheline_aligned_in_smp; 19\tunsigned int next_fd; 20\tunsigned long close_on_exec_init[1]; 21\tunsigned long open_fds_init[1]; 22\tunsigned long full_fds_bits_init[1]; 23\tstruct file __rcu * fd_array[NR_OPEN_DEFAULT]; 24}; 3.1. fdtable # 1// include/linux/fdtable.h 2struct fdtable { 3\tunsigned int max_fds; 4\tstruct file __rcu **fd; /* current fd array */ 5\tunsigned long *close_on_exec; 6\tunsigned long *open_fds; 7\tunsigned long *full_fds_bits; 8\tstruct rcu_head rcu; 9}; "},{"id":17,"href":"/docs/linux/kernel-troubleshooting/knowledge/","title":"知识性说明","section":"内核问题排查记录","content":" 一、vmcore解析 # 1. 寄存器 # 1.1. 参数寄存器 # 64位汇编中，当参数少于7个时，参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9 1.2. rsp 栈指针寄存器（指向栈顶） # x86汇编中 callq会将下一跳地址放到rsp中，rsp自动减四 push会放到rsp，rsp自动减四 pop会rsp加四，对应的值存放到寄存器中 1.3. gs percpu的基地址寄存器 # FS/GS寄存器的用途\n现代linux x86-64下gs里面存储了percpu的基地址，汇编中使用%gs:0x15bc0来取percpu的一些变量地址 用户态无法使用gs寄存器 "},{"id":18,"href":"/docs/mysql/compile/","title":"编译和调试方法","section":"mysql源码分析记录","content":" 一、概述 # mysql本身的开源就让我们可以很方便的编译出debug版本进行调试\n二、调试环境准备 # 1. 编译mysql的debug版本 # 预安装软件 1yum install ncurses-devel bison cmake libarchive gcc-toolset-10-gcc gcc-toolset-10-gcc-c++ gcc-toolset-10-binutils libtirpc-devel rpcgen 源码下载地址: https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.33.tar.gz 需要下载boost库1.73: https://boostorg.jfrog.io/artifactory/main/release/1.73.0/source/boost_1_73_0.tar.bz2 解压boost库到mysql-8.0.33/boost_1_73_0 编译命令 1# -DWITH_BOOST=./boost_1_73_0/ 指定boost库路径 2# -DWITH_DEBUG=1 编译成debug版本 3cmake -B build -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DWITH_BOOST=./boost_1_73_0/ -DWITH_DEBUG=1 4cmake --build build -j 8 执行命令为下面的输出即为成功编译出debug版 1=\u0026gt; ./build/runtime_output_directory/mysqld --version 2/mysql-8.0.33/build/runtime_output_directory/mysqld Ver 8.0.33-debug for Linux on x86_64 (Source distribution) 2. 替换mysqld进行调试 # 编译好之后，需要上传./build/runtime_output_directory/mysqld和./build/runtime_output_directory/lib目录到服务器 1=\u0026gt; cd build 2=\u0026gt; zip -r mysql-8.0.33.zip ./runtime_output_directory/mysqld ./lib 3=\u0026gt; scp mysql-8.0.33.zip admin@x.x.x.x:~/ 上传之后解压后目录结构如下 1=\u0026gt; tree mysql-8.0.33/ 2mysql-8.0.33/ 3├── runtime_output_directory 4│ └── mysqld 5└── lib 6 ├── libduktape.so 7 ├── libhttp_client.so 8 ├── libjson_binlog.so 9 ├── libjson_binlog.so.8.0.27 10 ├── libmetadata_cache_tests.so 11 ├── libmysqlclient.so 12 ├── libmysqlclient.so.21 13 ├── libmysqlclient.so.21.2.27 14 ├── libmysqlharness.so 15 ├── libmysqlharness.so.1 16 ├── libmysqlharness_stdx.so 17 ├── libmysqlharness_stdx.so.1 18 ... 启新进程 1=\u0026gt; export LD_LIBRARY_PATH=/home/admin/mysql-8.0.33/lib 2=\u0026gt; /home/admin/mysql-8.0.33/runtime_output_directory/mysqld -defaults-file=/app/native-app/sdp-mysqld/conf/my.cnf --user=mysql 先在设备安装yum install gdb-gdbserver\n开启gdbserver远程调试\n1# 先找到mysqld的进程号 2=\u0026gt; ps aux | grep mysqld 3mysql 3044 0.5 6.8 1061784 548580 ? Ssl 9月20 5:24 /home/admin/mysql-8.0.33/runtime_output_directory/mysqld --defaults-file=/etc/my.cnf --user=mysql 4admin 22163 0.0 0.0 12320 984 pts/4 S+ 14:49 0:00 grep --color=auto mysqld 5# 挂载到进程3044，起本地监听6666 6=\u0026gt; gdbserver 0.0.0.0:6666 --attach 3044 本地vscode打开mysql的源码目录，设置launch.json如下后，f5就可以开始调试了 1{ 2 \u0026#34;name\u0026#34;: \u0026#34;(gdb) Attach\u0026#34;, 3 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, 4 \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, 5 \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/build/runtime_output_directory/mysqld\u0026#34;, 6 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, 7 \u0026#34;miDebuggerServerAddress\u0026#34;: \u0026#34;x.x.x.x:6666\u0026#34;, 8 \u0026#34;cwd\u0026#34;: \u0026#34;.\u0026#34;, 9 \u0026#34;setupCommands\u0026#34;: [ 10 { 11 \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, 12 \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, 13 \u0026#34;ignoreFailures\u0026#34;: true 14 }, 15 { 16 \u0026#34;description\u0026#34;: \u0026#34;Set Disassembly Flavor to Intel\u0026#34;, 17 \u0026#34;text\u0026#34;: \u0026#34;-gdb-set disassembly-flavor intel\u0026#34;, 18 \u0026#34;ignoreFailures\u0026#34;: true 19 } 20 ] 21} "},{"id":19,"href":"/docs/linux/linux-kernel/compile-thinking/","title":"编译思想","section":"linux内核源码分析记录","content":" 一、typeof((fifo) + 1) __tmp = (fifo); # 想要外部传入的fifo为指针而非结构体，使用这个写法可以在编译期报错 当传入是指针，加1操作不会影响typeof结果，如果是结构体，加1操作编译会直接报错 "},{"id":20,"href":"/docs/linux/linux-kernel/net/common/","title":"网络数据包处理流程","section":"/net/ 网络部分","content":"参考一个比较好的帖子 理解 Linux 网络栈（1）：Linux 网络协议栈简单总结\n一、从驱动来的包处理流程 # 图取自 linux内核协议栈 UDP之数据报接收过程\n堆栈信息，从软中断到ip_rcv_finish\nip_rcv_finish(struct net * net, struct sock * sk, struct sk_buff * skb) (/net/ipv4/ip_input.c:449) NF_HOOK(uint8_t pf, unsigned int hook, struct net_device * in, struct net_device * out, int (*)(struct net *, struct sock *, struct sk_buff *) okfn, struct sk_buff * skb, struct sock * sk, struct net * net) (/include/linux/netfilter.h:307) __netif_receive_skb_one_core(struct sk_buff * skb, bool pfmemalloc) (/net/core/dev.c:5484) netif_receive_skb_internal(struct sk_buff * skb) (/net/core/dev.c:5684) netif_receive_skb(struct sk_buff * skb) (/net/core/dev.c:5743) [Unknown/Just-In-Time compiled code] (Unknown Source:0) fixed_percpu_data (Unknown Source:0) [Unknown/Just-In-Time compiled code] (Unknown Source:0) fixed_percpu_data (Unknown Source:0) [Unknown/Just-In-Time compiled code] (Unknown Source:0) "},{"id":21,"href":"/docs/linux/linux-kernel/drivers/net/common/","title":"通用网络驱动开发知识","section":"net/ 网卡驱动部分","content":" 一、驱动到网络协议栈处理过程 # @startuml box kernel #White participant net participant ksoftirqd end box box driver #White participant eth end box participant cpu autonumber net -\u0026gt; eth: net_device_ops::ndo_open eth -\u0026gt; cpu: 注册硬件中断处理函数 eth -\u0026gt; net: 调用netif_napi_add注册poll函数到napi列表里面 == 收到包 == autonumber 1 cpu -\u0026gt; eth: 来中断了 eth -\u0026gt; ksoftirqd: 设置软中断NET_RX_SOFTIRQ ksoftirqd -\u0026gt; net: 根据软中断类型调用net_rx_action net -\u0026gt; eth: 从napi列表中遍历处理，找到对应的poll函数 eth -\u0026gt; eth: 从硬件buffer中读取数据帧创建sk_buff eth -\u0026gt; net: 将sk_buff通过函数napi_gro_receive调用到内核 net -\u0026gt; net: napi_gro_receive =\u0026gt; napi_skb_finish net -\u0026gt; net: napi_skb_finish =\u0026gt; netif_receive_skb net -\u0026gt; net: netif_receive_skb =\u0026gt; deliver_skb net -\u0026gt; net: deliver_skb =\u0026gt; ip_rcv @enduml 二、驱动定义 # 1. 驱动操作结构体 net_device_ops # 每一个网卡需要定义下面这一系列操作函数 1// include/linux/netdevice.h 2/* 3 * This structure defines the management hooks for network devices. 4 * The following hooks can be defined; unless noted otherwise, they are 5 * optional and can be filled with a null pointer. 6 * 7 * int (*ndo_init)(struct net_device *dev); 8 * This function is called once when a network device is registered. 9 * The network device can use this for any late stage initialization 10 * or semantic validation. It can fail with an error code which will 11 * be propagated back to register_netdev. 12 * 13 * void (*ndo_uninit)(struct net_device *dev); 14 * This function is called when device is unregistered or when registration 15 * fails. It is not called if init fails. 16 * 17 * int (*ndo_open)(struct net_device *dev); 18 * This function is called when a network device transitions to the up 19 * state. 20 * 21 * int (*ndo_stop)(struct net_device *dev); 22 * This function is called when a network device transitions to the down 23 * state. 24 * 25 * netdev_tx_t (*ndo_start_xmit)(struct sk_buff *skb, 26 * struct net_device *dev); 27 *\tCalled when a packet needs to be transmitted. 28 *\tReturns NETDEV_TX_OK. Can return NETDEV_TX_BUSY, but you should stop 29 *\tthe queue before that can happen; it\u0026#39;s for obsolete devices and weird 30 *\tcorner cases, but the stack really does a non-trivial amount 31 *\tof useless work if you return NETDEV_TX_BUSY. 32 *\tRequired; cannot be NULL. 33 * 34 * netdev_features_t (*ndo_features_check)(struct sk_buff *skb, 35 *\tstruct net_device *dev 36 *\tnetdev_features_t features); 37 *\tCalled by core transmit path to determine if device is capable of 38 *\tperforming offload operations on a given packet. This is to give 39 *\tthe device an opportunity to implement any restrictions that cannot 40 *\tbe otherwise expressed by feature flags. The check is called with 41 *\tthe set of features that the stack has calculated and it returns 42 *\tthose the driver believes to be appropriate. 43 * 44 * u16 (*ndo_select_queue)(struct net_device *dev, struct sk_buff *skb, 45 * struct net_device *sb_dev); 46 *\tCalled to decide which queue to use when device supports multiple 47 *\ttransmit queues. 48 * 49 * void (*ndo_change_rx_flags)(struct net_device *dev, int flags); 50 *\tThis function is called to allow device receiver to make 51 *\tchanges to configuration when multicast or promiscuous is enabled. 52 * 53 * void (*ndo_set_rx_mode)(struct net_device *dev); 54 *\tThis function is called device changes address list filtering. 55 *\tIf driver handles unicast address filtering, it should set 56 *\tIFF_UNICAST_FLT in its priv_flags. 57 * 58 * int (*ndo_set_mac_address)(struct net_device *dev, void *addr); 59 *\tThis function is called when the Media Access Control address 60 *\tneeds to be changed. If this interface is not defined, the 61 *\tMAC address can not be changed. 62 * 63 * int (*ndo_validate_addr)(struct net_device *dev); 64 *\tTest if Media Access Control address is valid for the device. 65 * 66 * int (*ndo_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd); 67 *\tOld-style ioctl entry point. This is used internally by the 68 *\tappletalk and ieee802154 subsystems but is no longer called by 69 *\tthe device ioctl handler. 70 * 71 * int (*ndo_siocbond)(struct net_device *dev, struct ifreq *ifr, int cmd); 72 *\tUsed by the bonding driver for its device specific ioctls: 73 *\tSIOCBONDENSLAVE, SIOCBONDRELEASE, SIOCBONDSETHWADDR, SIOCBONDCHANGEACTIVE, 74 *\tSIOCBONDSLAVEINFOQUERY, and SIOCBONDINFOQUERY 75 * 76 * * int (*ndo_eth_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd); 77 *\tCalled for ethernet specific ioctls: SIOCGMIIPHY, SIOCGMIIREG, 78 *\tSIOCSMIIREG, SIOCSHWTSTAMP and SIOCGHWTSTAMP. 79 * 80 * int (*ndo_set_config)(struct net_device *dev, struct ifmap *map); 81 *\tUsed to set network devices bus interface parameters. This interface 82 *\tis retained for legacy reasons; new devices should use the bus 83 *\tinterface (PCI) for low level management. 84 * 85 * int (*ndo_change_mtu)(struct net_device *dev, int new_mtu); 86 *\tCalled when a user wants to change the Maximum Transfer Unit 87 *\tof a device. 88 * 89 * void (*ndo_tx_timeout)(struct net_device *dev, unsigned int txqueue); 90 *\tCallback used when the transmitter has not made any progress 91 *\tfor dev-\u0026gt;watchdog ticks. 92 * 93 * void (*ndo_get_stats64)(struct net_device *dev, 94 * struct rtnl_link_stats64 *storage); 95 * struct net_device_stats* (*ndo_get_stats)(struct net_device *dev); 96 *\tCalled when a user wants to get the network device usage 97 *\tstatistics. Drivers must do one of the following: 98 *\t1. Define @ndo_get_stats64 to fill in a zero-initialised 99 *\trtnl_link_stats64 structure passed by the caller. 100 *\t2. Define @ndo_get_stats to update a net_device_stats structure 101 *\t(which should normally be dev-\u0026gt;stats) and return a pointer to 102 *\tit. The structure may be changed asynchronously only if each 103 *\tfield is written atomically. 104 *\t3. Update dev-\u0026gt;stats asynchronously and atomically, and define 105 *\tneither operation. 106 * 107 * bool (*ndo_has_offload_stats)(const struct net_device *dev, int attr_id) 108 *\tReturn true if this device supports offload stats of this attr_id. 109 * 110 * int (*ndo_get_offload_stats)(int attr_id, const struct net_device *dev, 111 *\tvoid *attr_data) 112 *\tGet statistics for offload operations by attr_id. Write it into the 113 *\tattr_data pointer. 114 * 115 * int (*ndo_vlan_rx_add_vid)(struct net_device *dev, __be16 proto, u16 vid); 116 *\tIf device supports VLAN filtering this function is called when a 117 *\tVLAN id is registered. 118 * 119 * int (*ndo_vlan_rx_kill_vid)(struct net_device *dev, __be16 proto, u16 vid); 120 *\tIf device supports VLAN filtering this function is called when a 121 *\tVLAN id is unregistered. 122 * 123 * void (*ndo_poll_controller)(struct net_device *dev); 124 * 125 *\tSR-IOV management functions. 126 * int (*ndo_set_vf_mac)(struct net_device *dev, int vf, u8* mac); 127 * int (*ndo_set_vf_vlan)(struct net_device *dev, int vf, u16 vlan, 128 *\tu8 qos, __be16 proto); 129 * int (*ndo_set_vf_rate)(struct net_device *dev, int vf, int min_tx_rate, 130 *\tint max_tx_rate); 131 * int (*ndo_set_vf_spoofchk)(struct net_device *dev, int vf, bool setting); 132 * int (*ndo_set_vf_trust)(struct net_device *dev, int vf, bool setting); 133 * int (*ndo_get_vf_config)(struct net_device *dev, 134 *\tint vf, struct ifla_vf_info *ivf); 135 * int (*ndo_set_vf_link_state)(struct net_device *dev, int vf, int link_state); 136 * int (*ndo_set_vf_port)(struct net_device *dev, int vf, 137 *\tstruct nlattr *port[]); 138 * 139 * Enable or disable the VF ability to query its RSS Redirection Table and 140 * Hash Key. This is needed since on some devices VF share this information 141 * with PF and querying it may introduce a theoretical security risk. 142 * int (*ndo_set_vf_rss_query_en)(struct net_device *dev, int vf, bool setting); 143 * int (*ndo_get_vf_port)(struct net_device *dev, int vf, struct sk_buff *skb); 144 * int (*ndo_setup_tc)(struct net_device *dev, enum tc_setup_type type, 145 *\tvoid *type_data); 146 *\tCalled to setup any \u0026#39;tc\u0026#39; scheduler, classifier or action on @dev. 147 *\tThis is always called from the stack with the rtnl lock held and netif 148 *\ttx queues stopped. This allows the netdevice to perform queue 149 *\tmanagement safely. 150 * 151 *\tFiber Channel over Ethernet (FCoE) offload functions. 152 * int (*ndo_fcoe_enable)(struct net_device *dev); 153 *\tCalled when the FCoE protocol stack wants to start using LLD for FCoE 154 *\tso the underlying device can perform whatever needed configuration or 155 *\tinitialization to support acceleration of FCoE traffic. 156 * 157 * int (*ndo_fcoe_disable)(struct net_device *dev); 158 *\tCalled when the FCoE protocol stack wants to stop using LLD for FCoE 159 *\tso the underlying device can perform whatever needed clean-ups to 160 *\tstop supporting acceleration of FCoE traffic. 161 * 162 * int (*ndo_fcoe_ddp_setup)(struct net_device *dev, u16 xid, 163 *\tstruct scatterlist *sgl, unsigned int sgc); 164 *\tCalled when the FCoE Initiator wants to initialize an I/O that 165 *\tis a possible candidate for Direct Data Placement (DDP). The LLD can 166 *\tperform necessary setup and returns 1 to indicate the device is set up 167 *\tsuccessfully to perform DDP on this I/O, otherwise this returns 0. 168 * 169 * int (*ndo_fcoe_ddp_done)(struct net_device *dev, u16 xid); 170 *\tCalled when the FCoE Initiator/Target is done with the DDPed I/O as 171 *\tindicated by the FC exchange id \u0026#39;xid\u0026#39;, so the underlying device can 172 *\tclean up and reuse resources for later DDP requests. 173 * 174 * int (*ndo_fcoe_ddp_target)(struct net_device *dev, u16 xid, 175 *\tstruct scatterlist *sgl, unsigned int sgc); 176 *\tCalled when the FCoE Target wants to initialize an I/O that 177 *\tis a possible candidate for Direct Data Placement (DDP). The LLD can 178 *\tperform necessary setup and returns 1 to indicate the device is set up 179 *\tsuccessfully to perform DDP on this I/O, otherwise this returns 0. 180 * 181 * int (*ndo_fcoe_get_hbainfo)(struct net_device *dev, 182 *\tstruct netdev_fcoe_hbainfo *hbainfo); 183 *\tCalled when the FCoE Protocol stack wants information on the underlying 184 *\tdevice. This information is utilized by the FCoE protocol stack to 185 *\tregister attributes with Fiber Channel management service as per the 186 *\tFC-GS Fabric Device Management Information(FDMI) specification. 187 * 188 * int (*ndo_fcoe_get_wwn)(struct net_device *dev, u64 *wwn, int type); 189 *\tCalled when the underlying device wants to override default World Wide 190 *\tName (WWN) generation mechanism in FCoE protocol stack to pass its own 191 *\tWorld Wide Port Name (WWPN) or World Wide Node Name (WWNN) to the FCoE 192 *\tprotocol stack to use. 193 * 194 *\tRFS acceleration. 195 * int (*ndo_rx_flow_steer)(struct net_device *dev, const struct sk_buff *skb, 196 *\tu16 rxq_index, u32 flow_id); 197 *\tSet hardware filter for RFS. rxq_index is the target queue index; 198 *\tflow_id is a flow ID to be passed to rps_may_expire_flow() later. 199 *\tReturn the filter ID on success, or a negative error code. 200 * 201 *\tSlave management functions (for bridge, bonding, etc). 202 * int (*ndo_add_slave)(struct net_device *dev, struct net_device *slave_dev); 203 *\tCalled to make another netdev an underling. 204 * 205 * int (*ndo_del_slave)(struct net_device *dev, struct net_device *slave_dev); 206 *\tCalled to release previously enslaved netdev. 207 * 208 * struct net_device *(*ndo_get_xmit_slave)(struct net_device *dev, 209 *\tstruct sk_buff *skb, 210 *\tbool all_slaves); 211 *\tGet the xmit slave of master device. If all_slaves is true, function 212 *\tassume all the slaves can transmit. 213 * 214 * Feature/offload setting functions. 215 * netdev_features_t (*ndo_fix_features)(struct net_device *dev, 216 *\tnetdev_features_t features); 217 *\tAdjusts the requested feature flags according to device-specific 218 *\tconstraints, and returns the resulting flags. Must not modify 219 *\tthe device state. 220 * 221 * int (*ndo_set_features)(struct net_device *dev, netdev_features_t features); 222 *\tCalled to update device configuration to new features. Passed 223 *\tfeature set might be less than what was returned by ndo_fix_features()). 224 *\tMust return \u0026gt;0 or -errno if it changed dev-\u0026gt;features itself. 225 * 226 * int (*ndo_fdb_add)(struct ndmsg *ndm, struct nlattr *tb[], 227 *\tstruct net_device *dev, 228 *\tconst unsigned char *addr, u16 vid, u16 flags, 229 *\tstruct netlink_ext_ack *extack); 230 *\tAdds an FDB entry to dev for addr. 231 * int (*ndo_fdb_del)(struct ndmsg *ndm, struct nlattr *tb[], 232 *\tstruct net_device *dev, 233 *\tconst unsigned char *addr, u16 vid) 234 *\tDeletes the FDB entry from dev coresponding to addr. 235 * int (*ndo_fdb_del_bulk)(struct ndmsg *ndm, struct nlattr *tb[], 236 *\tstruct net_device *dev, 237 *\tu16 vid, 238 *\tstruct netlink_ext_ack *extack); 239 * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb, 240 *\tstruct net_device *dev, struct net_device *filter_dev, 241 *\tint *idx) 242 *\tUsed to add FDB entries to dump requests. Implementers should add 243 *\tentries to skb and update idx with the number of entries. 244 * 245 * int (*ndo_bridge_setlink)(struct net_device *dev, struct nlmsghdr *nlh, 246 *\tu16 flags, struct netlink_ext_ack *extack) 247 * int (*ndo_bridge_getlink)(struct sk_buff *skb, u32 pid, u32 seq, 248 *\tstruct net_device *dev, u32 filter_mask, 249 *\tint nlflags) 250 * int (*ndo_bridge_dellink)(struct net_device *dev, struct nlmsghdr *nlh, 251 *\tu16 flags); 252 * 253 * int (*ndo_change_carrier)(struct net_device *dev, bool new_carrier); 254 *\tCalled to change device carrier. Soft-devices (like dummy, team, etc) 255 *\twhich do not represent real hardware may define this to allow their 256 *\tuserspace components to manage their virtual carrier state. Devices 257 *\tthat determine carrier state from physical hardware properties (eg 258 *\tnetwork cables) or protocol-dependent mechanisms (eg 259 *\tUSB_CDC_NOTIFY_NETWORK_CONNECTION) should NOT implement this function. 260 * 261 * int (*ndo_get_phys_port_id)(struct net_device *dev, 262 *\tstruct netdev_phys_item_id *ppid); 263 *\tCalled to get ID of physical port of this device. If driver does 264 *\tnot implement this, it is assumed that the hw is not able to have 265 *\tmultiple net devices on single physical port. 266 * 267 * int (*ndo_get_port_parent_id)(struct net_device *dev, 268 *\tstruct netdev_phys_item_id *ppid) 269 *\tCalled to get the parent ID of the physical port of this device. 270 * 271 * void* (*ndo_dfwd_add_station)(struct net_device *pdev, 272 *\tstruct net_device *dev) 273 *\tCalled by upper layer devices to accelerate switching or other 274 *\tstation functionality into hardware. \u0026#39;pdev is the lowerdev 275 *\tto use for the offload and \u0026#39;dev\u0026#39; is the net device that will 276 *\tback the offload. Returns a pointer to the private structure 277 *\tthe upper layer will maintain. 278 * void (*ndo_dfwd_del_station)(struct net_device *pdev, void *priv) 279 *\tCalled by upper layer device to delete the station created 280 *\tby \u0026#39;ndo_dfwd_add_station\u0026#39;. \u0026#39;pdev\u0026#39; is the net device backing 281 *\tthe station and priv is the structure returned by the add 282 *\toperation. 283 * int (*ndo_set_tx_maxrate)(struct net_device *dev, 284 *\tint queue_index, u32 maxrate); 285 *\tCalled when a user wants to set a max-rate limitation of specific 286 *\tTX queue. 287 * int (*ndo_get_iflink)(const struct net_device *dev); 288 *\tCalled to get the iflink value of this device. 289 * int (*ndo_fill_metadata_dst)(struct net_device *dev, struct sk_buff *skb); 290 *\tThis function is used to get egress tunnel information for given skb. 291 *\tThis is useful for retrieving outer tunnel header parameters while 292 *\tsampling packet. 293 * void (*ndo_set_rx_headroom)(struct net_device *dev, int needed_headroom); 294 *\tThis function is used to specify the headroom that the skb must 295 *\tconsider when allocation skb during packet reception. Setting 296 *\tappropriate rx headroom value allows avoiding skb head copy on 297 *\tforward. Setting a negative value resets the rx headroom to the 298 *\tdefault value. 299 * int (*ndo_bpf)(struct net_device *dev, struct netdev_bpf *bpf); 300 *\tThis function is used to set or query state related to XDP on the 301 *\tnetdevice and manage BPF offload. See definition of 302 *\tenum bpf_netdev_command for details. 303 * int (*ndo_xdp_xmit)(struct net_device *dev, int n, struct xdp_frame **xdp, 304 *\tu32 flags); 305 *\tThis function is used to submit @n XDP packets for transmit on a 306 *\tnetdevice. Returns number of frames successfully transmitted, frames 307 *\tthat got dropped are freed/returned via xdp_return_frame(). 308 *\tReturns negative number, means general error invoking ndo, meaning 309 *\tno frames were xmit\u0026#39;ed and core-caller will free all frames. 310 * struct net_device *(*ndo_xdp_get_xmit_slave)(struct net_device *dev, 311 *\tstruct xdp_buff *xdp); 312 * Get the xmit slave of master device based on the xdp_buff. 313 * int (*ndo_xsk_wakeup)(struct net_device *dev, u32 queue_id, u32 flags); 314 * This function is used to wake up the softirq, ksoftirqd or kthread 315 *\tresponsible for sending and/or receiving packets on a specific 316 *\tqueue id bound to an AF_XDP socket. The flags field specifies if 317 *\tonly RX, only Tx, or both should be woken up using the flags 318 *\tXDP_WAKEUP_RX and XDP_WAKEUP_TX. 319 * struct devlink_port *(*ndo_get_devlink_port)(struct net_device *dev); 320 *\tGet devlink port instance associated with a given netdev. 321 *\tCalled with a reference on the netdevice and devlink locks only, 322 *\trtnl_lock is not held. 323 * int (*ndo_tunnel_ctl)(struct net_device *dev, struct ip_tunnel_parm *p, 324 *\tint cmd); 325 *\tAdd, change, delete or get information on an IPv4 tunnel. 326 * struct net_device *(*ndo_get_peer_dev)(struct net_device *dev); 327 *\tIf a device is paired with a peer device, return the peer instance. 328 *\tThe caller must be under RCU read context. 329 * int (*ndo_fill_forward_path)(struct net_device_path_ctx *ctx, struct net_device_path *path); 330 * Get the forwarding path to reach the real device from the HW destination address 331 * ktime_t (*ndo_get_tstamp)(struct net_device *dev, 332 *\tconst struct skb_shared_hwtstamps *hwtstamps, 333 *\tbool cycles); 334 *\tGet hardware timestamp based on normal/adjustable time or free running 335 *\tcycle counter. This function is required if physical clock supports a 336 *\tfree running cycle counter. 337 */ 338struct net_device_ops { 339\tint\t(*ndo_init)(struct net_device *dev); 340\tvoid\t(*ndo_uninit)(struct net_device *dev); 341\tint\t(*ndo_open)(struct net_device *dev); 342\tint\t(*ndo_stop)(struct net_device *dev); 343\tnetdev_tx_t\t(*ndo_start_xmit)(struct sk_buff *skb, 344\tstruct net_device *dev); 345\tnetdev_features_t\t(*ndo_features_check)(struct sk_buff *skb, 346\tstruct net_device *dev, 347\tnetdev_features_t features); 348\tu16\t(*ndo_select_queue)(struct net_device *dev, 349\tstruct sk_buff *skb, 350\tstruct net_device *sb_dev); 351\tvoid\t(*ndo_change_rx_flags)(struct net_device *dev, 352\tint flags); 353\tvoid\t(*ndo_set_rx_mode)(struct net_device *dev); 354\tint\t(*ndo_set_mac_address)(struct net_device *dev, 355\tvoid *addr); 356\tint\t(*ndo_validate_addr)(struct net_device *dev); 357\tint\t(*ndo_do_ioctl)(struct net_device *dev, 358\tstruct ifreq *ifr, int cmd); 359\tint\t(*ndo_eth_ioctl)(struct net_device *dev, 360\tstruct ifreq *ifr, int cmd); 361\tint\t(*ndo_siocbond)(struct net_device *dev, 362\tstruct ifreq *ifr, int cmd); 363\tint\t(*ndo_siocwandev)(struct net_device *dev, 364\tstruct if_settings *ifs); 365\tint\t(*ndo_siocdevprivate)(struct net_device *dev, 366\tstruct ifreq *ifr, 367\tvoid __user *data, int cmd); 368\tint\t(*ndo_set_config)(struct net_device *dev, 369\tstruct ifmap *map); 370\tint\t(*ndo_change_mtu)(struct net_device *dev, 371\tint new_mtu); 372\tint\t(*ndo_neigh_setup)(struct net_device *dev, 373\tstruct neigh_parms *); 374\tvoid\t(*ndo_tx_timeout) (struct net_device *dev, 375\tunsigned int txqueue); 376 377\tvoid\t(*ndo_get_stats64)(struct net_device *dev, 378\tstruct rtnl_link_stats64 *storage); 379\tbool\t(*ndo_has_offload_stats)(const struct net_device *dev, int attr_id); 380\tint\t(*ndo_get_offload_stats)(int attr_id, 381\tconst struct net_device *dev, 382\tvoid *attr_data); 383\tstruct net_device_stats* (*ndo_get_stats)(struct net_device *dev); 384 385\tint\t(*ndo_vlan_rx_add_vid)(struct net_device *dev, 386\t__be16 proto, u16 vid); 387\tint\t(*ndo_vlan_rx_kill_vid)(struct net_device *dev, 388\t__be16 proto, u16 vid); 389#ifdef CONFIG_NET_POLL_CONTROLLER 390\tvoid (*ndo_poll_controller)(struct net_device *dev); 391\tint\t(*ndo_netpoll_setup)(struct net_device *dev, 392\tstruct netpoll_info *info); 393\tvoid\t(*ndo_netpoll_cleanup)(struct net_device *dev); 394#endif 395\tint\t(*ndo_set_vf_mac)(struct net_device *dev, 396\tint queue, u8 *mac); 397\tint\t(*ndo_set_vf_vlan)(struct net_device *dev, 398\tint queue, u16 vlan, 399\tu8 qos, __be16 proto); 400\tint\t(*ndo_set_vf_rate)(struct net_device *dev, 401\tint vf, int min_tx_rate, 402\tint max_tx_rate); 403\tint\t(*ndo_set_vf_spoofchk)(struct net_device *dev, 404\tint vf, bool setting); 405\tint\t(*ndo_set_vf_trust)(struct net_device *dev, 406\tint vf, bool setting); 407\tint\t(*ndo_get_vf_config)(struct net_device *dev, 408\tint vf, 409\tstruct ifla_vf_info *ivf); 410\tint\t(*ndo_set_vf_link_state)(struct net_device *dev, 411\tint vf, int link_state); 412\tint\t(*ndo_get_vf_stats)(struct net_device *dev, 413\tint vf, 414\tstruct ifla_vf_stats 415\t*vf_stats); 416\tint\t(*ndo_set_vf_port)(struct net_device *dev, 417\tint vf, 418\tstruct nlattr *port[]); 419\tint\t(*ndo_get_vf_port)(struct net_device *dev, 420\tint vf, struct sk_buff *skb); 421\tint\t(*ndo_get_vf_guid)(struct net_device *dev, 422\tint vf, 423\tstruct ifla_vf_guid *node_guid, 424\tstruct ifla_vf_guid *port_guid); 425\tint\t(*ndo_set_vf_guid)(struct net_device *dev, 426\tint vf, u64 guid, 427\tint guid_type); 428\tint\t(*ndo_set_vf_rss_query_en)( 429\tstruct net_device *dev, 430\tint vf, bool setting); 431\tint\t(*ndo_setup_tc)(struct net_device *dev, 432\tenum tc_setup_type type, 433\tvoid *type_data); 434#if IS_ENABLED(CONFIG_FCOE) 435\tint\t(*ndo_fcoe_enable)(struct net_device *dev); 436\tint\t(*ndo_fcoe_disable)(struct net_device *dev); 437\tint\t(*ndo_fcoe_ddp_setup)(struct net_device *dev, 438\tu16 xid, 439\tstruct scatterlist *sgl, 440\tunsigned int sgc); 441\tint\t(*ndo_fcoe_ddp_done)(struct net_device *dev, 442\tu16 xid); 443\tint\t(*ndo_fcoe_ddp_target)(struct net_device *dev, 444\tu16 xid, 445\tstruct scatterlist *sgl, 446\tunsigned int sgc); 447\tint\t(*ndo_fcoe_get_hbainfo)(struct net_device *dev, 448\tstruct netdev_fcoe_hbainfo *hbainfo); 449#endif 450 451#if IS_ENABLED(CONFIG_LIBFCOE) 452#define NETDEV_FCOE_WWNN 0 453#define NETDEV_FCOE_WWPN 1 454\tint\t(*ndo_fcoe_get_wwn)(struct net_device *dev, 455\tu64 *wwn, int type); 456#endif 457 458#ifdef CONFIG_RFS_ACCEL 459\tint\t(*ndo_rx_flow_steer)(struct net_device *dev, 460\tconst struct sk_buff *skb, 461\tu16 rxq_index, 462\tu32 flow_id); 463#endif 464\tint\t(*ndo_add_slave)(struct net_device *dev, 465\tstruct net_device *slave_dev, 466\tstruct netlink_ext_ack *extack); 467\tint\t(*ndo_del_slave)(struct net_device *dev, 468\tstruct net_device *slave_dev); 469\tstruct net_device*\t(*ndo_get_xmit_slave)(struct net_device *dev, 470\tstruct sk_buff *skb, 471\tbool all_slaves); 472\tstruct net_device*\t(*ndo_sk_get_lower_dev)(struct net_device *dev, 473\tstruct sock *sk); 474\tnetdev_features_t\t(*ndo_fix_features)(struct net_device *dev, 475\tnetdev_features_t features); 476\tint\t(*ndo_set_features)(struct net_device *dev, 477\tnetdev_features_t features); 478\tint\t(*ndo_neigh_construct)(struct net_device *dev, 479\tstruct neighbour *n); 480\tvoid\t(*ndo_neigh_destroy)(struct net_device *dev, 481\tstruct neighbour *n); 482 483\tint\t(*ndo_fdb_add)(struct ndmsg *ndm, 484\tstruct nlattr *tb[], 485\tstruct net_device *dev, 486\tconst unsigned char *addr, 487\tu16 vid, 488\tu16 flags, 489\tstruct netlink_ext_ack *extack); 490\tint\t(*ndo_fdb_del)(struct ndmsg *ndm, 491\tstruct nlattr *tb[], 492\tstruct net_device *dev, 493\tconst unsigned char *addr, 494\tu16 vid, struct netlink_ext_ack *extack); 495\tint\t(*ndo_fdb_del_bulk)(struct ndmsg *ndm, 496\tstruct nlattr *tb[], 497\tstruct net_device *dev, 498\tu16 vid, 499\tstruct netlink_ext_ack *extack); 500\tint\t(*ndo_fdb_dump)(struct sk_buff *skb, 501\tstruct netlink_callback *cb, 502\tstruct net_device *dev, 503\tstruct net_device *filter_dev, 504\tint *idx); 505\tint\t(*ndo_fdb_get)(struct sk_buff *skb, 506\tstruct nlattr *tb[], 507\tstruct net_device *dev, 508\tconst unsigned char *addr, 509\tu16 vid, u32 portid, u32 seq, 510\tstruct netlink_ext_ack *extack); 511\tint\t(*ndo_bridge_setlink)(struct net_device *dev, 512\tstruct nlmsghdr *nlh, 513\tu16 flags, 514\tstruct netlink_ext_ack *extack); 515\tint\t(*ndo_bridge_getlink)(struct sk_buff *skb, 516\tu32 pid, u32 seq, 517\tstruct net_device *dev, 518\tu32 filter_mask, 519\tint nlflags); 520\tint\t(*ndo_bridge_dellink)(struct net_device *dev, 521\tstruct nlmsghdr *nlh, 522\tu16 flags); 523\tint\t(*ndo_change_carrier)(struct net_device *dev, 524\tbool new_carrier); 525\tint\t(*ndo_get_phys_port_id)(struct net_device *dev, 526\tstruct netdev_phys_item_id *ppid); 527\tint\t(*ndo_get_port_parent_id)(struct net_device *dev, 528\tstruct netdev_phys_item_id *ppid); 529\tint\t(*ndo_get_phys_port_name)(struct net_device *dev, 530\tchar *name, size_t len); 531\tvoid*\t(*ndo_dfwd_add_station)(struct net_device *pdev, 532\tstruct net_device *dev); 533\tvoid\t(*ndo_dfwd_del_station)(struct net_device *pdev, 534\tvoid *priv); 535 536\tint\t(*ndo_set_tx_maxrate)(struct net_device *dev, 537\tint queue_index, 538\tu32 maxrate); 539\tint\t(*ndo_get_iflink)(const struct net_device *dev); 540\tint\t(*ndo_fill_metadata_dst)(struct net_device *dev, 541\tstruct sk_buff *skb); 542\tvoid\t(*ndo_set_rx_headroom)(struct net_device *dev, 543\tint needed_headroom); 544\tint\t(*ndo_bpf)(struct net_device *dev, 545\tstruct netdev_bpf *bpf); 546\tint\t(*ndo_xdp_xmit)(struct net_device *dev, int n, 547\tstruct xdp_frame **xdp, 548\tu32 flags); 549\tstruct net_device *\t(*ndo_xdp_get_xmit_slave)(struct net_device *dev, 550\tstruct xdp_buff *xdp); 551\tint\t(*ndo_xsk_wakeup)(struct net_device *dev, 552\tu32 queue_id, u32 flags); 553\tstruct devlink_port *\t(*ndo_get_devlink_port)(struct net_device *dev); 554\tint\t(*ndo_tunnel_ctl)(struct net_device *dev, 555\tstruct ip_tunnel_parm *p, int cmd); 556\tstruct net_device *\t(*ndo_get_peer_dev)(struct net_device *dev); 557\tint (*ndo_fill_forward_path)(struct net_device_path_ctx *ctx, 558 struct net_device_path *path); 559\tktime_t\t(*ndo_get_tstamp)(struct net_device *dev, 560\tconst struct skb_shared_hwtstamps *hwtstamps, 561\tbool cycles); 562}; 二、软中断处理 # 在net_dev_init时，会将NET_RX_SOFTIRQ和NET_TX_SOFTIRQ注册两个回调函数 1// net/core/dev.c 2/* 3 *\tInitialize the DEV module. At boot time this walks the device list and 4 *\tunhooks any devices that fail to initialise (normally hardware not 5 *\tpresent) and leaves us with a valid list of present and active devices. 6 * 7 */ 8 9/* 10 * This is called single threaded during boot, so no need 11 * to take the rtnl semaphore. 12 */ 13static int __init net_dev_init(void) 14{ 15 ... 16\topen_softirq(NET_TX_SOFTIRQ, net_tx_action); 17\topen_softirq(NET_RX_SOFTIRQ, net_rx_action); 18 ... 19} 1. 接收软中断NET_TX_SOFTIRQ # 处理函数 1// net/core/dev.c 2static __latent_entropy void net_rx_action(struct softirq_action *h) 3{ 4 ... 5\tfor (;;) { 6\tstruct napi_struct *n; 7 8\tskb_defer_free_flush(sd); 9 10\tif (list_empty(\u0026amp;list)) { 11\tif (!sd_has_rps_ipi_waiting(sd) \u0026amp;\u0026amp; list_empty(\u0026amp;repoll)) 12\tgoto end; 13\tbreak; 14\t} 15 16\tn = list_first_entry(\u0026amp;list, struct napi_struct, poll_list); 17\tbudget -= napi_poll(n, \u0026amp;repoll); 18 ... 19\t} 20 ... 21} 给到napi_poll找对应的poll函数调用 1// net/core/dev.c 2static int napi_poll(struct napi_struct *n, struct list_head *repoll) 3{ 4\tbool do_repoll = false; 5\tvoid *have; 6\tint work; 7 8\tlist_del_init(\u0026amp;n-\u0026gt;poll_list); 9 10\thave = netpoll_poll_lock(n); 11 12\twork = __napi_poll(n, \u0026amp;do_repoll); 13 14\tif (do_repoll) 15\tlist_add_tail(\u0026amp;n-\u0026gt;poll_list, repoll); 16 17\tnetpoll_poll_unlock(have); 18 19\treturn work; 20} 21 22// net/core/dev.c 23static int __napi_poll(struct napi_struct *n, bool *repoll) 24{ 25\tint work, weight; 26 27\tweight = n-\u0026gt;weight; 28 29\t/* This NAPI_STATE_SCHED test is for avoiding a race 30\t* with netpoll\u0026#39;s poll_napi(). Only the entity which 31\t* obtains the lock and sees NAPI_STATE_SCHED set will 32\t* actually make the -\u0026gt;poll() call. Therefore we avoid 33\t* accidentally calling -\u0026gt;poll() when NAPI is not scheduled. 34\t*/ 35\twork = 0; 36\tif (test_bit(NAPI_STATE_SCHED, \u0026amp;n-\u0026gt;state)) { 37\twork = n-\u0026gt;poll(n, weight); 38\ttrace_napi_poll(n, work, weight); 39\t} 40 41\tif (unlikely(work \u0026gt; weight)) 42\tnetdev_err_once(n-\u0026gt;dev, \u0026#34;NAPI poll function %pS returned %d, exceeding its budget of %d.\\n\u0026#34;, 43\tn-\u0026gt;poll, work, weight); 44 45\tif (likely(work \u0026lt; weight)) 46\treturn work; 47 48\t/* Drivers must not modify the NAPI state if they 49\t* consume the entire weight. In such cases this code 50\t* still \u0026#34;owns\u0026#34; the NAPI instance and therefore can 51\t* move the instance around on the list at-will. 52\t*/ 53\tif (unlikely(napi_disable_pending(n))) { 54\tnapi_complete(n); 55\treturn work; 56\t} 57 58\t/* The NAPI context has more processing work, but busy-polling 59\t* is preferred. Exit early. 60\t*/ 61\tif (napi_prefer_busy_poll(n)) { 62\tif (napi_complete_done(n, work)) { 63\t/* If timeout is not set, we need to make sure 64\t* that the NAPI is re-scheduled. 65\t*/ 66\tnapi_schedule(n); 67\t} 68\treturn work; 69\t} 70 71\tif (n-\u0026gt;gro_bitmask) { 72\t/* flush too old packets 73\t* If HZ \u0026lt; 1000, flush all packets. 74\t*/ 75\tnapi_gro_flush(n, HZ \u0026gt;= 1000); 76\t} 77 78\tgro_normal_list(n); 79 80\t/* Some drivers may have called napi_schedule 81\t* prior to exhausting their budget. 82\t*/ 83\tif (unlikely(!list_empty(\u0026amp;n-\u0026gt;poll_list))) { 84\tpr_warn_once(\u0026#34;%s: Budget exhausted after napi rescheduled\\n\u0026#34;, 85\tn-\u0026gt;dev ? n-\u0026gt;dev-\u0026gt;name : \u0026#34;backlog\u0026#34;); 86\treturn work; 87\t} 88 89\t*repoll = true; 90 91\treturn work; 92} 上面调用poll函数后，就到驱动里面处理，驱动里面会调用到napi_gro_receive 1// net/core/gro.c 2gro_result_t napi_gro_receive(struct napi_struct *napi, struct sk_buff *skb) 3{ 4\tgro_result_t ret; 5 6\tskb_mark_napi_id(skb, napi); 7\ttrace_napi_gro_receive_entry(skb); 8 9\tskb_gro_reset_offset(skb, 0); 10 11\tret = napi_skb_finish(napi, skb, dev_gro_receive(napi, skb)); 12\ttrace_napi_gro_receive_exit(ret); 13 14\treturn ret; 15} 16EXPORT_SYMBOL(napi_gro_receive); 调用到napi_skb_finish，转netif_receive_skb 1// net/core/gro.c 2static gro_result_t napi_skb_finish(struct napi_struct *napi, 3\tstruct sk_buff *skb, 4\tgro_result_t ret) 5{ 6\tswitch (ret) { 7\tcase GRO_NORMAL: 8\tgro_normal_one(napi, skb, 1); 9\tbreak; 10 11\tcase GRO_MERGED_FREE: 12\tif (NAPI_GRO_CB(skb)-\u0026gt;free == NAPI_GRO_FREE_STOLEN_HEAD) 13\tnapi_skb_free_stolen_head(skb); 14\telse if (skb-\u0026gt;fclone != SKB_FCLONE_UNAVAILABLE) 15\t__kfree_skb(skb); 16\telse 17\t__kfree_skb_defer(skb); 18\tbreak; 19 20\tcase GRO_HELD: 21\tcase GRO_MERGED: 22\tcase GRO_CONSUMED: 23\tbreak; 24\t} 25 26\treturn ret; 27} 28 29// include/net/gro.h 30/* Queue one GRO_NORMAL SKB up for list processing. If batch size exceeded, 31 * pass the whole batch up to the stack. 32 */ 33static inline void gro_normal_one(struct napi_struct *napi, struct sk_buff *skb, int segs) 34{ 35\tlist_add_tail(\u0026amp;skb-\u0026gt;list, \u0026amp;napi-\u0026gt;rx_list); 36\tnapi-\u0026gt;rx_count += segs; 37\tif (napi-\u0026gt;rx_count \u0026gt;= gro_normal_batch) 38\tgro_normal_list(napi); 39} 40 41// include/net/gro.h 42/* Pass the currently batched GRO_NORMAL SKBs up to the stack. */ 43static inline void gro_normal_list(struct napi_struct *napi) 44{ 45\tif (!napi-\u0026gt;rx_count) 46\treturn; 47\tnetif_receive_skb_list_internal(\u0026amp;napi-\u0026gt;rx_list); 48\tINIT_LIST_HEAD(\u0026amp;napi-\u0026gt;rx_list); 49\tnapi-\u0026gt;rx_count = 0; 50} 51 52// net/core/dev.c 53void netif_receive_skb_list_internal(struct list_head *head) 54{ 55\tstruct sk_buff *skb, *next; 56\tstruct list_head sublist; 57 58\tINIT_LIST_HEAD(\u0026amp;sublist); 59\tlist_for_each_entry_safe(skb, next, head, list) { 60\tnet_timestamp_check(netdev_tstamp_prequeue, skb); 61\tskb_list_del_init(skb); 62\tif (!skb_defer_rx_timestamp(skb)) 63\tlist_add_tail(\u0026amp;skb-\u0026gt;list, \u0026amp;sublist); 64\t} 65\tlist_splice_init(\u0026amp;sublist, head); 66 67\trcu_read_lock(); 68#ifdef CONFIG_RPS 69\tif (static_branch_unlikely(\u0026amp;rps_needed)) { 70\tlist_for_each_entry_safe(skb, next, head, list) { 71\tstruct rps_dev_flow voidflow, *rflow = \u0026amp;voidflow; 72\tint cpu = get_rps_cpu(skb-\u0026gt;dev, skb, \u0026amp;rflow); 73 74\tif (cpu \u0026gt;= 0) { 75\t/* Will be handled, remove from list */ 76\tskb_list_del_init(skb); 77\tenqueue_to_backlog(skb, cpu, \u0026amp;rflow-\u0026gt;last_qtail); 78\t} 79\t} 80\t} 81#endif 82\t__netif_receive_skb_list(head); 83\trcu_read_unlock(); 84} 85 86// net/core/dev.c 87static void __netif_receive_skb_list(struct list_head *head) 88{ 89\tunsigned long noreclaim_flag = 0; 90\tstruct sk_buff *skb, *next; 91\tbool pfmemalloc = false; /* Is current sublist PF_MEMALLOC? */ 92 93\tlist_for_each_entry_safe(skb, next, head, list) { 94\tif ((sk_memalloc_socks() \u0026amp;\u0026amp; skb_pfmemalloc(skb)) != pfmemalloc) { 95\tstruct list_head sublist; 96 97\t/* Handle the previous sublist */ 98\tlist_cut_before(\u0026amp;sublist, head, \u0026amp;skb-\u0026gt;list); 99\tif (!list_empty(\u0026amp;sublist)) 100\t__netif_receive_skb_list_core(\u0026amp;sublist, pfmemalloc); 101\tpfmemalloc = !pfmemalloc; 102\t/* See comments in __netif_receive_skb */ 103\tif (pfmemalloc) 104\tnoreclaim_flag = memalloc_noreclaim_save(); 105\telse 106\tmemalloc_noreclaim_restore(noreclaim_flag); 107\t} 108\t} 109\t/* Handle the remaining sublist */ 110\tif (!list_empty(head)) 111\t__netif_receive_skb_list_core(head, pfmemalloc); 112\t/* Restore pflags */ 113\tif (pfmemalloc) 114\tmemalloc_noreclaim_restore(noreclaim_flag); 115} 116 117// net/core/dev.c 118static void __netif_receive_skb_list_core(struct list_head *head, bool pfmemalloc) 119{ 120\t/* Fast-path assumptions: 121\t* - There is no RX handler. 122\t* - Only one packet_type matches. 123\t* If either of these fails, we will end up doing some per-packet 124\t* processing in-line, then handling the \u0026#39;last ptype\u0026#39; for the whole 125\t* sublist. This can\u0026#39;t cause out-of-order delivery to any single ptype, 126\t* because the \u0026#39;last ptype\u0026#39; must be constant across the sublist, and all 127\t* other ptypes are handled per-packet. 128\t*/ 129\t/* Current (common) ptype of sublist */ 130\tstruct packet_type *pt_curr = NULL; 131\t/* Current (common) orig_dev of sublist */ 132\tstruct net_device *od_curr = NULL; 133\tstruct list_head sublist; 134\tstruct sk_buff *skb, *next; 135 136\tINIT_LIST_HEAD(\u0026amp;sublist); 137\tlist_for_each_entry_safe(skb, next, head, list) { 138\tstruct net_device *orig_dev = skb-\u0026gt;dev; 139\tstruct packet_type *pt_prev = NULL; 140 141\tskb_list_del_init(skb); 142\t__netif_receive_skb_core(\u0026amp;skb, pfmemalloc, \u0026amp;pt_prev); 143\tif (!pt_prev) 144\tcontinue; 145\tif (pt_curr != pt_prev || od_curr != orig_dev) { 146\t/* dispatch old sublist */ 147\t__netif_receive_skb_list_ptype(\u0026amp;sublist, pt_curr, od_curr); 148\t/* start new sublist */ 149\tINIT_LIST_HEAD(\u0026amp;sublist); 150\tpt_curr = pt_prev; 151\tod_curr = orig_dev; 152\t} 153\tlist_add_tail(\u0026amp;skb-\u0026gt;list, \u0026amp;sublist); 154\t} 155 156\t/* dispatch final sublist */ 157\t__netif_receive_skb_list_ptype(\u0026amp;sublist, pt_curr, od_curr); 158} netif_receive_skb_core里面处理包，并添加了trace入口，可以从这个函数进行追踪 tcpdump抓包同样也在这里挂载了虚拟协议，不过处理是链式，不考虑返回值，所以所有链上的设备都可以处理此包 1// net/core/dev.c 2static int __netif_receive_skb_core(struct sk_buff **pskb, bool pfmemalloc, 3\tstruct packet_type **ppt_prev) 4{ 5\tstruct packet_type *ptype, *pt_prev; 6\trx_handler_func_t *rx_handler; 7\tstruct sk_buff *skb = *pskb; 8\tstruct net_device *orig_dev; 9\tbool deliver_exact = false; 10\tint ret = NET_RX_DROP; 11\t__be16 type; 12 13\tnet_timestamp_check(!netdev_tstamp_prequeue, skb); 14 15\t// 这里插入的tracepoint 16\ttrace_netif_receive_skb(skb); 17 18\torig_dev = skb-\u0026gt;dev; 19 20\tskb_reset_network_header(skb); 21\tif (!skb_transport_header_was_set(skb)) 22\tskb_reset_transport_header(skb); 23\tskb_reset_mac_len(skb); 24 25\tpt_prev = NULL; 26 27another_round: 28\tskb-\u0026gt;skb_iif = skb-\u0026gt;dev-\u0026gt;ifindex; 29 30\t__this_cpu_inc(softnet_data.processed); 31 32\tif (static_branch_unlikely(\u0026amp;generic_xdp_needed_key)) { 33\tint ret2; 34 35\tmigrate_disable(); 36\tret2 = do_xdp_generic(rcu_dereference(skb-\u0026gt;dev-\u0026gt;xdp_prog), skb); 37\tmigrate_enable(); 38 39\tif (ret2 != XDP_PASS) { 40\tret = NET_RX_DROP; 41\tgoto out; 42\t} 43\t} 44 45\tif (eth_type_vlan(skb-\u0026gt;protocol)) { 46\tskb = skb_vlan_untag(skb); 47\tif (unlikely(!skb)) 48\tgoto out; 49\t} 50 51\tif (skb_skip_tc_classify(skb)) 52\tgoto skip_classify; 53 54\tif (pfmemalloc) 55\tgoto skip_taps; 56 57\t// 这一步是tcpdump的抓包入口，tcpdump在这里挂了虚拟协议 58\tlist_for_each_entry_rcu(ptype, \u0026amp;ptype_all, list) { 59\tif (pt_prev) 60\tret = deliver_skb(skb, pt_prev, orig_dev); 61\tpt_prev = ptype; 62\t} 63 64\tlist_for_each_entry_rcu(ptype, \u0026amp;skb-\u0026gt;dev-\u0026gt;ptype_all, list) { 65\tif (pt_prev) 66\tret = deliver_skb(skb, pt_prev, orig_dev); 67\tpt_prev = ptype; 68\t} 69\t... 70} deliver_skb就会调用注册的func函数 1/* 到这一步的堆栈信息 2ip_rcv(struct sk_buff * skb, struct net_device * dev, struct packet_type * pt, struct net_device * orig_dev) (/net/ipv4/ip_input.c:565) 3deliver_skb(struct packet_type * pt_prev) (/net/core/dev.c:2189) 4deliver_ptype_list_skb(struct list_head * ptype_list, __be16 type, struct net_device * orig_dev, struct packet_type ** pt, struct sk_buff * skb) (/net/core/dev.c:2204) 5__netif_receive_skb_core(struct sk_buff ** pskb, bool pfmemalloc, struct packet_type ** ppt_prev) (/net/core/dev.c:5440) 6__netif_receive_skb_list_core(struct list_head * head, bool pfmemalloc) (/net/core/dev.c:5560) 7__netif_receive_skb_list(struct list_head * head) (/net/core/dev.c:5627) 8netif_receive_skb_list_internal(struct list_head * head) (/net/core/dev.c:5718) 9gro_normal_list(struct napi_struct * napi) (/include/net/gro.h:430) 10gro_normal_list(struct napi_struct * napi) (/include/net/gro.h:426) 11napi_complete_done(struct napi_struct * n, int work_done) (/net/core/dev.c:6059) 12e1000_clean(struct napi_struct * napi, int budget) (/drivers/net/ethernet/intel/e1000/e1000_main.c:3811) 13__napi_poll(struct napi_struct * n, bool * repoll) (/net/core/dev.c:6492) 14napi_poll(struct list_head * repoll, struct napi_struct * n) (/net/core/dev.c:6559) 15net_rx_action(struct softirq_action * h) (/net/core/dev.c:6670) 16__do_softirq() (/kernel/softirq.c:571) 17invoke_softirq() (/kernel/softirq.c:445) 18__irq_exit_rcu() (/kernel/softirq.c:650) 19irq_exit_rcu() (/kernel/softirq.c:662) 20common_interrupt(struct pt_regs * regs, unsigned long error_code) (/arch/x86/kernel/irq.c:240) 21 */ 22// net/core/dev.c 23static inline int deliver_skb(struct sk_buff *skb, 24\tstruct packet_type *pt_prev, 25\tstruct net_device *orig_dev) 26{ 27\tif (unlikely(skb_orphan_frags_rx(skb, GFP_ATOMIC))) 28\treturn -ENOMEM; 29\trefcount_inc(\u0026amp;skb-\u0026gt;users); 30\treturn pt_prev-\u0026gt;func(skb, skb-\u0026gt;dev, pt_prev, orig_dev); 31} 注册函数是下面的 1// net/core/dev.c 2/** 3 *\tdev_add_pack - add packet handler 4 *\t@pt: packet type declaration 5 * 6 *\tAdd a protocol handler to the networking stack. The passed \u0026amp;packet_type 7 *\tis linked into kernel lists and may not be freed until it has been 8 *\tremoved from the kernel lists. 9 * 10 *\tThis call does not sleep therefore it can not 11 *\tguarantee all CPU\u0026#39;s that are in middle of receiving packets 12 *\twill see the new packet type (until the next received packet). 13 */ 14 15void dev_add_pack(struct packet_type *pt) 16{ 17\tstruct list_head *head = ptype_head(pt); 18 19\tspin_lock(\u0026amp;ptype_lock); 20\tlist_add_rcu(\u0026amp;pt-\u0026gt;list, head); 21\tspin_unlock(\u0026amp;ptype_lock); 22} 23EXPORT_SYMBOL(dev_add_pack); ipv4就是注册了此接口，所以ipv4包会调用到ip_rcv 1// net/ipv4/af_inet.c 2static struct packet_type ip_packet_type __read_mostly = { 3\t.type = cpu_to_be16(ETH_P_IP), 4\t.func = ip_rcv, 5\t.list_func = ip_list_rcv, 6}; 7 8// net/ipv4/af_inet.c 9static int __init inet_init(void) 10{ 11\t... 12 // 注册到dev里面 13\tdev_add_pack(\u0026amp;ip_packet_type); 14\t... 15} 16 17fs_initcall(inet_init); "},{"id":22,"href":"/docs/c++/macro/","title":"预定义宏","section":"C++源码分析记录","content":" 一、变量修饰 # 1. 返回值修饰 # 1.1. _GLIBCXX_NODISCARD # C++17生效，会在返回值没有使用的情况下编译报warning 1// /usr/include/c++/12.2.0/x86_64-pc-linux-gnu/bits/c++config.h 2// Macro to warn about unused results. 3#if __cplusplus \u0026gt;= 201703L 4# define _GLIBCXX_NODISCARD [[__nodiscard__]] 5#else 6# define _GLIBCXX_NODISCARD 7#endif "},{"id":23,"href":"/docs/glibc/","title":"glibc源码分析记录","section":"Docs","content":"版本2.36\n"},{"id":24,"href":"/docs/nginx/nginx/http/","title":"http模块","section":"nginx","content":" 一、源码分析 # 1. 几个结构的生命周期和关系 # 1.1. ngx_http_request_t 代表一次http请求 # 和其他结构的代码关系 1// ngx_http.h 2typedef struct ngx_http_request_s ngx_http_request_t; 3// ngx_http_request.h 4struct ngx_http_request_s { 5 ... 6 ngx_connection_t *connection; 7 ... 8 ngx_http_upstream_t *upstream; 9 ... 10 ngx_pool_t *pool; 11 ... 12 ngx_http_connection_t *http_connection; 13 ... 14}; ngx_http_request_t代表一次http请求 一次ngx_connection_t可以给多个ngx_http_request_t使用 每个ngx_http_request_t必须依赖于一个ngx_connection_t，并且持有r-\u0026gt;connection 每个ngx_http_request_t拥有自己的内存池r-\u0026gt;pool，当一次请求结束后会进行释放 (1) 创造 # 在ngx_http_wait_request_handler中进行构造，存放到ngx_connection_t的data中 每个http请求接收的回调中创建 1// ngx_http_request.c 2static void 3ngx_http_wait_request_handler(ngx_event_t *rev) 4{ 5 ... 6 c-\u0026gt;log-\u0026gt;action = \u0026#34;reading client request line\u0026#34;; 7 8 ngx_reusable_connection(c, 0); 9 10 c-\u0026gt;data = ngx_http_create_request(c); 11 ... 12} 2. nginx网络模型 # 2.1. 网络模型总述 # 使用master进程监听端口创建套接字，然后fork子进程，每个子进程就可以复用监听套接字 "},{"id":25,"href":"/docs/mysql/","title":"mysql源码分析记录","section":"Docs","content":"版本8.0.33\n"},{"id":26,"href":"/docs/openssl/","title":"openssl源码分析记录","section":"Docs","content":"版本3.1.1\n"},{"id":27,"href":"/docs/linux/linux-kernel/net/socket/sendmsg/","title":"sendmsg","section":"socket","content":" 一、总述 # sendmsg可以像普通的send一样发送消息，也可以进行fd的转发 做fd的转发需要使用域套接字 二、代码流程 # 入口自然是系统调用的定义 1// net/socket.c 2long __sys_sendmsg(int fd, struct user_msghdr __user *msg, unsigned int flags, 3\tbool forbid_cmsg_compat) 4{ 5\tint fput_needed, err; 6\tstruct msghdr msg_sys; 7\tstruct socket *sock; 8 9\tif (forbid_cmsg_compat \u0026amp;\u0026amp; (flags \u0026amp; MSG_CMSG_COMPAT)) 10\treturn -EINVAL; 11 12 // 根据文件句柄号找sock结构体 13\tsock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); 14\tif (!sock) 15\tgoto out; 16 17\terr = ___sys_sendmsg(sock, msg, \u0026amp;msg_sys, flags, NULL, 0); 18 19\tfput_light(sock-\u0026gt;file, fput_needed); 20out: 21\treturn err; 22} 23 24SYSCALL_DEFINE3(sendmsg, int, fd, struct user_msghdr __user *, msg, unsigned int, flags) 25{ 26\treturn __sys_sendmsg(fd, msg, flags, true); 27} 继续到发送的地方 1// net/socket.c 2/* 3 *\tBSD sendmsg interface 4 */ 5long __sys_sendmsg_sock(struct socket *sock, struct msghdr *msg, 6\tunsigned int flags) 7{ 8\treturn ____sys_sendmsg(sock, msg, flags, NULL, 0); 9} 10 11// net/socket.c 12static int ____sys_sendmsg(struct socket *sock, struct msghdr *msg_sys, 13\tunsigned int flags, struct used_address *used_address, 14\tunsigned int allowed_msghdr_flags) 15{ 16\tunsigned char ctl[sizeof(struct cmsghdr) + 20] 17\t__aligned(sizeof(__kernel_size_t)); 18\t/* 20 is size of ipv6_pktinfo */ 19\tunsigned char *ctl_buf = ctl; 20\tint ctl_len; 21\tssize_t err; 22 23\terr = -ENOBUFS; 24 25\tif (msg_sys-\u0026gt;msg_controllen \u0026gt; INT_MAX) 26\tgoto out; 27\tflags |= (msg_sys-\u0026gt;msg_flags \u0026amp; allowed_msghdr_flags); 28\tctl_len = msg_sys-\u0026gt;msg_controllen; 29 // 兼容64和32位，从用户空间拷贝消息到内核空间 30\tif ((MSG_CMSG_COMPAT \u0026amp; flags) \u0026amp;\u0026amp; ctl_len) { 31 // 从64位消息头到32位消息头 32\terr = 33\tcmsghdr_from_user_compat_to_kern(msg_sys, sock-\u0026gt;sk, ctl, 34\tsizeof(ctl)); 35\tif (err) 36\tgoto out; 37\tctl_buf = msg_sys-\u0026gt;msg_control; 38\tctl_len = msg_sys-\u0026gt;msg_controllen; 39\t} else if (ctl_len) { 40\tBUILD_BUG_ON(sizeof(struct cmsghdr) != 41\tCMSG_ALIGN(sizeof(struct cmsghdr))); 42\tif (ctl_len \u0026gt; sizeof(ctl)) { 43\tctl_buf = sock_kmalloc(sock-\u0026gt;sk, ctl_len, GFP_KERNEL); 44\tif (ctl_buf == NULL) 45\tgoto out; 46\t} 47\terr = -EFAULT; 48\tif (copy_from_user(ctl_buf, msg_sys-\u0026gt;msg_control_user, ctl_len)) 49\tgoto out_freectl; 50\tmsg_sys-\u0026gt;msg_control = ctl_buf; 51\tmsg_sys-\u0026gt;msg_control_is_user = false; 52\t} 53\tmsg_sys-\u0026gt;msg_flags = flags; 54 55\tif (sock-\u0026gt;file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) 56\tmsg_sys-\u0026gt;msg_flags |= MSG_DONTWAIT; 57\t/* 58\t* If this is sendmmsg() and current destination address is same as 59\t* previously succeeded address, omit asking LSM\u0026#39;s decision. 60\t* used_address-\u0026gt;name_len is initialized to UINT_MAX so that the first 61\t* destination address never matches. 62\t*/ 63\tif (used_address \u0026amp;\u0026amp; msg_sys-\u0026gt;msg_name \u0026amp;\u0026amp; 64\tused_address-\u0026gt;name_len == msg_sys-\u0026gt;msg_namelen \u0026amp;\u0026amp; 65\t!memcmp(\u0026amp;used_address-\u0026gt;name, msg_sys-\u0026gt;msg_name, 66\tused_address-\u0026gt;name_len)) { 67\terr = sock_sendmsg_nosec(sock, msg_sys); 68\tgoto out_freectl; 69\t} 70 // 这里开始发送数据 71\terr = sock_sendmsg(sock, msg_sys); 72\t/* 73\t* If this is sendmmsg() and sending to current destination address was 74\t* successful, remember it. 75\t*/ 76\tif (used_address \u0026amp;\u0026amp; err \u0026gt;= 0) { 77\tused_address-\u0026gt;name_len = msg_sys-\u0026gt;msg_namelen; 78\tif (msg_sys-\u0026gt;msg_name) 79\tmemcpy(\u0026amp;used_address-\u0026gt;name, msg_sys-\u0026gt;msg_name, 80\tused_address-\u0026gt;name_len); 81\t} 82 83out_freectl: 84\tif (ctl_buf != ctl) 85\tsock_kfree_s(sock-\u0026gt;sk, ctl_buf, ctl_len); 86out: 87\treturn err; 88} 最终调用对应套接字的发送函数上 1// net/socket.c 2/** 3 *\tsock_sendmsg - send a message through @sock 4 *\t@sock: socket 5 *\t@msg: message to send 6 * 7 *\tSends @msg through @sock, passing through LSM. 8 *\tReturns the number of bytes sent, or an error code. 9 */ 10int sock_sendmsg(struct socket *sock, struct msghdr *msg) 11{ 12\tint err = security_socket_sendmsg(sock, msg, 13\tmsg_data_left(msg)); 14 15\treturn err ?: sock_sendmsg_nosec(sock, msg); 16} 17EXPORT_SYMBOL(sock_sendmsg); 18 19// net/socket.c 20INDIRECT_CALLABLE_DECLARE(int inet_sendmsg(struct socket *, struct msghdr *, 21\tsize_t)); 22INDIRECT_CALLABLE_DECLARE(int inet6_sendmsg(struct socket *, struct msghdr *, 23\tsize_t)); 24static inline int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg) 25{ 26\tint ret = INDIRECT_CALL_INET(sock-\u0026gt;ops-\u0026gt;sendmsg, inet6_sendmsg, 27\tinet_sendmsg, sock, msg, 28\tmsg_data_left(msg)); 29\tBUG_ON(ret == -EIOCBQUEUED); 30\treturn ret; 31} unix套接字发送 # dgram udp的发送 # 1// net/unix/af_unix.c 2static int unix_dgram_sendmsg(struct socket *sock, struct msghdr *msg, 3\tsize_t len) 4{ 5\tstruct sock *sk = sock-\u0026gt;sk; 6\tstruct net *net = sock_net(sk); 7\tstruct unix_sock *u = unix_sk(sk); 8\tDECLARE_SOCKADDR(struct sockaddr_un *, sunaddr, msg-\u0026gt;msg_name); 9\tstruct sock *other = NULL; 10\tint err; 11\tstruct sk_buff *skb; 12\tlong timeo; 13\tstruct scm_cookie scm; 14\tint data_len = 0; 15\tint sk_locked; 16 17\twait_for_unix_gc(); 18 // 这里是处理scm相关，包括句柄发送到其他进程的函数 19\terr = scm_send(sock, msg, \u0026amp;scm, false); 20\tif (err \u0026lt; 0) 21\treturn err; 22 23\terr = -EOPNOTSUPP; 24\tif (msg-\u0026gt;msg_flags\u0026amp;MSG_OOB) 25\tgoto out; 26 27 // 判断是否提供了目的地址 28\tif (msg-\u0026gt;msg_namelen) { 29 // 提供了就校验地址 30\terr = unix_validate_addr(sunaddr, msg-\u0026gt;msg_namelen); 31\tif (err) 32\tgoto out; 33\t} else { 34 // 没提供说明已经连接了，根据sock结构体获取对端地址 35\tsunaddr = NULL; 36\terr = -ENOTCONN; 37\tother = unix_peer_get(sk); 38\tif (!other) 39\tgoto out; 40\t} 41 42\tif (test_bit(SOCK_PASSCRED, \u0026amp;sock-\u0026gt;flags) \u0026amp;\u0026amp; !u-\u0026gt;addr) { 43\terr = unix_autobind(sk); 44\tif (err) 45\tgoto out; 46\t} 47 48\terr = -EMSGSIZE; 49\tif (len \u0026gt; sk-\u0026gt;sk_sndbuf - 32) 50\tgoto out; 51 52\tif (len \u0026gt; SKB_MAX_ALLOC) { 53\tdata_len = min_t(size_t, 54\tlen - SKB_MAX_ALLOC, 55\tMAX_SKB_FRAGS * PAGE_SIZE); 56\tdata_len = PAGE_ALIGN(data_len); 57 58\tBUILD_BUG_ON(SKB_MAX_ALLOC \u0026lt; PAGE_SIZE); 59\t} 60 61 // 申请skb结构体 62\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len, 63\tmsg-\u0026gt;msg_flags \u0026amp; MSG_DONTWAIT, \u0026amp;err, 64\tPAGE_ALLOC_COSTLY_ORDER); 65\tif (skb == NULL) 66\tgoto out; 67 68 // 拷贝scm的数据到skb中 69\terr = unix_scm_to_skb(\u0026amp;scm, skb, true); 70\tif (err \u0026lt; 0) 71\tgoto out_free; 72 73\tskb_put(skb, len - data_len); 74\tskb-\u0026gt;data_len = data_len; 75\tskb-\u0026gt;len = len; 76\terr = skb_copy_datagram_from_iter(skb, 0, \u0026amp;msg-\u0026gt;msg_iter, len); 77\tif (err) 78\tgoto out_free; 79\ttimeo = sock_sndtimeo(sk, msg-\u0026gt;msg_flags \u0026amp; MSG_DONTWAIT); 80 81restart: 82 // 这里为空说明还没有connect，需要根据地址进行connect 83\tif (!other) { 84\terr = -ECONNRESET; 85\tif (sunaddr == NULL) 86\tgoto out_free; 87 88\tother = unix_find_other(net, sunaddr, msg-\u0026gt;msg_namelen, 89\tsk-\u0026gt;sk_type); 90\tif (IS_ERR(other)) { 91\terr = PTR_ERR(other); 92\tother = NULL; 93\tgoto out_free; 94\t} 95\t} 96 97\tif (sk_filter(other, skb) \u0026lt; 0) { 98\t/* Toss the packet but do not return any error to the sender */ 99\terr = len; 100\tgoto out_free; 101\t} 102 103\tsk_locked = 0; 104\tunix_state_lock(other); 105restart_locked: 106\terr = -EPERM; 107\tif (!unix_may_send(sk, other)) 108\tgoto out_unlock; 109 110\tif (unlikely(sock_flag(other, SOCK_DEAD))) { 111\t/* 112\t*\tCheck with 1003.1g - what should 113\t*\tdatagram error 114\t*/ 115\tunix_state_unlock(other); 116\tsock_put(other); 117 118\tif (!sk_locked) 119\tunix_state_lock(sk); 120 121\terr = 0; 122\tif (unix_peer(sk) == other) { 123\tunix_peer(sk) = NULL; 124\tunix_dgram_peer_wake_disconnect_wakeup(sk, other); 125 126\tunix_state_unlock(sk); 127 128\tsk-\u0026gt;sk_state = TCP_CLOSE; 129\tunix_dgram_disconnected(sk, other); 130\tsock_put(other); 131\terr = -ECONNREFUSED; 132\t} else { 133\tunix_state_unlock(sk); 134\t} 135 136\tother = NULL; 137\tif (err) 138\tgoto out_free; 139\tgoto restart; 140\t} 141 142\terr = -EPIPE; 143\tif (other-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN) 144\tgoto out_unlock; 145 146\tif (sk-\u0026gt;sk_type != SOCK_SEQPACKET) { 147\terr = security_unix_may_send(sk-\u0026gt;sk_socket, other-\u0026gt;sk_socket); 148\tif (err) 149\tgoto out_unlock; 150\t} 151 152\t/* other == sk \u0026amp;\u0026amp; unix_peer(other) != sk if 153\t* - unix_peer(sk) == NULL, destination address bound to sk 154\t* - unix_peer(sk) == sk by time of get but disconnected before lock 155\t*/ 156\tif (other != sk \u0026amp;\u0026amp; 157\tunlikely(unix_peer(other) != sk \u0026amp;\u0026amp; 158\tunix_recvq_full_lockless(other))) { 159\tif (timeo) { 160\ttimeo = unix_wait_for_peer(other, timeo); 161 162\terr = sock_intr_errno(timeo); 163\tif (signal_pending(current)) 164\tgoto out_free; 165 166\tgoto restart; 167\t} 168 169\tif (!sk_locked) { 170\tunix_state_unlock(other); 171\tunix_state_double_lock(sk, other); 172\t} 173 174\tif (unix_peer(sk) != other || 175\tunix_dgram_peer_wake_me(sk, other)) { 176\terr = -EAGAIN; 177\tsk_locked = 1; 178\tgoto out_unlock; 179\t} 180 181\tif (!sk_locked) { 182\tsk_locked = 1; 183\tgoto restart_locked; 184\t} 185\t} 186 187\tif (unlikely(sk_locked)) 188\tunix_state_unlock(sk); 189 190\tif (sock_flag(other, SOCK_RCVTSTAMP)) 191\t__net_timestamp(skb); 192\tmaybe_add_creds(skb, sock, other); 193\tscm_stat_add(other, skb); 194 // 这里就是将skb挂到目的地址的接收队列上，这里就是真正的发送 195\tskb_queue_tail(\u0026amp;other-\u0026gt;sk_receive_queue, skb); 196\tunix_state_unlock(other); 197\tother-\u0026gt;sk_data_ready(other); 198\tsock_put(other); 199\tscm_destroy(\u0026amp;scm); 200\treturn len; 201 202out_unlock: 203\tif (sk_locked) 204\tunix_state_unlock(sk); 205\tunix_state_unlock(other); 206out_free: 207\tkfree_skb(skb); 208out: 209\tif (other) 210\tsock_put(other); 211\tscm_destroy(\u0026amp;scm); 212\treturn err; 213} 发送句柄到其他进程的处理 # 1// include/net/scm.h 2static __inline__ int scm_send(struct socket *sock, struct msghdr *msg, 3\tstruct scm_cookie *scm, bool forcecreds) 4{ 5\tmemset(scm, 0, sizeof(*scm)); 6\tscm-\u0026gt;creds.uid = INVALID_UID; 7\tscm-\u0026gt;creds.gid = INVALID_GID; 8\tif (forcecreds) 9\tscm_set_cred(scm, task_tgid(current), current_uid(), current_gid()); 10\tunix_get_peersec_dgram(sock, scm); 11\tif (msg-\u0026gt;msg_controllen \u0026lt;= 0) 12\treturn 0; 13\treturn __scm_send(sock, msg, scm); 14} 15 16// net/core/scm.c 17int __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p) 18{ 19\tstruct cmsghdr *cmsg; 20\tint err; 21 22\tfor_each_cmsghdr(cmsg, msg) { 23\terr = -EINVAL; 24 25\t/* Verify that cmsg_len is at least sizeof(struct cmsghdr) */ 26\t/* The first check was omitted in \u0026lt;= 2.2.5. The reasoning was 27\tthat parser checks cmsg_len in any case, so that 28\tadditional check would be work duplication. 29\tBut if cmsg_level is not SOL_SOCKET, we do not check 30\tfor too short ancillary data object at all! Oops. 31\tOK, let\u0026#39;s add it... 32\t*/ 33\tif (!CMSG_OK(msg, cmsg)) 34\tgoto error; 35 36\tif (cmsg-\u0026gt;cmsg_level != SOL_SOCKET) 37\tcontinue; 38 39\tswitch (cmsg-\u0026gt;cmsg_type) 40\t{ 41\tcase SCM_RIGHTS: 42 // 发送句柄必须使用unix套接字 43\tif (!sock-\u0026gt;ops || sock-\u0026gt;ops-\u0026gt;family != PF_UNIX) 44\tgoto error; 45\terr=scm_fp_copy(cmsg, \u0026amp;p-\u0026gt;fp); 46\tif (err\u0026lt;0) 47\tgoto error; 48\tbreak; 49\tcase SCM_CREDENTIALS: 50\t{ 51\tstruct ucred creds; 52\tkuid_t uid; 53\tkgid_t gid; 54\tif (cmsg-\u0026gt;cmsg_len != CMSG_LEN(sizeof(struct ucred))) 55\tgoto error; 56\tmemcpy(\u0026amp;creds, CMSG_DATA(cmsg), sizeof(struct ucred)); 57\terr = scm_check_creds(\u0026amp;creds); 58\tif (err) 59\tgoto error; 60 61\tp-\u0026gt;creds.pid = creds.pid; 62\tif (!p-\u0026gt;pid || pid_vnr(p-\u0026gt;pid) != creds.pid) { 63\tstruct pid *pid; 64\terr = -ESRCH; 65\tpid = find_get_pid(creds.pid); 66\tif (!pid) 67\tgoto error; 68\tput_pid(p-\u0026gt;pid); 69\tp-\u0026gt;pid = pid; 70\t} 71 72\terr = -EINVAL; 73\tuid = make_kuid(current_user_ns(), creds.uid); 74\tgid = make_kgid(current_user_ns(), creds.gid); 75\tif (!uid_valid(uid) || !gid_valid(gid)) 76\tgoto error; 77 78\tp-\u0026gt;creds.uid = uid; 79\tp-\u0026gt;creds.gid = gid; 80\tbreak; 81\t} 82\tdefault: 83\tgoto error; 84\t} 85\t} 86 87\tif (p-\u0026gt;fp \u0026amp;\u0026amp; !p-\u0026gt;fp-\u0026gt;count) 88\t{ 89\tkfree(p-\u0026gt;fp); 90\tp-\u0026gt;fp = NULL; 91\t} 92\treturn 0; 93 94error: 95\tscm_destroy(p); 96\treturn err; 97} 98EXPORT_SYMBOL(__scm_send); 上面可以看到需要设置cmsg-\u0026gt;cmsg_level = SOL_SOCKET并且cmsg-\u0026gt;cmsg_type = SCM_RIGHTS就会进入到句柄发送里面 发送句柄必须使用unix套接字 使用下面的函数将文件句柄拷贝转具体文件拷贝出来，并校验句柄是否合法，只发送合法的句柄 sendmsg里面就会增加文件对应的引用计数 1// net/core/scm.c 2static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp) 3{ 4\tint *fdp = (int*)CMSG_DATA(cmsg); 5\tstruct scm_fp_list *fpl = *fplp; 6\tstruct file **fpp; 7\tint i, num; 8 9 // cmsg除了header之外的按照int组装fd数组 10\tnum = (cmsg-\u0026gt;cmsg_len - sizeof(struct cmsghdr))/sizeof(int); 11 12\tif (num \u0026lt;= 0) 13\treturn 0; 14 15\tif (num \u0026gt; SCM_MAX_FD) 16\treturn -EINVAL; 17 18\tif (!fpl) 19\t{ 20\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL_ACCOUNT); 21\tif (!fpl) 22\treturn -ENOMEM; 23\t*fplp = fpl; 24\tfpl-\u0026gt;count = 0; 25\tfpl-\u0026gt;max = SCM_MAX_FD; 26\tfpl-\u0026gt;user = NULL; 27\t} 28\tfpp = \u0026amp;fpl-\u0026gt;fp[fpl-\u0026gt;count]; 29 30\tif (fpl-\u0026gt;count + num \u0026gt; fpl-\u0026gt;max) 31\treturn -EINVAL; 32 33\t/* 34\t*\tVerify the descriptors and increment the usage count. 35\t*/ 36 37\tfor (i=0; i\u0026lt; num; i++) 38\t{ 39\tint fd = fdp[i]; 40\tstruct file *file; 41 // 这里转换fd到真正的file结构体，所以发送过去的其实是文件结构体而非fd 42 // fget_raw会增加文件的引用计数 43\tif (fd \u0026lt; 0 || !(file = fget_raw(fd))) 44\treturn -EBADF; 45\t*fpp++ = file; 46\tfpl-\u0026gt;count++; 47\t} 48 49\tif (!fpl-\u0026gt;user) 50\tfpl-\u0026gt;user = get_uid(current_user()); 51 52\treturn num; 53} "},{"id":28,"href":"/docs/examination/system-architect/large-concurrency/reliability/","title":"可靠性","section":"大并发架构","content":" 一、超压可靠性（过载保护） # 某些情况可能导致系统面临数倍于正常容量的压力\n集群中某些节点故障 客户突发高峰期，节假日前后 1. 量化指标 # 设备正常上线为QPS，当承受N倍压力下，保证QPS*95%的上线成功速率。上线成功速率不代表可以让95%用户都成功上线，只是保证QPS的速率\n2. 业界实践 # 2.1. 微信过载控制机制 DAGOR # https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf\n1) 过载判断 # 在一个时间窗口中，等待队列所有请求的平均等待时间超过20ms，认为服务发生了过载 2) 请求优先级 # 在请求入口处赋予每个请求两个优先级，业务优先级和用户优先级 优先级会携带到子调用中 3) 过载处理 # 检测到发生过载后，统计上一个时间窗口的请求数量根据优先级画出直方图，计算下一个窗口的预期请求数量（降低5%），使用这个数量在直方图上找到最接近的优先级，调整准入优先级 检测到过载恢复，计算下一个窗口的预期请求数（增加1%），继续调整准入优先级 3. 第三方组件限流机制 # 3.1. nginx限流机制 # 1) 基本配置 # 在 nginx 中，主要通过下面的两个配置实现限流限速：\nlimit_req_zone key zone=name:size rate=rate [sync]; limit_req zone=name [burst=number] [nodelay | delay=number]; 例如： http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; ... server { ... location /search/ { limit_req zone=one burst=5; } 一个限流配置中有几个要素：\nkey 表示计算流速时根据什么来累加计数，比如 limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; 中把 key 设置为 $binary_remote_addr 意味着根据客户端 IP 进行累加计数，如果同一个 IP 在 1 秒内发起了 10 个任意请求则速率为 10r/s. 可以把 key 理解为队列编号。 rate 表示要限速值。 burst 是用于削峰填谷的，下面会详细介绍。 nodelay 和 delay 是和 burst 配合使用的，下面介绍我们的限流机制时会详细解释。 2) 工作原理 # 基于漏桶算法 rate 是这个桶的开口大小，控制出水的速度 burst 是这个桶的容量，如果进水的速度太快，就会存在桶里，如果桶里的水满了就溢出，即拒绝请求。 当一个请求进来时，nginx 拿当前时间减去上一个请求进来的时间，然后计算当前速率，看看当前这个请求超速多少了，然后得出这个请求应该延迟多久才能放行，接着设置定时器，定时器到了再继续处理这个请求。\n3) 遇到的问题 # (1) 计算得到的超时时间很长导致无效请求占坑不释放，引发恶性循环 # 解决为添加超时机制，超过timeout值直接拒绝，不再等待 (2) burst参数导致所有请求变慢 # 当用户请求速率一直超过rate，所有请求等待时间就会越来越长，需要等之前的请求处理完才能处理新的请求 解决方案\n调低timeout值，可以缓解 使用nodelay，桶满之前正常处理，桶满了就开始拒绝请求，保证进入的请求和处理的请求速率一致 (3) 动态调整rate有滞后性 # 解决方案\n高速路长度调短，灵敏度会高一些 使用nodelay参数 "},{"id":29,"href":"/docs/examination/system-architect/book-study/designing-data-intensive-application/","title":"数据密集型应用系统设计","section":"读书和学习笔记","content":"参考书本《数据密集型应用系统设计》\n第一部分 数据系统基础 # 1. 可靠、可拓展与可维护的应用系统 # 1.1. 可靠性 # 用户期望的功能实现 容忍用户错误或不正确的使用方法 性能可以应对的典型场景、压力和数据量 系统可以防止未经授权的访问和滥用 1.2. 可扩展性 # 负载描述\nqps（queries Per Second） 性能描述\n百分位数：类似于中位数，不过是按照百分比计算的中位数 关注的百分位数一般有95%、99%、99.9% 1.3. 可维护性 # 运营\n监视系统健康状况，出现异常快速恢复 追踪问题原因，如系统故障和性能下降 保持软件和平台到最新状态，如安全补丁 避免执行破坏性操作 预测未来可能的问题，如容量不足 建立用于部署、配置管理等实践规范和工具包 执行复杂的维护任务，如迁移 配置更改，维护系统安全稳定 指定流程规范操作行为 传承相关知识 系统设计考虑点\n提供系统运行时行为和内部的观测性，方便监控 自动化标准工具集成 避免特定机器绑定，允许整体运行完整的同时，部分机器停机维护 文档和操作模式良好 默认配置良好 尝试自我修复，并允许管理员手动控制状态 预测可能出现的意外进行处理 简单化\n后续人员好维护 可演化\n应对需求改变的解决方案考虑 2. 数据模型与查询语言 # 2.1. 数据库分类 # 关系型\n数据之间存在关系，查询需要按照关系进行查询 一般是多对多的关系 如sql、网络数据库、图数据库 文档型\n一对多，一个id对应很多数据，但是数据之间关系不大 如json、xml等 第二部分 分布式数据系统 # 第三部分 派生数据 # "},{"id":30,"href":"/docs/linux/linux-kernel/arch/x86/register/","title":"特殊寄存器","section":"x86/ x86体系","content":" 一、CRx 寄存器 # control register 控制寄存器\n1. CR0 # PE: Protection Enable（保护使能）。为0为实地址模式，为1为保护模式 PG: Paging（分页）。为1启用分页模式，为0则仅用分页模式 禁用分页所有线性地址被视为物理地址。 禁用分页下，段机制中段基址加上偏移就是真实的物理地址。 分页标志必须在PE设置为1时才能配置，否则会导致通用保护异常 "},{"id":31,"href":"/docs/linux/linux-kernel/net/iptables/","title":"Iptables","section":"/net/ 网络部分","content":" 一、iptables的规则链 # 参考 Linux-iptables 防火墙、四表五链及SNAT与DNAT的原理与应用\n1. 规则链图 # 2. 每个表对应的链 # 表匹配顺序: raw -\u0026gt; mangle -\u0026gt; nat -\u0026gt; filter 说明 PREROUTING INPUT FORWARD OUTPUT POSTROUTING raw 确定是否跟踪数据包状态 1 1 mangle 修改数据包内容，如设置标记 1 1 1 1 1 nat 网络地址转换 1 1 1 1 filter 数据包是否放行 1 1 1 3. 规则匹配顺序 # 路由选择确实是在OUTPUT链前面，但是如果OUTPUT链里面做了nat或设置了mark，在netfilter里面会重新走一遍路由 4. 常用控制类型 # ACCEPT: 允许数据包通过 DROP: 直接丢弃数据包，不给出任何回应信息 REJECT: 拒绝数据包通过，会给数据发送端一个响应信息 SNAT: 修改数据包的源地址 DNAT: 修改数据包的目的地址 MASQUERADE: 伪装成一个非固定公网IP地址 LOG: 在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则。LOG只是一种辅助动作，并没有真正处理数据包 当前测试只能在filter表上才能加LOG，其他表加LOG没生效 5. 常用的管理选项 # -t: 指定表，也就是raw、mangle、nat、filter，不指定默认是filter -A: 在指定链的末尾追加(\u0026ndash;append) 一条新的规则 -I: 在指定链的开头插入(\u0026ndash;insert)一条新的规则，未指定序号时默认作为第一条规则 -R: 修改、替换(\u0026ndash;replace) 指定链中的某一条规则，可指定规则序号或具体内容 -P: 设置指定链的默认策略(\u0026ndash;policy) -D: 删除(\u0026ndash;delete)指定链中的某一条规则，可指定规则序号或具体内容 -F: 清空(\u0026ndash;flush)指定链中的所有规则，若未指定链名，则清空表中的所有链 -L：列出(\u0026ndash;list) 指定链中所有的规则，若未指定链名，则列出表中的所有链 -n: 使用数字形式(\u0026ndash;numeric)显示输出结果，如显示IP地址而不是主机名 -v: 显示详细信息，包括每条规则的匹配包数量和匹配字节数 --line-numbers: 查看规则时，显示规则的序号 二、mark # linux内核中网络相关的mark有三个，socket中的mark、netfilter的mark、sk_buff的mark 分别在下面三个位置 1// include/net/sock.h 2/** 3 *\tstruct sock - network layer representation of sockets 4 ... 5 *\t@sk_mark: generic packet mark 6 ... 7 */ 8struct sock { 9 ... 10\t__u32\tsk_mark; 11\t... 12}; 13 14// include/net/netfilter/nf_conntrack.h 15struct nf_conn { 16 ... 17#if defined(CONFIG_NF_CONNTRACK_MARK) 18\tu_int32_t mark; 19#endif 20 ... 21}; 22 23// include/linux/skbuff.h 24/** 25 *\tstruct sk_buff - socket buffer 26 ... 27 *\t@mark: Generic packet mark 28 ... 29 */ 30struct sk_buff { 31\t... 32\tunion { 33\t__u32\tmark; 34\t__u32\treserved_tailroom; 35\t}; 36 ... 37}; 1. socket的mark # socket的mark使用setsockopt来进行设置 1int mark = 100 2setsockopt(fd, SOL_SOCKET, SO_MARK, \u0026amp;mark, sizeof(mark)); 在使用此socket发包时，会自动添加mark到sk_buff的mark中，代码在下面 1// net/ipv4/ip_output.c 2/* 3 *\tAdd an ip header to a skbuff and send it out. 4 * 5 */ 6int ip_build_and_send_pkt(struct sk_buff *skb, const struct sock *sk, 7\t__be32 saddr, __be32 daddr, struct ip_options_rcu *opt, 8\tu8 tos) 9{ 10 ... 11\tif (!skb-\u0026gt;mark) 12\tskb-\u0026gt;mark = sk-\u0026gt;sk_mark; 13 14\t/* Send it out. */ 15\treturn ip_local_out(net, skb-\u0026gt;sk, skb); 16} 17EXPORT_SYMBOL_GPL(ip_build_and_send_pkt); 2. sk_buff的mark # 使用iptables规则可以将数据包的mark保存到连接跟踪中，然后在回包时将连接跟踪的mark恢复到数据包上 策略路由只能匹配sk_buff的mark 下面使用iptables实现一个转发的需求，虚拟网卡来的发给物理网卡，物理网卡来的转回虚拟网卡 1# 从虚拟网卡来的包，要转发给物理网卡，在走路由前给连接跟踪添加mark 2# --set-mark 设置mark到连接跟踪上 3iptables -t mangle -A PREROUTING -j CONNMARK -i tun0 --set-mark 1000 -m comment --comment \u0026#34;from tun\u0026#34; 4# 物理网卡回包时，连接跟踪有mark，写到sk_buff中 5# -m connmark --mark 1000 connmark上的mark为1000的包 6# --restore-mark 连接跟踪的mark写到sk_buff上 7iptables -t mangle -A PREROUTING -j CONNMARK -m connmark --mark 1000 ! -i tun+ --restore-mark -m comment --comment \u0026#34;need to tun\u0026#34; 8# 策略路由添加mark为1000的给到1000路由表，fwmark匹配的是sk_buff的mark 9ip rule add fwmark 1000 table 1000 10# 1000的路由表直接把所有流量路由到tun0上去 11ip route add default dev tun0 table 1000 "},{"id":32,"href":"/docs/leetcode/medium/leetcode3/","title":"3. Longest Substring Without Repeating Characters","section":"中等","content":" 题目 # Given a string s, find the length of the longest substring without repeating characters.\n思路1 # 暴力遍历，每个子字符串都判断是否没有重复字符串 思路2 # 两个指针，i和j，j代表右侧，i代表左侧 j向后遍历，判断i和j之间是否有和j对应字符相同的 如果有，计算长度，i移到相同的字符后面 使用hashMap进行判断 1func LengthOfLongestSubstring(s string) (result int) { 2\thashMap := make(map[byte]int) 3\tfor i, v := range s { 4\ti1, ok := hashMap[byte(v)] 5\tif !ok { 6\thashMap[byte(v)] = i 7\tcontinue 8\t} 9\tif result \u0026lt; len(hashMap) { 10\tresult = len(hashMap) 11\t} 12\thashMap[byte(v)] = i 13\t} 14\tif result \u0026lt; len(hashMap) { 15\tresult = len(hashMap) 16\t} 17 18\treturn 19} 思路3 # 在思路2的基础上，将hashMap换成数组，128位 由于初始化为0，我们使用index+1来作为value 1func LengthOfLongestSubstring(s string) (result int) { 2\tvar charMap [128]int 3\ti := 0 4\tfor j, v := range s { 5\tindex := charMap[byte(v)] 6\tif index \u0026gt; i { 7\t// 0 1 2 3 8\t// a b c a 9\t// i j 10\tlength := j - i 11\tif result \u0026lt; length { 12\tresult = length 13\t} 14\ti = index 15\t} 16\tcharMap[byte(v)] = j + 1 17\t} 18\t// 0 1 2 3 19\t// a b c d 20\t// i 21\tlength := len(s) - i 22\tif result \u0026lt; length { 23\tresult = length 24\t} 25 26\treturn 27} 思路4 # 在思路3的基础上，最后一段怎么看都不爽 在j移动过程中动态计算长度，不用在遍历完再来判断一遍 1func LengthOfLongestSubstring(s string) (result int) { 2\tvar charMap [128]int 3\ti := 0 4\tfor j, v := range s { 5\tindex := charMap[byte(v)] 6\t// 0 1 2 3 4 7\t// a b c b d 8\t// i j 9\t// index = 2 10\tif i \u0026lt; index { 11\ti = index 12\t} 13\tlength := j - i + 1 14\tif result \u0026lt; length { 15\tresult = length 16\t} 17\tcharMap[byte(v)] = j + 1 18\t} 19 20\treturn 21} "},{"id":33,"href":"/docs/nginx/openresty/stream/","title":"https://github.com/openresty/stream-lua-nginx-module","section":"openresty扩展组件","content":" stream模块的lua拓展 "},{"id":34,"href":"/docs/nginx/openresty/","title":"openresty扩展组件","section":"nginx与openresty源码分析记录","content":"=\u0026gt; nginx -v nginx version: openresty/1.21.4.2 https://github.com/openresty/stream-lua-nginx-module\n"},{"id":35,"href":"/docs/linux/linux-kernel/fs/open/","title":"open系统调用","section":"/fs/ 文件部分","content":" open()在Linux内核的实现(2)-路径查找 详解应用层open函数如何调用到底层驱动中xxx_open函数 打开一个文件操作系统做了什么？\n一、总述 # 二、代码流程 # 1. SYSCALL_DEFINE3 从系统调用定义开始 # 1// fs/open.c 2SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) 3{ 4\tif (force_o_largefile()) 5\tflags |= O_LARGEFILE; 6\treturn do_sys_open(AT_FDCWD, filename, flags, mode); 7} 8 9// fs/open.c 10long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode) 11{ 12\tstruct open_how how = build_open_how(flags, mode); 13\treturn do_sys_openat2(dfd, filename, \u0026amp;how); 14} 1.1. 先构造如何打开的结构体，主要是处理flag # 1// fs/open.c 2#define WILL_CREATE(flags)\t(flags \u0026amp; (O_CREAT | __O_TMPFILE)) 3#define O_PATH_FLAGS\t(O_DIRECTORY | O_NOFOLLOW | O_PATH | O_CLOEXEC) 4 5inline struct open_how build_open_how(int flags, umode_t mode) 6{ 7\tstruct open_how how = { 8\t.flags = flags \u0026amp; VALID_OPEN_FLAGS, 9\t.mode = mode \u0026amp; S_IALLUGO, 10\t}; 11 12\t/* O_PATH beats everything else. */ 13\tif (how.flags \u0026amp; O_PATH) 14\thow.flags \u0026amp;= O_PATH_FLAGS; 15\t/* Modes should only be set for create-like flags. */ 16\tif (!WILL_CREATE(how.flags)) 17\thow.mode = 0; 18\treturn how; 19} 2. do_sys_openat2 继续调用打开文件 # 1// fs/open.c 2static long do_sys_openat2(int dfd, const char __user *filename, 3\tstruct open_how *how) 4{ 5\tstruct open_flags op; 6 // 根据open_how构建open_flags结构体，这里fd只是复用为返回值判断用 7\tint fd = build_open_flags(how, \u0026amp;op); 8\tstruct filename *tmp; 9 10\tif (fd) 11\treturn fd; 12 13\ttmp = getname(filename); 14\tif (IS_ERR(tmp)) 15\treturn PTR_ERR(tmp); 16 17 // 获取一个未使用的fd 18\tfd = get_unused_fd_flags(how-\u0026gt;flags); 19\tif (fd \u0026gt;= 0) { 20 // 真正打开文件的函数 21\tstruct file *f = do_filp_open(dfd, tmp, \u0026amp;op); 22\tif (IS_ERR(f)) { 23\tput_unused_fd(fd); 24\tfd = PTR_ERR(f); 25\t} else { 26\tfsnotify_open(f); 27 // 绑定fd和文件结构体 28\tfd_install(fd, f); 29\t} 30\t} 31\tputname(tmp); 32\treturn fd; 33} 2.1. build_open_flags 构建open_flags # 1// fs/open.c 2inline int build_open_flags(const struct open_how *how, struct open_flags *op) 3{ 4\tu64 flags = how-\u0026gt;flags; 5\tu64 strip = FMODE_NONOTIFY | O_CLOEXEC; 6\tint lookup_flags = 0; 7\tint acc_mode = ACC_MODE(flags); 8 9\tBUILD_BUG_ON_MSG(upper_32_bits(VALID_OPEN_FLAGS), 10\t\u0026#34;struct open_flags doesn\u0026#39;t yet handle flags \u0026gt; 32 bits\u0026#34;); 11 12\t/* 13\t* Strip flags that either shouldn\u0026#39;t be set by userspace like 14\t* FMODE_NONOTIFY or that aren\u0026#39;t relevant in determining struct 15\t* open_flags like O_CLOEXEC. 16\t*/ 17\tflags \u0026amp;= ~strip; 18 19\t/* 20\t* Older syscalls implicitly clear all of the invalid flags or argument 21\t* values before calling build_open_flags(), but openat2(2) checks all 22\t* of its arguments. 23\t*/ 24\tif (flags \u0026amp; ~VALID_OPEN_FLAGS) 25\treturn -EINVAL; 26\tif (how-\u0026gt;resolve \u0026amp; ~VALID_RESOLVE_FLAGS) 27\treturn -EINVAL; 28 29\t/* Scoping flags are mutually exclusive. */ 30\tif ((how-\u0026gt;resolve \u0026amp; RESOLVE_BENEATH) \u0026amp;\u0026amp; (how-\u0026gt;resolve \u0026amp; RESOLVE_IN_ROOT)) 31\treturn -EINVAL; 32 33\t/* Deal with the mode. */ 34\tif (WILL_CREATE(flags)) { 35\tif (how-\u0026gt;mode \u0026amp; ~S_IALLUGO) 36\treturn -EINVAL; 37\top-\u0026gt;mode = how-\u0026gt;mode | S_IFREG; 38\t} else { 39\tif (how-\u0026gt;mode != 0) 40\treturn -EINVAL; 41\top-\u0026gt;mode = 0; 42\t} 43 44\t/* 45\t* In order to ensure programs get explicit errors when trying to use 46\t* O_TMPFILE on old kernels, O_TMPFILE is implemented such that it 47\t* looks like (O_DIRECTORY|O_RDWR \u0026amp; ~O_CREAT) to old kernels. But we 48\t* have to require userspace to explicitly set it. 49\t*/ 50\tif (flags \u0026amp; __O_TMPFILE) { 51\tif ((flags \u0026amp; O_TMPFILE_MASK) != O_TMPFILE) 52\treturn -EINVAL; 53\tif (!(acc_mode \u0026amp; MAY_WRITE)) 54\treturn -EINVAL; 55\t} 56\tif (flags \u0026amp; O_PATH) { 57\t/* O_PATH only permits certain other flags to be set. */ 58\tif (flags \u0026amp; ~O_PATH_FLAGS) 59\treturn -EINVAL; 60\tacc_mode = 0; 61\t} 62 63\t/* 64\t* O_SYNC is implemented as __O_SYNC|O_DSYNC. As many places only 65\t* check for O_DSYNC if the need any syncing at all we enforce it\u0026#39;s 66\t* always set instead of having to deal with possibly weird behaviour 67\t* for malicious applications setting only __O_SYNC. 68\t*/ 69\tif (flags \u0026amp; __O_SYNC) 70\tflags |= O_DSYNC; 71 72\top-\u0026gt;open_flag = flags; 73 74\t/* O_TRUNC implies we need access checks for write permissions */ 75\tif (flags \u0026amp; O_TRUNC) 76\tacc_mode |= MAY_WRITE; 77 78\t/* Allow the LSM permission hook to distinguish append 79\taccess from general write access. */ 80\tif (flags \u0026amp; O_APPEND) 81\tacc_mode |= MAY_APPEND; 82 83\top-\u0026gt;acc_mode = acc_mode; 84 85\top-\u0026gt;intent = flags \u0026amp; O_PATH ? 0 : LOOKUP_OPEN; 86 87\tif (flags \u0026amp; O_CREAT) { 88\top-\u0026gt;intent |= LOOKUP_CREATE; 89\tif (flags \u0026amp; O_EXCL) { 90\top-\u0026gt;intent |= LOOKUP_EXCL; 91\tflags |= O_NOFOLLOW; 92\t} 93\t} 94 95\tif (flags \u0026amp; O_DIRECTORY) 96\tlookup_flags |= LOOKUP_DIRECTORY; 97\tif (!(flags \u0026amp; O_NOFOLLOW)) 98\tlookup_flags |= LOOKUP_FOLLOW; 99 100\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_NO_XDEV) 101\tlookup_flags |= LOOKUP_NO_XDEV; 102\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_NO_MAGICLINKS) 103\tlookup_flags |= LOOKUP_NO_MAGICLINKS; 104\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_NO_SYMLINKS) 105\tlookup_flags |= LOOKUP_NO_SYMLINKS; 106\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_BENEATH) 107\tlookup_flags |= LOOKUP_BENEATH; 108\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_IN_ROOT) 109\tlookup_flags |= LOOKUP_IN_ROOT; 110\tif (how-\u0026gt;resolve \u0026amp; RESOLVE_CACHED) { 111\t/* Don\u0026#39;t bother even trying for create/truncate/tmpfile open */ 112\tif (flags \u0026amp; (O_TRUNC | O_CREAT | O_TMPFILE)) 113\treturn -EAGAIN; 114\tlookup_flags |= LOOKUP_CACHED; 115\t} 116 117\top-\u0026gt;lookup_flags = lookup_flags; 118\treturn 0; 119} 3. do_filp_open 打开文件的调用 # path_openat会申请file结构体的空间，用于返回 link_path_walk找路径的最后一个分量 open_last_lookups对最后一个分量进行处理，会查找文件是否存在，不存在则根据条件创建 1// fs/namei.c 2struct file *do_filp_open(int dfd, struct filename *pathname, 3\tconst struct open_flags *op) 4{ 5\tstruct nameidata nd; 6\tint flags = op-\u0026gt;lookup_flags; 7\tstruct file *filp; 8 9\tset_nameidata(\u0026amp;nd, dfd, pathname, NULL); 10\tfilp = path_openat(\u0026amp;nd, op, flags | LOOKUP_RCU); 11\tif (unlikely(filp == ERR_PTR(-ECHILD))) 12\tfilp = path_openat(\u0026amp;nd, op, flags); 13\tif (unlikely(filp == ERR_PTR(-ESTALE))) 14\tfilp = path_openat(\u0026amp;nd, op, flags | LOOKUP_REVAL); 15\trestore_nameidata(); 16\treturn filp; 17} 18 19// fs/namei.c 20static struct file *path_openat(struct nameidata *nd, 21\tconst struct open_flags *op, unsigned flags) 22{ 23\tstruct file *file; 24\tint error; 25 26 // 申请空间 27\tfile = alloc_empty_file(op-\u0026gt;open_flag, current_cred()); 28\tif (IS_ERR(file)) 29\treturn file; 30 31\tif (unlikely(file-\u0026gt;f_flags \u0026amp; __O_TMPFILE)) { 32\terror = do_tmpfile(nd, flags, op, file); 33\t} else if (unlikely(file-\u0026gt;f_flags \u0026amp; O_PATH)) { 34\terror = do_o_path(nd, flags, file); 35\t} else { 36\tconst char *s = path_init(nd, flags); 37\t// link_path_walk找路径的最后一个分量 38\t// open_last_lookups对最后一个分量进行处理，会查找文件是否存在，不存在则根据条件创建 39\twhile (!(error = link_path_walk(s, nd)) \u0026amp;\u0026amp; 40\t(s = open_last_lookups(nd, file, op)) != NULL) 41\t; 42\tif (!error) 43\t// 遍历到后，执行open的后续操作 44\terror = do_open(nd, file, op); 45\tterminate_walk(nd); 46\t} 47\tif (likely(!error)) { 48\tif (likely(file-\u0026gt;f_mode \u0026amp; FMODE_OPENED)) 49\treturn file; 50\tWARN_ON(1); 51\terror = -EINVAL; 52\t} 53 // 此函数减少文件引用计数 54\tfput(file); 55\tif (error == -EOPENSTALE) { 56\tif (flags \u0026amp; LOOKUP_RCU) 57\terror = -ECHILD; 58\telse 59\terror = -ESTALE; 60\t} 61\treturn ERR_PTR(error); 62} 4. do_open 打开文件的最后一步 # 1// fs/namei.c 2/* 3 * Handle the last step of open() 4 */ 5static int do_open(struct nameidata *nd, 6\tstruct file *file, const struct open_flags *op) 7{ 8\tstruct user_namespace *mnt_userns; 9\tint open_flag = op-\u0026gt;open_flag; 10\tbool do_truncate; 11\tint acc_mode; 12\tint error; 13 14\tif (!(file-\u0026gt;f_mode \u0026amp; (FMODE_OPENED | FMODE_CREATED))) { 15\terror = complete_walk(nd); 16\tif (error) 17\treturn error; 18\t} 19\tif (!(file-\u0026gt;f_mode \u0026amp; FMODE_CREATED)) 20\taudit_inode(nd-\u0026gt;name, nd-\u0026gt;path.dentry, 0); 21\tmnt_userns = mnt_user_ns(nd-\u0026gt;path.mnt); 22\tif (open_flag \u0026amp; O_CREAT) { 23\tif ((open_flag \u0026amp; O_EXCL) \u0026amp;\u0026amp; !(file-\u0026gt;f_mode \u0026amp; FMODE_CREATED)) 24\treturn -EEXIST; 25\tif (d_is_dir(nd-\u0026gt;path.dentry)) 26\treturn -EISDIR; 27\terror = may_create_in_sticky(mnt_userns, nd, 28\td_backing_inode(nd-\u0026gt;path.dentry)); 29\tif (unlikely(error)) 30\treturn error; 31\t} 32\tif ((nd-\u0026gt;flags \u0026amp; LOOKUP_DIRECTORY) \u0026amp;\u0026amp; !d_can_lookup(nd-\u0026gt;path.dentry)) 33\treturn -ENOTDIR; 34 35\tdo_truncate = false; 36\tacc_mode = op-\u0026gt;acc_mode; 37\tif (file-\u0026gt;f_mode \u0026amp; FMODE_CREATED) { 38\t/* Don\u0026#39;t check for write permission, don\u0026#39;t truncate */ 39\topen_flag \u0026amp;= ~O_TRUNC; 40\tacc_mode = 0; 41\t} else if (d_is_reg(nd-\u0026gt;path.dentry) \u0026amp;\u0026amp; open_flag \u0026amp; O_TRUNC) { 42\terror = mnt_want_write(nd-\u0026gt;path.mnt); 43\tif (error) 44\treturn error; 45\tdo_truncate = true; 46\t} 47\terror = may_open(mnt_userns, \u0026amp;nd-\u0026gt;path, acc_mode, open_flag); 48\tif (!error \u0026amp;\u0026amp; !(file-\u0026gt;f_mode \u0026amp; FMODE_OPENED)) 49\terror = vfs_open(\u0026amp;nd-\u0026gt;path, file); 50\tif (!error) 51\terror = ima_file_check(file, op-\u0026gt;acc_mode); 52\tif (!error \u0026amp;\u0026amp; do_truncate) 53\terror = handle_truncate(mnt_userns, file); 54\tif (unlikely(error \u0026gt; 0)) { 55\tWARN_ON(1); 56\terror = -EINVAL; 57\t} 58\tif (do_truncate) 59\tmnt_drop_write(nd-\u0026gt;path.mnt); 60\treturn error; 61} 5. vfs_open 虚拟文件系统打开文件 # 设置文件操作集 调用操作对应的open函数 1// fs/open.c 2/** 3 * vfs_open - open the file at the given path 4 * @path: path to open 5 * @file: newly allocated file with f_flag initialized 6 * @cred: credentials to use 7 */ 8int vfs_open(const struct path *path, struct file *file) 9{ 10\tfile-\u0026gt;f_path = *path; 11\treturn do_dentry_open(file, d_backing_inode(path-\u0026gt;dentry), NULL); 12} 13 14// fs/open.c 15static int do_dentry_open(struct file *f, 16\tstruct inode *inode, 17\tint (*open)(struct inode *, struct file *)) 18{ 19\tstatic const struct file_operations empty_fops = {}; 20\tint error; 21 22\tpath_get(\u0026amp;f-\u0026gt;f_path); 23\tf-\u0026gt;f_inode = inode; 24\tf-\u0026gt;f_mapping = inode-\u0026gt;i_mapping; 25\tf-\u0026gt;f_wb_err = filemap_sample_wb_err(f-\u0026gt;f_mapping); 26\tf-\u0026gt;f_sb_err = file_sample_sb_err(f); 27 28\tif (unlikely(f-\u0026gt;f_flags \u0026amp; O_PATH)) { 29\tf-\u0026gt;f_mode = FMODE_PATH | FMODE_OPENED; 30\tf-\u0026gt;f_op = \u0026amp;empty_fops; 31\treturn 0; 32\t} 33 34\tif (f-\u0026gt;f_mode \u0026amp; FMODE_WRITE \u0026amp;\u0026amp; !special_file(inode-\u0026gt;i_mode)) { 35\terror = get_write_access(inode); 36\tif (unlikely(error)) 37\tgoto cleanup_file; 38\terror = __mnt_want_write(f-\u0026gt;f_path.mnt); 39\tif (unlikely(error)) { 40\tput_write_access(inode); 41\tgoto cleanup_file; 42\t} 43\tf-\u0026gt;f_mode |= FMODE_WRITER; 44\t} 45 46\t/* POSIX.1-2008/SUSv4 Section XSI 2.9.7 */ 47\tif (S_ISREG(inode-\u0026gt;i_mode) || S_ISDIR(inode-\u0026gt;i_mode)) 48\tf-\u0026gt;f_mode |= FMODE_ATOMIC_POS; 49 50\t// 设置文件相关的方法 51\tf-\u0026gt;f_op = fops_get(inode-\u0026gt;i_fop); 52\tif (WARN_ON(!f-\u0026gt;f_op)) { 53\terror = -ENODEV; 54\tgoto cleanup_all; 55\t} 56 57\terror = security_file_open(f); 58\tif (error) 59\tgoto cleanup_all; 60 61\terror = break_lease(locks_inode(f), f-\u0026gt;f_flags); 62\tif (error) 63\tgoto cleanup_all; 64 65\t/* normally all 3 are set; -\u0026gt;open() can clear them if needed */ 66\tf-\u0026gt;f_mode |= FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE; 67\t// 这里找对应的f_op中的open进行调用 68\tif (!open) 69\topen = f-\u0026gt;f_op-\u0026gt;open; 70\tif (open) { 71\terror = open(inode, f); 72\tif (error) 73\tgoto cleanup_all; 74\t} 75\t// 设置文件打开标记 76\tf-\u0026gt;f_mode |= FMODE_OPENED; 77\tif ((f-\u0026gt;f_mode \u0026amp; (FMODE_READ | FMODE_WRITE)) == FMODE_READ) 78\ti_readcount_inc(inode); 79\tif ((f-\u0026gt;f_mode \u0026amp; FMODE_READ) \u0026amp;\u0026amp; 80\tlikely(f-\u0026gt;f_op-\u0026gt;read || f-\u0026gt;f_op-\u0026gt;read_iter)) 81\tf-\u0026gt;f_mode |= FMODE_CAN_READ; 82\tif ((f-\u0026gt;f_mode \u0026amp; FMODE_WRITE) \u0026amp;\u0026amp; 83\tlikely(f-\u0026gt;f_op-\u0026gt;write || f-\u0026gt;f_op-\u0026gt;write_iter)) 84\tf-\u0026gt;f_mode |= FMODE_CAN_WRITE; 85\tif (f-\u0026gt;f_mapping-\u0026gt;a_ops \u0026amp;\u0026amp; f-\u0026gt;f_mapping-\u0026gt;a_ops-\u0026gt;direct_IO) 86\tf-\u0026gt;f_mode |= FMODE_CAN_ODIRECT; 87 88\tf-\u0026gt;f_flags \u0026amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC); 89 90\tfile_ra_state_init(\u0026amp;f-\u0026gt;f_ra, f-\u0026gt;f_mapping-\u0026gt;host-\u0026gt;i_mapping); 91 92\tif ((f-\u0026gt;f_flags \u0026amp; O_DIRECT) \u0026amp;\u0026amp; !(f-\u0026gt;f_mode \u0026amp; FMODE_CAN_ODIRECT)) 93\treturn -EINVAL; 94 95\t/* 96\t* XXX: Huge page cache doesn\u0026#39;t support writing yet. Drop all page 97\t* cache for this file before processing writes. 98\t*/ 99\tif (f-\u0026gt;f_mode \u0026amp; FMODE_WRITE) { 100\t/* 101\t* Paired with smp_mb() in collapse_file() to ensure nr_thps 102\t* is up to date and the update to i_writecount by 103\t* get_write_access() is visible. Ensures subsequent insertion 104\t* of THPs into the page cache will fail. 105\t*/ 106\tsmp_mb(); 107\tif (filemap_nr_thps(inode-\u0026gt;i_mapping)) { 108\tstruct address_space *mapping = inode-\u0026gt;i_mapping; 109 110\tfilemap_invalidate_lock(inode-\u0026gt;i_mapping); 111\t/* 112\t* unmap_mapping_range just need to be called once 113\t* here, because the private pages is not need to be 114\t* unmapped mapping (e.g. data segment of dynamic 115\t* shared libraries here). 116\t*/ 117\tunmap_mapping_range(mapping, 0, 0, 0); 118\ttruncate_inode_pages(mapping, 0); 119\tfilemap_invalidate_unlock(inode-\u0026gt;i_mapping); 120\t} 121\t} 122 123\treturn 0; 124 125cleanup_all: 126\tif (WARN_ON_ONCE(error \u0026gt; 0)) 127\terror = -EINVAL; 128\tfops_put(f-\u0026gt;f_op); 129\tif (f-\u0026gt;f_mode \u0026amp; FMODE_WRITER) { 130\tput_write_access(inode); 131\t__mnt_drop_write(f-\u0026gt;f_path.mnt); 132\t} 133cleanup_file: 134\tpath_put(\u0026amp;f-\u0026gt;f_path); 135\tf-\u0026gt;f_path.mnt = NULL; 136\tf-\u0026gt;f_path.dentry = NULL; 137\tf-\u0026gt;f_inode = NULL; 138\treturn error; 139} "},{"id":36,"href":"/docs/linux/linux-kernel/net/socket/recvmsg/","title":"recvmsg","section":"socket","content":" 一、总述 # recvmsg可以像普通的recv一样接收消息，也可以其他进程提供的文件句柄 二、代码流程 # 入口自然是系统调用的定义 1// net/socket.c 2long __sys_recvmsg(int fd, struct user_msghdr __user *msg, unsigned int flags, 3\tbool forbid_cmsg_compat) 4{ 5\tint fput_needed, err; 6\tstruct msghdr msg_sys; 7\tstruct socket *sock; 8 9\tif (forbid_cmsg_compat \u0026amp;\u0026amp; (flags \u0026amp; MSG_CMSG_COMPAT)) 10\treturn -EINVAL; 11 12\tsock = sockfd_lookup_light(fd, \u0026amp;err, \u0026amp;fput_needed); 13\tif (!sock) 14\tgoto out; 15 16\terr = ___sys_recvmsg(sock, msg, \u0026amp;msg_sys, flags, 0); 17 18\tfput_light(sock-\u0026gt;file, fput_needed); 19out: 20\treturn err; 21} 22 23SYSCALL_DEFINE3(recvmsg, int, fd, struct user_msghdr __user *, msg, 24\tunsigned int, flags) 25{ 26\treturn __sys_recvmsg(fd, msg, flags, true); 27} 继续到接收的地方 1// net/socket.c 2static int ___sys_recvmsg(struct socket *sock, struct user_msghdr __user *msg, 3\tstruct msghdr *msg_sys, unsigned int flags, int nosec) 4{ 5\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack; 6\t/* user mode address pointers */ 7\tstruct sockaddr __user *uaddr; 8\tssize_t err; 9 10\terr = recvmsg_copy_msghdr(msg_sys, msg, flags, \u0026amp;uaddr, \u0026amp;iov); 11\tif (err \u0026lt; 0) 12\treturn err; 13 14\terr = ____sys_recvmsg(sock, msg_sys, msg, uaddr, flags, nosec); 15\tkfree(iov); 16\treturn err; 17} 最终调用对应套接字的接收函数上 1// net/socket.c 2static int ____sys_recvmsg(struct socket *sock, struct msghdr *msg_sys, 3\tstruct user_msghdr __user *msg, 4\tstruct sockaddr __user *uaddr, 5\tunsigned int flags, int nosec) 6{ 7\tstruct compat_msghdr __user *msg_compat = 8\t(struct compat_msghdr __user *) msg; 9\tint __user *uaddr_len = COMPAT_NAMELEN(msg); 10\tstruct sockaddr_storage addr; 11\tunsigned long cmsg_ptr; 12\tint len; 13\tssize_t err; 14 15\tmsg_sys-\u0026gt;msg_name = \u0026amp;addr; 16\tcmsg_ptr = (unsigned long)msg_sys-\u0026gt;msg_control; 17\tmsg_sys-\u0026gt;msg_flags = flags \u0026amp; (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT); 18 19\t/* We assume all kernel code knows the size of sockaddr_storage */ 20\tmsg_sys-\u0026gt;msg_namelen = 0; 21 22\tif (sock-\u0026gt;file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) 23\tflags |= MSG_DONTWAIT; 24 25\t// 这里从socket中接收数据 26\tif (unlikely(nosec)) 27\terr = sock_recvmsg_nosec(sock, msg_sys, flags); 28\telse 29\terr = sock_recvmsg(sock, msg_sys, flags); 30 31\tif (err \u0026lt; 0) 32\tgoto out; 33\tlen = err; 34 35\tif (uaddr != NULL) { 36\terr = move_addr_to_user(\u0026amp;addr, 37\tmsg_sys-\u0026gt;msg_namelen, uaddr, 38\tuaddr_len); 39\tif (err \u0026lt; 0) 40\tgoto out; 41\t} 42\terr = __put_user((msg_sys-\u0026gt;msg_flags \u0026amp; ~MSG_CMSG_COMPAT), 43\tCOMPAT_FLAGS(msg)); 44\tif (err) 45\tgoto out; 46\t// 兼容64位和32位，拷贝内核空间数据到用户空间 47\tif (MSG_CMSG_COMPAT \u0026amp; flags) 48\terr = __put_user((unsigned long)msg_sys-\u0026gt;msg_control - cmsg_ptr, 49\t\u0026amp;msg_compat-\u0026gt;msg_controllen); 50\telse 51\terr = __put_user((unsigned long)msg_sys-\u0026gt;msg_control - cmsg_ptr, 52\t\u0026amp;msg-\u0026gt;msg_controllen); 53\tif (err) 54\tgoto out; 55\terr = len; 56out: 57\treturn err; 58} 59 60// net/socket.c 61/** 62 *\tsock_recvmsg - receive a message from @sock 63 *\t@sock: socket 64 *\t@msg: message to receive 65 *\t@flags: message flags 66 * 67 *\tReceives @msg from @sock, passing through LSM. Returns the total number 68 *\tof bytes received, or an error. 69 */ 70int sock_recvmsg(struct socket *sock, struct msghdr *msg, int flags) 71{ 72\tint err = security_socket_recvmsg(sock, msg, msg_data_left(msg), flags); 73 74\treturn err ?: sock_recvmsg_nosec(sock, msg, flags); 75} 76EXPORT_SYMBOL(sock_recvmsg); unix套接字 # dgram udp的接收 # 1// net/unix/af_unix.c 2static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg, size_t size, 3\tint flags) 4{ 5\tstruct sock *sk = sock-\u0026gt;sk; 6 7#ifdef CONFIG_BPF_SYSCALL 8\tconst struct proto *prot = READ_ONCE(sk-\u0026gt;sk_prot); 9 10\tif (prot != \u0026amp;unix_dgram_proto) 11\treturn prot-\u0026gt;recvmsg(sk, msg, size, flags, NULL); 12#endif 13\treturn __unix_dgram_recvmsg(sk, msg, size, flags); 14} 15 16// net/unix/af_unix.c 17int __unix_dgram_recvmsg(struct sock *sk, struct msghdr *msg, size_t size, 18\tint flags) 19{ 20\tstruct scm_cookie scm; 21\tstruct socket *sock = sk-\u0026gt;sk_socket; 22\tstruct unix_sock *u = unix_sk(sk); 23\tstruct sk_buff *skb, *last; 24\tlong timeo; 25\tint skip; 26\tint err; 27 28\terr = -EOPNOTSUPP; 29\tif (flags\u0026amp;MSG_OOB) 30\tgoto out; 31 32\ttimeo = sock_rcvtimeo(sk, flags \u0026amp; MSG_DONTWAIT); 33\t// 带超时时间的接收 34\tdo { 35\tmutex_lock(\u0026amp;u-\u0026gt;iolock); 36 37\tskip = sk_peek_offset(sk, flags); 38\t// 这里是从sock结构体的接收队列取消息 39\tskb = __skb_try_recv_datagram(sk, \u0026amp;sk-\u0026gt;sk_receive_queue, flags, 40\t\u0026amp;skip, \u0026amp;err, \u0026amp;last); 41\tif (skb) { 42\tif (!(flags \u0026amp; MSG_PEEK)) 43\tscm_stat_del(sk, skb); 44\tbreak; 45\t} 46 47\tmutex_unlock(\u0026amp;u-\u0026gt;iolock); 48 49\tif (err != -EAGAIN) 50\tbreak; 51\t} while (timeo \u0026amp;\u0026amp; 52\t!__skb_wait_for_more_packets(sk, \u0026amp;sk-\u0026gt;sk_receive_queue, 53\t\u0026amp;err, \u0026amp;timeo, last)); 54 55\tif (!skb) { /* implies iolock unlocked */ 56\tunix_state_lock(sk); 57\t/* Signal EOF on disconnected non-blocking SEQPACKET socket. */ 58\tif (sk-\u0026gt;sk_type == SOCK_SEQPACKET \u0026amp;\u0026amp; err == -EAGAIN \u0026amp;\u0026amp; 59\t(sk-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN)) 60\terr = 0; 61\tunix_state_unlock(sk); 62\tgoto out; 63\t} 64 65\tif (wq_has_sleeper(\u0026amp;u-\u0026gt;peer_wait)) 66\twake_up_interruptible_sync_poll(\u0026amp;u-\u0026gt;peer_wait, 67\tEPOLLOUT | EPOLLWRNORM | 68\tEPOLLWRBAND); 69 70\tif (msg-\u0026gt;msg_name) 71\tunix_copy_addr(msg, skb-\u0026gt;sk); 72 73\tif (size \u0026gt; skb-\u0026gt;len - skip) 74\tsize = skb-\u0026gt;len - skip; 75\telse if (size \u0026lt; skb-\u0026gt;len - skip) 76\tmsg-\u0026gt;msg_flags |= MSG_TRUNC; 77 78\terr = skb_copy_datagram_msg(skb, skip, msg, size); 79\tif (err) 80\tgoto out_free; 81 82\tif (sock_flag(sk, SOCK_RCVTSTAMP)) 83\t__sock_recv_timestamp(msg, sk, skb); 84 85\tmemset(\u0026amp;scm, 0, sizeof(scm)); 86 87\tscm_set_cred(\u0026amp;scm, UNIXCB(skb).pid, UNIXCB(skb).uid, UNIXCB(skb).gid); 88\t// 将skb结构体还原成scm结构体 89\tunix_set_secdata(\u0026amp;scm, skb); 90 91\tif (!(flags \u0026amp; MSG_PEEK)) { 92\tif (UNIXCB(skb).fp) 93\tunix_detach_fds(\u0026amp;scm, skb); 94 95\tsk_peek_offset_bwd(sk, skb-\u0026gt;len); 96\t} else { 97\t/* It is questionable: on PEEK we could: 98\t- do not return fds - good, but too simple 8) 99\t- return fds, and do not return them on read (old strategy, 100\tapparently wrong) 101\t- clone fds (I chose it for now, it is the most universal 102\tsolution) 103 104\tPOSIX 1003.1g does not actually define this clearly 105\tat all. POSIX 1003.1g doesn\u0026#39;t define a lot of things 106\tclearly however! 107 108\t*/ 109 110\tsk_peek_offset_fwd(sk, size); 111 112\tif (UNIXCB(skb).fp) 113\tunix_peek_fds(\u0026amp;scm, skb); 114\t} 115\terr = (flags \u0026amp; MSG_TRUNC) ? skb-\u0026gt;len - skip : size; 116\t// 这里处理scm结构体数据 117\tscm_recv(sock, msg, \u0026amp;scm, flags); 118 119out_free: 120\tskb_free_datagram(sk, skb); 121\tmutex_unlock(\u0026amp;u-\u0026gt;iolock); 122out: 123\treturn err; 124} scm接收处理函数 1// include/net/scm.h 2static __inline__ void scm_recv(struct socket *sock, struct msghdr *msg, 3\tstruct scm_cookie *scm, int flags) 4{ 5\tif (!msg-\u0026gt;msg_control) { 6\tif (test_bit(SOCK_PASSCRED, \u0026amp;sock-\u0026gt;flags) || scm-\u0026gt;fp) 7\tmsg-\u0026gt;msg_flags |= MSG_CTRUNC; 8\tscm_destroy(scm); 9\treturn; 10\t} 11 12\tif (test_bit(SOCK_PASSCRED, \u0026amp;sock-\u0026gt;flags)) { 13\tstruct user_namespace *current_ns = current_user_ns(); 14\tstruct ucred ucreds = { 15\t.pid = scm-\u0026gt;creds.pid, 16\t.uid = from_kuid_munged(current_ns, scm-\u0026gt;creds.uid), 17\t.gid = from_kgid_munged(current_ns, scm-\u0026gt;creds.gid), 18\t}; 19\tput_cmsg(msg, SOL_SOCKET, SCM_CREDENTIALS, sizeof(ucreds), \u0026amp;ucreds); 20\t} 21 22\tscm_destroy_cred(scm); 23 24\tscm_passec(sock, msg, scm); 25 26\tif (!scm-\u0026gt;fp) 27\treturn; 28\t// 这里是将数据转化的函数 29\tscm_detach_fds(msg, scm); 30} 发送句柄到其他进程的处理 # 接收到的数据处理一下然后将文件结构体转成文件句柄 1// net/core/scm.c 2void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm) 3{ 4\tstruct cmsghdr __user *cm = 5\t(__force struct cmsghdr __user *)msg-\u0026gt;msg_control; 6\tunsigned int o_flags = (msg-\u0026gt;msg_flags \u0026amp; MSG_CMSG_CLOEXEC) ? O_CLOEXEC : 0; 7\tint fdmax = min_t(int, scm_max_fds(msg), scm-\u0026gt;fp-\u0026gt;count); 8\tint __user *cmsg_data = CMSG_USER_DATA(cm); 9\tint err = 0, i; 10 11\t/* no use for FD passing from kernel space callers */ 12\tif (WARN_ON_ONCE(!msg-\u0026gt;msg_control_is_user)) 13\treturn; 14 15\tif (msg-\u0026gt;msg_flags \u0026amp; MSG_CMSG_COMPAT) { 16\tscm_detach_fds_compat(msg, scm); 17\treturn; 18\t} 19 20\t// 这里从scm中获取文件结构体然后分配句柄号，放到cmsg_data的对应位置 21\tfor (i = 0; i \u0026lt; fdmax; i++) { 22\terr = receive_fd_user(scm-\u0026gt;fp-\u0026gt;fp[i], cmsg_data + i, o_flags); 23\tif (err \u0026lt; 0) 24\tbreak; 25\t} 26 27\tif (i \u0026gt; 0) { 28\tint cmlen = CMSG_LEN(i * sizeof(int)); 29 30\terr = put_user(SOL_SOCKET, \u0026amp;cm-\u0026gt;cmsg_level); 31\tif (!err) 32\terr = put_user(SCM_RIGHTS, \u0026amp;cm-\u0026gt;cmsg_type); 33\tif (!err) 34\terr = put_user(cmlen, \u0026amp;cm-\u0026gt;cmsg_len); 35\tif (!err) { 36\tcmlen = CMSG_SPACE(i * sizeof(int)); 37\tif (msg-\u0026gt;msg_controllen \u0026lt; cmlen) 38\tcmlen = msg-\u0026gt;msg_controllen; 39\tmsg-\u0026gt;msg_control += cmlen; 40\tmsg-\u0026gt;msg_controllen -= cmlen; 41\t} 42\t} 43 44\tif (i \u0026lt; scm-\u0026gt;fp-\u0026gt;count || (scm-\u0026gt;fp-\u0026gt;count \u0026amp;\u0026amp; fdmax \u0026lt;= 0)) 45\tmsg-\u0026gt;msg_flags |= MSG_CTRUNC; 46 47\t/* 48\t* All of the files that fit in the message have had their usage counts 49\t* incremented, so we just free the list. 50\t*/ 51\t__scm_destroy(scm); 52} 53EXPORT_SYMBOL(scm_detach_fds); 下面是将文件结构体分配fd的处理 1// include/linux/file.h 2static inline int receive_fd_user(struct file *file, int __user *ufd, 3\tunsigned int o_flags) 4{ 5\tif (ufd == NULL) 6\treturn -EFAULT; 7\treturn __receive_fd(file, ufd, o_flags); 8} 9 10// fs/file.c 11/** 12 * __receive_fd() - Install received file into file descriptor table 13 * @file: struct file that was received from another process 14 * @ufd: __user pointer to write new fd number to 15 * @o_flags: the O_* flags to apply to the new fd entry 16 * 17 * Installs a received file into the file descriptor table, with appropriate 18 * checks and count updates. Optionally writes the fd number to userspace, if 19 * @ufd is non-NULL. 20 * 21 * This helper handles its own reference counting of the incoming 22 * struct file. 23 * 24 * Returns newly install fd or -ve on error. 25 */ 26int __receive_fd(struct file *file, int __user *ufd, unsigned int o_flags) 27{ 28\tint new_fd; 29\tint error; 30 31\terror = security_file_receive(file); 32\tif (error) 33\treturn error; 34 35\t// 获取一个新的fd 36\tnew_fd = get_unused_fd_flags(o_flags); 37\tif (new_fd \u0026lt; 0) 38\treturn new_fd; 39 40\tif (ufd) { 41\t// 将系统的fd转成用户空间的fd赋值 42\terror = put_user(new_fd, ufd); 43\tif (error) { 44\tput_unused_fd(new_fd); 45\treturn error; 46\t} 47\t} 48 49\t// 将file结构体和新的fd绑定 50\t// get_file会增加文件的引用计数 51\tfd_install(new_fd, get_file(file)); 52\t// 如果是socket类型文件，这里处理 53\t__receive_sock(file); 54\treturn new_fd; 55} socket文件类型有单独的处理，应该是更新socket相关状态 1// net/core/sock.c 2/* 3 * When a file is received (via SCM_RIGHTS, etc), we must bump the 4 * various sock-based usage counts. 5 */ 6void __receive_sock(struct file *file) 7{ 8\tstruct socket *sock; 9 10\tsock = sock_from_file(file); 11\tif (sock) { 12\tsock_update_netprioidx(\u0026amp;sock-\u0026gt;sk-\u0026gt;sk_cgrp_data); 13\tsock_update_classid(\u0026amp;sock-\u0026gt;sk-\u0026gt;sk_cgrp_data); 14\t} 15} "},{"id":37,"href":"/docs/leetcode/hard/leetcode4/","title":"4. Median of Two Sorted Arrays","section":"困难","content":" 题目 # Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\n思路1 # 合并到同一个数组，找到第(m+n)/2和(m+n+1)/2个 时间复杂度 $O(m+n)$ 空间复杂度 $O(m+n)$ 思路2 # 用i和j分别代表两个数组移动的索引，不用合并，直接找 时间复杂度 $O(m+n)$ 空间复杂度 $O(1)$ 思路3 # 时间复杂度 $O(log(min(m, n)))$ 空间复杂度 $O(1)$ 数学模型\n中位数的含义是将两个数组分成两个部分，两个数组的左半部分数量和与右半部分数量和相等 那么假设i和j分别将两个数组分割成左半部分和右半部分，可以得到\n$$ j = \\frac{(m + n)}{2} - i $$\n并且左半部分的最大值一定小于等于右半部分的最小值\n$$ max(nums_{1left}, nums_{2left}) \\le min(nums_{1right}, nums_{2right}) $$\n按照两个数组中小的那个为准，$i$ 作为二分查找的目标值。\n当 $i$ 比预期大，可以得到\n$$ max(nums_{1left}, nums_{2left}) = nums_1[i] \u0026gt; nums_2[j] = min(nums_{1right}, nums_{2right}) $$\n同理 $i$ 比预期小，可以得到\n$$ max(nums_{1left}, nums_{2left}) = nums_2[j] \u0026gt; nums_1[i] = min(nums_{1right}, nums_{2right}) $$\n转化成代码\n使 i = (left + right) / 2, j = (m + n) / 2 - i\n0 1 | 0 1 2 =\u0026gt; left b0 b1 i | j =\u0026gt; right a0 a1 b2 0 1 | 0 1 =\u0026gt; left b0 b1 i | j =\u0026gt; right a0 a1 取i和j所在位置的元素属于右半部分\n当总数为奇数时，右半部分多一个，中位数为 $min(nums_{1r}, nums_{2r})$ 当总数为偶数时，正好平分，中位数为 $\\frac{max(nums_{1l}, nums_{2l}) + min(nums_{1r}, nums_{2r})}{2}$ 并且i和j允许超出数组范围，代表所在数组都属于左半部分，可以得到\n$$ \\begin{aligned} \u0026amp; \\because \u0026amp; i \u0026amp; \u0026amp; \\in \u0026amp; [0, m] \\\\ \u0026amp; \\therefore \u0026amp; j \u0026amp; = \\frac{m+n}{2} - i \u0026amp; \\in \u0026amp; [0, n] \\end{aligned} $$\n不需要考虑j \u0026lt; 0 || j \u0026gt; n的情况\n代码如下\n1func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { 2\tm := len(nums1) 3\tn := len(nums2) 4\tif m \u0026gt; n { 5\treturn findMedianSortedArrays(nums2, nums1) 6\t} 7 8\ti := 0 // value range: [0, m] 9\tvar j int // j = (m+n+1) / 2 - i, value range: [(m-n) / 2, (m+n+1) / 2] =\u0026gt; [0, n] 10\tleft := 0 11\tright := m 12\tfor { 13\t// 0, 1, 2 =\u0026gt; 1 14\t// 0, 1 =\u0026gt; 0 15\ti = (left + right) / 2 16\t// i == 0 =\u0026gt; j = (2+3) / 2 - 0 = 2: 17\t// 0 1 | 0 1 2 =\u0026gt; left b0 b1 18\t// i | j =\u0026gt; right a0 a1 b2 19\tj = (m + n) / 2 - i 20 21\t// m == 0 =\u0026gt; i == 0, so (i != 0 || i != m) =\u0026gt; m != 0 22\tif i != 0 \u0026amp;\u0026amp; j != n \u0026amp;\u0026amp; nums1[i-1] \u0026gt; nums2[j] { 23\t// i is bigger than expect, so i != 0 \u0026amp;\u0026amp; j != m 24\t// index | 0 1 2 3 | 0 1 2 3 4 25\t// value | 1 3 5 | 2 4 6 8 10 26\t// | i | j 27\tright = i - 1 28\t} else if i != m \u0026amp;\u0026amp; j != 0 \u0026amp;\u0026amp; nums2[j-1] \u0026gt; nums1[i] { 29\t// i is less than expect, so i != m \u0026amp;\u0026amp; j != 0 30\t// index | 0 1 2 3 | 0 1 2 3 4 31\t// value | 1 3 5 | 2 4 6 8 10 32\t// | i | j 33\tleft = i + 1 34\t} else { 35\t// m == 0, right must be nums[j] 36\t// i == m, right must be nums[j] 37\t// j == n, right must be nums[i] 38\tvar rightMin int 39\tif m == 0 || i == m || (j != n \u0026amp;\u0026amp; nums1[i] \u0026gt; nums2[j]) { 40\trightMin = nums2[j] 41\t} else { 42\trightMin = nums1[i] 43\t} 44\tif (m+n)%2 == 1 { 45\treturn float64(rightMin) 46\t} 47 48\t// m == 0, left must be nums[j-1] 49\t// i == 0, left must be nums[j-1] 50\t// j == 0, left must be nums[i-1] 51\tvar leftMax int 52\tif m == 0 || i == 0 || (j != 0 \u0026amp;\u0026amp; nums1[i-1] \u0026lt; nums2[j-1]) { 53\tleftMax = nums2[j-1] 54\t} else { 55\tleftMax = nums1[i-1] 56\t} 57 58\treturn float64(leftMax+rightMin) / 2 59\t} 60\t} 61} 思路4 # 时间复杂度 $O(log(m+n))$ 空间复杂度 $O(1)$ 数学模型\n由于要求时间复杂度为O(log(m+n))，并且找中位数其实可以类似成找第K大的数 $$ K = \\frac{m+n}{2} $$ 那么对K进行二分法查找，每次排除 $\\frac{K}{2}$ 个数 具体思路是在两个数组中找第 $\\frac{K}{2}$ 的元素 如果 $nums_1[\\frac{K}{2}] \u0026gt; nums_2[\\frac{K}{2}]$ ，说明 $nums_2[\\frac{K}{2}]$ 在前K个数中，将它排掉 新的两个数组继续找 $\\frac{K}{4}$\n代码实现\n1// s1 range [0, m] 2// s2 range [0, n] 3// k range [1, (m+n+1)/2] 4func getKth(nums1 []int, s1 int, nums2 []int, s2 int, k int) int { 5\tm := len(nums1) 6\tn := len(nums2) 7 8\tif s1 == m { 9\treturn nums2[s2+k-1] 10\t} 11\tif s2 == n { 12\treturn nums1[s1+k-1] 13\t} 14\tif k == 1 { 15\tif nums1[s1+k-1] \u0026gt; nums2[s2+k-1] { 16\treturn nums2[s2+k-1] 17\t} 18\treturn nums1[s1+k-1] 19\t} 20\tindex := k / 2 21\tvar a1 int 22\tvar a2 int 23\ta1 = s1 + index - 1 24\tif a1 \u0026gt;= m { 25\ta1 = m - 1 26\t} 27\ta2 = s2 + index - 1 28\tif a2 \u0026gt;= n { 29\ta2 = n - 1 30\t} 31\tif nums1[a1] \u0026gt; nums2[a2] { 32\treturn getKth(nums1, s1, nums2, a2+1, k+s2-a2-1) 33\t} else { 34\treturn getKth(nums1, a1+1, nums2, s2, k+s1-a1-1) 35\t} 36} 37 38func FindMedianSortedArrays(nums1 []int, nums2 []int) float64 { 39\tm := len(nums1) 40\tn := len(nums2) 41\tleft := getKth(nums1, 0, nums2, 0, (m+n+1)/2) 42\tif (m+n)%2 == 1 { 43\treturn float64(left) 44\t} 45 46\tright := getKth(nums1, 0, nums2, 0, (m+n)/2+1) 47\treturn float64(left+right) / 2 48} "},{"id":38,"href":"/docs/leetcode/medium/leetcode5/","title":"5. Longest Palindromic Substring","section":"中等","content":" 题目 # Given a string s, return the longest palindromic substring in s.\n思路1 # 暴力破解，遍历所有子串，判断是否为回文串 时间复杂度 $O(n^2)$ 思路2 # 用i表示中心点，向两边扩展判断最长的回文串 顺便判断一下i作为中心线前一个的情况 时间复杂度 $O(n^2)$ 1func longestPalindrome(s string) (result string) { 2\tfor i := range s { 3\t// think medium of palindrome as i 4\tleft := i - 1 5\tright := i + 1 6\tfor left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; len(s) { 7\tif s[left] != s[right] { 8\tbreak 9\t} 10\tleft-- 11\tright++ 12\t} 13\tleft++ 14\tif right-left \u0026gt; len(result) { 15\tresult = s[left:right] 16\t} 17\t// think medium of palindrome as i and i+1 18\tleft = i 19\tright = i + 1 20\tfor left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; len(s) { 21\tif s[left] != s[right] { 22\tbreak 23\t} 24\tleft-- 25\tright++ 26\t} 27\tleft++ 28\tif right-left \u0026gt; len(result) { 29\tresult = s[left:right] 30\t} 31\t} 32\treturn 33} 思路3 # Manache算法，可以将时间复杂度降低到 $O(n)$ 不过稍微有点不好理解 就是在思路2的基础上，按照前面某个回文串（要求i在其臂长内）的中心进行对称一下，对称点已经有结果就可以少判断已经判断的地方 1func longestPalindrome(s string) string { 2\tstart, end := 0, -1 3\tt := \u0026#34;#\u0026#34; 4\tfor i := 0; i \u0026lt; len(s); i++ { 5\tt += string(s[i]) + \u0026#34;#\u0026#34; 6\t} 7\tt += \u0026#34;#\u0026#34; 8\ts = t 9\tarm_len := []int{} 10\tright, j := -1, -1 11\tfor i := 0; i \u0026lt; len(s); i++ { 12\tvar cur_arm_len int 13\tif right \u0026gt;= i { 14\ti_sym := j*2 - i 15\tmin_arm_len := min(arm_len[i_sym], right-i) 16\tcur_arm_len = expand(s, i-min_arm_len, i+min_arm_len) 17\t} else { 18\tcur_arm_len = expand(s, i, i) 19\t} 20\tarm_len = append(arm_len, cur_arm_len) 21\tif i+cur_arm_len \u0026gt; right { 22\tj = i 23\tright = i + cur_arm_len 24\t} 25\tif cur_arm_len*2+1 \u0026gt; end-start { 26\tstart = i - cur_arm_len 27\tend = i + cur_arm_len 28\t} 29\t} 30\tans := \u0026#34;\u0026#34; 31\tfor i := start; i \u0026lt;= end; i++ { 32\tif s[i] != \u0026#39;#\u0026#39; { 33\tans += string(s[i]) 34\t} 35\t} 36\treturn ans 37} 38 39func expand(s string, left, right int) int { 40\tfor ; left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; len(s) \u0026amp;\u0026amp; s[left] == s[right]; left, right = left-1, right+1 { 41\t} 42\treturn (right - left - 2) / 2 43} 44 45func min(x, y int) int { 46\tif x \u0026lt; y { 47\treturn x 48\t} 49\treturn y 50} "},{"id":39,"href":"/docs/linux/linux-kernel/net/bridge/","title":"linux网桥","section":"/net/ 网络部分","content":" 一、结构和原理 # 参考 浅析linux内核网络协议栈\u0026ndash;linux bridge（一）\nbr0绑定了两个网卡，对于协议栈来说，只能看到一个br0的设备 "},{"id":40,"href":"/docs/leetcode/medium/leetcode6/","title":"6. ZigZag Conversion","section":"中等","content":" 题目 # The string \u0026ldquo;PAYPALISHIRING\u0026rdquo; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP A H N A P L S I I G Y I R And then read line by line: \u0026ldquo;PAHNAPLSIIGYIR\u0026rdquo;\nWrite the code that will take a string and make this conversion given a number of rows:\n1string convert(string s, int numRows); 思路1 # 这就是个数学题，每一个周期是 $n+(n-2)$\n对于第一行和最后一行，字符所在位置为每一个周期的第 $i$ 个\n对于其他行，字符所在位置为每一个周期的第 $i$ 个和倒数第 $i$ 个\n所以直接写循环搞定\nfunc convert(s string, numRows int) string { if numRows == 1 { return s } result := make([]byte, 0, len(s)) for i := 0; i \u0026lt; numRows; i++ { index := 0 for index+i \u0026lt; len(s) { // every line has index+i result = append(result, s[index+i]) index += numRows + numRows - 2 if i == 0 || i == numRows-1 { continue } // line except first line and last line, has index-i if index-i \u0026gt;= len(s) { break } result = append(result, s[index-i]) } } return string(result) } "},{"id":41,"href":"/docs/leetcode/medium/leetcode7/","title":"7. Reverse Integer","section":"中等","content":" 题目 # Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range $[-2^{31}, 2^{31} - 1]$, then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n思路1 # 数学推导\n反转不难，重点是不允许用64位的变量，所以要考虑边界\n从输入x的倒序开始遍历，设每一位都为digit，那么每一个循环都有\n$$ result = result \\times 10 + digit $$\n如果可以反转到超出 $[-2^{31}, 2^{31} - 1]$，那么在前一个循环，result必须满足\n$$ result \\ge \\lfloor \\frac{2^{31} - 1}{10} \\rfloor = 214748364 \\vee result \\le \\lceil -\\frac{2^{31}}{10} \\rceil = -214748364 \\tag{1} $$\n如果取等号，digit则需要满足\n$$ \\left\\{ \\begin{array}{ll} digit \u0026gt; 7 \u0026amp; if \u0026amp; x \u0026gt; 0 \\\\ digit \u0026gt; 8 \u0026amp; if \u0026amp; x \u0026lt; 0 \\end{array} \\right. $$\n假设x满足反转超出，x的位数肯定和 $2^{31}$ 一致，最高位也就是反转后的个位数满足 $digit \\le 2$\n也就是(1)式取等号时，反转不会超出范围，只用判断不取等号的情况\n代码实现\n为了防止每次对x进行除法和取余运算，直接转成字符串处理\n1func reverse(x int) (result int) { 2\ttmp := fmt.Sprint(x) 3\tfor i := range(tmp) { 4\tif tmp[len(tmp)-i-1] == \u0026#39;-\u0026#39; { 5\tresult = -result 6\tbreak 7\t} 8\tif result \u0026gt; math.MaxInt32 / 10 || result \u0026lt; math.MinInt32 / 10 { 9\tresult = 0 10\treturn 11\t} 12\tresult *= 10 13\tresult += int(tmp[len(tmp)-1-i] - \u0026#39;0\u0026#39;) 14\t} 15\treturn 16} "},{"id":42,"href":"/docs/leetcode/medium/leetcode8/","title":"8. String to Integer (atoi)","section":"中等","content":" 题目 # Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++\u0026rsquo;s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\nRead in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is \u0026lsquo;-\u0026rsquo; or \u0026lsquo;+\u0026rsquo;. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. \u0026ldquo;123\u0026rdquo; -\u0026gt; 123, \u0026ldquo;0032\u0026rdquo; -\u0026gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range $[-2^{31}, 2^{31} - 1]$, then clamp the integer so that it remains in the range. Specifically, integers less than $-2^{31}$ should be clamped to $-2^{31}$, and integers greater than $2^{31} - 1$ should be clamped to $2^{31} - 1$. Return the integer as the final result. Note:\nOnly the space character \u0026rsquo; \u0026rsquo; is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. 思路1 # 状态机实现，不详细解释\n由于没有限制64位，直接用64位判断溢出\n1func myAtoi(s string) int { 2\tvar result int64 3\tsign := 1 4\tisParse := false 5\tfor _, v := range s { 6\tif v \u0026lt;= \u0026#39;9\u0026#39; \u0026amp;\u0026amp; v \u0026gt;= \u0026#39;0\u0026#39; { 7\tif !isParse { 8\tresult = int64(v - \u0026#39;0\u0026#39;) 9\tisParse = true 10\tcontinue 11\t} 12\tresult *= 10 13\tresult += int64(v - \u0026#39;0\u0026#39;) 14\tif sign == 1 \u0026amp;\u0026amp; result \u0026gt; math.MaxInt32 { 15\treturn math.MaxInt32 16\t} else if result-1 \u0026gt; math.MaxInt32 { 17\treturn math.MinInt32 18\t} 19\tcontinue 20\t} else if isParse { 21\tbreak 22\t} else if v == \u0026#39;-\u0026#39; { 23\tsign = -1 24\tisParse = true 25\t} else if v == \u0026#39;+\u0026#39; { 26\tisParse = true 27\t} else if v != \u0026#39; \u0026#39; { 28\treturn 0 29\t} 30\t} 31\treturn int(result) * sign 32} "},{"id":43,"href":"/docs/leetcode/simple/leetcode9/","title":"9. Palindrome Number","section":"简单","content":" 题目 # Given an integer x, return true if x is palindrome integer.\nAn integer is a palindrome when it reads the same backward as forward.\nFor example, 121 is a palindrome while 123 is not. 思路1 # 最简单直接的想法，转成字符串，然后判断 1func isPalindrome(x int) bool { 2\ts := fmt.Sprint(x) 3\ti := 0 4\tj := len(s) - 1 5\tfor i \u0026lt; j { 6\tif s[i] != s[j] { 7\treturn false 8\t} 9\ti++ 10\tj-- 11\t} 12\treturn true 13} 思路2 # 无情打脸，官方解法nb 转字符串太占内存，直接反转一半（位数为奇数多反转一个）的数字，然后比较 位数为奇数\n@startuml rectangle x { (121) as left1 (12) as left2 (1) as left3 } rectangle revert { ( ) as right1 (1) as right2 (12) as right3 } (x == revert/10) as mid left1 --\u0026gt; left2 left2 --\u0026gt; left3 right1 --\u0026gt; right2 right2 --\u0026gt; right3 left3 --\u0026gt; mid right3 --\u0026gt; mid @enduml 位数为偶数\n@startuml rectangle x { (1221) as left1 (122) as left2 (12) as left3 } rectangle revert { ( ) as right1 (1) as right2 (12) as right3 } (x == revert) as mid left1 --\u0026gt; left2 left2 --\u0026gt; left3 right1 --\u0026gt; right2 right2 --\u0026gt; right3 left3 --\u0026gt; mid right3 --\u0026gt; mid @enduml 代码实现\n1func isPalindrome(x int) bool { 2\tif x == 0 { 3\treturn true 4\t} 5\tif x \u0026lt; 0 || x%10 == 0 { 6\treturn false 7\t} 8\trevertNum := 0 9\tfor x \u0026gt; revertNum { 10\trevertNum = revertNum*10 + x%10 11\tx /= 10 12\t} 13\treturn x == revertNum || x == revertNum/10 14} "},{"id":44,"href":"/posts/creating-a-new-theme/","title":"Creating a New Theme","section":"Blog","content":" Introduction # This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I\u0026rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won\u0026rsquo;t cover using CSS to style your theme.\nWe\u0026rsquo;ll start with creating a new site with a very basic template. Then we\u0026rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the \u0026ldquo;$\u0026rdquo; prompt. The output will follow. Lines that start with \u0026ldquo;#\u0026rdquo; are comments that I\u0026rsquo;ve added to explain a point. When I show updates to a file, the \u0026ldquo;:wq\u0026rdquo; on the last line means to save the file.\nHere\u0026rsquo;s an example:\n## this is a comment $ echo this is a command this is a command ## edit the file $ vi foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug :wq ## show it $ cat foo.md +++ date = \u0026#34;2014-09-28\u0026#34; title = \u0026#34;creating a new theme\u0026#34; +++ bah and humbug $ Some Definitions # There are a few concepts that you need to understand before creating a theme.\nSkins # Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\nThe Home Page # The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\nSite Configuration File # When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\nContent # Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\nFront Matter # The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\nMarkdown # Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\nTemplate Files # Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it\u0026rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\nSingle Template # A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\nList Template # A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\nPartial Template # A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.\nCreate a New Site # Let\u0026rsquo;s use Hugo to create a new web site. I\u0026rsquo;m a Mac user, so I\u0026rsquo;ll create mine in my home directory, in the Sites folder. If you\u0026rsquo;re using Linux, you might have to create the folder first.\nThe \u0026ldquo;new site\u0026rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta $ cd ~/Sites/zafta $ ls -l total 8 drwxr-xr-x 7 quoha staff 238 Sep 29 16:49 . drwxr-xr-x 3 quoha staff 102 Sep 29 16:49 .. drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ Take a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That\u0026rsquo;s a topic for a different tutorial, so please ignore them for now.\nGenerate the HTML For the New Site # Running the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that\u0026rsquo;s everything that\u0026rsquo;s not content). Since we have an empty site, it won\u0026rsquo;t do much, but it will do it very quickly.\n$ hugo --verbose INFO: 2014/09/29 Using config file: config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ The \u0026ldquo;--verbose\u0026rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with \u0026ldquo;INFO:\u0026rdquo; or \u0026ldquo;WARN:\u0026rdquo; is present because we used that flag. The lines that start with \u0026ldquo;WARN:\u0026rdquo; are warning messages. We\u0026rsquo;ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static $ See that new public/ directory? Hugo placed all generated content there. When you\u0026rsquo;re ready to publish your web site, that\u0026rsquo;s the place to start. For now, though, let\u0026rsquo;s just confirm that we have what we\u0026rsquo;d expect from a site with no content.\n$ ls -l public total 16 -rw-r--r-- 1 quoha staff 416 Sep 29 17:02 index.xml -rw-r--r-- 1 quoha staff 262 Sep 29 17:02 sitemap.xml $ Hugo created two XML files, which is standard, but there are no HTML files.\nTest the New Site # Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the \u0026ldquo;server\u0026rdquo; command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop Connect to the listed URL (it\u0026rsquo;s on the line that starts with \u0026ldquo;Web Server\u0026rdquo;). If everything is working correctly, you should get a page that shows the following:\nindex.xml sitemap.xml That\u0026rsquo;s a listing of your public/ directory. Hugo didn\u0026rsquo;t create a home page because our site has no content. When there\u0026rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] WARN: 2014/09/29 Unable to locate layout: [404.html] That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it\u0026rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we\u0026rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn\u0026rsquo;t find a template for the home page and it told you so.\nAt this point, you\u0026rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.\nCreate a New Theme # Hugo doesn\u0026rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe\u0026rsquo;re going to create a new theme called \u0026ldquo;zafta.\u0026rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses \u0026ldquo;post\u0026rdquo; over \u0026ldquo;blog\u0026rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\nCreate a Skeleton # Use the hugo \u0026ldquo;new\u0026rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta $ ls -l total 8 drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 archetypes -rw-r--r-- 1 quoha staff 82 Sep 29 16:49 config.toml drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 content drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:02 public drwxr-xr-x 2 quoha staff 68 Sep 29 16:49 static drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes $ find themes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 1081 Sep 29 17:31 themes/zafta/LICENSE.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html -rw-r--r-- 1 quoha staff 93 Sep 29 17:31 themes/zafta/theme.toml $ The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They\u0026rsquo;re optional, but if you\u0026rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It\u0026rsquo;s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml author = \u0026#34;michael d henderson\u0026#34; description = \u0026#34;a minimal working template\u0026#34; license = \u0026#34;MIT\u0026#34; name = \u0026#34;zafta\u0026#34; source_repo = \u0026#34;\u0026#34; tags = [\u0026#34;tags\u0026#34;, \u0026#34;categories\u0026#34;] :wq ## also edit themes/zafta/LICENSE.md and change ## the bit that says \u0026#34;YOUR_NAME_HERE\u0026#34; Note that the the skeleton\u0026rsquo;s template files are empty. Don\u0026rsquo;t worry, we\u0026rsquo;ll be changing that shortly.\n$ find themes/zafta -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/single.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/partials/header.html $ Update the Configuration File to Use the Theme # Now that we\u0026rsquo;ve got a theme to work with, it\u0026rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add \u0026ldquo;-t zafta\u0026rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don\u0026rsquo;t put it in the configuration file or specify it on the command line, you won\u0026rsquo;t use the template that you\u0026rsquo;re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml theme = \u0026#34;zafta\u0026#34; baseurl = \u0026#34;\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;zafta - totally refreshing\u0026#34; MetaDataFormat = \u0026#34;toml\u0026#34; :wq $ Generate the Site # Now that we have an empty theme, let\u0026rsquo;s generate the site again.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme\u0026rsquo;s directory.\nLet\u0026rsquo;s check the public/ directory to see what Hugo\u0026rsquo;s created.\n$ ls -l public total 16 drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 css -rw-r--r-- 1 quoha staff 0 Sep 29 17:56 index.html -rw-r--r-- 1 quoha staff 407 Sep 29 17:56 index.xml drwxr-xr-x 2 quoha staff 68 Sep 29 17:56 js -rw-r--r-- 1 quoha staff 243 Sep 29 17:56 sitemap.xml $ Notice four things:\nHugo created a home page. This is the file public/index.html. Hugo created a css/ directory. Hugo created a js/ directory. Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn\u0026rsquo;t create any pages. That\u0026rsquo;s because it considers a \u0026ldquo;page\u0026rdquo; to be a file created directly from a content file. It doesn\u0026rsquo;t count things like the index.html files that it creates automatically. The Home Page # Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo\u0026rsquo;s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html] If it can\u0026rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 20:21 ./public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 ./themes/zafta/layouts/index.html $ The Magic of Static # Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo\u0026rsquo;s opinion is that you\u0026rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don\u0026rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo\u0026rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld drwxr-xr-x 7 quoha staff 238 Sep 29 17:38 themes/zafta drwxr-xr-x 3 quoha staff 102 Sep 29 17:31 themes/zafta/archetypes drwxr-xr-x 5 quoha staff 170 Sep 29 17:31 themes/zafta/layouts drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/_default drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/layouts/partials drwxr-xr-x 4 quoha staff 136 Sep 29 17:31 themes/zafta/static drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/css drwxr-xr-x 2 quoha staff 68 Sep 29 17:31 themes/zafta/static/js $ The Theme Development Cycle # When you\u0026rsquo;re working on a theme, you will make changes in the theme\u0026rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\nPurge the public/ directory. Run the built in web server in watch mode. Open your site in a browser. Update the theme. Glance at your browser window to see changes. Return to step 4. I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\nPurge the public/ Directory # When generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you\u0026rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.\nHugo\u0026rsquo;s Watch Option # Hugo\u0026rsquo;s \u0026ldquo;--watch\u0026rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\nLive Reload # Hugo\u0026rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, \u0026ldquo;Wow, that\u0026rsquo;s totally amazing.\u0026rdquo;\nDevelopment Commands # Use the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory. ## $ rm -rf public ## ## run hugo in watch mode ## $ hugo server --watch --verbose Here\u0026rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I\u0026rsquo;ve said this before, it\u0026rsquo;s amazing.\n$ rm -rf public $ hugo server --watch --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms Watching for changes in /Users/quoha/Sites/zafta/content Serving pages from /Users/quoha/Sites/zafta/public Web Server is available at http://localhost:1313 Press Ctrl+C to stop INFO: 2014/09/29 File System Event: [\u0026#34;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\u0026#34;: MODIFY|ATTRIB] Change detected, rebuilding site WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 1 ms Update the Home Page Template # The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme\u0026rsquo;s layout/ directory:\nindex.html _default/list.html _default/single.html We could update one of the default templates, but a good design decision is to update the most specific template available. That\u0026rsquo;s not a hard and fast rule (in fact, we\u0026rsquo;ll break it a few times in this tutorial), but it is a good generalization.\nMake a Static Home Page # Right now, that page is empty because we don\u0026rsquo;t have any content and we don\u0026rsquo;t have any logic in the template. Let\u0026rsquo;s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and then verify the results.\n$ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 0 pages created 0 tags created 0 categories created in 2 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 21:26 public/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;/html\u0026gt; Live Reload # Note: If you\u0026rsquo;re running the server with the --watch option, you\u0026rsquo;ll see different content in the file:\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hugo says hello!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; When you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\nBuild a \u0026ldquo;Dynamic\u0026rdquo; Home Page # \u0026ldquo;Dynamic home page?\u0026rdquo; Hugo\u0026rsquo;s a static web site generator, so this seems an odd thing to say. I mean let\u0026rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We\u0026rsquo;ll use iteration in the template to do that.\nCreate New Posts # Now that we have the home page generating static content, let\u0026rsquo;s add some content to the site. We\u0026rsquo;ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md ERROR: 2014/09/29 Unable to Cast \u0026lt;nil\u0026gt; to map[string]interface{} $ That wasn\u0026rsquo;t very nice, was it?\nThe \u0026ldquo;new\u0026rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there\u0026rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md +++ Description = \u0026#34;\u0026#34; Tags = [] Categories = [] +++ :wq $ find themes/zafta/archetypes -type f | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 21:53 themes/zafta/archetypes/default.md -rw-r--r-- 1 quoha staff 51 Sep 29 21:54 themes/zafta/archetypes/post.md $ hugo --verbose new post/first.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/first.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md /Users/quoha/Sites/zafta/content/post/first.md created $ hugo --verbose new post/second.md INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 attempting to create post/second.md of post INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md /Users/quoha/Sites/zafta/content/post/second.md created $ ls -l content/post total 16 -rw-r--r-- 1 quoha staff 104 Sep 29 21:54 first.md -rw-r--r-- 1 quoha staff 105 Sep 29 21:57 second.md $ cat content/post/first.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:54:53-05:00\u0026#34; title = \u0026#34;first\u0026#34; +++ my first post $ cat content/post/second.md +++ Categories = [] Description = \u0026#34;\u0026#34; Tags = [] date = \u0026#34;2014-09-29T21:57:09-05:00\u0026#34; title = \u0026#34;second\u0026#34; +++ my second post $ Build the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;, \u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ The output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 78 Sep 29 22:13 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:13 public/post/second/index.html $ The new files are empty because because the templates used to generate the content are empty. The homepage doesn\u0026rsquo;t show the new content, either. We have to update the templates to add the posts.\nList and Single Templates # In Hugo, we have three major kinds of templates. There\u0026rsquo;s the home page template that we updated previously. It is used only by the home page. We also have \u0026ldquo;single\u0026rdquo; templates which are used to generate output for a single content file. We also have \u0026ldquo;list\u0026rdquo; templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named \u0026ldquo;list.html\u0026rdquo; and single templates are named \u0026ldquo;single.html.\u0026rdquo;\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\nAdd Content to the Homepage # The home page will contain a list of posts. Let\u0026rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between \u0026ldquo;{{\u0026rdquo; and \u0026ldquo;}}\u0026rdquo;. In our template, the commands are:\nrange .Title end The \u0026ldquo;range\u0026rdquo; command is an iterator. We\u0026rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe \u0026ldquo;.Title\u0026rdquo; command prints the value of the \u0026ldquo;title\u0026rdquo; variable. Hugo pulls it from the front matter in the Markdown file.\nThe \u0026ldquo;end\u0026rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds \u0026ldquo;end.\u0026rdquo; Everything between the \u0026ldquo;range\u0026rdquo; and \u0026ldquo;end\u0026rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt\u0026rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:23 public/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:23 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let\u0026rsquo;s take a moment to appreciate what we\u0026rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you\u0026rsquo;ve learned everything you need to know to build a theme. All that\u0026rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don\u0026rsquo;t worry, though, that\u0026rsquo;s all to come.\nAdd Content to the Posts # We\u0026rsquo;re working with posts, which are in the content/post/ directory. That means that their section is \u0026ldquo;post\u0026rdquo; (and if we don\u0026rsquo;t do something weird, their type is also \u0026ldquo;post\u0026rdquo;).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can\u0026rsquo;t find one, then it will look in the _default/ directory. There are some twists that we\u0026rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let\u0026rsquo;s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l -rw-r--r-- 1 quoha staff 132 Sep 29 17:31 themes/zafta/layouts/_default/single.html We could create a new template, post/single.html, or change the default. Since we don\u0026rsquo;t know of any other content types, let\u0026rsquo;s start with updating the default.\nRemember, any content that we haven\u0026rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we\u0026rsquo;re going to be adding different types of content and we\u0026rsquo;re going to end up undoing some of the changes we\u0026rsquo;ve made. It\u0026rsquo;s good because we\u0026rsquo;ll be able to see immediate results. It\u0026rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we\u0026rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we\u0026rsquo;ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you\u0026rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That\u0026rsquo;s a refreshing amount of joy right there.\nUpdate the Template File # $ vi themes/zafta/layouts/_default/single.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq $ Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 94 Sep 29 22:40 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:40 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:40 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:40 public/post/second/index.html $ cat public/post/first/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;first\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;first\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my first post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ cat public/post/second/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;second\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;second\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;my second post\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Notice that the posts now have content. You can go to localhost:1313/post/first to verify.\nLinking to Content # The posts are on the home page. Let\u0026rsquo;s add a link from there to the post. Since this is the home page, we\u0026rsquo;ll update its template.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; {{ range first 10 .Data.Pages }} \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Build the web site and verify the results.\n$ rm -rf public $ hugo --verbose INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/ INFO: 2014/09/29 found taxonomies: map[string]string{\u0026#34;tag\u0026#34;:\u0026#34;tags\u0026#34;, \u0026#34;category\u0026#34;:\u0026#34;categories\u0026#34;} WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html] 0 draft content 0 future content 2 pages created 0 tags created 0 categories created in 4 ms $ find public -type f -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-r--r-- 1 quoha staff 149 Sep 29 22:44 public/index.html -rw-r--r-- 1 quoha staff 125 Sep 29 22:44 public/post/first/index.html -rw-r--r-- 1 quoha staff 0 Sep 29 22:44 public/post/index.html -rw-r--r-- 1 quoha staff 128 Sep 29 22:44 public/post/second/index.html $ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/second/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;/post/first/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; $ Create a Post Listing # We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let\u0026rsquo;s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let\u0026rsquo;s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l -rw-r--r-- 1 quoha staff 0 Sep 29 17:31 themes/zafta/layouts/_default/list.html As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don\u0026rsquo;t have multiple content types, so let\u0026rsquo;s stay consistent and update the default list template.\nCreating Top Level Pages # Let\u0026rsquo;s add an \u0026ldquo;about\u0026rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let\u0026rsquo;s verify that by creating an \u0026ldquo;about\u0026rdquo; page at the top level:\n$ vi content/about.md +++ title = \u0026#34;about\u0026#34; description = \u0026#34;about this site\u0026#34; date = \u0026#34;2014-09-27\u0026#34; slug = \u0026#34;about time\u0026#34; +++ ## about us i\u0026#39;m speechless :wq Generate the web site and verify the results.\n$ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:08 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 527 Sep 27 15:08 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:08 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:08 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:08 public/post/second-post/index.html Notice that the page wasn\u0026rsquo;t created at the top level. It was created in a sub-directory named \u0026lsquo;about-time/\u0026rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It\u0026rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/theme/\u0026#34;\u0026gt;creating a new theme\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/about-time/\u0026#34;\u0026gt;about\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/second-post/\u0026#34;\u0026gt;second\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;a href=\u0026#34;http://localhost:1313/post/first-post/\u0026#34;\u0026gt;first\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;script\u0026gt;document.write(\u0026#39;\u0026lt;script src=\u0026#34;http://\u0026#39; + (location.host || \u0026#39;localhost\u0026#39;).split(\u0026#39;:\u0026#39;)[0] + \u0026#39;:1313/livereload.js?mindelay=10\u0026#34;\u0026gt;\u0026lt;/\u0026#39; + \u0026#39;script\u0026gt;\u0026#39;)\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Notice that the \u0026ldquo;about\u0026rdquo; link is listed with the posts? That\u0026rsquo;s not desirable, so let\u0026rsquo;s change that first.\n$ vi themes/zafta/layouts/index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if eq .Type \u0026#34;page\u0026#34; }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name \u0026#39;*.html\u0026#39; | xargs ls -l -rw-rw-r-- 1 mdhender staff 334 Sep 27 15:33 public/about-time/index.html -rw-rw-r-- 1 mdhender staff 645 Sep 27 15:33 public/index.html -rw-rw-r-- 1 mdhender staff 358 Sep 27 15:33 public/post/first-post/index.html -rw-rw-r-- 1 mdhender staff 0 Sep 27 15:33 public/post/index.html -rw-rw-r-- 1 mdhender staff 342 Sep 27 15:33 public/post/second-post/index.html Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let\u0026rsquo;s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml [permalinks] page = \u0026#34;/:title/\u0026#34; about = \u0026#34;/:filename/\u0026#34; Generate the web site and verify that this didn\u0026rsquo;t work. Hugo lets \u0026ldquo;slug\u0026rdquo; or \u0026ldquo;URL\u0026rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.\nSharing Templates # If you\u0026rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn\u0026rsquo;t. That\u0026rsquo;s because we didn\u0026rsquo;t put the title in the home page\u0026rsquo;s template (layouts/index.html). That\u0026rsquo;s an easy thing to do, but let\u0026rsquo;s look at a different option.\nWe can put the common bits into a shared template that\u0026rsquo;s stored in the themes/zafta/layouts/partials/ directory.\nCreate the Header and Footer Partials # In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme\u0026rsquo;s presentation.\n$ vi themes/zafta/layouts/partials/header.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; :wq $ vi themes/zafta/layouts/partials/footer.html \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; :wq Update the Home Page Template to Use the Partials # The most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \u0026#34;theme/partials/header.html\u0026#34; . }} versus\n{{ partial \u0026#34;header.html\u0026#34; . }} Both pass in the context.\nLet\u0026rsquo;s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;posts\u0026lt;/h1\u0026gt; {{ range first 10 .Data.Pages }} {{ if eq .Type \u0026#34;post\u0026#34;}} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} \u0026lt;h1\u0026gt;pages\u0026lt;/h1\u0026gt; {{ range .Data.Pages }} {{ if or (eq .Type \u0026#34;page\u0026#34;) (eq .Type \u0026#34;about\u0026#34;) }} \u0026lt;h2\u0026gt;\u0026lt;a href=\u0026#34;{{ .Permalink }}\u0026#34;\u0026gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}\u0026lt;/a\u0026gt;\u0026lt;/h2\u0026gt; {{ end }} {{ end }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the home page is now \u0026ldquo;your title here\u0026rdquo;, which comes from the \u0026ldquo;title\u0026rdquo; variable in the config.toml file.\nUpdate the Default Single Template to Use the Partials # $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.\nAdd “Date Published” to Posts # It\u0026rsquo;s common to have posts display the date that they were written or published, so let\u0026rsquo;s add that. The front matter of our posts has a variable named \u0026ldquo;date.\u0026rdquo; It\u0026rsquo;s usually the date the content was created, but let\u0026rsquo;s pretend that\u0026rsquo;s the value we want to display.\nAdd “Date Published” to the Template # We\u0026rsquo;ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }} Posts use the default single template, so we\u0026rsquo;ll change that file.\n$ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Generate the web site and verify the results. The posts now have the date displayed in them. There\u0026rsquo;s a problem, though. The \u0026ldquo;about\u0026rdquo; page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an \u0026ldquo;if\u0026rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.\nThe \u0026ldquo;if\u0026rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of \u0026ldquo;code for today,\u0026rdquo; too.\nLet\u0026rsquo;s assume, though, that we\u0026rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we\u0026rsquo;re going to create a section template.\nLet\u0026rsquo;s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post $ vi themes/zafta/layouts/_default/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Now we\u0026rsquo;ll update the post\u0026rsquo;s version of the single template. If you remember Hugo\u0026rsquo;s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html {{ partial \u0026#34;header.html\u0026#34; . }} \u0026lt;h1\u0026gt;{{ .Title }}\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;{{ .Date.Format \u0026#34;Mon, Jan 2, 2006\u0026#34; }}\u0026lt;/h2\u0026gt; {{ .Content }} {{ partial \u0026#34;footer.html\u0026#34; . }} :wq Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn\u0026rsquo;t.\nDon\u0026rsquo;t Repeat Yourself # DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you\u0026rsquo;re figuring that out, accept that you\u0026rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it\u0026rsquo;s okay to delay splitting up a template.\n"},{"id":45,"href":"/posts/migrate-from-jekyll/","title":"Migrating from Jekyll","section":"Blog","content":" Move static content to static # Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ \u0026lt;root\u0026gt;/ ▾ images/ logo.png should become\n▾ \u0026lt;root\u0026gt;/ ▾ static/ ▾ images/ logo.png Additionally, you\u0026rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.\nCreate your Hugo configuration file # Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.\nSet your configuration publish folder to _site # The default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you\u0026rsquo;ll want to do one of two alternatives:\nChange your submodule to point to map gh-pages to public instead of _site (recommended).\ngit submodule deinit _site git rm _site git submodule add -b gh-pages git@github.com:your-username/your-repo.git public Or, change the Hugo configuration to use _site instead of public.\n{ .. \u0026quot;publishdir\u0026quot;: \u0026quot;_site\u0026quot;, .. } Convert Jekyll templates to Hugo templates # That\u0026rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll\u0026rsquo;s template documentation if you need to refresh your memory on how you built your blog and Hugo\u0026rsquo;s template to learn Hugo\u0026rsquo;s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.\nConvert Jekyll plugins to Hugo shortcodes # Jekyll has plugins; Hugo has shortcodes. It\u0026rsquo;s fairly trivial to do a port.\nImplementation # As an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll\u0026rsquo;s plugin:\nmodule Jekyll class ImageTag \u0026lt; Liquid::Tag @url = nil @caption = nil @class = nil @link = nil // Patterns IMAGE_URL_WITH_CLASS_AND_CAPTION = IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;(\\s+)-\u0026gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i IMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\u0026quot;(.*?)\u0026quot;/i IMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i IMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i def initialize(tag_name, markup, tokens) super if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK @class = $1 @url = $3 @caption = $7 @link = $9 elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION @class = $1 @url = $3 @caption = $7 elsif markup =~ IMAGE_URL_WITH_CAPTION @url = $1 @caption = $5 elsif markup =~ IMAGE_URL_WITH_CLASS @class = $1 @url = $3 elsif markup =~ IMAGE_URL @url = $1 end end def render(context) if @class source = \u0026quot;\u0026lt;figure class='#{@class}'\u0026gt;\u0026quot; else source = \u0026quot;\u0026lt;figure\u0026gt;\u0026quot; end if @link source += \u0026quot;\u0026lt;a href=\\\u0026quot;#{@link}\\\u0026quot;\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;img src=\\\u0026quot;#{@url}\\\u0026quot;\u0026gt;\u0026quot; if @link source += \u0026quot;\u0026lt;/a\u0026gt;\u0026quot; end source += \u0026quot;\u0026lt;figcaption\u0026gt;#{@caption}\u0026lt;/figcaption\u0026gt;\u0026quot; if @caption source += \u0026quot;\u0026lt;/figure\u0026gt;\u0026quot; source end end end Liquid::Template.register_tag('image', Jekyll::ImageTag) is written as this Hugo shortcode:\n\u0026lt;!-- image --\u0026gt; \u0026lt;figure {{ with .Get \u0026quot;class\u0026quot; }}class=\u0026quot;{{.}}\u0026quot;{{ end }}\u0026gt; {{ with .Get \u0026quot;link\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt;{{ end }} \u0026lt;img src=\u0026quot;{{ .Get \u0026quot;src\u0026quot; }}\u0026quot; {{ if or (.Get \u0026quot;alt\u0026quot;) (.Get \u0026quot;caption\u0026quot;) }}alt=\u0026quot;{{ with .Get \u0026quot;alt\u0026quot;}}{{.}}{{else}}{{ .Get \u0026quot;caption\u0026quot; }}{{ end }}\u0026quot;{{ end }} /\u0026gt; {{ if .Get \u0026quot;link\u0026quot;}}\u0026lt;/a\u0026gt;{{ end }} {{ if or (or (.Get \u0026quot;title\u0026quot;) (.Get \u0026quot;caption\u0026quot;)) (.Get \u0026quot;attr\u0026quot;)}} \u0026lt;figcaption\u0026gt;{{ if isset .Params \u0026quot;title\u0026quot; }} {{ .Get \u0026quot;title\u0026quot; }}{{ end }} {{ if or (.Get \u0026quot;caption\u0026quot;) (.Get \u0026quot;attr\u0026quot;)}}\u0026lt;p\u0026gt; {{ .Get \u0026quot;caption\u0026quot; }} {{ with .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;a href=\u0026quot;{{.}}\u0026quot;\u0026gt; {{ end }} {{ .Get \u0026quot;attr\u0026quot; }} {{ if .Get \u0026quot;attrlink\u0026quot;}}\u0026lt;/a\u0026gt; {{ end }} \u0026lt;/p\u0026gt; {{ end }} \u0026lt;/figcaption\u0026gt; {{ end }} \u0026lt;/figure\u0026gt; \u0026lt;!-- image --\u0026gt; Usage # I simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were \u0026quot;having fun\u0026quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; -\u0026gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %} to this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{% fig class=\u0026quot;full\u0026quot; src=\u0026quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\u0026quot; title=\u0026quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\u0026quot; link=\u0026quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\u0026quot; %}} As a bonus, the shortcode named parameters are, arguably, more readable.\nFinishing touches # Fix content # Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\nClean up # You\u0026rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn\u0026rsquo;t used, delete it.\nA practical example in a diff # Hey, it\u0026rsquo;s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.\n"},{"id":46,"href":"/docs/linux/linux-kernel/net/epoll/","title":"Epoll","section":"/net/ 网络部分","content":" 参考 从linux5.9看网络层的设计 一、总述 # epoll本身使用红黑树处理fd的存储，主要是用于epoll_ctl可以快速插入删除某个fd epoll加入一个fd时会将自身的一个回调函数插入到此socket的就绪队列的回调上 回调函数中可以直接拿到epoll红黑树上的节点，然后将对应事件加入到链表中，通知上面进行收消息 二、数据结构 # 1. eventpoll # epoll的主结构体，存放到file的private_data中 epoll对于fd的储存使用的是红黑树 使用链表保存处于就绪状态的fd 1// fs/eventpoll.c 2/* 3 * This structure is stored inside the \u0026#34;private_data\u0026#34; member of the file 4 * structure and represents the main data structure for the eventpoll 5 * interface. 6 */ 7struct eventpoll { 8\t/* 9\t* This mutex is used to ensure that files are not removed 10\t* while epoll is using them. This is held during the event 11\t* collection loop, the file cleanup path, the epoll file exit 12\t* code and the ctl operations. 13\t*/ 14\tstruct mutex mtx; 15 16\t/* Wait queue used by sys_epoll_wait() */ 17\twait_queue_head_t wq; 18 19\t/* Wait queue used by file-\u0026gt;poll() */ 20\twait_queue_head_t poll_wait; 21 22\t/* List of ready file descriptors */ 23\tstruct list_head rdllist;\t// 就绪队列，epoll收事件是从这里收取 24 25\t/* Lock which protects rdllist and ovflist */ 26\trwlock_t lock; 27 28\t/* RB tree root used to store monitored fd structs */ 29\tstruct rb_root_cached rbr;\t// 存储要监听的fd结构体，实际是epitem结构体 30 31\t/* 32\t* This is a single linked list that chains all the \u0026#34;struct epitem\u0026#34; that 33\t* happened while transferring ready events to userspace w/out 34\t* holding -\u0026gt;lock. 35\t*/ 36\tstruct epitem *ovflist; 37 38\t/* wakeup_source used when ep_scan_ready_list is running */ 39\tstruct wakeup_source *ws; 40 41\t/* The user that created the eventpoll descriptor */ 42\tstruct user_struct *user; 43 44\tstruct file *file; 45 46\t/* used to optimize loop detection check */ 47\tu64 gen; 48\tstruct hlist_head refs; 49 50#ifdef CONFIG_NET_RX_BUSY_POLL 51\t/* used to track busy poll napi_id */ 52\tunsigned int napi_id; 53#endif 54 55#ifdef CONFIG_DEBUG_LOCK_ALLOC 56\t/* tracks wakeup nests for lockdep validation */ 57\tu8 nests; 58#endif 59}; 2. epitem # 每个fd存到epitem中，epitem在epoll中使用红黑树存储 1// fs/eventpoll.c 2/* 3 * Each file descriptor added to the eventpoll interface will 4 * have an entry of this type linked to the \u0026#34;rbr\u0026#34; RB tree. 5 * Avoid increasing the size of this struct, there can be many thousands 6 * of these on a server and we do not want this to take another cache line. 7 */ 8struct epitem { 9\tunion { 10\t/* RB tree node links this structure to the eventpoll RB tree */ 11\tstruct rb_node rbn; 12\t/* Used to free the struct epitem */ 13\tstruct rcu_head rcu; 14\t}; 15 16\t/* List header used to link this structure to the eventpoll ready list */ 17\tstruct list_head rdllink; 18 19\t/* 20\t* Works together \u0026#34;struct eventpoll\u0026#34;-\u0026gt;ovflist in keeping the 21\t* single linked chain of items. 22\t*/ 23\tstruct epitem *next; 24 25\t/* The file descriptor information this item refers to */ 26\tstruct epoll_filefd ffd; 27 28\t/* List containing poll wait queues */ 29\tstruct eppoll_entry *pwqlist; 30 31\t/* The \u0026#34;container\u0026#34; of this item */ 32\tstruct eventpoll *ep; 33 34\t/* List header used to link this item to the \u0026#34;struct file\u0026#34; items list */ 35\tstruct hlist_node fllink; 36 37\t/* wakeup_source used when EPOLLWAKEUP is set */ 38\tstruct wakeup_source __rcu *ws; 39 40\t/* The structure that describe the interested events and the source fd */ 41\tstruct epoll_event event; 42}; 2.1. epoll_filefd # 1// fs/eventpoll.c 2struct epoll_filefd { 3\tstruct file *file; 4\tint fd; 5} __packed; 三、epoll_create调用 # 1. 接口定义 # 1// fs/eventpoll.c 2SYSCALL_DEFINE1(epoll_create, int, size) 3{ 4\tif (size \u0026lt;= 0) 5\treturn -EINVAL; 6 7\treturn do_epoll_create(0); 8} 2. do_epoll_create # 就是创建一个epoll结构体，然后将file结构体和epoll关联 对应epoll本身的相关文件操作 1// fs/eventpoll.c 2/* 3 * Open an eventpoll file descriptor. 4 */ 5static int do_epoll_create(int flags) 6{ 7\tint error, fd; 8\tstruct eventpoll *ep = NULL; 9\tstruct file *file; 10 11\t/* Check the EPOLL_* constant for consistency. */ 12\tBUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC); 13 14\tif (flags \u0026amp; ~EPOLL_CLOEXEC) 15\treturn -EINVAL; 16\t/* 17\t* Create the internal data structure (\u0026#34;struct eventpoll\u0026#34;). 18\t*/ 19\terror = ep_alloc(\u0026amp;ep); 20\tif (error \u0026lt; 0) 21\treturn error; 22\t/* 23\t* Creates all the items needed to setup an eventpoll file. That is, 24\t* a file structure and a free file descriptor. 25\t*/ 26\t// 获取一个未使用的fd 27\tfd = get_unused_fd_flags(O_RDWR | (flags \u0026amp; O_CLOEXEC)); 28\tif (fd \u0026lt; 0) { 29\terror = fd; 30\tgoto out_free_ep; 31\t} 32\t// 创建epoll类型的file结构体 33\tfile = anon_inode_getfile(\u0026#34;[eventpoll]\u0026#34;, \u0026amp;eventpoll_fops, ep, 34\tO_RDWR | (flags \u0026amp; O_CLOEXEC)); 35\tif (IS_ERR(file)) { 36\terror = PTR_ERR(file); 37\tgoto out_free_fd; 38\t} 39\tep-\u0026gt;file = file; 40\t// fd和file绑定 41\tfd_install(fd, file); 42\treturn fd; 43 44out_free_fd: 45\tput_unused_fd(fd); 46out_free_ep: 47\tep_free(ep); 48\treturn error; 49} 3. anon_inode_getfile # ep结构体存到file的private_data中 1// fs/anon_inodes.c 2/** 3 * anon_inode_getfile - creates a new file instance by hooking it up to an 4 * anonymous inode, and a dentry that describe the \u0026#34;class\u0026#34; 5 * of the file 6 * 7 * @name: [in] name of the \u0026#34;class\u0026#34; of the new file 8 * @fops: [in] file operations for the new file 9 * @priv: [in] private data for the new file (will be file\u0026#39;s private_data) 10 * @flags: [in] flags 11 * 12 * Creates a new file by hooking it on a single inode. This is useful for files 13 * that do not need to have a full-fledged inode in order to operate correctly. 14 * All the files created with anon_inode_getfile() will share a single inode, 15 * hence saving memory and avoiding code duplication for the file/inode/dentry 16 * setup. Returns the newly created file* or an error pointer. 17 */ 18struct file *anon_inode_getfile(const char *name, 19\tconst struct file_operations *fops, 20\tvoid *priv, int flags) 21{ 22\treturn __anon_inode_getfile(name, fops, priv, flags, NULL, false); 23} 24EXPORT_SYMBOL_GPL(anon_inode_getfile); 25 26// fs/anon_inodes.c 27static struct file *__anon_inode_getfile(const char *name, 28\tconst struct file_operations *fops, 29\tvoid *priv, int flags, 30\tconst struct inode *context_inode, 31\tbool secure) 32{ 33\tstruct inode *inode; 34\tstruct file *file; 35 36\tif (fops-\u0026gt;owner \u0026amp;\u0026amp; !try_module_get(fops-\u0026gt;owner)) 37\treturn ERR_PTR(-ENOENT); 38 39\tif (secure) { 40\tinode =\tanon_inode_make_secure_inode(name, context_inode); 41\tif (IS_ERR(inode)) { 42\tfile = ERR_CAST(inode); 43\tgoto err; 44\t} 45\t} else { 46\tinode =\tanon_inode_inode; 47\tif (IS_ERR(inode)) { 48\tfile = ERR_PTR(-ENODEV); 49\tgoto err; 50\t} 51\t/* 52\t* We know the anon_inode inode count is always 53\t* greater than zero, so ihold() is safe. 54\t*/ 55\tihold(inode); 56\t} 57 58\tfile = alloc_file_pseudo(inode, anon_inode_mnt, name, 59\tflags \u0026amp; (O_ACCMODE | O_NONBLOCK), fops); 60\tif (IS_ERR(file)) 61\tgoto err_iput; 62 63\tfile-\u0026gt;f_mapping = inode-\u0026gt;i_mapping; 64\t// 将priv存到file的private_data 65\tfile-\u0026gt;private_data = priv; 66 67\treturn file; 68 69err_iput: 70\tiput(inode); 71err: 72\tmodule_put(fops-\u0026gt;owner); 73\treturn file; 74} 四、epoll_ctl # 1. 系统调用定义 # 1// fs/eventpoll.c 2/* 3 * The following function implements the controller interface for 4 * the eventpoll file that enables the insertion/removal/change of 5 * file descriptors inside the interest set. 6 */ 7SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd, 8\tstruct epoll_event __user *, event) 9{ 10\tstruct epoll_event epds; 11 12\tif (ep_op_has_event(op) \u0026amp;\u0026amp; 13\tcopy_from_user(\u0026amp;epds, event, sizeof(struct epoll_event))) 14\treturn -EFAULT; 15 16\treturn do_epoll_ctl(epfd, op, fd, \u0026amp;epds, false); 17} 2. do_epoll_ctl # 1// fs/eventpoll.c 2int do_epoll_ctl(int epfd, int op, int fd, struct epoll_event *epds, 3\tbool nonblock) 4{ 5\tint error; 6\tint full_check = 0; 7\tstruct fd f, tf; 8\tstruct eventpoll *ep; 9\tstruct epitem *epi; 10\tstruct eventpoll *tep = NULL; 11 12\terror = -EBADF; 13\tf = fdget(epfd); 14\tif (!f.file) 15\tgoto error_return; 16 17\t/* Get the \u0026#34;struct file *\u0026#34; for the target file */ 18\ttf = fdget(fd); 19\tif (!tf.file) 20\tgoto error_fput; 21 22\t/* The target file descriptor must support poll */ 23\terror = -EPERM; 24\tif (!file_can_poll(tf.file)) 25\tgoto error_tgt_fput; 26 27\t/* Check if EPOLLWAKEUP is allowed */ 28\tif (ep_op_has_event(op)) 29\tep_take_care_of_epollwakeup(epds); 30 31\t/* 32\t* We have to check that the file structure underneath the file descriptor 33\t* the user passed to us _is_ an eventpoll file. And also we do not permit 34\t* adding an epoll file descriptor inside itself. 35\t*/ 36\terror = -EINVAL; 37\tif (f.file == tf.file || !is_file_epoll(f.file)) 38\tgoto error_tgt_fput; 39 40\t/* 41\t* epoll adds to the wakeup queue at EPOLL_CTL_ADD time only, 42\t* so EPOLLEXCLUSIVE is not allowed for a EPOLL_CTL_MOD operation. 43\t* Also, we do not currently supported nested exclusive wakeups. 44\t*/ 45\tif (ep_op_has_event(op) \u0026amp;\u0026amp; (epds-\u0026gt;events \u0026amp; EPOLLEXCLUSIVE)) { 46\tif (op == EPOLL_CTL_MOD) 47\tgoto error_tgt_fput; 48\tif (op == EPOLL_CTL_ADD \u0026amp;\u0026amp; (is_file_epoll(tf.file) || 49\t(epds-\u0026gt;events \u0026amp; ~EPOLLEXCLUSIVE_OK_BITS))) 50\tgoto error_tgt_fput; 51\t} 52 53\t/* 54\t* At this point it is safe to assume that the \u0026#34;private_data\u0026#34; contains 55\t* our own data structure. 56\t*/ 57\t// fd找到file结构体后，从private_data取出epoll的主结构体 58\tep = f.file-\u0026gt;private_data; 59 60\t/* 61\t* When we insert an epoll file descriptor inside another epoll file 62\t* descriptor, there is the chance of creating closed loops, which are 63\t* better be handled here, than in more critical paths. While we are 64\t* checking for loops we also determine the list of files reachable 65\t* and hang them on the tfile_check_list, so we can check that we 66\t* haven\u0026#39;t created too many possible wakeup paths. 67\t* 68\t* We do not need to take the global \u0026#39;epumutex\u0026#39; on EPOLL_CTL_ADD when 69\t* the epoll file descriptor is attaching directly to a wakeup source, 70\t* unless the epoll file descriptor is nested. The purpose of taking the 71\t* \u0026#39;epmutex\u0026#39; on add is to prevent complex toplogies such as loops and 72\t* deep wakeup paths from forming in parallel through multiple 73\t* EPOLL_CTL_ADD operations. 74\t*/ 75\terror = epoll_mutex_lock(\u0026amp;ep-\u0026gt;mtx, 0, nonblock); 76\tif (error) 77\tgoto error_tgt_fput; 78\tif (op == EPOLL_CTL_ADD) { 79\tif (READ_ONCE(f.file-\u0026gt;f_ep) || ep-\u0026gt;gen == loop_check_gen || 80\tis_file_epoll(tf.file)) { 81\tmutex_unlock(\u0026amp;ep-\u0026gt;mtx); 82\terror = epoll_mutex_lock(\u0026amp;epmutex, 0, nonblock); 83\tif (error) 84\tgoto error_tgt_fput; 85\tloop_check_gen++; 86\tfull_check = 1; 87\tif (is_file_epoll(tf.file)) { 88\ttep = tf.file-\u0026gt;private_data; 89\terror = -ELOOP; 90\tif (ep_loop_check(ep, tep) != 0) 91\tgoto error_tgt_fput; 92\t} 93\terror = epoll_mutex_lock(\u0026amp;ep-\u0026gt;mtx, 0, nonblock); 94\tif (error) 95\tgoto error_tgt_fput; 96\t} 97\t} 98 99\t/* 100\t* Try to lookup the file inside our RB tree. Since we grabbed \u0026#34;mtx\u0026#34; 101\t* above, we can be sure to be able to use the item looked up by 102\t* ep_find() till we release the mutex. 103\t*/ 104\tepi = ep_find(ep, tf.file, fd); 105 106\terror = -EINVAL; 107\tswitch (op) { 108\tcase EPOLL_CTL_ADD: 109\tif (!epi) { 110\tepds-\u0026gt;events |= EPOLLERR | EPOLLHUP; 111\terror = ep_insert(ep, epds, tf.file, fd, full_check); 112\t} else 113\terror = -EEXIST; 114\tbreak; 115\tcase EPOLL_CTL_DEL: 116\tif (epi) 117\terror = ep_remove(ep, epi); 118\telse 119\terror = -ENOENT; 120\tbreak; 121\tcase EPOLL_CTL_MOD: 122\tif (epi) { 123\tif (!(epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE)) { 124\tepds-\u0026gt;events |= EPOLLERR | EPOLLHUP; 125\terror = ep_modify(ep, epi, epds); 126\t} 127\t} else 128\terror = -ENOENT; 129\tbreak; 130\t} 131\tmutex_unlock(\u0026amp;ep-\u0026gt;mtx); 132 133error_tgt_fput: 134\tif (full_check) { 135\tclear_tfile_check_list(); 136\tloop_check_gen++; 137\tmutex_unlock(\u0026amp;epmutex); 138\t} 139 140\tfdput(tf); 141error_fput: 142\tfdput(f); 143error_return: 144 145\treturn error; 146} 3. EPOLL_CTL_ADD 添加fd监听 # 3.1. ep_insert # 先插入fd到epitem 再将epitem插入到epoll的红黑树中 然后将epoll的回调设置到socket中 1// fs/eventpoll.c 2/* 3 * Must be called with \u0026#34;mtx\u0026#34; held. 4 */ 5static int ep_insert(struct eventpoll *ep, const struct epoll_event *event, 6\tstruct file *tfile, int fd, int full_check) 7{ 8\tint error, pwake = 0; 9\t__poll_t revents; 10\tstruct epitem *epi; 11\tstruct ep_pqueue epq; 12\tstruct eventpoll *tep = NULL; 13 14\tif (is_file_epoll(tfile)) 15\ttep = tfile-\u0026gt;private_data; 16 17\tlockdep_assert_irqs_enabled(); 18 19\tif (unlikely(percpu_counter_compare(\u0026amp;ep-\u0026gt;user-\u0026gt;epoll_watches, 20\tmax_user_watches) \u0026gt;= 0)) 21\treturn -ENOSPC; 22\tpercpu_counter_inc(\u0026amp;ep-\u0026gt;user-\u0026gt;epoll_watches); 23 24\tif (!(epi = kmem_cache_zalloc(epi_cache, GFP_KERNEL))) { 25\tpercpu_counter_dec(\u0026amp;ep-\u0026gt;user-\u0026gt;epoll_watches); 26\treturn -ENOMEM; 27\t} 28 29\t/* Item initialization follow here ... */ 30\tINIT_LIST_HEAD(\u0026amp;epi-\u0026gt;rdllink); 31\tepi-\u0026gt;ep = ep; 32\tep_set_ffd(\u0026amp;epi-\u0026gt;ffd, tfile, fd);\t// 设置fd到epitem中 33\tepi-\u0026gt;event = *event; 34\tepi-\u0026gt;next = EP_UNACTIVE_PTR; 35 36\tif (tep) 37\tmutex_lock_nested(\u0026amp;tep-\u0026gt;mtx, 1); 38\t/* Add the current item to the list of active epoll hook for this file */ 39\tif (unlikely(attach_epitem(tfile, epi) \u0026lt; 0)) { 40\tif (tep) 41\tmutex_unlock(\u0026amp;tep-\u0026gt;mtx); 42\tkmem_cache_free(epi_cache, epi); 43\tpercpu_counter_dec(\u0026amp;ep-\u0026gt;user-\u0026gt;epoll_watches); 44\treturn -ENOMEM; 45\t} 46 47\tif (full_check \u0026amp;\u0026amp; !tep) 48\tlist_file(tfile); 49 50\t/* 51\t* Add the current item to the RB tree. All RB tree operations are 52\t* protected by \u0026#34;mtx\u0026#34;, and ep_insert() is called with \u0026#34;mtx\u0026#34; held. 53\t*/ 54\t// epitem插入到红黑树中 55\tep_rbtree_insert(ep, epi); 56\tif (tep) 57\tmutex_unlock(\u0026amp;tep-\u0026gt;mtx); 58 59\t/* now check if we\u0026#39;ve created too many backpaths */ 60\tif (unlikely(full_check \u0026amp;\u0026amp; reverse_path_check())) { 61\tep_remove(ep, epi); 62\treturn -EINVAL; 63\t} 64 65\tif (epi-\u0026gt;event.events \u0026amp; EPOLLWAKEUP) { 66\terror = ep_create_wakeup_source(epi); 67\tif (error) { 68\tep_remove(ep, epi); 69\treturn error; 70\t} 71\t} 72 73\t/* Initialize the poll table using the queue callback */ 74\tepq.epi = epi; 75\t// 将ep_ptable_queue_proc设置为_qproc，加入等待队列的操作函数 76\tinit_poll_funcptr(\u0026amp;epq.pt, ep_ptable_queue_proc); 77 78\t/* 79\t* Attach the item to the poll hooks and get current event bits. 80\t* We can safely use the file* here because its usage count has 81\t* been increased by the caller of this function. Note that after 82\t* this operation completes, the poll callback can start hitting 83\t* the new item. 84\t*/ 85\trevents = ep_item_poll(epi, \u0026amp;epq.pt, 1); 86 87\t/* 88\t* We have to check if something went wrong during the poll wait queue 89\t* install process. Namely an allocation for a wait queue failed due 90\t* high memory pressure. 91\t*/ 92\tif (unlikely(!epq.epi)) { 93\tep_remove(ep, epi); 94\treturn -ENOMEM; 95\t} 96 97\t/* We have to drop the new item inside our item list to keep track of it */ 98\twrite_lock_irq(\u0026amp;ep-\u0026gt;lock); 99 100\t/* record NAPI ID of new item if present */ 101\tep_set_busy_poll_napi_id(epi); 102 103\t/* If the file is already \u0026#34;ready\u0026#34; we drop it inside the ready list */ 104\tif (revents \u0026amp;\u0026amp; !ep_is_linked(epi)) { 105\tlist_add_tail(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist); 106\tep_pm_stay_awake(epi); 107 108\t/* Notify waiting tasks that events are available */ 109\tif (waitqueue_active(\u0026amp;ep-\u0026gt;wq)) 110\twake_up(\u0026amp;ep-\u0026gt;wq); 111\tif (waitqueue_active(\u0026amp;ep-\u0026gt;poll_wait)) 112\tpwake++; 113\t} 114 115\twrite_unlock_irq(\u0026amp;ep-\u0026gt;lock); 116 117\t/* We have to call this outside the lock */ 118\tif (pwake) 119\tep_poll_safewake(ep, NULL); 120 121\treturn 0; 122} 1) init_poll_funcptr 初始化插入等待队列的操作函数指针 # 将_qproc设置为上面的ep_ptable_queue_proc 记住下面的操作，后面插入等待队列会使用 1// include/linux/poll.h 2static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc) 3{ 4\tpt-\u0026gt;_qproc = qproc; 5\tpt-\u0026gt;_key = ~(__poll_t)0; /* all events enabled */ 6} 2) ep_rbtree_insert 插入epitem # 1// fs/eventpoll.c 2static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi) 3{ 4\tint kcmp; 5\tstruct rb_node **p = \u0026amp;ep-\u0026gt;rbr.rb_root.rb_node, *parent = NULL; 6\tstruct epitem *epic; 7\tbool leftmost = true; 8 9\twhile (*p) { 10\tparent = *p; 11\tepic = rb_entry(parent, struct epitem, rbn); 12\t// 使用fd的比较进行红黑树的查找 13\tkcmp = ep_cmp_ffd(\u0026amp;epi-\u0026gt;ffd, \u0026amp;epic-\u0026gt;ffd); 14\tif (kcmp \u0026gt; 0) { 15\tp = \u0026amp;parent-\u0026gt;rb_right; 16\tleftmost = false; 17\t} else 18\tp = \u0026amp;parent-\u0026gt;rb_left; 19\t} 20\t// 将epi的节点插入到红黑树中 21\trb_link_node(\u0026amp;epi-\u0026gt;rbn, parent, p); 22\t// 着色 23\trb_insert_color_cached(\u0026amp;epi-\u0026gt;rbn, \u0026amp;ep-\u0026gt;rbr, leftmost); 24} 3) ep_item_poll 插入epoll的回调到socket上 # 1// fs/eventpoll.c 2/* 3 * Differs from ep_eventpoll_poll() in that internal callers already have 4 * the ep-\u0026gt;mtx so we need to start from depth=1, such that mutex_lock_nested() 5 * is correctly annotated. 6 */ 7static __poll_t ep_item_poll(const struct epitem *epi, poll_table *pt, 8\tint depth) 9{ 10\tstruct file *file = epi-\u0026gt;ffd.file; 11\t__poll_t res; 12 13\tpt-\u0026gt;_key = epi-\u0026gt;event.events; 14\tif (!is_file_epoll(file)) 15\tres = vfs_poll(file, pt); 16\telse 17\tres = __ep_eventpoll_poll(file, pt, depth); 18\treturn res \u0026amp; epi-\u0026gt;event.events; 19} 插入socket的情况调用vfs_poll 这里对应socket的poll调用 1// include/linux/poll.h 2static inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt) 3{ 4\tif (unlikely(!file-\u0026gt;f_op-\u0026gt;poll)) 5\treturn DEFAULT_POLLMASK; 6\treturn file-\u0026gt;f_op-\u0026gt;poll(file, pt); 7} 4) socket的poll处理 # (1) 先看poll的定义位置 # 1// net/socket.c 2/* 3 *\tSocket files have a set of \u0026#39;special\u0026#39; operations as well as the generic file ones. These don\u0026#39;t appear 4 *\tin the operation structures but are done directly via the socketcall() multiplexor. 5 */ 6static const struct file_operations socket_file_ops = { 7\t.owner =\tTHIS_MODULE, 8\t.llseek =\tno_llseek, 9\t.read_iter =\tsock_read_iter, 10\t.write_iter =\tsock_write_iter, 11\t.poll =\tsock_poll, 12\t.unlocked_ioctl = sock_ioctl, 13#ifdef CONFIG_COMPAT 14\t.compat_ioctl = compat_sock_ioctl, 15#endif 16\t.mmap =\tsock_mmap, 17\t.release =\tsock_close, 18\t.fasync =\tsock_fasync, 19\t.sendpage =\tsock_sendpage, 20\t.splice_write = generic_splice_sendpage, 21\t.splice_read =\tsock_splice_read, 22\t.show_fdinfo =\tsock_show_fdinfo, 23}; (2) sock_poll # 这里又调用到对应的协议的poll函数 1/* No kernel lock held - perfect */ 2static __poll_t sock_poll(struct file *file, poll_table *wait) 3{ 4\tstruct socket *sock = file-\u0026gt;private_data; 5\t__poll_t events = poll_requested_events(wait), flag = 0; 6 7\tif (!sock-\u0026gt;ops-\u0026gt;poll) 8\treturn 0; 9 10\tif (sk_can_busy_loop(sock-\u0026gt;sk)) { 11\t/* poll once if requested by the syscall */ 12\tif (events \u0026amp; POLL_BUSY_LOOP) 13\tsk_busy_loop(sock-\u0026gt;sk, 1); 14 15\t/* if this socket can poll_ll, tell the system call */ 16\tflag = POLL_BUSY_LOOP; 17\t} 18 19\treturn sock-\u0026gt;ops-\u0026gt;poll(file, sock, wait) | flag; 20} unix套接字的udp操作 # 定义 1static const struct proto_ops unix_dgram_ops = { 2\t.family =\tPF_UNIX, 3\t.owner =\tTHIS_MODULE, 4\t.release =\tunix_release, 5\t.bind =\tunix_bind, 6\t.connect =\tunix_dgram_connect, 7\t.socketpair =\tunix_socketpair, 8\t.accept =\tsock_no_accept, 9\t.getname =\tunix_getname, 10\t.poll =\tunix_dgram_poll, 11\t.ioctl =\tunix_ioctl, 12#ifdef CONFIG_COMPAT 13\t.compat_ioctl =\tunix_compat_ioctl, 14#endif 15\t.listen =\tsock_no_listen, 16\t.shutdown =\tunix_shutdown, 17\t.sendmsg =\tunix_dgram_sendmsg, 18\t.read_sock =\tunix_read_sock, 19\t.recvmsg =\tunix_dgram_recvmsg, 20\t.mmap =\tsock_no_mmap, 21\t.sendpage =\tsock_no_sendpage, 22\t.set_peek_off =\tunix_set_peek_off, 23\t.show_fdinfo =\tunix_show_fdinfo, 24}; unix_dgram_poll 1static __poll_t unix_dgram_poll(struct file *file, struct socket *sock, 2\tpoll_table *wait) 3{ 4\tstruct sock *sk = sock-\u0026gt;sk, *other; 5\tunsigned int writable; 6\t__poll_t mask; 7 8\t// 这里插入到等待队列 9\tsock_poll_wait(file, sock, wait); 10\tmask = 0; 11 12\t/* exceptional events? */ 13\tif (sk-\u0026gt;sk_err || !skb_queue_empty_lockless(\u0026amp;sk-\u0026gt;sk_error_queue)) 14\tmask |= EPOLLERR | 15\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? EPOLLPRI : 0); 16 17\tif (sk-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN) 18\tmask |= EPOLLRDHUP | EPOLLIN | EPOLLRDNORM; 19\tif (sk-\u0026gt;sk_shutdown == SHUTDOWN_MASK) 20\tmask |= EPOLLHUP; 21 22\t/* readable? */ 23\tif (!skb_queue_empty_lockless(\u0026amp;sk-\u0026gt;sk_receive_queue)) 24\tmask |= EPOLLIN | EPOLLRDNORM; 25\tif (sk_is_readable(sk)) 26\tmask |= EPOLLIN | EPOLLRDNORM; 27 28\t/* Connection-based need to check for termination and startup */ 29\tif (sk-\u0026gt;sk_type == SOCK_SEQPACKET) { 30\tif (sk-\u0026gt;sk_state == TCP_CLOSE) 31\tmask |= EPOLLHUP; 32\t/* connection hasn\u0026#39;t started yet? */ 33\tif (sk-\u0026gt;sk_state == TCP_SYN_SENT) 34\treturn mask; 35\t} 36 37\t/* No write status requested, avoid expensive OUT tests. */ 38\tif (!(poll_requested_events(wait) \u0026amp; (EPOLLWRBAND|EPOLLWRNORM|EPOLLOUT))) 39\treturn mask; 40 41\twritable = unix_writable(sk); 42\tif (writable) { 43\tunix_state_lock(sk); 44 45\tother = unix_peer(sk); 46\tif (other \u0026amp;\u0026amp; unix_peer(other) != sk \u0026amp;\u0026amp; 47\tunix_recvq_full_lockless(other) \u0026amp;\u0026amp; 48\tunix_dgram_peer_wake_me(sk, other)) 49\twritable = 0; 50 51\tunix_state_unlock(sk); 52\t} 53 54\tif (writable) 55\tmask |= EPOLLOUT | EPOLLWRNORM | EPOLLWRBAND; 56\telse 57\tsk_set_bit(SOCKWQ_ASYNC_NOSPACE, sk); 58 59\treturn mask; 60} sock_poll_wait中取到等待队列的头部，调用poll_wait 1// include/net/sock.h 2/** 3 * sock_poll_wait - place memory barrier behind the poll_wait call. 4 * @filp: file 5 * @sock: socket to wait on 6 * @p: poll_table 7 * 8 * See the comments in the wq_has_sleeper function. 9 */ 10static inline void sock_poll_wait(struct file *filp, struct socket *sock, 11\tpoll_table *p) 12{ 13\tif (!poll_does_not_wait(p)) { 14\tpoll_wait(filp, \u0026amp;sock-\u0026gt;wq.wait, p); 15\t/* We need to be sure we are in sync with the 16\t* socket flags modification. 17\t* 18\t* This memory barrier is paired in the wq_has_sleeper. 19\t*/ 20\tsmp_mb(); 21\t} 22} poll_wait拿到等待队列的头部后，调用_qproc将p插入进去 这里的_qproc其实是上面epoll中设置的ep_ptable_queue_proc 1// include/linux/poll.h 2static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p) 3{ 4\tif (p \u0026amp;\u0026amp; p-\u0026gt;_qproc \u0026amp;\u0026amp; wait_address) 5\tp-\u0026gt;_qproc(filp, wait_address, p); 6} ep_ptable_queue_proc，插入ep_poll_callback到socket的等待队列中 1// fs/eventpoll.c 2/* 3 * This is the callback that is used to add our wait queue to the 4 * target file wakeup lists. 5 */ 6static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead, 7\tpoll_table *pt) 8{ 9\tstruct ep_pqueue *epq = container_of(pt, struct ep_pqueue, pt); 10\tstruct epitem *epi = epq-\u0026gt;epi; 11\tstruct eppoll_entry *pwq; 12 13\tif (unlikely(!epi))\t// an earlier allocation has failed 14\treturn; 15 16\tpwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL); 17\tif (unlikely(!pwq)) { 18\tepq-\u0026gt;epi = NULL; 19\treturn; 20\t} 21 22\tinit_waitqueue_func_entry(\u0026amp;pwq-\u0026gt;wait, ep_poll_callback); 23\tpwq-\u0026gt;whead = whead; 24\tpwq-\u0026gt;base = epi; 25\t// 这里插入到等待队列头部，插入的是ep_poll_callback函数 26\tif (epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE) 27\tadd_wait_queue_exclusive(whead, \u0026amp;pwq-\u0026gt;wait); 28\telse 29\tadd_wait_queue(whead, \u0026amp;pwq-\u0026gt;wait); 30\tpwq-\u0026gt;next = epi-\u0026gt;pwqlist; 31\tepi-\u0026gt;pwqlist = pwq; 32} ep_poll_callback函数，当回调调用时，将对应的epitem插入到epoll主结构体的链表尾部，通知唤醒 1// fs/eventpoll.c 2/* 3 * This is the callback that is passed to the wait queue wakeup 4 * mechanism. It is called by the stored file descriptors when they 5 * have events to report. 6 * 7 * This callback takes a read lock in order not to contend with concurrent 8 * events from another file descriptor, thus all modifications to -\u0026gt;rdllist 9 * or -\u0026gt;ovflist are lockless. Read lock is paired with the write lock from 10 * ep_scan_ready_list(), which stops all list modifications and guarantees 11 * that lists state is seen correctly. 12 * 13 * Another thing worth to mention is that ep_poll_callback() can be called 14 * concurrently for the same @epi from different CPUs if poll table was inited 15 * with several wait queues entries. Plural wakeup from different CPUs of a 16 * single wait queue is serialized by wq.lock, but the case when multiple wait 17 * queues are used should be detected accordingly. This is detected using 18 * cmpxchg() operation. 19 */ 20static int ep_poll_callback(wait_queue_entry_t *wait, unsigned mode, int sync, void *key) 21{ 22\tint pwake = 0; 23\tstruct epitem *epi = ep_item_from_wait(wait); 24\tstruct eventpoll *ep = epi-\u0026gt;ep; 25\t__poll_t pollflags = key_to_poll(key); 26\tunsigned long flags; 27\tint ewake = 0; 28 29\tread_lock_irqsave(\u0026amp;ep-\u0026gt;lock, flags); 30 31\tep_set_busy_poll_napi_id(epi); 32 33\t/* 34\t* If the event mask does not contain any poll(2) event, we consider the 35\t* descriptor to be disabled. This condition is likely the effect of the 36\t* EPOLLONESHOT bit that disables the descriptor when an event is received, 37\t* until the next EPOLL_CTL_MOD will be issued. 38\t*/ 39\tif (!(epi-\u0026gt;event.events \u0026amp; ~EP_PRIVATE_BITS)) 40\tgoto out_unlock; 41 42\t/* 43\t* Check the events coming with the callback. At this stage, not 44\t* every device reports the events in the \u0026#34;key\u0026#34; parameter of the 45\t* callback. We need to be able to handle both cases here, hence the 46\t* test for \u0026#34;key\u0026#34; != NULL before the event match test. 47\t*/ 48\tif (pollflags \u0026amp;\u0026amp; !(pollflags \u0026amp; epi-\u0026gt;event.events)) 49\tgoto out_unlock; 50 51\t/* 52\t* If we are transferring events to userspace, we can hold no locks 53\t* (because we\u0026#39;re accessing user memory, and because of linux f_op-\u0026gt;poll() 54\t* semantics). All the events that happen during that period of time are 55\t* chained in ep-\u0026gt;ovflist and requeued later on. 56\t*/ 57\t// 这里插入epi到eventpoll的就绪队列 58\tif (READ_ONCE(ep-\u0026gt;ovflist) != EP_UNACTIVE_PTR) { 59\tif (chain_epi_lockless(epi)) 60\tep_pm_stay_awake_rcu(epi); 61\t} else if (!ep_is_linked(epi)) { 62\t/* In the usual case, add event to ready list. */ 63\tif (list_add_tail_lockless(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist)) 64\tep_pm_stay_awake_rcu(epi); 65\t} 66 67\t/* 68\t* Wake up ( if active ) both the eventpoll wait list and the -\u0026gt;poll() 69\t* wait list. 70\t*/ 71\tif (waitqueue_active(\u0026amp;ep-\u0026gt;wq)) { 72\tif ((epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE) \u0026amp;\u0026amp; 73\t!(pollflags \u0026amp; POLLFREE)) { 74\tswitch (pollflags \u0026amp; EPOLLINOUT_BITS) { 75\tcase EPOLLIN: 76\tif (epi-\u0026gt;event.events \u0026amp; EPOLLIN) 77\tewake = 1; 78\tbreak; 79\tcase EPOLLOUT: 80\tif (epi-\u0026gt;event.events \u0026amp; EPOLLOUT) 81\tewake = 1; 82\tbreak; 83\tcase 0: 84\tewake = 1; 85\tbreak; 86\t} 87\t} 88\twake_up(\u0026amp;ep-\u0026gt;wq); 89\t} 90\tif (waitqueue_active(\u0026amp;ep-\u0026gt;poll_wait)) 91\tpwake++; 92 93out_unlock: 94\tread_unlock_irqrestore(\u0026amp;ep-\u0026gt;lock, flags); 95 96\t/* We have to call this outside the lock */ 97\tif (pwake) 98\tep_poll_safewake(ep, epi); 99 100\tif (!(epi-\u0026gt;event.events \u0026amp; EPOLLEXCLUSIVE)) 101\tewake = 1; 102 103\tif (pollflags \u0026amp; POLLFREE) { 104\t/* 105\t* If we race with ep_remove_wait_queue() it can miss 106\t* -\u0026gt;whead = NULL and do another remove_wait_queue() after 107\t* us, so we can\u0026#39;t use __remove_wait_queue(). 108\t*/ 109\tlist_del_init(\u0026amp;wait-\u0026gt;entry); 110\t/* 111\t* -\u0026gt;whead != NULL protects us from the race with ep_free() 112\t* or ep_remove(), ep_remove_wait_queue() takes whead-\u0026gt;lock 113\t* held by the caller. Once we nullify it, nothing protects 114\t* ep/epi or even wait. 115\t*/ 116\tsmp_store_release(\u0026amp;ep_pwq_from_wait(wait)-\u0026gt;whead, NULL); 117\t} 118 119\treturn ewake; 120} 总结 # 将socket插入到epoll中最中会将epoll的处理函数插入到socket的等待队列中，socket来消息后会调用 五、epoll_wait # 1. 主体逻辑 # 从系统定义开始 1// fs/eventpoll.c 2SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, 3\tint, maxevents, int, timeout) 4{ 5\tstruct timespec64 to; 6 7\treturn do_epoll_wait(epfd, events, maxevents, 8\tep_timeout_to_timespec(\u0026amp;to, timeout)); 9} 10 11// fs/eventpoll.c 12/* 13 * Implement the event wait interface for the eventpoll file. It is the kernel 14 * part of the user space epoll_wait(2). 15 */ 16static int do_epoll_wait(int epfd, struct epoll_event __user *events, 17\tint maxevents, struct timespec64 *to) 18{ 19\tint error; 20\tstruct fd f; 21\tstruct eventpoll *ep; 22 23\t/* The maximum number of event must be greater than zero */ 24\tif (maxevents \u0026lt;= 0 || maxevents \u0026gt; EP_MAX_EVENTS) 25\treturn -EINVAL; 26 27\t/* Verify that the area passed by the user is writeable */ 28\tif (!access_ok(events, maxevents * sizeof(struct epoll_event))) 29\treturn -EFAULT; 30 31\t/* Get the \u0026#34;struct file *\u0026#34; for the eventpoll file */ 32\tf = fdget(epfd); 33\tif (!f.file) 34\treturn -EBADF; 35 36\t/* 37\t* We have to check that the file structure underneath the fd 38\t* the user passed to us _is_ an eventpoll file. 39\t*/ 40\terror = -EINVAL; 41\tif (!is_file_epoll(f.file)) 42\tgoto error_fput; 43 44\t/* 45\t* At this point it is safe to assume that the \u0026#34;private_data\u0026#34; contains 46\t* our own data structure. 47\t*/ 48\tep = f.file-\u0026gt;private_data; 49 50\t/* Time to fish for events ... */ 51\terror = ep_poll(ep, events, maxevents, to); 52 53error_fput: 54\tfdput(f); 55\treturn error; 56} 主要逻辑在ep_poll 1// fs/eventpoll.c 2/** 3 * ep_poll - Retrieves ready events, and delivers them to the caller-supplied 4 * event buffer. 5 * 6 * @ep: Pointer to the eventpoll context. 7 * @events: Pointer to the userspace buffer where the ready events should be 8 * stored. 9 * @maxevents: Size (in terms of number of events) of the caller event buffer. 10 * @timeout: Maximum timeout for the ready events fetch operation, in 11 * timespec. If the timeout is zero, the function will not block, 12 * while if the @timeout ptr is NULL, the function will block 13 * until at least one event has been retrieved (or an error 14 * occurred). 15 * 16 * Return: the number of ready events which have been fetched, or an 17 * error code, in case of error. 18 */ 19static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, 20\tint maxevents, struct timespec64 *timeout) 21{ 22\tint res, eavail, timed_out = 0; 23\tu64 slack = 0; 24\twait_queue_entry_t wait; 25\tktime_t expires, *to = NULL; 26 27\tlockdep_assert_irqs_enabled(); 28 29\tif (timeout \u0026amp;\u0026amp; (timeout-\u0026gt;tv_sec | timeout-\u0026gt;tv_nsec)) { 30\tslack = select_estimate_accuracy(timeout); 31\tto = \u0026amp;expires; 32\t*to = timespec64_to_ktime(*timeout); 33\t} else if (timeout) { 34\t/* 35\t* Avoid the unnecessary trip to the wait queue loop, if the 36\t* caller specified a non blocking operation. 37\t*/ 38\ttimed_out = 1; 39\t} 40 41\t/* 42\t* This call is racy: We may or may not see events that are being added 43\t* to the ready list under the lock (e.g., in IRQ callbacks). For cases 44\t* with a non-zero timeout, this thread will check the ready list under 45\t* lock and will add to the wait queue. For cases with a zero 46\t* timeout, the user by definition should not care and will have to 47\t* recheck again. 48\t*/ 49\t// 获取是否有事件 50\teavail = ep_events_available(ep); 51 52\twhile (1) { 53\tif (eavail) { 54\t// 有事件就把事件发给用户空间 55\t/* 56\t* Try to transfer events to user space. In case we get 57\t* 0 events and there\u0026#39;s still timeout left over, we go 58\t* trying again in search of more luck. 59\t*/ 60\tres = ep_send_events(ep, events, maxevents); 61\tif (res) 62\treturn res; 63\t} 64 65\t// 超时时间处理 66\tif (timed_out) 67\treturn 0; 68 69\teavail = ep_busy_loop(ep, timed_out); 70\tif (eavail) 71\tcontinue; 72 73\tif (signal_pending(current)) 74\treturn -EINTR; 75 76\t/* 77\t* Internally init_wait() uses autoremove_wake_function(), 78\t* thus wait entry is removed from the wait queue on each 79\t* wakeup. Why it is important? In case of several waiters 80\t* each new wakeup will hit the next waiter, giving it the 81\t* chance to harvest new event. Otherwise wakeup can be 82\t* lost. This is also good performance-wise, because on 83\t* normal wakeup path no need to call __remove_wait_queue() 84\t* explicitly, thus ep-\u0026gt;lock is not taken, which halts the 85\t* event delivery. 86\t*/ 87\tinit_wait(\u0026amp;wait); 88 89\twrite_lock_irq(\u0026amp;ep-\u0026gt;lock); 90\t/* 91\t* Barrierless variant, waitqueue_active() is called under 92\t* the same lock on wakeup ep_poll_callback() side, so it 93\t* is safe to avoid an explicit barrier. 94\t*/ 95\t__set_current_state(TASK_INTERRUPTIBLE); 96 97\t/* 98\t* Do the final check under the lock. ep_scan_ready_list() 99\t* plays with two lists (-\u0026gt;rdllist and -\u0026gt;ovflist) and there 100\t* is always a race when both lists are empty for short 101\t* period of time although events are pending, so lock is 102\t* important. 103\t*/ 104\t// 最后检查一次是否有事件，没有事件就把自己加入到wq中 105\teavail = ep_events_available(ep); 106\tif (!eavail) 107\t__add_wait_queue_exclusive(\u0026amp;ep-\u0026gt;wq, \u0026amp;wait); 108 109\twrite_unlock_irq(\u0026amp;ep-\u0026gt;lock); 110 111\t// 这里进入睡眠，带超时时间的睡眠 112\tif (!eavail) 113\ttimed_out = !schedule_hrtimeout_range(to, slack, 114\tHRTIMER_MODE_ABS); 115\t// 这里唤醒后，设置进程状态为running 116\t__set_current_state(TASK_RUNNING); 117 118\t/* 119\t* We were woken up, thus go and try to harvest some events. 120\t* If timed out and still on the wait queue, recheck eavail 121\t* carefully under lock, below. 122\t*/ 123\teavail = 1; 124 125\t// 等待队列不为空，就从等待队列移除等待项 126\tif (!list_empty_careful(\u0026amp;wait.entry)) { 127\twrite_lock_irq(\u0026amp;ep-\u0026gt;lock); 128\t/* 129\t* If the thread timed out and is not on the wait queue, 130\t* it means that the thread was woken up after its 131\t* timeout expired before it could reacquire the lock. 132\t* Thus, when wait.entry is empty, it needs to harvest 133\t* events. 134\t*/ 135\tif (timed_out) 136\teavail = list_empty(\u0026amp;wait.entry); 137\t__remove_wait_queue(\u0026amp;ep-\u0026gt;wq, \u0026amp;wait); 138\twrite_unlock_irq(\u0026amp;ep-\u0026gt;lock); 139\t} 140\t} 141} ep_events_available主要检查rdllist是否为空 1// fs/eventpoll.c 2/** 3 * ep_events_available - Checks if ready events might be available. 4 * 5 * @ep: Pointer to the eventpoll context. 6 * 7 * Return: a value different than %zero if ready events are available, 8 * or %zero otherwise. 9 */ 10static inline int ep_events_available(struct eventpoll *ep) 11{ 12\treturn !list_empty_careful(\u0026amp;ep-\u0026gt;rdllist) || 13\tREAD_ONCE(ep-\u0026gt;ovflist) != EP_UNACTIVE_PTR; 14} 水平触发和边沿触发主要逻辑在ep_send_events 水平触发就是有事件还是加回就绪队列，同时返回。下一次epoll_wait会检查就绪队列被加回的这个事件是否读完了，没读完继续返回，读完了就移除 1static int ep_send_events(struct eventpoll *ep, 2\tstruct epoll_event __user *events, int maxevents) 3{ 4\tstruct epitem *epi, *tmp; 5\tLIST_HEAD(txlist); 6\tpoll_table pt; 7\tint res = 0; 8 9\t/* 10\t* Always short-circuit for fatal signals to allow threads to make a 11\t* timely exit without the chance of finding more events available and 12\t* fetching repeatedly. 13\t*/ 14\tif (fatal_signal_pending(current)) 15\treturn -EINTR; 16 17\tinit_poll_funcptr(\u0026amp;pt, NULL); 18 19\tmutex_lock(\u0026amp;ep-\u0026gt;mtx); 20\t// 把ep-\u0026gt;rdlist全部转移到txlist中，清空rdlist 21\tep_start_scan(ep, \u0026amp;txlist); 22 23\t// 遍历txlist链表，将所有就绪队列事件取出检查，取出的元素为epi 24\t/* 25\t* We can loop without lock because we are passed a task private list. 26\t* Items cannot vanish during the loop we are holding ep-\u0026gt;mtx. 27\t*/ 28\tlist_for_each_entry_safe(epi, tmp, \u0026amp;txlist, rdllink) { 29\tstruct wakeup_source *ws; 30\t__poll_t revents; 31 32\tif (res \u0026gt;= maxevents) 33\tbreak; 34 35\t/* 36\t* Activate ep-\u0026gt;ws before deactivating epi-\u0026gt;ws to prevent 37\t* triggering auto-suspend here (in case we reactive epi-\u0026gt;ws 38\t* below). 39\t* 40\t* This could be rearranged to delay the deactivation of epi-\u0026gt;ws 41\t* instead, but then epi-\u0026gt;ws would temporarily be out of sync 42\t* with ep_is_linked(). 43\t*/ 44\tws = ep_wakeup_source(epi); 45\tif (ws) { 46\tif (ws-\u0026gt;active) 47\t__pm_stay_awake(ep-\u0026gt;ws); 48\t__pm_relax(ws); 49\t} 50 51\t// 将epi从链表中移除 52\tlist_del_init(\u0026amp;epi-\u0026gt;rdllink); 53 54\t// 检查一下epi是否有事件，没事件就跳过 55\t/* 56\t* If the event mask intersect the caller-requested one, 57\t* deliver the event to userspace. Again, we are holding ep-\u0026gt;mtx, 58\t* so no operations coming from userspace can change the item. 59\t*/ 60\trevents = ep_item_poll(epi, \u0026amp;pt, 1); 61\tif (!revents) 62\tcontinue; 63 64\t// 有事件将event拷贝到用户空间中，没拷贝成功就加回txlist末尾，退出循环 65\tevents = epoll_put_uevent(revents, epi-\u0026gt;event.data, events); 66\tif (!events) { 67\tlist_add(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;txlist); 68\tep_pm_stay_awake(epi); 69\tif (!res) 70\tres = -EFAULT; 71\tbreak; 72\t} 73\tres++; 74\tif (epi-\u0026gt;event.events \u0026amp; EPOLLONESHOT) 75\tepi-\u0026gt;event.events \u0026amp;= EP_PRIVATE_BITS; 76\telse if (!(epi-\u0026gt;event.events \u0026amp; EPOLLET)) { 77\t// 关键点，如果不是边沿触发也就是水平触发，会把epi加回ep-\u0026gt;rdllist 78\t// 下次调用epoll_wait时，会直接有就绪队列，上面会判断是否有事件 79\t// 如果读完了，就绪队列中会删除此epi；没有读完就会继续返回这个epi 80\t/* 81\t* If this file has been added with Level 82\t* Trigger mode, we need to insert back inside 83\t* the ready list, so that the next call to 84\t* epoll_wait() will check again the events 85\t* availability. At this point, no one can insert 86\t* into ep-\u0026gt;rdllist besides us. The epoll_ctl() 87\t* callers are locked out by 88\t* ep_scan_ready_list() holding \u0026#34;mtx\u0026#34; and the 89\t* poll callback will queue them in ep-\u0026gt;ovflist. 90\t*/ 91\tlist_add_tail(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist); 92\tep_pm_stay_awake(epi); 93\t} 94\t} 95\t// 到这里有三个情况 96\t// 一个是用户空间给进来的范围写满了，一个是中间拷贝用户空间出错了，还有就是正常读完了 97\t// 检查txlist，把txlist剩余的放回ep-\u0026gt;rdllist 98\tep_done_scan(ep, \u0026amp;txlist); 99\tmutex_unlock(\u0026amp;ep-\u0026gt;mtx); 100 101\treturn res; 102} ep_done_scan 1// fs/eventpoll.c 2static void ep_done_scan(struct eventpoll *ep, 3\tstruct list_head *txlist) 4{ 5\tstruct epitem *epi, *nepi; 6 7\twrite_lock_irq(\u0026amp;ep-\u0026gt;lock); 8\t// 这里遍历一下当把事件给到用户空间过程中来的事件，放到ep-\u0026gt;rdllist中 9\t/* 10\t* During the time we spent inside the \u0026#34;sproc\u0026#34; callback, some 11\t* other events might have been queued by the poll callback. 12\t* We re-insert them inside the main ready-list here. 13\t*/ 14\tfor (nepi = READ_ONCE(ep-\u0026gt;ovflist); (epi = nepi) != NULL; 15\tnepi = epi-\u0026gt;next, epi-\u0026gt;next = EP_UNACTIVE_PTR) { 16\t/* 17\t* We need to check if the item is already in the list. 18\t* During the \u0026#34;sproc\u0026#34; callback execution time, items are 19\t* queued into -\u0026gt;ovflist but the \u0026#34;txlist\u0026#34; might already 20\t* contain them, and the list_splice() below takes care of them. 21\t*/ 22\tif (!ep_is_linked(epi)) { 23\t/* 24\t* -\u0026gt;ovflist is LIFO, so we have to reverse it in order 25\t* to keep in FIFO. 26\t*/ 27\tlist_add(\u0026amp;epi-\u0026gt;rdllink, \u0026amp;ep-\u0026gt;rdllist); 28\tep_pm_stay_awake(epi); 29\t} 30\t} 31\t/* 32\t* We need to set back ep-\u0026gt;ovflist to EP_UNACTIVE_PTR, so that after 33\t* releasing the lock, events will be queued in the normal way inside 34\t* ep-\u0026gt;rdllist. 35\t*/ 36\tWRITE_ONCE(ep-\u0026gt;ovflist, EP_UNACTIVE_PTR); 37 38\t/* 39\t* Quickly re-inject items left on \u0026#34;txlist\u0026#34;. 40\t*/ 41\tlist_splice(txlist, \u0026amp;ep-\u0026gt;rdllist); 42\t__pm_relax(ep-\u0026gt;ws); 43 44\t// 如果就绪队列还有事件，继续唤醒等待的进程（多进程同时等待同一个epoll的场景） 45\tif (!list_empty(\u0026amp;ep-\u0026gt;rdllist)) { 46\tif (waitqueue_active(\u0026amp;ep-\u0026gt;wq)) 47\twake_up(\u0026amp;ep-\u0026gt;wq); 48\t} 49 50\twrite_unlock_irq(\u0026amp;ep-\u0026gt;lock); 51} "},{"id":47,"href":"/docs/linux/linux-kernel/net/ipv4/ipv4/","title":"Ipv4","section":"ipv4/ ipv4的处理部分","content":" 一、总述 # 1. 关键结构体关系 # @startuml xxx class socket { struct sock *sk; } class sock {} class inet_sock implements sock { struct sock sk; } note left of inet_sock inet_sock是在sock基础上做了一些拓展 创建时申请的是inet_sock但是使用sock结构体指针赋值给socket 在inet里面的操作做强转使用 end note class inet_connection_sock implements inet_sock { struct inet_sock icsk_inet; } note left of inet_connection_sock inet_connection_sock是拓展了inet_sock 同样复用sock的指针 end note socket \u0026lt;|-- sock @enduml 2.1. inet_sock # 1// include/net/inet_sock.h 2/** struct inet_sock - representation of INET sockets 3 * 4 * @sk - ancestor class 5 * @pinet6 - pointer to IPv6 control block 6 * @inet_daddr - Foreign IPv4 addr 7 * @inet_rcv_saddr - Bound local IPv4 addr 8 * @inet_dport - Destination port 9 * @inet_num - Local port 10 * @inet_saddr - Sending source 11 * @uc_ttl - Unicast TTL 12 * @inet_sport - Source port 13 * @inet_id - ID counter for DF pkts 14 * @tos - TOS 15 * @mc_ttl - Multicasting TTL 16 * @is_icsk - is this an inet_connection_sock? 17 * @uc_index - Unicast outgoing device index 18 * @mc_index - Multicast device index 19 * @mc_list - Group array 20 * @cork - info to build ip hdr on each ip frag while socket is corked 21 */ 22struct inet_sock { 23\t/* sk and pinet6 has to be the first two members of inet_sock */ 24\tstruct sock\tsk; 25#if IS_ENABLED(CONFIG_IPV6) 26\tstruct ipv6_pinfo\t*pinet6; 27#endif 28\t/* Socket demultiplex comparisons on incoming packets. */ 29#define inet_daddr\tsk.__sk_common.skc_daddr 30#define inet_rcv_saddr\tsk.__sk_common.skc_rcv_saddr 31#define inet_dport\tsk.__sk_common.skc_dport 32#define inet_num\tsk.__sk_common.skc_num 33 34\t__be32\tinet_saddr; 35\t__s16\tuc_ttl; 36\t__u16\tcmsg_flags; 37\tstruct ip_options_rcu __rcu\t*inet_opt; 38\t__be16\tinet_sport; 39\t__u16\tinet_id; 40 41\t__u8\ttos; 42\t__u8\tmin_ttl; 43\t__u8\tmc_ttl; 44\t__u8\tpmtudisc; 45\t__u8\trecverr:1, 46\tis_icsk:1, 47\tfreebind:1, 48\thdrincl:1, 49\tmc_loop:1, 50\ttransparent:1, 51\tmc_all:1, 52\tnodefrag:1; 53\t__u8\tbind_address_no_port:1, 54\trecverr_rfc4884:1, 55\tdefer_connect:1; /* Indicates that fastopen_connect is set 56\t* and cookie exists so we defer connect 57\t* until first data frame is written 58\t*/ 59\t__u8\trcv_tos; 60\t__u8\tconvert_csum; 61\tint\tuc_index; 62\tint\tmc_index; 63\t__be32\tmc_addr; 64\tstruct ip_mc_socklist __rcu\t*mc_list; 65\tstruct inet_cork_full\tcork; 66}; 2.2. inet_connection_sock # 1// include/net/inet_connection_sock.h 2/** inet_connection_sock - INET connection oriented sock 3 * 4 * @icsk_accept_queue:\tFIFO of established children 5 * @icsk_bind_hash:\tBind node 6 * @icsk_timeout:\tTimeout 7 * @icsk_retransmit_timer: Resend (no ack) 8 * @icsk_rto:\tRetransmit timeout 9 * @icsk_pmtu_cookie\tLast pmtu seen by socket 10 * @icsk_ca_ops\tPluggable congestion control hook 11 * @icsk_af_ops\tOperations which are AF_INET{4,6} specific 12 * @icsk_ulp_ops\tPluggable ULP control hook 13 * @icsk_ulp_data\tULP private data 14 * @icsk_clean_acked\tClean acked data hook 15 * @icsk_ca_state:\tCongestion control state 16 * @icsk_retransmits:\tNumber of unrecovered [RTO] timeouts 17 * @icsk_pending:\tScheduled timer event 18 * @icsk_backoff:\tBackoff 19 * @icsk_syn_retries: Number of allowed SYN (or equivalent) retries 20 * @icsk_probes_out:\tunanswered 0 window probes 21 * @icsk_ext_hdr_len:\tNetwork protocol overhead (IP/IPv6 options) 22 * @icsk_ack:\tDelayed ACK control data 23 * @icsk_mtup;\tMTU probing control data 24 * @icsk_probes_tstamp: Probe timestamp (cleared by non-zero window ack) 25 * @icsk_user_timeout:\tTCP_USER_TIMEOUT value 26 */ 27struct inet_connection_sock { 28\t/* inet_sock has to be the first member! */ 29\tstruct inet_sock\ticsk_inet; 30\tstruct request_sock_queue icsk_accept_queue; 31\tstruct inet_bind_bucket\t*icsk_bind_hash; 32\tunsigned long\ticsk_timeout; 33 struct timer_list\ticsk_retransmit_timer; 34 struct timer_list\ticsk_delack_timer; 35\t__u32\ticsk_rto; 36\t__u32 icsk_rto_min; 37\t__u32 icsk_delack_max; 38\t__u32\ticsk_pmtu_cookie; 39\tconst struct tcp_congestion_ops *icsk_ca_ops; 40\tconst struct inet_connection_sock_af_ops *icsk_af_ops; 41\tconst struct tcp_ulp_ops *icsk_ulp_ops; 42\tvoid __rcu\t*icsk_ulp_data; 43\tvoid (*icsk_clean_acked)(struct sock *sk, u32 acked_seq); 44\tunsigned int\t(*icsk_sync_mss)(struct sock *sk, u32 pmtu); 45\t__u8\ticsk_ca_state:5, 46\ticsk_ca_initialized:1, 47\ticsk_ca_setsockopt:1, 48\ticsk_ca_dst_locked:1; 49\t__u8\ticsk_retransmits; 50\t__u8\ticsk_pending; 51\t__u8\ticsk_backoff; 52\t__u8\ticsk_syn_retries; 53\t__u8\ticsk_probes_out; 54\t__u16\ticsk_ext_hdr_len; 55\tstruct { 56\t__u8\tpending;\t/* ACK is pending\t*/ 57\t__u8\tquick;\t/* Scheduled number of quick acks\t*/ 58\t__u8\tpingpong;\t/* The session is interactive\t*/ 59\t__u8\tretry;\t/* Number of attempts\t*/ 60\t__u32\tato;\t/* Predicted tick of soft clock\t*/ 61\tunsigned long\ttimeout;\t/* Currently scheduled timeout\t*/ 62\t__u32\tlrcvtime;\t/* timestamp of last received data packet */ 63\t__u16\tlast_seg_size; /* Size of last incoming segment\t*/ 64\t__u16\trcv_mss;\t/* MSS used for delayed ACK decisions\t*/ 65\t} icsk_ack; 66\tstruct { 67\t/* Range of MTUs to search */ 68\tint\tsearch_high; 69\tint\tsearch_low; 70 71\t/* Information on the current probe. */ 72\tu32\tprobe_size:31, 73\t/* Is the MTUP feature enabled for this connection? */ 74\tenabled:1; 75 76\tu32\tprobe_timestamp; 77\t} icsk_mtup; 78\tu32\ticsk_probes_tstamp; 79\tu32\ticsk_user_timeout; 80 81\tu64\ticsk_ca_priv[104 / sizeof(u64)]; 82#define ICSK_CA_PRIV_SIZE\tsizeof_field(struct inet_connection_sock, icsk_ca_priv) 83}; 2. 初始化流程 # @startuml package inet_init { class sock_register class inet_add_protocol class inet_register_protosw class dev_add_pack sock_register .. inet_add_protocol inet_add_protocol .. inet_register_protosw inet_register_protosw .. dev_add_pack } class net_families { net_proto_family[] } note right of net_families socket创建时选择PF_INET 调用inet_create end note class inet_protos { net_protocol[] } note right of inet_protos 收包时网络层到传输层处理 end note class inetsw { inet_protosw[] } note right of inetsw inet_create中根据具体协议赋值ops end note class ptype_all { list_head } note right of ptype_all 收包时软中断到协议栈处理 也是数据链路层到网络层 end note sock_register -right-\u0026gt; net_families: (void)sock_register(\u0026amp;inet_family_ops); inet_add_protocol -right-\u0026gt; inet_protos: inet_add_protocol(\u0026amp;icmp_protocol, IPPROTO_ICMP) inet_register_protosw -right-\u0026gt; inetsw: inet_register_protosw(q); dev_add_pack -right-\u0026gt; ptype_all: dev_add_pack(\u0026amp;ip_packet_type); @enduml 1// net/ipv4/af_inet.c 2static int __init inet_init(void) 3{ 4\tstruct inet_protosw *q; 5\tstruct list_head *r; 6\tint rc; 7 8\tsock_skb_cb_check_size(sizeof(struct inet_skb_parm)); 9 10\trc = proto_register(\u0026amp;tcp_prot, 1); 11\tif (rc) 12\tgoto out; 13 14\trc = proto_register(\u0026amp;udp_prot, 1); 15\tif (rc) 16\tgoto out_unregister_tcp_proto; 17 18\trc = proto_register(\u0026amp;raw_prot, 1); 19\tif (rc) 20\tgoto out_unregister_udp_proto; 21 22\trc = proto_register(\u0026amp;ping_prot, 1); 23\tif (rc) 24\tgoto out_unregister_raw_proto; 25 26\t/* 27\t*\tTell SOCKET that we are alive... 28\t*/ 29\t// 向socket注册协议族，这个在socket创建时有用 30\t(void)sock_register(\u0026amp;inet_family_ops); 31 32#ifdef CONFIG_SYSCTL 33\tip_static_sysctl_init(); 34#endif 35 36\t/* 37\t*\tAdd all the base protocols. 38\t*/ 39\t// 注册传输层协议到网络层，收包使用 40\tif (inet_add_protocol(\u0026amp;icmp_protocol, IPPROTO_ICMP) \u0026lt; 0) 41\tpr_crit(\u0026#34;%s: Cannot add ICMP protocol\\n\u0026#34;, __func__); 42\tif (inet_add_protocol(\u0026amp;udp_protocol, IPPROTO_UDP) \u0026lt; 0) 43\tpr_crit(\u0026#34;%s: Cannot add UDP protocol\\n\u0026#34;, __func__); 44\tif (inet_add_protocol(\u0026amp;tcp_protocol, IPPROTO_TCP) \u0026lt; 0) 45\tpr_crit(\u0026#34;%s: Cannot add TCP protocol\\n\u0026#34;, __func__); 46#ifdef CONFIG_IP_MULTICAST 47\tif (inet_add_protocol(\u0026amp;igmp_protocol, IPPROTO_IGMP) \u0026lt; 0) 48\tpr_crit(\u0026#34;%s: Cannot add IGMP protocol\\n\u0026#34;, __func__); 49#endif 50 51\t/* Register the socket-side information for inet_create. */ 52\tfor (r = \u0026amp;inetsw[0]; r \u0026lt; \u0026amp;inetsw[SOCK_MAX]; ++r) 53\tINIT_LIST_HEAD(r); 54 55\t// 注册下层协议的相关信息到inetsw中 56\tfor (q = inetsw_array; q \u0026lt; \u0026amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) 57\tinet_register_protosw(q); 58 59\t/* 60\t*\tSet the ARP module up 61\t*/ 62 63\tarp_init(); 64 65\t/* 66\t*\tSet the IP module up 67\t*/ 68 69\tip_init(); 70 71\t/* Initialise per-cpu ipv4 mibs */ 72\tif (init_ipv4_mibs()) 73\tpanic(\u0026#34;%s: Cannot init ipv4 mibs\\n\u0026#34;, __func__); 74 75\t/* Setup TCP slab cache for open requests. */ 76\ttcp_init(); 77 78\t/* Setup UDP memory threshold */ 79\tudp_init(); 80 81\t/* Add UDP-Lite (RFC 3828) */ 82\tudplite4_register(); 83 84\traw_init(); 85 86\tping_init(); 87 88\t/* 89\t*\tSet the ICMP layer up 90\t*/ 91 92\tif (icmp_init() \u0026lt; 0) 93\tpanic(\u0026#34;Failed to create the ICMP control socket.\\n\u0026#34;); 94 95\t/* 96\t*\tInitialise the multicast router 97\t*/ 98#if defined(CONFIG_IP_MROUTE) 99\tif (ip_mr_init()) 100\tpr_crit(\u0026#34;%s: Cannot init ipv4 mroute\\n\u0026#34;, __func__); 101#endif 102 103\tif (init_inet_pernet_ops()) 104\tpr_crit(\u0026#34;%s: Cannot init ipv4 inet pernet ops\\n\u0026#34;, __func__); 105 106\tipv4_proc_init(); 107 108\tipfrag_init(); 109 110 // 注册收包处理 111\tdev_add_pack(\u0026amp;ip_packet_type); 112 113\tip_tunnel_core_init(); 114 115\trc = 0; 116out: 117\treturn rc; 118out_unregister_raw_proto: 119\tproto_unregister(\u0026amp;raw_prot); 120out_unregister_udp_proto: 121\tproto_unregister(\u0026amp;udp_prot); 122out_unregister_tcp_proto: 123\tproto_unregister(\u0026amp;tcp_prot); 124\tgoto out; 125} 126 127fs_initcall(inet_init); 二、ipv4收包后如何处理 # 1. ip层包入口 # 1.1. 最开始注册一个packet_type结构体，定义func为ip_rcv，被inet_init注册 # 1// net/ipv4/af_inet.c 2static struct packet_type ip_packet_type __read_mostly = { 3\t.type = cpu_to_be16(ETH_P_IP), 4\t.func = ip_rcv, 5\t.list_func = ip_list_rcv, 6}; 7 8static int __init inet_init(void) 9{ 10\t... 11 // 注册到dev里面 12\tdev_add_pack(\u0026amp;ip_packet_type); 13\t... 14} 1.2. ip_rcv 驱动在受到包之后会调用func # 可以看到这里是netflt的PRE_ROUTING链的挂载点 1// net/ipv4/ip_input.c 2/* 3 * IP receive entry point 4 */ 5int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, 6\tstruct net_device *orig_dev) 7{ 8\tstruct net *net = dev_net(dev); 9 10\tskb = ip_rcv_core(skb, net); 11\tif (skb == NULL) 12\treturn NET_RX_DROP; 13 14\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, 15\tnet, NULL, skb, dev, NULL, 16\tip_rcv_finish); 17} ip_rcv_core 校验包是否是ipv4的包 # 校验ip头的版本是否为v4 校验ip头的checksum是否正确 1// net/ipv4/ip_input.c 2/* 3 * Main IP Receive routine. 4 */ 5static struct sk_buff *ip_rcv_core(struct sk_buff *skb, struct net *net) 6{ 7\tconst struct iphdr *iph; 8\tint drop_reason; 9\tu32 len; 10 11\t/* When the interface is in promisc. mode, drop all the crap 12\t* that it receives, do not try to analyse it. 13\t*/ 14\tif (skb-\u0026gt;pkt_type == PACKET_OTHERHOST) { 15\tdev_core_stats_rx_otherhost_dropped_inc(skb-\u0026gt;dev); 16\tdrop_reason = SKB_DROP_REASON_OTHERHOST; 17\tgoto drop; 18\t} 19 20\t__IP_UPD_PO_STATS(net, IPSTATS_MIB_IN, skb-\u0026gt;len); 21 22\tskb = skb_share_check(skb, GFP_ATOMIC); 23\tif (!skb) { 24\t__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS); 25\tgoto out; 26\t} 27 28\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED; 29\tif (!pskb_may_pull(skb, sizeof(struct iphdr))) 30\tgoto inhdr_error; 31 32\tiph = ip_hdr(skb); 33 34\t/* 35\t*\tRFC1122: 3.2.1.2 MUST silently discard any IP frame that fails the checksum. 36\t* 37\t*\tIs the datagram acceptable? 38\t* 39\t*\t1.\tLength at least the size of an ip header 40\t*\t2.\tVersion of 4 41\t*\t3.\tChecksums correctly. [Speed optimisation for later, skip loopback checksums] 42\t*\t4.\tDoesn\u0026#39;t have a bogus length 43\t*/ 44\t// 判断版本是否为ipv4 45\tif (iph-\u0026gt;ihl \u0026lt; 5 || iph-\u0026gt;version != 4) 46\tgoto inhdr_error; 47 48\tBUILD_BUG_ON(IPSTATS_MIB_ECT1PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_1); 49\tBUILD_BUG_ON(IPSTATS_MIB_ECT0PKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_ECT_0); 50\tBUILD_BUG_ON(IPSTATS_MIB_CEPKTS != IPSTATS_MIB_NOECTPKTS + INET_ECN_CE); 51\t__IP_ADD_STATS(net, 52\tIPSTATS_MIB_NOECTPKTS + (iph-\u0026gt;tos \u0026amp; INET_ECN_MASK), 53\tmax_t(unsigned short, 1, skb_shinfo(skb)-\u0026gt;gso_segs)); 54 55\tif (!pskb_may_pull(skb, iph-\u0026gt;ihl*4)) 56\tgoto inhdr_error; 57 58\tiph = ip_hdr(skb); 59 60\t// 校验checksum，校验失败直接丢包 61\tif (unlikely(ip_fast_csum((u8 *)iph, iph-\u0026gt;ihl))) 62\tgoto csum_error; 63 64\tlen = ntohs(iph-\u0026gt;tot_len); 65\tif (skb-\u0026gt;len \u0026lt; len) { 66\tdrop_reason = SKB_DROP_REASON_PKT_TOO_SMALL; 67\t__IP_INC_STATS(net, IPSTATS_MIB_INTRUNCATEDPKTS); 68\tgoto drop; 69\t} else if (len \u0026lt; (iph-\u0026gt;ihl*4)) 70\tgoto inhdr_error; 71 72\t/* Our transport medium may have padded the buffer out. Now we know it 73\t* is IP we can trim to the true length of the frame. 74\t* Note this now means skb-\u0026gt;len holds ntohs(iph-\u0026gt;tot_len). 75\t*/ 76\tif (pskb_trim_rcsum(skb, len)) { 77\t__IP_INC_STATS(net, IPSTATS_MIB_INDISCARDS); 78\tgoto drop; 79\t} 80 81\tiph = ip_hdr(skb); 82\tskb-\u0026gt;transport_header = skb-\u0026gt;network_header + iph-\u0026gt;ihl*4; 83 84\t/* Remove any debris in the socket control block */ 85\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm)); 86\tIPCB(skb)-\u0026gt;iif = skb-\u0026gt;skb_iif; 87 88\t/* Must drop socket now because of tproxy. */ 89\tif (!skb_sk_is_prefetched(skb)) 90\tskb_orphan(skb); 91 92\treturn skb; 93 94csum_error: 95\tdrop_reason = SKB_DROP_REASON_IP_CSUM; 96\t__IP_INC_STATS(net, IPSTATS_MIB_CSUMERRORS); 97inhdr_error: 98\tif (drop_reason == SKB_DROP_REASON_NOT_SPECIFIED) 99\tdrop_reason = SKB_DROP_REASON_IP_INHDR; 100\t__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS); 101drop: 102\tkfree_skb_reason(skb, drop_reason); 103out: 104\treturn NULL; 105} 1.3. ip_rcv_finish这里处理了路由，如果路由不过就进行drop # 1// net/ipv4/ip_input.c 2static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb) 3{ 4\tstruct net_device *dev = skb-\u0026gt;dev; 5\tint ret; 6 7\t/* if ingress device is enslaved to an L3 master device pass the 8\t* skb to its handler for processing 9\t*/ 10\tskb = l3mdev_ip_rcv(skb); 11\tif (!skb) 12\treturn NET_RX_SUCCESS; 13 14 // 这个函数处理了路由 15\tret = ip_rcv_finish_core(net, sk, skb, dev, NULL); 16\tif (ret != NET_RX_DROP) 17\tret = dst_input(skb); 18\treturn ret; 19} dst_input里面是调用skb_dst(skb)-\u0026gt;input，不过一般是ip_local_deliver 1// include/net/dst.h 2INDIRECT_CALLABLE_DECLARE(int ip6_input(struct sk_buff *)); 3INDIRECT_CALLABLE_DECLARE(int ip_local_deliver(struct sk_buff *)); 4/* Input packet from network to transport. */ 5static inline int dst_input(struct sk_buff *skb) 6{ 7\treturn INDIRECT_CALL_INET(skb_dst(skb)-\u0026gt;input, 8\tip6_input, ip_local_deliver, skb); 9} 这里也是netfilter的LOCAL_IN挂载点，可以在这里进行过滤 1// net/ipv4/ip_input.c 2/* 3 * Deliver IP Packets to the higher protocol layers. 4 */ 5int ip_local_deliver(struct sk_buff *skb) { 6 /* 7 *\tReassemble IP fragments. 8 */ 9 struct net *net = dev_net(skb-\u0026gt;dev); 10 11 // 判断是否为分片包，分片包就先处理分片 12 if (ip_is_fragment(ip_hdr(skb))) { 13 if (ip_defrag(net, skb, IP_DEFRAG_LOCAL_DELIVER)) 14 return 0; 15 } 16 17 // 分片处理完毕调用ip_local_deliver_finish() 18 // NF_HOOK挂载netflt 19 return NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, 20 net, NULL, skb, skb-\u0026gt;dev, NULL, 21 ip_local_deliver_finish); 22} 根据ip包内的协议处理具体的协议 1// net/ipv4/ip_input.c 2// ip_local_deliver_finish() -call-\u0026gt; ip_local_deliver_finish() 3void ip_local_deliver_finish(struct net *net, struct sk_buff *skb, int protocol) { 4 const struct net_protocol *ipprot; 5 int raw, ret; 6 7resubmit: 8 raw = raw_local_deliver(skb, protocol); 9 10 // 这里找到具体的协议的处理函数，然后调用具体的协议处理函数 11 ipprot = rcu_dereference(inet_protos[protocol]); 12 if (ipprot) { 13 if (!ipprot-\u0026gt;no_policy) { 14 if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) { 15 kfree_skb(skb); 16 return; 17 } 18 nf_reset_ct(skb); 19 } 20 // 相当于调用ipprot-\u0026gt;handler(skb) 21 ret = INDIRECT_CALL_2(ipprot-\u0026gt;handler, tcp_v4_rcv, udp_rcv, 22 skb); 23 if (ret \u0026lt; 0) { 24 protocol = -ret; 25 goto resubmit; 26 } 27 __IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS); 28 } else { 29 if (!raw) { 30 if (xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) { 31 __IP_INC_STATS(net, IPSTATS_MIB_INUNKNOWNPROTOS); 32 // 这里是服务端会回复一个icmp包，内容就是端口不可达 33 icmp_send(skb, ICMP_DEST_UNREACH, 34 ICMP_PROT_UNREACH, 0); 35 } 36 kfree_skb(skb); 37 } else { 38 __IP_INC_STATS(net, IPSTATS_MIB_INDELIVERS); 39 consume_skb(skb); 40 } 41 } 42} inet_protos[protocol]是一个指向net_protocol结构的指针，net_protocol结构中包含了协议的处理函数 使用下面两个函数进行注册特定的协议 1// net/ipv4/protocol.c 2int inet_add_protocol(const struct net_protocol *prot, unsigned char protocol); 3EXPORT_SYMBOL(inet_add_protocol); 4 5int inet_del_protocol(const struct net_protocol *prot, unsigned char protocol); 6EXPORT_SYMBOL(inet_del_protocol); 2. 路由处理 # 上面讲了通过ip_rcv_finish_core来处理路由 1// net/ipv4/ip_input.c 2static int ip_rcv_finish_core(struct net *net, struct sock *sk, 3\tstruct sk_buff *skb, struct net_device *dev, 4\tconst struct sk_buff *hint) 5{ 6\tconst struct iphdr *iph = ip_hdr(skb); 7\tint err, drop_reason; 8\tstruct rtable *rt; 9 10\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED; 11 12\tif (ip_can_use_hint(skb, iph, hint)) { 13\terr = ip_route_use_hint(skb, iph-\u0026gt;daddr, iph-\u0026gt;saddr, iph-\u0026gt;tos, 14\tdev, hint); 15\tif (unlikely(err)) 16\tgoto drop_error; 17\t} 18 19\tif (READ_ONCE(net-\u0026gt;ipv4.sysctl_ip_early_demux) \u0026amp;\u0026amp; 20\t!skb_dst(skb) \u0026amp;\u0026amp; 21\t!skb-\u0026gt;sk \u0026amp;\u0026amp; 22\t!ip_is_fragment(iph)) { 23\tswitch (iph-\u0026gt;protocol) { 24\tcase IPPROTO_TCP: 25\tif (READ_ONCE(net-\u0026gt;ipv4.sysctl_tcp_early_demux)) { 26\ttcp_v4_early_demux(skb); 27 28\t/* must reload iph, skb-\u0026gt;head might have changed */ 29\tiph = ip_hdr(skb); 30\t} 31\tbreak; 32\tcase IPPROTO_UDP: 33\tif (READ_ONCE(net-\u0026gt;ipv4.sysctl_udp_early_demux)) { 34\terr = udp_v4_early_demux(skb); 35\tif (unlikely(err)) 36\tgoto drop_error; 37 38\t/* must reload iph, skb-\u0026gt;head might have changed */ 39\tiph = ip_hdr(skb); 40\t} 41\tbreak; 42\t} 43\t} 44 45\t/* 46\t*\tInitialise the virtual path cache for the packet. It describes 47\t*\thow the packet travels inside Linux networking. 48\t*/ 49\tif (!skb_valid_dst(skb)) { 50 // 处理路由 51\terr = ip_route_input_noref(skb, iph-\u0026gt;daddr, iph-\u0026gt;saddr, 52\tiph-\u0026gt;tos, dev); 53\tif (unlikely(err)) 54\tgoto drop_error; 55\t} 56 ... 57 58drop: 59\tkfree_skb_reason(skb, drop_reason); 60\treturn NET_RX_DROP; 61 62drop_error: 63\tif (err == -EXDEV) { 64\tdrop_reason = SKB_DROP_REASON_IP_RPFILTER; 65\t__NET_INC_STATS(net, LINUX_MIB_IPRPFILTER); 66\t} 67\tgoto drop; 68} ip_route_input_noref处理路由 1// net/ipv4/route.c 2int ip_route_input_noref(struct sk_buff *skb, __be32 daddr, __be32 saddr, 3\tu8 tos, struct net_device *dev) 4{ 5\tstruct fib_result res; 6\tint err; 7 8\ttos \u0026amp;= IPTOS_RT_MASK; 9\trcu_read_lock(); 10\terr = ip_route_input_rcu(skb, daddr, saddr, tos, dev, \u0026amp;res); 11\trcu_read_unlock(); 12 13\treturn err; 14} 15EXPORT_SYMBOL(ip_route_input_noref); 16 17// net/ipv4/route.c 18/* called with rcu_read_lock held */ 19int ip_route_input_rcu(struct sk_buff *skb, __be32 daddr, __be32 saddr, 20\tu8 tos, struct net_device *dev, struct fib_result *res) 21{ 22\t/* Multicast recognition logic is moved from route cache to here. 23\t* The problem was that too many Ethernet cards have broken/missing 24\t* hardware multicast filters :-( As result the host on multicasting 25\t* network acquires a lot of useless route cache entries, sort of 26\t* SDR messages from all the world. Now we try to get rid of them. 27\t* Really, provided software IP multicast filter is organized 28\t* reasonably (at least, hashed), it does not result in a slowdown 29\t* comparing with route cache reject entries. 30\t* Note, that multicast routers are not affected, because 31\t* route cache entry is created eventually. 32\t*/ 33 // 多播地址处理 34\tif (ipv4_is_multicast(daddr)) { 35 ... 36 return err; 37\t} 38 39 // 单播处理 40\treturn ip_route_input_slow(skb, daddr, saddr, tos, dev, res); 41} 2.1. rp_filter如何生效 # ip_route_input_slow处理单播包 1// net/ipv4/route.c 2/* 3 *\tNOTE. We drop all the packets that has local source 4 *\taddresses, because every properly looped back packet 5 *\tmust have correct destination already attached by output routine. 6 *\tChanges in the enforced policies must be applied also to 7 *\tip_route_use_hint(). 8 * 9 *\tSuch approach solves two big problems: 10 *\t1. Not simplex devices are handled properly. 11 *\t2. IP spoofing attempts are filtered with 100% of guarantee. 12 *\tcalled with rcu_read_lock() 13 */ 14 15static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr, 16\tu8 tos, struct net_device *dev, 17\tstruct fib_result *res) 18{ 19\t... 20\t// 这里处理一下res，获取type 21\terr = fib_lookup(net, \u0026amp;fl4, res, 0); 22\tif (err != 0) { 23\tif (!IN_DEV_FORWARD(in_dev)) 24\terr = -EHOSTUNREACH; 25\tgoto no_route; 26\t} 27 28\tif (res-\u0026gt;type == RTN_BROADCAST) { 29\t// 广播包 30\tif (IN_DEV_BFORWARD(in_dev)) 31\tgoto make_route; 32\t/* not do cache if bc_forwarding is enabled */ 33\tif (IPV4_DEVCONF_ALL(net, BC_FORWARDING)) 34\tdo_cache = false; 35\tgoto brd_input; 36\t} 37 38\tif (res-\u0026gt;type == RTN_LOCAL) { 39\t// 发给本地的走这个逻辑，下面校验源地址是否正确 40\terr = fib_validate_source(skb, saddr, daddr, tos, 41\t0, dev, in_dev, \u0026amp;itag); 42\tif (err \u0026lt; 0) 43\tgoto martian_source; 44\tgoto local_input; 45\t} 46\t... 47out:\treturn err; 48\t... 49local_input: 50\tno_policy = IN_DEV_ORCONF(in_dev, NOPOLICY); 51\tif (no_policy) 52\tIPCB(skb)-\u0026gt;flags |= IPSKB_NOPOLICY; 53 54\tdo_cache \u0026amp;= res-\u0026gt;fi \u0026amp;\u0026amp; !itag; 55\tif (do_cache) { 56\tstruct fib_nh_common *nhc = FIB_RES_NHC(*res); 57 58\trth = rcu_dereference(nhc-\u0026gt;nhc_rth_input); 59\tif (rt_cache_valid(rth)) { 60\tskb_dst_set_noref(skb, \u0026amp;rth-\u0026gt;dst); 61\terr = 0; 62\t// 有cache正常走到这里 63\tgoto out; 64\t} 65\t} 66\t// 没有就创建cache，最终都会到out返回 67\t... 68\tgoto out; fib_validate_source校验源地址是否正确 这里会判断进入的设备的rp_filter选项，如果为1，根据对应的源地址目的地址反向查找路由，对应的网卡如果不匹配就进行丢包 1// net/ipv4/fib_frontend.c 2/* Ignore rp_filter for packets protected by IPsec. */ 3int fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst, 4\tu8 tos, int oif, struct net_device *dev, 5\tstruct in_device *idev, u32 *itag) 6{ 7 // r就是对应网卡的rp_filter选项，使用sysctl -a | grep -i \\.rp_filter可以看到 8 // net.ipv4.conf.wlp0s20f0u1u2.rp_filter = 2 9\tint r = secpath_exists(skb) ? 0 : IN_DEV_RPFILTER(idev); 10\tstruct net *net = dev_net(dev); 11 12\tif (!r \u0026amp;\u0026amp; !fib_num_tclassid_users(net) \u0026amp;\u0026amp; 13\t(dev-\u0026gt;ifindex != oif || !IN_DEV_TX_REDIRECTS(idev))) { 14\tif (IN_DEV_ACCEPT_LOCAL(idev)) 15\tgoto ok; 16\t/* with custom local routes in place, checking local addresses 17\t* only will be too optimistic, with custom rules, checking 18\t* local addresses only can be too strict, e.g. due to vrf 19\t*/ 20\tif (net-\u0026gt;ipv4.fib_has_custom_local_routes || 21\tfib4_has_custom_rules(net)) 22\tgoto full_check; 23\t/* Within the same container, it is regarded as a martian source, 24\t* and the same host but different containers are not. 25\t*/ 26\tif (inet_lookup_ifaddr_rcu(net, src)) 27\treturn -EINVAL; 28 29ok: 30\t*itag = 0; 31\treturn 0; 32\t} 33 34full_check: 35\treturn __fib_validate_source(skb, src, dst, tos, oif, dev, r, idev, itag); 36} 下面的函数__fib_validate_source做判断 1// net/ipv4/fib_frontend.c 2/* 到这一步的堆栈 3__fib_validate_source(struct sk_buff * skb, __be32 src, __be32 dst, u8 tos, int oif, struct net_device * dev, int rpf, struct in_device * idev, u32 * itag) (/net/ipv4/fib_frontend.c:385) 4fib_validate_source(struct sk_buff * skb, __be32 src, __be32 dst, u8 tos, int oif, struct net_device * dev, struct in_device * idev, u32 * itag) (/net/ipv4/fib_frontend.c:454) 5ip_route_input_slow(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev, struct fib_result * res) (/net/ipv4/route.c:2336) 6ip_route_input_rcu(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev, struct fib_result * res) (/net/ipv4/route.c:2519) 7ip_route_input_noref(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev) (/net/ipv4/route.c:2462) 8ip_rcv_finish_core(struct net * net, struct sock * sk, struct sk_buff * skb, struct net_device * dev, const struct sk_buff * hint) (/net/ipv4/ip_input.c:369) 9ip_rcv_finish(struct net * net, struct sock * sk, struct sk_buff * skb) (/net/ipv4/ip_input.c:447) 10 */ 11/* Given (packet source, input interface) and optional (dst, oif, tos): 12 * - (main) check, that source is valid i.e. not broadcast or our local 13 * address. 14 * - figure out what \u0026#34;logical\u0026#34; interface this packet arrived 15 * and calculate \u0026#34;specific destination\u0026#34; address. 16 * - check, that packet arrived from expected physical interface. 17 * called with rcu_read_lock() 18 */ 19static int __fib_validate_source(struct sk_buff *skb, __be32 src, __be32 dst, 20\tu8 tos, int oif, struct net_device *dev, 21\tint rpf, struct in_device *idev, u32 *itag) 22{ 23\tstruct net *net = dev_net(dev); 24\t... 25\tdev_match = fib_info_nh_uses_dev(res.fi, dev); 26\t/* This is not common, loopback packets retain skb_dst so normally they 27\t* would not even hit this slow path. 28\t*/ 29 // 看网卡是否对应上，如果对应不上走后面流程 30\tdev_match = dev_match || (res.type == RTN_LOCAL \u0026amp;\u0026amp; 31\tdev == net-\u0026gt;loopback_dev); 32\tif (dev_match) { 33\tret = FIB_RES_NHC(res)-\u0026gt;nhc_scope \u0026gt;= RT_SCOPE_HOST; 34\treturn ret; 35\t} 36\tif (no_addr) 37\tgoto last_resort; 38 // 这里判断如果rp_filter == 1就会丢包，否则正常返回 39\tif (rpf == 1) 40\tgoto e_rpf; 41\tfl4.flowi4_oif = dev-\u0026gt;ifindex; 42 43\tret = 0; 44\tif (fib_lookup(net, \u0026amp;fl4, \u0026amp;res, FIB_LOOKUP_IGNORE_LINKSTATE) == 0) { 45\tif (res.type == RTN_UNICAST) 46\tret = FIB_RES_NHC(res)-\u0026gt;nhc_scope \u0026gt;= RT_SCOPE_HOST; 47\t} 48\treturn ret; 49 50last_resort: 51\tif (rpf) 52\tgoto e_rpf; 53\t*itag = 0; 54\treturn 0; 55\t... 56e_rpf: 57\treturn -EXDEV; 58} 2.2. 路由如何走转发 # ip_route_input_slow处理单播包 1// net/ipv4/route.c 2static int ip_route_input_slow(struct sk_buff *skb, __be32 daddr, __be32 saddr, 3\tu8 tos, struct net_device *dev, 4\tstruct fib_result *res) 5{ 6\t... 7\t// 这里处理一下res，获取type 8\terr = fib_lookup(net, \u0026amp;fl4, res, 0); 9\tif (err != 0) { 10\tif (!IN_DEV_FORWARD(in_dev)) 11\terr = -EHOSTUNREACH; 12\tgoto no_route; 13\t} 14 15\t// 非广播包 16\tif (res-\u0026gt;type == RTN_BROADCAST) { 17\t... 18\tgoto brd_input; 19\t} 20 21\t// 非发给本地的包 22\tif (res-\u0026gt;type == RTN_LOCAL) { 23\t... 24\tgoto local_input; 25\t} 26 27\t// 不是发给本地的也不是广播，判断一下进入的设备有没有开启forwarding 28\t// 配置为 /proc/sys/net/ipv4/conf/\u0026lt;interface\u0026gt;/forwarding 29\t// 可以用 sysctl -w net.ipv4.conf.\u0026lt;interface\u0026gt;.forwarding=1 进行配置 30\tif (!IN_DEV_FORWARD(in_dev)) { 31\terr = -EHOSTUNREACH; 32\tgoto no_route; 33\t} 34 35\t// 非组播包 36\tif (res-\u0026gt;type != RTN_UNICAST) 37\tgoto martian_destination; 38 39make_route: 40 // 转发包走到这里 41\terr = ip_mkroute_input(skb, res, in_dev, daddr, saddr, tos, flkeys); 42out:\treturn err; 43 ... 44} 45 46// net/ipv4/route.c 47static int ip_mkroute_input(struct sk_buff *skb, 48\tstruct fib_result *res, 49\tstruct in_device *in_dev, 50\t__be32 daddr, __be32 saddr, u32 tos, 51\tstruct flow_keys *hkeys) 52{ 53#ifdef CONFIG_IP_ROUTE_MULTIPATH 54\tif (res-\u0026gt;fi \u0026amp;\u0026amp; fib_info_num_path(res-\u0026gt;fi) \u0026gt; 1) { 55\tint h = fib_multipath_hash(res-\u0026gt;fi-\u0026gt;fib_net, NULL, skb, hkeys); 56 57\tfib_select_multipath(res, h); 58\t} 59#endif 60 61\t/* create a routing cache entry */ 62\treturn __mkroute_input(skb, res, in_dev, daddr, saddr, tos); 63} 下面是处理转发的，将rth-\u0026gt;dst.input设置为ip_forward 1// net/ipv4/route.c 2/* 到这里的堆栈 3__mkroute_input(struct sk_buff * skb, const struct fib_result * res, struct in_device * in_dev, __be32 daddr, __be32 saddr, u32 tos) (/net/ipv4/route.c:1881) 4ip_mkroute_input(struct sk_buff * skb, struct fib_result * res, struct in_device * in_dev, __be32 daddr, __be32 saddr, u32 tos, struct flow_keys * hkeys) (/net/ipv4/route.c:2168) 5ip_route_input_slow(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev, struct fib_result * res) (/net/ipv4/route.c:2351) 6ip_route_input_rcu(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev, struct fib_result * res) (/net/ipv4/route.c:2519) 7ip_route_input_noref(struct sk_buff * skb, __be32 daddr, __be32 saddr, u8 tos, struct net_device * dev) (/net/ipv4/route.c:2462) 8ip_rcv_finish_core(struct net * net, struct sock * sk, struct sk_buff * skb, struct net_device * dev, const struct sk_buff * hint) (/net/ipv4/ip_input.c:369) 9 */ 10/* called in rcu_read_lock() section */ 11static int __mkroute_input(struct sk_buff *skb, 12\tconst struct fib_result *res, 13\tstruct in_device *in_dev, 14\t__be32 daddr, __be32 saddr, u32 tos) 15{ 16\t... 17\t// 这里会校验rp_filter，同样需要入包的设备配置 18\terr = fib_validate_source(skb, saddr, daddr, tos, FIB_RES_OIF(*res), 19\tin_dev-\u0026gt;dev, in_dev, \u0026amp;itag); 20\tif (err \u0026lt; 0) { 21\tip_handle_martian_source(in_dev-\u0026gt;dev, in_dev, skb, daddr, 22\tsaddr); 23 24\tgoto cleanup; 25\t} 26\t... 27\trth-\u0026gt;rt_is_input = 1; 28\tRT_CACHE_STAT_INC(in_slow_tot); 29 30\trth-\u0026gt;dst.input = ip_forward; 31 32\trt_set_nexthop(rth, daddr, res, fnhe, res-\u0026gt;fi, res-\u0026gt;type, itag, 33\tdo_cache); 34\tlwtunnel_set_redirect(\u0026amp;rth-\u0026gt;dst); 35\tskb_dst_set(skb, \u0026amp;rth-\u0026gt;dst); 36out: 37\terr = 0; 38 cleanup: 39\treturn err; 40} 3. 转发数据包处理 # 从上面得知，当数据包要走转发，rth-\u0026gt;dst.input设置为ip_forward 下面的调用就会调用到skb_dst(skb)-\u0026gt;input也就是ip_forward 1// include/net/dst.h 2INDIRECT_CALLABLE_DECLARE(int ip6_input(struct sk_buff *)); 3INDIRECT_CALLABLE_DECLARE(int ip_local_deliver(struct sk_buff *)); 4/* Input packet from network to transport. */ 5static inline int dst_input(struct sk_buff *skb) 6{ 7\treturn INDIRECT_CALL_INET(skb_dst(skb)-\u0026gt;input, 8\tip6_input, ip_local_deliver, skb); 9} ip_forward处理，会走到forward链 1// net/ipv4/ip_forward.c 2int ip_forward(struct sk_buff *skb) 3{ 4\t... 5\t/* 6\t*\tAccording to the RFC, we must first decrease the TTL field. If 7\t*\tthat reaches zero, we must reply an ICMP control message telling 8\t*\tthat the packet\u0026#39;s lifetime expired. 9\t*/ 10\t// 转发前判断一下ttl，ttl不够就不转发了，到后面返回icmp不可达 11\tif (ip_hdr(skb)-\u0026gt;ttl \u0026lt;= 1) 12\tgoto too_many_hops; 13 14\tif (!xfrm4_route_forward(skb)) { 15\tSKB_DR_SET(reason, XFRM_POLICY); 16\tgoto drop; 17\t} 18 19\trt = skb_rtable(skb); 20 21\tif (opt-\u0026gt;is_strictroute \u0026amp;\u0026amp; rt-\u0026gt;rt_uses_gateway) 22\tgoto sr_failed; 23 24\tIPCB(skb)-\u0026gt;flags |= IPSKB_FORWARDED; 25\tmtu = ip_dst_mtu_maybe_forward(\u0026amp;rt-\u0026gt;dst, true); 26\tif (ip_exceeds_mtu(skb, mtu)) { 27\tIP_INC_STATS(net, IPSTATS_MIB_FRAGFAILS); 28\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, 29\thtonl(mtu)); 30\tSKB_DR_SET(reason, PKT_TOO_BIG); 31\tgoto drop; 32\t} 33 34\t/* We are about to mangle packet. Copy it! */ 35\tif (skb_cow(skb, LL_RESERVED_SPACE(rt-\u0026gt;dst.dev)+rt-\u0026gt;dst.header_len)) 36\tgoto drop; 37\tiph = ip_hdr(skb); 38 39\t/* Decrease ttl after skb cow done */ 40\t// 减ttl 41\tip_decrease_ttl(iph); 42 43\t/* 44\t*\tWe now generate an ICMP HOST REDIRECT giving the route 45\t*\twe calculated. 46\t*/ 47\tif (IPCB(skb)-\u0026gt;flags \u0026amp; IPSKB_DOREDIRECT \u0026amp;\u0026amp; !opt-\u0026gt;srr \u0026amp;\u0026amp; 48\t!skb_sec_path(skb)) 49\tip_rt_send_redirect(skb); 50 51\tif (READ_ONCE(net-\u0026gt;ipv4.sysctl_ip_fwd_update_priority)) 52\tskb-\u0026gt;priority = rt_tos2priority(iph-\u0026gt;tos); 53 54\t// 这里处理netfilter的forward链，然后调用ip_forward_finish 55\treturn NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD, 56\tnet, NULL, skb, skb-\u0026gt;dev, rt-\u0026gt;dst.dev, 57\tip_forward_finish); 58 59sr_failed: 60\t/* 61\t*\tStrict routing permits no gatewaying 62\t*/ 63\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_SR_FAILED, 0); 64\tgoto drop; 65 66too_many_hops: 67\t/* Tell the sender its packet died... */ 68\t__IP_INC_STATS(net, IPSTATS_MIB_INHDRERRORS); 69\t// 这里回icmp，到达ttl上限 70\ticmp_send(skb, ICMP_TIME_EXCEEDED, ICMP_EXC_TTL, 0); 71\tSKB_DR_SET(reason, IP_INHDR); 72drop: 73\tkfree_skb_reason(skb, reason); 74\treturn NET_RX_DROP; 75} 走完FORWARD链调用ip_forward_finish，就调用到dst_output走发包流程 dst_output后面就是POSTROUTING，过了转发链就不会走OUTPUT和路由了 1// net/ipv4/ip_forward.c 2/* 到这一步的堆栈，从rcv到forward，中间有一个ip_forward和netfilter的FORWARD链没展示出来 3ip_forward_finish(struct net * net, struct sock * sk, struct sk_buff * skb) (/net/ipv4/ip_forward.c:69) 4dst_input(struct sk_buff * skb) (/include/net/dst.h:462) 5ip_rcv_finish(struct net * net, struct sock * sk, struct sk_buff * skb) (/net/ipv4/ip_input.c:449) 6 */ 7static int ip_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb) 8{ 9\t... 10\tskb_clear_tstamp(skb); 11\treturn dst_output(net, sk, skb); 12} 三、socket相关操作 # 1. inet_create socket创建 # 1.1. 注册协议族到socket那边，create调用inet_create # 1// net/ipv4/af_inet.c 2static const struct net_proto_family inet_family_ops = { 3\t.family = PF_INET, 4\t.create = inet_create, 5\t.owner\t= THIS_MODULE, 6}; 7 8static int __init inet_init(void) { 9 ... 10 (void)sock_register(\u0026amp;inet_family_ops); 11 ... 12} 1.2. 注册对应的下层协议到inet_sw中 # 1// net/ipv4/af_inet.c 2// net/ipv4/af_inet.c 3/* Upon startup we insert all the elements in inetsw_array[] into 4 * the linked list inetsw. 5 */ 6static struct inet_protosw inetsw_array[] = 7{ 8 { 9 .type = SOCK_STREAM, 10 .protocol = IPPROTO_TCP, 11 .prot = \u0026amp;tcp_prot, 12 .ops = \u0026amp;inet_stream_ops, 13 .flags = INET_PROTOSW_PERMANENT | 14 INET_PROTOSW_ICSK, 15 }, 16 17 { 18 .type = SOCK_DGRAM, 19 .protocol = IPPROTO_UDP, 20 .prot = \u0026amp;udp_prot, 21 .ops = \u0026amp;inet_dgram_ops, 22 .flags = INET_PROTOSW_PERMANENT, 23 }, 24 25 { 26 .type = SOCK_DGRAM, 27 .protocol = IPPROTO_ICMP, 28 .prot = \u0026amp;ping_prot, 29 .ops = \u0026amp;inet_sockraw_ops, 30 .flags = INET_PROTOSW_REUSE, 31 }, 32 33 { 34 .type = SOCK_RAW, 35 .protocol = IPPROTO_IP,\t/* wild card */ 36 .prot = \u0026amp;raw_prot, 37 .ops = \u0026amp;inet_sockraw_ops, 38 .flags = INET_PROTOSW_REUSE, 39 } 40}; 41... 42static int __init inet_init(void) 43{ 44... 45 for (q = inetsw_array; q \u0026lt; \u0026amp;inetsw_array[INETSW_ARRAY_LEN]; ++q) 46 inet_register_protosw(q); 47... 48} 1.3. 调用inet_create创建socket # 会继续根据协议找特定协议需要注册的结构，然后调用底层的init 1// net/ipv4/af_inet.c 2/* 3 *\tCreate an inet socket. 4 */ 5 6static int inet_create(struct net *net, struct socket *sock, int protocol, 7 int kern) 8{ 9 struct sock *sk; 10 struct inet_protosw *answer; 11 struct inet_sock *inet; 12 struct proto *answer_prot; 13 unsigned char answer_flags; 14 int try_loading_module = 0; 15 int err; 16 17 if (protocol \u0026lt; 0 || protocol \u0026gt;= IPPROTO_MAX) 18 return -EINVAL; 19 20 // 初始化状态为SS_UNCONNETED 21 sock-\u0026gt;state = SS_UNCONNECTED; 22 23 /* Look for the requested type/protocol pair. */ 24lookup_protocol: 25 err = -ESOCKTNOSUPPORT; 26 rcu_read_lock(); 27 // 从inetsw中找到对应协议的结构体，赋值给answer变量 28 list_for_each_entry_rcu(answer, \u0026amp;inetsw[sock-\u0026gt;type], list) { 29 30 err = 0; 31 /* Check the non-wild match. */ 32 if (protocol == answer-\u0026gt;protocol) { 33 if (protocol != IPPROTO_IP) 34 break; 35 } else { 36 /* Check for the two wild cases. */ 37 if (IPPROTO_IP == protocol) { 38 protocol = answer-\u0026gt;protocol; 39 break; 40 } 41 if (IPPROTO_IP == answer-\u0026gt;protocol) 42 break; 43 } 44 err = -EPROTONOSUPPORT; 45 } 46 47 if (unlikely(err)) { 48 if (try_loading_module \u0026lt; 2) { 49 rcu_read_unlock(); 50 /* 51 * Be more specific, e.g. net-pf-2-proto-132-type-1 52 * (net-pf-PF_INET-proto-IPPROTO_SCTP-type-SOCK_STREAM) 53 */ 54 if (++try_loading_module == 1) 55 request_module(\u0026#34;net-pf-%d-proto-%d-type-%d\u0026#34;, 56 PF_INET, protocol, sock-\u0026gt;type); 57 /* 58 * Fall back to generic, e.g. net-pf-2-proto-132 59 * (net-pf-PF_INET-proto-IPPROTO_SCTP) 60 */ 61 else 62 request_module(\u0026#34;net-pf-%d-proto-%d\u0026#34;, 63 PF_INET, protocol); 64 goto lookup_protocol; 65 } else 66 goto out_rcu_unlock; 67 } 68 69 err = -EPERM; 70 if (sock-\u0026gt;type == SOCK_RAW \u0026amp;\u0026amp; !kern \u0026amp;\u0026amp; 71 !ns_capable(net-\u0026gt;user_ns, CAP_NET_RAW)) 72 goto out_rcu_unlock; 73 74 // 将对应协议的操作放到sock里面 75 sock-\u0026gt;ops = answer-\u0026gt;ops; 76 answer_prot = answer-\u0026gt;prot; 77 answer_flags = answer-\u0026gt;flags; 78 rcu_read_unlock(); 79 80 WARN_ON(!answer_prot-\u0026gt;slab); 81 82 err = -ENOMEM; 83\t// 给sock结构体申请内存 84\t// 同时把sk-\u0026gt;sk_prot = answer_prot也就是对应的inetsw[proto]-\u0026gt;prot 85 sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern); 86 if (!sk) 87 goto out; 88 89 err = 0; 90 if (INET_PROTOSW_REUSE \u0026amp; answer_flags) 91 sk-\u0026gt;sk_reuse = SK_CAN_REUSE; 92 93 inet = inet_sk(sk); 94 inet-\u0026gt;is_icsk = (INET_PROTOSW_ICSK \u0026amp; answer_flags) != 0; 95 96 inet-\u0026gt;nodefrag = 0; 97 98 if (SOCK_RAW == sock-\u0026gt;type) { 99 inet-\u0026gt;inet_num = protocol; 100 if (IPPROTO_RAW == protocol) 101 inet-\u0026gt;hdrincl = 1; 102 } 103 104 if (READ_ONCE(net-\u0026gt;ipv4.sysctl_ip_no_pmtu_disc)) 105 inet-\u0026gt;pmtudisc = IP_PMTUDISC_DONT; 106 else 107 inet-\u0026gt;pmtudisc = IP_PMTUDISC_WANT; 108 109 inet-\u0026gt;inet_id = 0; 110 111 sock_init_data(sock, sk); 112 113 sk-\u0026gt;sk_destruct\t= inet_sock_destruct;\t// 设置sock结构体的析构函数 114 sk-\u0026gt;sk_protocol\t= protocol; 115 sk-\u0026gt;sk_backlog_rcv = sk-\u0026gt;sk_prot-\u0026gt;backlog_rcv; 116 117 inet-\u0026gt;uc_ttl\t= -1; 118 inet-\u0026gt;mc_loop\t= 1; 119 inet-\u0026gt;mc_ttl\t= 1; 120 inet-\u0026gt;mc_all\t= 1; 121 inet-\u0026gt;mc_index\t= 0; 122 inet-\u0026gt;mc_list\t= NULL; 123 inet-\u0026gt;rcv_tos\t= 0; 124 125 sk_refcnt_debug_inc(sk); 126 127 if (inet-\u0026gt;inet_num) { 128 /* It assumes that any protocol which allows 129 * the user to assign a number at socket 130 * creation time automatically 131 * shares. 132 */ 133 inet-\u0026gt;inet_sport = htons(inet-\u0026gt;inet_num); 134 /* Add to protocol hash chains. */ 135 err = sk-\u0026gt;sk_prot-\u0026gt;hash(sk); 136 if (err) { 137 sk_common_release(sk); 138 goto out; 139 } 140 } 141 142 if (sk-\u0026gt;sk_prot-\u0026gt;init) { 143\t// 这里调用tcp特定的init 144 err = sk-\u0026gt;sk_prot-\u0026gt;init(sk); 145 if (err) { 146 sk_common_release(sk); 147 goto out; 148 } 149 } 150 151 if (!kern) { 152 err = BPF_CGROUP_RUN_PROG_INET_SOCK(sk); 153 if (err) { 154 sk_common_release(sk); 155 goto out; 156 } 157 } 158out: 159 return err; 160out_rcu_unlock: 161 rcu_read_unlock(); 162 goto out; 163} tcp相关结构注册查看 tcp初始化socket 2. bind 绑定地址 # tcp和udp的bind接口都指向inet_bind 1// net/ipv4/af_inet.c 2const struct proto_ops inet_stream_ops = { 3\t... 4\t.bind\t= inet_bind, 5\t... 6}; 7 8// net/ipv4/af_inet.c 9const struct proto_ops inet_dgram_ops = { 10\t... 11\t.bind\t= inet_bind, 12\t... 13}; 14 15// net/ipv4/af_inet.c 16/* 17 * For SOCK_RAW sockets; should be the same as inet_dgram_ops but without 18 * udp_poll 19 */ 20const struct proto_ops inet_sockraw_ops = { 21\t... 22\t.bind\t= inet_bind, 23\t... 24}; 2.1. inet_bind # 主要逻辑是参数检查和赋值，将端口和地址赋值到inet_sock的recv的地址上 端口检查要到具体的传输层协议查看 1// net/ipv4/af_inet.c 2int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len) 3{ 4\tstruct sock *sk = sock-\u0026gt;sk; 5\tu32 flags = BIND_WITH_LOCK; 6\tint err; 7 8\t/* If the socket has its own bind function then use it. (RAW) */ 9\tif (sk-\u0026gt;sk_prot-\u0026gt;bind) { 10\treturn sk-\u0026gt;sk_prot-\u0026gt;bind(sk, uaddr, addr_len); 11\t} 12\tif (addr_len \u0026lt; sizeof(struct sockaddr_in)) 13\treturn -EINVAL; 14 15\t/* BPF prog is run before any checks are done so that if the prog 16\t* changes context in a wrong way it will be caught. 17\t*/ 18\terr = BPF_CGROUP_RUN_PROG_INET_BIND_LOCK(sk, uaddr, 19\tCGROUP_INET4_BIND, \u0026amp;flags); 20\tif (err) 21\treturn err; 22 23\treturn __inet_bind(sk, uaddr, addr_len, flags); 24} 25EXPORT_SYMBOL(inet_bind); 26 27// net/ipv4/af_inet.c 28int __inet_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len, 29\tu32 flags) 30{ 31\tstruct sockaddr_in *addr = (struct sockaddr_in *)uaddr; 32\tstruct inet_sock *inet = inet_sk(sk); 33\tstruct net *net = sock_net(sk); 34\tunsigned short snum; 35\tint chk_addr_ret; 36\tu32 tb_id = RT_TABLE_LOCAL; 37\tint err; 38 39\tif (addr-\u0026gt;sin_family != AF_INET) { 40\t/* Compatibility games : accept AF_UNSPEC (mapped to AF_INET) 41\t* only if s_addr is INADDR_ANY. 42\t*/ 43\terr = -EAFNOSUPPORT; 44\tif (addr-\u0026gt;sin_family != AF_UNSPEC || 45\taddr-\u0026gt;sin_addr.s_addr != htonl(INADDR_ANY)) 46\tgoto out; 47\t} 48 49\ttb_id = l3mdev_fib_table_by_index(net, sk-\u0026gt;sk_bound_dev_if) ? : tb_id; 50\tchk_addr_ret = inet_addr_type_table(net, addr-\u0026gt;sin_addr.s_addr, tb_id); 51 52\t/* Not specified by any standard per-se, however it breaks too 53\t* many applications when removed. It is unfortunate since 54\t* allowing applications to make a non-local bind solves 55\t* several problems with systems using dynamic addressing. 56\t* (ie. your servers still start up even if your ISDN link 57\t* is temporarily down) 58\t*/ 59\terr = -EADDRNOTAVAIL; 60\tif (!inet_addr_valid_or_nonlocal(net, inet, addr-\u0026gt;sin_addr.s_addr, 61\tchk_addr_ret)) 62\tgoto out; 63 64\tsnum = ntohs(addr-\u0026gt;sin_port); 65\terr = -EACCES; 66\tif (!(flags \u0026amp; BIND_NO_CAP_NET_BIND_SERVICE) \u0026amp;\u0026amp; 67\tsnum \u0026amp;\u0026amp; inet_port_requires_bind_service(net, snum) \u0026amp;\u0026amp; 68\t!ns_capable(net-\u0026gt;user_ns, CAP_NET_BIND_SERVICE)) 69\tgoto out; 70 71\t/* We keep a pair of addresses. rcv_saddr is the one 72\t* used by hash lookups, and saddr is used for transmit. 73\t* 74\t* In the BSD API these are the same except where it 75\t* would be illegal to use them (multicast/broadcast) in 76\t* which case the sending device address is used. 77\t*/ 78\tif (flags \u0026amp; BIND_WITH_LOCK) 79\tlock_sock(sk); 80 81\t/* Check these errors (active socket, double bind). */ 82\terr = -EINVAL; 83\tif (sk-\u0026gt;sk_state != TCP_CLOSE || inet-\u0026gt;inet_num) 84\tgoto out_release_sock; 85 86\tinet-\u0026gt;inet_rcv_saddr = inet-\u0026gt;inet_saddr = addr-\u0026gt;sin_addr.s_addr; 87\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST) 88\tinet-\u0026gt;inet_saddr = 0; /* Use device */ 89 90\t/* Make sure we are allowed to bind here. */ 91\tif (snum || !(inet-\u0026gt;bind_address_no_port || 92\t(flags \u0026amp; BIND_FORCE_ADDRESS_NO_PORT))) { 93\t// 有端口或没有设置绑定地址不绑定端口的flags就会走到绑定端口的处理中 94 95\t// 有端口的情况下，需要检查端口是否已经占用，这一步要走到tcp自己的端口判断中 96\tif (sk-\u0026gt;sk_prot-\u0026gt;get_port(sk, snum)) { 97\tinet-\u0026gt;inet_saddr = inet-\u0026gt;inet_rcv_saddr = 0; 98\terr = -EADDRINUSE; 99\tgoto out_release_sock; 100\t} 101\tif (!(flags \u0026amp; BIND_FROM_BPF)) { 102\terr = BPF_CGROUP_RUN_PROG_INET4_POST_BIND(sk); 103\tif (err) { 104\tinet-\u0026gt;inet_saddr = inet-\u0026gt;inet_rcv_saddr = 0; 105\tif (sk-\u0026gt;sk_prot-\u0026gt;put_port) 106\tsk-\u0026gt;sk_prot-\u0026gt;put_port(sk); 107\tgoto out_release_sock; 108\t} 109\t} 110\t} 111 112\tif (inet-\u0026gt;inet_rcv_saddr) 113\tsk-\u0026gt;sk_userlocks |= SOCK_BINDADDR_LOCK; 114\tif (snum) 115\tsk-\u0026gt;sk_userlocks |= SOCK_BINDPORT_LOCK; 116\tinet-\u0026gt;inet_sport = htons(inet-\u0026gt;inet_num); 117\tinet-\u0026gt;inet_daddr = 0; 118\tinet-\u0026gt;inet_dport = 0; 119\tsk_dst_reset(sk); 120\terr = 0; 121out_release_sock: 122\tif (flags \u0026amp; BIND_WITH_LOCK) 123\trelease_sock(sk); 124out: 125\treturn err; 126} sk_prot-\u0026gt;get_port检查端口是否可用，tcp的调用到 inet_sck_get_port 3. listen # 3.1. 定义 # tcp才有listen，udp和raw协议都没有listen 1// net/ipv4/af_inet.c 2const struct proto_ops inet_stream_ops = { 3\t... 4\t.listen = inet_listen, 5\t... 6}; 7 8// net/ipv4/af_inet.c 9const struct proto_ops inet_dgram_ops = { 10\t... 11\t.listen\t= sock_no_listen, 12\t... 13}; 14 15// net/ipv4/af_inet.c 16/* 17 * For SOCK_RAW sockets; should be the same as inet_dgram_ops but without 18 * udp_poll 19 */ 20const struct proto_ops inet_sockraw_ops = { 21\t... 22\t.listen\t= sock_no_listen, 23\t... 24}; sock_no_listen # 1// net/core/sock.c 2int sock_no_listen(struct socket *sock, int backlog) 3{ 4\treturn -EOPNOTSUPP; 5} 6EXPORT_SYMBOL(sock_no_listen); 3.2. inet_listen # 会给socket分配backlog队列长度，用于存储sync包进来的socket 1// net/ipv4/af_inet.c 2/* 3 *\tMove a socket into listening state. 4 */ 5int inet_listen(struct socket *sock, int backlog) 6{ 7\tstruct sock *sk = sock-\u0026gt;sk; 8\tunsigned char old_state; 9\tint err, tcp_fastopen; 10 11\tlock_sock(sk); 12 13\terr = -EINVAL; 14\tif (sock-\u0026gt;state != SS_UNCONNECTED || sock-\u0026gt;type != SOCK_STREAM) 15\tgoto out; 16 17\told_state = sk-\u0026gt;sk_state; 18\tif (!((1 \u0026lt;\u0026lt; old_state) \u0026amp; (TCPF_CLOSE | TCPF_LISTEN))) 19\tgoto out; 20 21\tWRITE_ONCE(sk-\u0026gt;sk_max_ack_backlog, backlog); 22\t/* Really, if the socket is already in listen state 23\t* we can only allow the backlog to be adjusted. 24\t*/ 25\tif (old_state != TCP_LISTEN) { 26\t/* Enable TFO w/o requiring TCP_FASTOPEN socket option. 27\t* Note that only TCP sockets (SOCK_STREAM) will reach here. 28\t* Also fastopen backlog may already been set via the option 29\t* because the socket was in TCP_LISTEN state previously but 30\t* was shutdown() rather than close(). 31\t*/ 32\ttcp_fastopen = READ_ONCE(sock_net(sk)-\u0026gt;ipv4.sysctl_tcp_fastopen); 33\tif ((tcp_fastopen \u0026amp; TFO_SERVER_WO_SOCKOPT1) \u0026amp;\u0026amp; 34\t(tcp_fastopen \u0026amp; TFO_SERVER_ENABLE) \u0026amp;\u0026amp; 35\t!inet_csk(sk)-\u0026gt;icsk_accept_queue.fastopenq.max_qlen) { 36\tfastopen_queue_tune(sk, backlog); 37\ttcp_fastopen_init_key_once(sock_net(sk)); 38\t} 39 40\terr = inet_csk_listen_start(sk); 41\tif (err) 42\tgoto out; 43\ttcp_call_bpf(sk, BPF_SOCK_OPS_TCP_LISTEN_CB, 0, NULL); 44\t} 45\terr = 0; 46 47out: 48\trelease_sock(sk); 49\treturn err; 50} 51EXPORT_SYMBOL(inet_listen); 3.3. inet_csk_listen_start # 设置状态到TCP_LISTEN 1// net/ipv4/inet_connection_sock.c 2int inet_csk_listen_start(struct sock *sk) 3{ 4\tstruct inet_connection_sock *icsk = inet_csk(sk); 5\tstruct inet_sock *inet = inet_sk(sk); 6\tint err = -EADDRINUSE; 7 8\treqsk_queue_alloc(\u0026amp;icsk-\u0026gt;icsk_accept_queue); 9 10\tsk-\u0026gt;sk_ack_backlog = 0; 11\tinet_csk_delack_init(sk); 12 13\tif (sk-\u0026gt;sk_txrehash == SOCK_TXREHASH_DEFAULT) 14\tsk-\u0026gt;sk_txrehash = READ_ONCE(sock_net(sk)-\u0026gt;core.sysctl_txrehash); 15 16\t/* There is race window here: we announce ourselves listening, 17\t* but this transition is still not validated by get_port(). 18\t* It is OK, because this socket enters to hash table only 19\t* after validation is complete. 20\t*/ 21\tinet_sk_state_store(sk, TCP_LISTEN); 22\tif (!sk-\u0026gt;sk_prot-\u0026gt;get_port(sk, inet-\u0026gt;inet_num)) { 23\tinet-\u0026gt;inet_sport = htons(inet-\u0026gt;inet_num); 24 25\tsk_dst_reset(sk); 26\terr = sk-\u0026gt;sk_prot-\u0026gt;hash(sk); 27 28\tif (likely(!err)) 29\treturn 0; 30\t} 31 32\tinet_sk_set_state(sk, TCP_CLOSE); 33\treturn err; 34} 35EXPORT_SYMBOL_GPL(inet_csk_listen_start); "},{"id":48,"href":"/docs/linux/linux-kernel/kernel/cgroup/","title":"/kernel/cgroup/ cgroup处理","section":"/kernel/ 内核运行主要代码","content":" 容器三把斧之 | cgroup原理与实现\n"},{"id":49,"href":"/docs/leetcode/hard/leetcode10/","title":"10. Regular Expression Matching","section":"困难","content":" 题目 # Given an input string s and a pattern p, implement regular expression matching with support for . and * where:\n. Matches any single character * Matches zero or more of the preceding element. The matching should cover the entire input string (not partial).\n思路1 # 分析 # 当仅出现字符或.时，单个匹配即可\n如果出现x*或.*时，可以不匹配或者匹配多个，这时匹配多个不好定义匹配几个，但是可以简化一下\n如果出现x*，分成两种情况\n匹配0个，跳过x* 匹配1个，不跳过x* 出现这两种情况取或运算即可\n代码实现 # 1func matchSubStr(s string, i int, p string, j int) bool { 2\tif j == len(p) { 3\treturn i == len(s) 4\t} 5\t// check is first charactor match 6\tfirstMatch := i \u0026lt; len(s) \u0026amp;\u0026amp; (p[j] == \u0026#39;.\u0026#39; || s[i] == p[j]) 7\t// when match \u0026#39;x*\u0026#39; 8\tif j+1 \u0026lt; len(p) \u0026amp;\u0026amp; p[j+1] == \u0026#39;*\u0026#39; { 9\t// match none and skip || match one but not skip 10\treturn matchSubStr(s, i, p, j+2) || (firstMatch \u0026amp;\u0026amp; matchSubStr(s, i+1, p, j)) 11\t} 12 13\t// other, match charactor directly 14\treturn firstMatch \u0026amp;\u0026amp; matchSubStr(s, i+1, p, j+1) 15} 16 17func isMatch(s string, p string) bool { 18\treturn matchSubStr(s, 0, p, 0) 19} 思路2 # 使用动态规划\n分析 # 定义状态方程需要先找状态\n定义 $f(i, j)$ 为s的前 $i$ 个字符和p的前 $j$ 个表达式是否匹配，那么没有*的情况，会有\n$$ f(i, j) = \\left\\{ \\begin{array}{ll} f(i-1, j-1) \u0026amp; if \u0026amp; s[i] = p[j] \\\\ false \u0026amp; if \u0026amp; s[i] \\ne p[j] \\end{array} \\right. $$\n如果遇到*的情况，同上一个思路，分为匹配0个跳过和匹配1个不跳过的情况\n$$ f(i, j) = \\left\\{ \\begin{array}{ll} f(i, j-2) \u0026amp; 匹配0个跳过 \\\\ s[i] == j[j-1] \\land f(i-1, j) \u0026amp; 匹配1个不跳过 \\end{array} \\right. $$\n合并一下就成了状态转移方程\n$$ f(i, j) = \\left\\{ \\begin{array}{ll} p[j] \\ne * \u0026amp; \\left\\{ \\begin{array}{ll} f(i-1, j-1) \u0026amp; if \u0026amp; s[i] = p[j] \\\\ false \u0026amp; if \u0026amp; s[i] \\ne p[j] \\end{array} \\right.\t\\\\ p[j] = * \u0026amp; \\left\\{ \\begin{array}{ll} f(i, j-2) \u0026amp; 匹配0个跳过 \\\\ s[i] = p[j-1] \\land f(i-1, j) \u0026amp; 匹配1个不跳过 \\end{array} \\right. \\end{array} \\right. $$\n定义一下初始状态\n$i$ 为0，$j$ 为0就是一个都没有，认为是true $i$ 为0，$j$ 可能为x*格式，判断一下 $j$ 为0，$i$ 不为0，false $$ f(i, j) = \\left\\{ \\begin{array}{ll} true \u0026amp; i = 0 \\land j = 0 \\\\ p[j] = * \\land f(i, j-2) \u0026amp; i = 0 \\\\ false \u0026amp; j = 0 \\end{array} \\right. $$\n代码实现 # 用递归实现动态规划，并且由于上述 $i$ 和 $j$ 和数组索引不一样，要按照 $i-1$ 和 $j-1$ 处理\n代码看起来和上面递归差不多，但是leetcode耗时要少，我也不知道为啥\n1func getStatus(s string, i int, p string, j int) bool { 2\tif j \u0026lt; 0 { 3\treturn i \u0026lt; 0 4\t} 5\tif i \u0026lt; 0 { 6\treturn p[j] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; getStatus(s, i, p, j-2) 7\t} 8 9\tif p[j] != \u0026#39;*\u0026#39; { 10\treturn (p[j] == \u0026#39;.\u0026#39; || s[i] == p[j]) \u0026amp;\u0026amp; getStatus(s, i-1, p, j-1) 11\t} 12\treturn getStatus(s, i, p, j-2) || ((p[j-1] == \u0026#39;.\u0026#39; || s[i] == p[j-1]) \u0026amp;\u0026amp; getStatus(s, i-1, p, j)) 13} 14 15func isMatch(s string, p string) bool { 16\treturn getStatus(s, len(s)-1, p, len(p)-1) 17} "},{"id":50,"href":"/docs/linux/linux-kernel/arch/x86/gdt-idt-ldt-tss-tgd/","title":"gdt/idt/ldt/tss/tgd","section":"x86/ x86体系","content":" 介绍 # GDT，IDT都是全局的。LDT是局部的（在GDT中有它的描述符） GDT用来存储描述符（门或非门）；系统中几个CPU,就有几个GDT IDT整个系统只有一个 系统启动时候需要初始化GDT和IDT。LDT和进程相关，并不一定必有 TSS: Task-State Segment，任务状态段，保存任务状态信息的系统段 TSS只能存在于GDT中 Task-Gate Descriptor，任务门描述符，用来间接的宝玉引用任务。可以放到GDT、LDT、IDT中，里面的TSS段选择指向GDT的TSS描述符 1. 相关结构的cpu手册 # IDT结构 下图为32位TSS结构 下图为64位TSS或LDT结构 一、数据结构 # 1// arch/x86/include/asm/desc_defs.h 2// gdt结构 3/* 8 byte segment descriptor */ 4struct desc_struct { 5 u16 limit0; // 段管理的内存上限low 6 u16 base0; // 段的对应的内存实际地址low 7 u16 base1 : 8; // 段的对应的内存实际地址mid 8 u16 type : 4; 9 u16 s : 1; // 系统段为1，普通段为0 10 u16 dpl : 2; 11 u16 p : 1; 12 u16 limit1 : 4; // 段管理的内存上限low 13 u16 avl : 1; 14 u16 l : 1; 15 u16 d : 1; 16 u16 g : 1; // 为1就是4K为单位定义上限（上限1，管理内存4K），为0则以一个字节为单位 17 u16 base2 : 8; // 段的对应的内存实际地址high 18} __attribute__((packed)); 19 20#define GDT_ENTRY_INIT(flags, base, limit)\t\\ 21\t{\t\\ 22\t.limit0\t= (u16) (limit),\t\\ 23\t.limit1\t= ((limit) \u0026gt;\u0026gt; 16) \u0026amp; 0x0F,\t\\ 24\t.base0\t= (u16) (base),\t\\ 25\t.base1\t= ((base) \u0026gt;\u0026gt; 16) \u0026amp; 0xFF,\t\\ 26\t.base2\t= ((base) \u0026gt;\u0026gt; 24) \u0026amp; 0xFF,\t\\ 27\t.type\t= (flags \u0026amp; 0x0f),\t\\ 28\t.s\t= (flags \u0026gt;\u0026gt; 4) \u0026amp; 0x01,\t\\ 29\t.dpl\t= (flags \u0026gt;\u0026gt; 5) \u0026amp; 0x03,\t\\ 30\t.p\t= (flags \u0026gt;\u0026gt; 7) \u0026amp; 0x01,\t\\ 31\t.avl\t= (flags \u0026gt;\u0026gt; 12) \u0026amp; 0x01,\t\\ 32\t.l\t= (flags \u0026gt;\u0026gt; 13) \u0026amp; 0x01,\t\\ 33\t.d\t= (flags \u0026gt;\u0026gt; 14) \u0026amp; 0x01,\t\\ 34\t.g\t= (flags \u0026gt;\u0026gt; 15) \u0026amp; 0x01,\t\\ 35\t} 36 37enum { 38\tGATE_INTERRUPT = 0xE, 39\tGATE_TRAP = 0xF, 40\tGATE_CALL = 0xC, 41\tGATE_TASK = 0x5, 42}; 43 44enum { 45\tDESC_TSS = 0x9, 46\tDESC_LDT = 0x2, 47\tDESCTYPE_S = 0x10,\t/* !system */ 48}; 49 50/* LDT or TSS descriptor in the GDT. */ 51struct ldttss_desc { 52\tu16\tlimit0; 53\tu16\tbase0; 54 55\tu16\tbase1 : 8, type : 5, dpl : 2, p : 1; 56\tu16\tlimit1 : 4, zero0 : 3, g : 1, base2 : 8; 57#ifdef CONFIG_X86_64 58\tu32\tbase3; 59\tu32\tzero1; 60#endif 61} __attribute__((packed)); 62 63typedef struct ldttss_desc ldt_desc; 64typedef struct ldttss_desc tss_desc; 65 66struct idt_bits { 67 u16 ist : 3; 68 u16 zero : 5; 69 u16 type : 5; 70 u16 dpl : 2; // Descriptor Privilege Level 71 u16 p : 1; 72} __attribute__((packed)); 73 74struct idt_data { 75\tunsigned int\tvector; 76\tunsigned int\tsegment; 77\tstruct idt_bits\tbits; 78\tconst void\t*addr; 79}; 80 81// idt结构 82struct gate_struct { 83 u16 offset_low; // 函数在段内的偏移地址low 84 u16 segment; // 段配置对应的偏移，比如第2号段，就是 2 * 8，一个段配置8个字节 85 struct idt_bits bits; 86 u16 offset_middle; // 函数在段内的偏移地址mid 87#ifdef CONFIG_X86_64 88\tu32\toffset_high; 89\tu32\treserved; 90#endif 91} __attribute__((packed)); 92 93typedef struct gate_struct gate_desc; 94 95... 96 97#endif /* !__ASSEMBLY__ */ 98 99/* Boot IDT definitions */ 100#define\tBOOT_IDT_ENTRIES\t32 二、配置 # 1. GDT分布配置，每个cpu都有一个 # 1// arch/x86/include/asm/segment.h 2/* 3 * Number of entries in the GDT table: 4 */ 5#define GDT_ENTRIES\t32 6 7// arch/x86/include/asm/desc.h 8struct gdt_page { 9\tstruct desc_struct gdt[GDT_ENTRIES]; 10} __attribute__((aligned(PAGE_SIZE))); 11 12// arch/x86/kernel/cpu/common.c 13DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) = { .gdt = { 14#ifdef CONFIG_X86_64 15\t/* 16\t* We need valid kernel segments for data and code in long mode too 17\t* IRET will check the segment types kkeil 2000/10/28 18\t* Also sysret mandates a special GDT layout 19\t* 20\t* TLS descriptors are currently at a different place compared to i386. 21\t* Hopefully nobody expects them at a fixed place (Wine?) 22\t*/ 23\t[GDT_ENTRY_KERNEL32_CS]\t= GDT_ENTRY_INIT(0xc09b, 0, 0xfffff), 24\t[GDT_ENTRY_KERNEL_CS]\t= GDT_ENTRY_INIT(0xa09b, 0, 0xfffff), // kernel代码段 25\t[GDT_ENTRY_KERNEL_DS]\t= GDT_ENTRY_INIT(0xc093, 0, 0xfffff), // kernel数据段 26\t[GDT_ENTRY_DEFAULT_USER32_CS]\t= GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff), 27\t[GDT_ENTRY_DEFAULT_USER_DS]\t= GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff), 28\t[GDT_ENTRY_DEFAULT_USER_CS]\t= GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff), 29#else 30\t[GDT_ENTRY_KERNEL_CS]\t= GDT_ENTRY_INIT(0xc09a, 0, 0xfffff), // kernel代码段 31\t[GDT_ENTRY_KERNEL_DS]\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff), // kernel数据段 32\t[GDT_ENTRY_DEFAULT_USER_CS]\t= GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff), 33\t[GDT_ENTRY_DEFAULT_USER_DS]\t= GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff), 34\t/* 35\t* Segments used for calling PnP BIOS have byte granularity. 36\t* They code segments and data segments have fixed 64k limits, 37\t* the transfer segment sizes are set at run time. 38\t*/ 39\t/* 32-bit code */ 40\t[GDT_ENTRY_PNPBIOS_CS32]\t= GDT_ENTRY_INIT(0x409a, 0, 0xffff), 41\t/* 16-bit code */ 42\t[GDT_ENTRY_PNPBIOS_CS16]\t= GDT_ENTRY_INIT(0x009a, 0, 0xffff), 43\t/* 16-bit data */ 44\t[GDT_ENTRY_PNPBIOS_DS]\t= GDT_ENTRY_INIT(0x0092, 0, 0xffff), 45\t/* 16-bit data */ 46\t[GDT_ENTRY_PNPBIOS_TS1]\t= GDT_ENTRY_INIT(0x0092, 0, 0), 47\t/* 16-bit data */ 48\t[GDT_ENTRY_PNPBIOS_TS2]\t= GDT_ENTRY_INIT(0x0092, 0, 0), 49\t/* 50\t* The APM segments have byte granularity and their bases 51\t* are set at run time. All have 64k limits. 52\t*/ 53\t/* 32-bit code */ 54\t[GDT_ENTRY_APMBIOS_BASE]\t= GDT_ENTRY_INIT(0x409a, 0, 0xffff), 55\t/* 16-bit code */ 56\t[GDT_ENTRY_APMBIOS_BASE+1]\t= GDT_ENTRY_INIT(0x009a, 0, 0xffff), 57\t/* data */ 58\t[GDT_ENTRY_APMBIOS_BASE+2]\t= GDT_ENTRY_INIT(0x4092, 0, 0xffff), 59 60\t[GDT_ENTRY_ESPFIX_SS]\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff), 61\t[GDT_ENTRY_PERCPU]\t= GDT_ENTRY_INIT(0xc092, 0, 0xfffff), 62#endif 63} }; 64EXPORT_PER_CPU_SYMBOL_GPL(gdt_page); 段分布情况 1#ifdef CONFIG_X86_32 2// arch/x86/include/asm/segment.h 3/* 4 * The layout of the per-CPU GDT under Linux: 5 * 6 * 0 - null\t\u0026lt;=== cacheline #1 7 * 1 - reserved 8 * 2 - reserved 9 * 3 - reserved 10 * 11 * 4 - unused\t\u0026lt;=== cacheline #2 12 * 5 - unused 13 * 14 * ------- start of TLS (Thread-Local Storage) segments: 15 * 16 * 6 - TLS segment #1\t[ glibc\u0026#39;s TLS segment ] 17 * 7 - TLS segment #2\t[ Wine\u0026#39;s %fs Win32 segment ] 18 * 8 - TLS segment #3\t\u0026lt;=== cacheline #3 19 * 9 - reserved 20 * 10 - reserved 21 * 11 - reserved 22 * 23 * ------- start of kernel segments: 24 * 25 * 12 - kernel code segment\t\u0026lt;=== cacheline #4 26 * 13 - kernel data segment 27 * 14 - default user CS 28 * 15 - default user DS 29 * 16 - TSS\t\u0026lt;=== cacheline #5 30 * 17 - LDT 31 * 18 - PNPBIOS support (16-\u0026gt;32 gate) 32 * 19 - PNPBIOS support 33 * 20 - PNPBIOS support\t\u0026lt;=== cacheline #6 34 * 21 - PNPBIOS support 35 * 22 - PNPBIOS support 36 * 23 - APM BIOS support 37 * 24 - APM BIOS support\t\u0026lt;=== cacheline #7 38 * 25 - APM BIOS support 39 * 40 * 26 - ESPFIX small SS 41 * 27 - per-cpu\t[ offset to per-cpu data area ] 42 * 28 - unused 43 * 29 - unused 44 * 30 - unused 45 * 31 - TSS for double fault handler 46 */ 47#define GDT_ENTRY_TLS_MIN\t6 48#define GDT_ENTRY_TLS_MAX (GDT_ENTRY_TLS_MIN + GDT_ENTRY_TLS_ENTRIES - 1) 49 50#define GDT_ENTRY_KERNEL_CS\t12 51#define GDT_ENTRY_KERNEL_DS\t13 52#define GDT_ENTRY_DEFAULT_USER_CS\t14 53#define GDT_ENTRY_DEFAULT_USER_DS\t15 54#define GDT_ENTRY_TSS\t16 55#define GDT_ENTRY_LDT\t17 56#define GDT_ENTRY_PNPBIOS_CS32\t18 57#define GDT_ENTRY_PNPBIOS_CS16\t19 58#define GDT_ENTRY_PNPBIOS_DS\t20 59#define GDT_ENTRY_PNPBIOS_TS1\t21 60#define GDT_ENTRY_PNPBIOS_TS2\t22 61#define GDT_ENTRY_APMBIOS_BASE\t23 62 63#define GDT_ENTRY_ESPFIX_SS\t26 64#define GDT_ENTRY_PERCPU\t27 65 66#define GDT_ENTRY_DOUBLEFAULT_TSS\t31 67 68/* 69 * Number of entries in the GDT table: 70 */ 71#define GDT_ENTRIES\t32 72 73/* 74 * Segment selector values corresponding to the above entries: 75 */ 76 77#define __KERNEL_CS\t(GDT_ENTRY_KERNEL_CS*8) 78#define __KERNEL_DS\t(GDT_ENTRY_KERNEL_DS*8) 79#define __USER_DS\t(GDT_ENTRY_DEFAULT_USER_DS*8 + 3) 80#define __USER_CS\t(GDT_ENTRY_DEFAULT_USER_CS*8 + 3) 81#define __ESPFIX_SS\t(GDT_ENTRY_ESPFIX_SS*8) 82 83/* segment for calling fn: */ 84#define PNP_CS32\t(GDT_ENTRY_PNPBIOS_CS32*8) 85/* code segment for BIOS: */ 86#define PNP_CS16\t(GDT_ENTRY_PNPBIOS_CS16*8) 87 88/* \u0026#34;Is this PNP code selector (PNP_CS32 or PNP_CS16)?\u0026#34; */ 89#define SEGMENT_IS_PNP_CODE(x)\t(((x) \u0026amp; 0xf4) == PNP_CS32) 90 91/* data segment for BIOS: */ 92#define PNP_DS\t(GDT_ENTRY_PNPBIOS_DS*8) 93/* transfer data segment: */ 94#define PNP_TS1\t(GDT_ENTRY_PNPBIOS_TS1*8) 95/* another data segment: */ 96#define PNP_TS2\t(GDT_ENTRY_PNPBIOS_TS2*8) 97 98#ifdef CONFIG_SMP 99# define __KERNEL_PERCPU\t(GDT_ENTRY_PERCPU*8) 100#else 101# define __KERNEL_PERCPU\t0 102#endif 103 104#else /* 64-bit: */ 105 106#include \u0026lt;asm/cache.h\u0026gt; 107 108#define GDT_ENTRY_KERNEL32_CS\t1 109#define GDT_ENTRY_KERNEL_CS\t2 110#define GDT_ENTRY_KERNEL_DS\t3 111 112/* 113 * We cannot use the same code segment descriptor for user and kernel mode, 114 * not even in long flat mode, because of different DPL. 115 * 116 * GDT layout to get 64-bit SYSCALL/SYSRET support right. SYSRET hardcodes 117 * selectors: 118 * 119 * if returning to 32-bit userspace: cs = STAR.SYSRET_CS, 120 * if returning to 64-bit userspace: cs = STAR.SYSRET_CS+16, 121 * 122 * ss = STAR.SYSRET_CS+8 (in either case) 123 * 124 * thus USER_DS should be between 32-bit and 64-bit code selectors: 125 */ 126#define GDT_ENTRY_DEFAULT_USER32_CS\t4 127#define GDT_ENTRY_DEFAULT_USER_DS\t5 128#define GDT_ENTRY_DEFAULT_USER_CS\t6 129 130/* Needs two entries */ 131#define GDT_ENTRY_TSS\t8 132/* Needs two entries */ 133#define GDT_ENTRY_LDT\t10 134 135#define GDT_ENTRY_TLS_MIN\t12 136#define GDT_ENTRY_TLS_MAX\t14 137 138#define GDT_ENTRY_CPUNODE\t15 139 140/* 141 * Number of entries in the GDT table: 142 */ 143#define GDT_ENTRIES\t16 144 145/* 146 * Segment selector values corresponding to the above entries: 147 * 148 * Note, selectors also need to have a correct RPL, 149 * expressed with the +3 value for user-space selectors: 150 */ 151#define __KERNEL32_CS\t(GDT_ENTRY_KERNEL32_CS*8) 152#define __KERNEL_CS\t(GDT_ENTRY_KERNEL_CS*8) 153#define __KERNEL_DS\t(GDT_ENTRY_KERNEL_DS*8) 154#define __USER32_CS\t(GDT_ENTRY_DEFAULT_USER32_CS*8 + 3) 155#define __USER_DS\t(GDT_ENTRY_DEFAULT_USER_DS*8 + 3) 156#define __USER32_DS\t__USER_DS 157#define __USER_CS\t(GDT_ENTRY_DEFAULT_USER_CS*8 + 3) 158#define __CPUNODE_SEG\t(GDT_ENTRY_CPUNODE*8 + 3) 159 160#endif 2. IDT分布配置 # 1// arch/x86/kernel/idt.c 2/* 3 * The default IDT entries which are set up in trap_init() before 4 * cpu_init() is invoked. Interrupt stacks cannot be used at that point and 5 * the traps which use them are reinitialized with IST after cpu_init() has 6 * set up TSS. 7 */ 8static const __initconst struct idt_data def_idts[] = { 9\tINTG(X86_TRAP_DE,\tasm_exc_divide_error), 10\tISTG(X86_TRAP_NMI,\tasm_exc_nmi, IST_INDEX_NMI), 11\tINTG(X86_TRAP_BR,\tasm_exc_bounds), 12\tINTG(X86_TRAP_UD,\tasm_exc_invalid_op), 13\tINTG(X86_TRAP_NM,\tasm_exc_device_not_available), 14\tINTG(X86_TRAP_OLD_MF,\tasm_exc_coproc_segment_overrun), 15\tINTG(X86_TRAP_TS,\tasm_exc_invalid_tss), 16\tINTG(X86_TRAP_NP,\tasm_exc_segment_not_present), 17\tINTG(X86_TRAP_SS,\tasm_exc_stack_segment), 18\tINTG(X86_TRAP_GP,\tasm_exc_general_protection), 19\tINTG(X86_TRAP_SPURIOUS,\tasm_exc_spurious_interrupt_bug), 20\tINTG(X86_TRAP_MF,\tasm_exc_coprocessor_error), 21\tINTG(X86_TRAP_AC,\tasm_exc_alignment_check), 22\tINTG(X86_TRAP_XF,\tasm_exc_simd_coprocessor_error), 23 24#ifdef CONFIG_X86_32 25\tTSKG(X86_TRAP_DF,\tGDT_ENTRY_DOUBLEFAULT_TSS), 26#else 27\tISTG(X86_TRAP_DF,\tasm_exc_double_fault, IST_INDEX_DF), 28#endif 29\tISTG(X86_TRAP_DB,\tasm_exc_debug, IST_INDEX_DB), 30 31#ifdef CONFIG_X86_MCE 32\tISTG(X86_TRAP_MC,\tasm_exc_machine_check, IST_INDEX_MCE), 33#endif 34 35#ifdef CONFIG_X86_KERNEL_IBT 36\tINTG(X86_TRAP_CP,\tasm_exc_control_protection), 37#endif 38 39#ifdef CONFIG_AMD_MEM_ENCRYPT 40\tISTG(X86_TRAP_VC,\tasm_exc_vmm_communication, IST_INDEX_VC), 41#endif 42 43\tSYSG(X86_TRAP_OF,\tasm_exc_overflow), 44#if defined(CONFIG_IA32_EMULATION) 45\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_compat), 46#elif defined(CONFIG_X86_32) 47\tSYSG(IA32_SYSCALL_VECTOR,\tentry_INT80_32), 48#endif 49}; "},{"id":51,"href":"/docs/linux/linux-kernel/net/poll/","title":"Poll","section":"/net/ 网络部分","content":" 一、总述 # poll同样也是轮询，但是poll的轮询数组是用户自定义长度 "},{"id":52,"href":"/docs/linux/linux-kernel/kernel/watchdog/","title":"/kernel/watchdog* 看门狗","section":"/kernel/ 内核运行主要代码","content":" 请记住内核中这个勤劳的监测卫士\u0026mdash;Watchdog（Hard lockup篇） Softlockup与hardlockup检测机制(又名:nmi_watchdog)\n"},{"id":53,"href":"/docs/leetcode/medium/leetcode11/","title":"11. Container With Most Water","section":"中等","content":" 题目 # You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\n思路1 # 分析 # 自己想的动态规划\n定义两个函数\n$f(n)$ 代表前 $n$ 个数组中最大的容量 $g(n)$ 代表以 $n$ 结尾的最大的容量 那么有\n$$ f(n+1) = max(f(n), g(n+1)) $$\n然后，时间复杂度超了。。。。应该是很多计算没必要\n思路2 # 分析 # $i$ 和 $j$ 之间的容量表示为\n$$ container(i, j) = (j - i) \\times min(height[i], height[j]) $$\n那么先要求 $j-i$ 最大，也就是两个边界\n向内收缩的时候，$j-i$ 会减小，需要找到一个比小的边界更高的才行，不然无法计算出比结果更大的\n那么就需要较小的边界收缩，较大的不动\n代码实现 # 1func maxArea(height []int) (result int) { 2\tleft, right := 0, len(height)-1 3 4\tfor right \u0026gt; left { 5\tminValue := height[left] 6\tif minValue \u0026gt; height[right] { 7\tminValue = height[right] 8\t} 9 10\ttmp := (right - left) * minValue 11\tif tmp \u0026gt; result { 12\tresult = tmp 13\t} 14 15\t// less border move, move to a bigger border than minValue 16\tif height[left] \u0026lt; height[right] { 17\tfor right \u0026gt; left \u0026amp;\u0026amp; height[left] \u0026lt;= minValue { 18\tleft++ 19\t} 20\t} else { 21\tfor right \u0026gt; left \u0026amp;\u0026amp; height[right] \u0026lt;= minValue { 22\tright-- 23\t} 24\t} 25\t} 26\treturn 27} 思路3 # 官方解答\n分析 # 和思路2差不多，还更差一点，但是代码量小了\n通俗来讲，小的移动，虽然可能变得更差，但是总比不动（或者减小）强\n代码实现 # 1func maxArea1(height []int) (result int) { 2\tleft, right := 0, len(height)-1 3 4\tfor right \u0026gt; left { 5\tminValue := height[left] 6\tif minValue \u0026gt; height[right] { 7\tminValue = height[right] 8\t} 9\ttmp := (right - left) * minValue 10\tif result \u0026lt; tmp { 11\tresult = tmp 12\t} 13\tif height[left] \u0026lt; height[right] { 14\tleft++ 15\t} else { 16\tright-- 17\t} 18\t} 19\treturn 20} "},{"id":54,"href":"/docs/linux/linux-kernel/net/select/","title":"Select","section":"/net/ 网络部分","content":" 一、总述 # select调用是将集合中的fd进行遍历，查看每个fd是否有事件，时间复杂度为 $O(n)$ 有最大fd限制，内核正常限制最大1024 内部有定长数组，维护所有fd，主要使用掩码和位运算遍历 "},{"id":55,"href":"/docs/leetcode/medium/leetcode12/","title":"12. Integer to Roman","section":"中等","content":" 题目 # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral.\n思路1 # 分析 # 递归实现，每次减去一个范围内最大的数字，加一个字母\n代码实现 # 1var intA = [...]int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000} 2var strA = [...]string{\u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34;} 3 4func intToRoman(num int) string { 5\tfor i := len(intA) - 1; i \u0026gt;= 0; i-- { 6\tif num \u0026gt;= intA[i] { 7\treturn strA[i] + intToRoman(num-intA[i]) 8\t} 9\t} 10\treturn \u0026#34;\u0026#34; 11} 思路2 # 分析 # 果然递归时间长耗内存，虽然代码少 转非递归实现 代码实现 # 1func intToRoman1(num int) (result string) { 2\tvar intA = [...]int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000} 3\tvar strA = [...]string{\u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34;} 4 5\tfor i := len(intA) - 1; i \u0026gt;= 0; i-- { 6\tfor num \u0026gt;= intA[i] { 7\tnum -= intA[i] 8\tresult += strA[i] 9\t} 10\t} 11\treturn 12} 思路3 # 分析 # 千位搞个表 百位搞个表 十位搞个表 个位搞个表 直接每一位按照表取拼接即可 "},{"id":56,"href":"/docs/leetcode/simple/leetcode13/","title":"13. Roman to Integer","section":"简单","content":" 题目 # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one\u0026rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\n思路1 # 分析 # 和前一道题同样的处理，两个数组，从数组最大的那一端开始比较 比较相等就加，不等就下一个。判断一下是否字母是两个的情况\n代码实现 # 1func romanToInt(s string) (result int) { 2\tvar intA = [...]int{1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000} 3\tvar strA = [...]string{\u0026#34;I\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;M\u0026#34;} 4\tindex := 0 5\tfor i := len(strA) - 1; i \u0026gt;= 0; i-- { 6\tcompareLen := len(strA[i]) 7\tfor index+compareLen \u0026lt;= len(s) \u0026amp;\u0026amp; s[index:index+compareLen] == strA[i] { 8\tresult += intA[i] 9\tindex += compareLen 10\t} 11\t} 12\treturn 13} 思路2 # 分析 # 官方方法思路就是清奇 左边比右边小，就减去，大或者相等就加上 代码实现 # 1func romanToInt1(s string) (result int) { 2\tromToIntMap := map[byte]int{ 3\t\u0026#39;I\u0026#39;: 1, 4\t\u0026#39;V\u0026#39;: 5, 5\t\u0026#39;X\u0026#39;: 10, 6\t\u0026#39;L\u0026#39;: 50, 7\t\u0026#39;C\u0026#39;: 100, 8\t\u0026#39;D\u0026#39;: 500, 9\t\u0026#39;M\u0026#39;: 1000, 10\t} 11 12\tfor i := range s { 13\tvalue := romToIntMap[s[i]] 14\tif i \u0026lt; len(s)-1 \u0026amp;\u0026amp; romToIntMap[s[i+1]] \u0026gt; value { 15\tresult -= value 16\tcontinue 17\t} 18\tresult += value 19\t} 20\treturn 21} "},{"id":57,"href":"/docs/leetcode/medium/leetcode18/","title":"18. 4Sum","section":"中等","content":" 题目 # Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 \u0026lt;= a, b, c, d \u0026lt; n a, b, c, and d are distinct. nums[a] + nums[b] + nums[c] + nums[d] == target You may return the answer in any order.\nExample 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0 Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] Example 2:\nInput: nums = [2,2,2,2,2], target = 8 Output: [[2,2,2,2]] Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 200 $-10^9 \u0026lt;= nums[i] \u0026lt;= 10^9$ $-10^9 \u0026lt;= target \u0026lt;= 10^9$ 思路1 暴力破解 # 分析 # 所有人的第一想法，4重循环直接做，然后去个重 思路2 两轮循环+双指针 # 分析 # 第一个优化，因为要去重，那直接排个序，然后保证顺序的情况下就不会有重复的数字了，循环时考虑每一个元素不要取到相同的就好了 第二个优化，最后两轮循环其实可以参考两个元素之和，使用双指针进行，将 $O(n^2)$ 变成 $O(n)$ 代码 # 1func fourSum(nums []int, target int) [][]int { 2\t// 先排序 3\tsort.Ints(nums) 4\tresult := make([][]int, 0) 5\tn := len(nums) 6\t// 然后前两个用循环套 7\t// 第一个元素首先不能和随后的三个相加已经大于target了，毕竟排了序，大于后面随便选都不可能等于target 8\tfor i := 0; i \u0026lt; n-3 \u0026amp;\u0026amp; nums[i]+nums[i+1]+nums[i+2]+nums[i+3] \u0026lt;= target; i++ { 9\t// 下一轮循环时第一个元素必须选和当前不一样的，否则就重复了 10\t// 并且不能和最大的三个相加还比target小，否则同样无法满足选四个相加等于target 11\tif nums[i]+nums[n-1]+nums[n-2]+nums[n-3] \u0026lt; target || (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i-1]) { 12\tcontinue 13\t} 14\tfor j := i + 1; j \u0026lt; n-2 \u0026amp;\u0026amp; nums[i]+nums[j]+nums[j+1]+nums[j+2] \u0026lt;= target; j++ { 15\tif nums[i]+nums[j]+nums[n-1]+nums[n-2] \u0026lt; target || (j \u0026gt; i+1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) { 16\tcontinue 17\t} 18\t// 剩余两个数使用双指针找 19\tfor l, r, t := j+1, n-1, target-nums[i]-nums[j]; r \u0026gt; l; { 20\ttmp := nums[r] + nums[l] - t 21\tif tmp == 0 { 22\tresult = append(result, []int{nums[i], nums[j], nums[l], nums[r]}) 23\t} 24\tif tmp \u0026gt;= 0 { 25\tfor r--; r \u0026gt; l \u0026amp;\u0026amp; nums[r] == nums[r+1]; r-- { 26\t} 27\t} 28\tif tmp \u0026lt;= 0 { 29\tfor l++; r \u0026gt; l \u0026amp;\u0026amp; nums[l] == nums[l-1]; l++ { 30\t} 31\t} 32\t} 33\t} 34\t} 35\treturn result 36} "},{"id":58,"href":"/docs/leetcode/simple/leetcode20/","title":"20. Valid Parentheses","section":"简单","content":" 题目 # Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1: Input: s = \u0026#34;()\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;()[]{}\u0026#34; Output: true Example 3:\nInput: s = \u0026#34;(]\u0026#34; Output: false Constraints:\n$1 \u0026lt;= s.length \u0026lt;= 10^4$ s consists of parentheses only \u0026lsquo;()[]{}\u0026rsquo;. 思路1 # 分析 # 没啥说的，栈搞定就好 代码 # 1func isValid(s string) bool { 2\tn := len(s) 3\tif n%2 == 1 { 4\treturn false 5\t} 6 7\tcheck := map[byte]byte{ 8\t\u0026#39;)\u0026#39;: \u0026#39;(\u0026#39;, 9\t\u0026#39;]\u0026#39;: \u0026#39;[\u0026#39;, 10\t\u0026#39;}\u0026#39;: \u0026#39;{\u0026#39;, 11\t} 12\tstack := make([]byte, 0, 1) 13\tfor _, v := range s { 14\tif t := check[byte(v)]; t \u0026gt; 0 { 15\tif len(stack) == 0 || t != stack[len(stack)-1] { 16\treturn false 17\t} 18\tstack = stack[:len(stack)-1] 19\t} else { 20\tstack = append(stack, byte(v)) 21\t} 22\t} 23\treturn len(stack) == 0 24} "},{"id":59,"href":"/docs/leetcode/hard/leetcode41/","title":"41. First Missing Positive","section":"困难","content":" 题目 # Given an unsorted integer array nums, return the smallest missing positive integer.\nYou must implement an algorithm that runs in O(n) time and uses constant extra space.\nExample 1:\nInput: nums = [1,2,0] Output: 3 Explanation: The numbers in the range [1,2] are all in the array. Example 2:\nInput: nums = [3,4,-1,1] Output: 2 Explanation: 1 is in the array but 2 is missing. Example 3:\nInput: nums = [7,8,9,11,12] Output: 1 Explanation: The smallest positive integer 1 is missing. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $-2^{31} \u0026lt;= nums[i] \u0026lt;= 2^{31} - 1$ 思路1 排序遍历 # 分析 # 排序遍历 思路2 复用原数组，O(n) # 分析 # 最小正整数，那么一定从1开始找 将原数组设想为从1到n的数组，数组元素只需要填空就好，哪里填空不对就代表这里是最小没出现的 每次交换一定有一个到指定位置，那么最多交换n次 防止重复交换，需要判断是否相等 代码 # 1func firstMissingPositive(nums []int) int { 2\tfor i := range nums { 3\t// 不在范围内或相等（交换也相等或位置一样）就退出 4\tfor nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= len(nums) \u0026amp;\u0026amp; nums[i] != nums[nums[i]-1] { 5\tnums[i], nums[nums[i]-1] = nums[nums[i]-1], nums[i] 6\t} 7\t} 8\tfor i := range nums { 9\tif i+1 != nums[i] { 10\treturn i + 1 11\t} 12\t} 13\treturn len(nums) + 1 14} "},{"id":60,"href":"/docs/ctf/","title":"ctf知识总结","section":"Docs","content":" Introduction # 记录ctf相关知识总结\n"},{"id":61,"href":"/docs/leetcode/","title":"LeetCode刷题思路总结","section":"Docs","content":" Introduction # 本博客只记录leetcode刷题过程中的思路\n"},{"id":62,"href":"/docs/examination/system-architect/large-concurrency/proctical-scene/","title":"实践场景","section":"大并发架构","content":" 一、百万级并发优化实战 # 1.1. 背景 # 主场景为认证、资源列表下发、环境上报、资源访问鉴权 1.2. 如何优化点分析 # 本地集群瓶颈\n模拟高峰流量，分析到是cpu占用过高，然后是数据库瓶颈，然后是内存 1.3. 优化过程 # 1) api级别短时效缓存 # 业务处理多个地方调用接口查询数据库，对同一个数据进行多次查询不能每一次都读io 对接口进行api级别缓存，业务代码可直接调用数据库接口查询，接口内部会对查询数据进行缓存 2) 数据预处理 # 对于每次都需要进行复杂转换和计算的大数据，提前进行预处理储存到缓存中，每次只需要读取结果即可 3) 运行时数据缓存（时间局部性） # 对于登陆访问过程中通过不同api查询同样的数据，将数据和对应id进行缓存 第一个api调用查询数据库然后缓存，后续直接通过id查询即可，不需要再查询数据库 4) 非核心业务降频排队 # 非核心业务可能会占用数据库并加锁，如果是io密集型，将其隔离并进行低优先级排队处理，防止阻塞核心业务 5) 连接池分离 # 不同业务的redis和数据库的连接池分离，核心业务和非核心业务分离，防止非核心业务占用核心业务连接池导致无法访问 6) 数据库写操作有区分按不同优先级同/异步落盘 # 使用代理服务进行sql语句插入，可以进行批量插入和数据可视化 仅针对非强实时性要求的数据 可以有日志和重试可靠性处理 7) 合并api请求数据 # 当某个请求过程中，api可以复用下发数据，减少api调用次数 不止客户端到服务端的数据复用，服务端内部的链路也同样可以复用数据 8) 高峰期分析 # 对于真实场景高峰期的cpu分析，找到是否数据库索引存在问题 对于需要计算类型的，提前进行预处理缓存，防止索引没命中导致的扫表 1.4. 优化效果 # 一个主节点带两个工作节点，40w并发15min登陆上线完成，cpu占用不超过30% 二、微博场景 # 2.1. twitter推送 # 场景 # 用户发布tweet，关注者在主页可以查看到其发布的消息，按照时间线排序 目标，3000w关注者5s内完成发布接收 方案 # 方案1\n使用关系型数据库，每个用户发tweet插入到全局tweet库 每个关注者查询全局tweet库，根据自己关注的用户进行查询，获取到按照时间线排序的结果 方案2\n使用redis对每个用户维护一个时间线缓存，类似邮箱 发布者发布tweet后，查询关注者，将tweet插入到所有关注者的时间线缓存中 对比\n方案1 方案2 优点 实现简单，发布tweet写入少 读负载降低，只需要读取缓存即可 缺点 全局tweet的读负载压力与日俱增 实现复杂，发布tweet写入多个关注者缓存中，大V情况下写入负载很高 结论 # twitter最后使用方案2的稳定实现，但是对于大V，使用方案1。使用混合方案可以达到很好的表现 三、秒杀系统 # 参考 https://blog.csdn.net/flynetcn/article/details/120228586#comments_30579499\n秒杀系统是针对短时间大量并发场景所考虑的系统，如果系统本身性能就存在优化点，不在这里考虑范围，参考上面的百万并发优化\n1. 电商系统架构 # 负载均衡层使用nginx，nginx的最大并发预估为10W+，万为单位 应用层使用tomcat，最大并发预估为800，百为单位 持久层 redis缓存的并发预估为5W，万为单位 mysql的最大并发预估为1000，千为单位 如何扩容 # 系统扩容，水平扩容和垂直扩容，增加设备机器数量或配置 缓存，本地缓存或集中式缓存，减少网络IO 读写分离，增加机器并行处理能力 2. 秒杀系统特点 # 2.1. 业务特点 # 12306举例，春运访问量特别大，平常访问量很平缓，春运期间会出现访问量瞬时激增\n小米秒杀系统，10点开售商品，10点前访问量比较平缓，10点出现并发量瞬时突增的现象\n所以秒杀系统的特点\n限时、限量、限价 活动预热，开始前用户可以查看活动信息 持续时间短，购买人数庞大，商品快速卖完 2.2. 技术特点 # 瞬时并发量高，大量用户同一时间抢购商品 读多写少，由于商品数量少，但是购买用户多，所以大量查询而购买少 流程简单，下单减库存 3. 秒杀系统流程 # 准备阶段，系统预热，由于用户不断刷新秒杀界面，一定程度上可以将一些数据存储到缓存中进行预热 秒杀阶段，这个阶段会瞬时产生高并发流量，对系统资源造成巨大冲击，需要做好系统防护 结算阶段，完成秒杀后的数据处理工作，数据一致性，异常处理，商品回仓处理等 对于这种短时间大量请求的系统来说，扩容不太合适，因为大部分场景下扩容的机器在闲置，仅部分场景下才需要这么大的流量请求\n4. 秒杀系统方案 # 考虑几个措施提升系统的性能\n4.1. 异步解耦 # 整体流程拆解，核心流程通过队列进行控制\n4.2. 限流防刷 # 控制整体流量，提高请求门槛，防止刷单，避免系统资源耗尽\n4.3. 资源控制 # 整体流程中对资源调度进行控制，扬长避短\n由于应用层的并发量比缓存少很多，而且比负载均衡层也少很多，考虑在负载均衡层访问缓存，避免到应用层的损耗\n并发量太高也可以将用户请求放到队列进行处理，弹出排队界面\n5. 秒杀系统时序图 # 5.1. 同步下单流程 # @startuml participant user box server participant nginx participant service database redis database mysql end box user-\u0026gt;nginx: 1. 发起秒杀请求 nginx-\u0026gt;service: service-\u0026gt;service: 验证码是否正确 service-\u0026gt;service: 活动是否结束 service-\u0026gt;service: 是否黑名单（拦截器统计访问频次） service\u0026lt;-\u0026gt;mysql: 真实库存是否足够 service\u0026lt;-\u0026gt;redis: 扣减缓存中的库存 service-\u0026gt;service: 计算秒杀价格 service-\u0026gt;user user-\u0026gt;nginx: 2. 提交订单 nginx-\u0026gt;service service-\u0026gt;mysql: 订单入库 service-\u0026gt;mysql: 扣减真实库存 service-\u0026gt;user @enduml 大部分网上的秒杀系统都是这个方案，在设备性能高且用户量不大的情况下，此方案是可以的。但是放到小米、淘宝、天猫、京东等秒杀和12306的场景，这个系统明显会被玩死\n5.2. 异步下单流程 # @startuml participant user box server participant nginx participant service database redis database mysql end box user-\u0026gt;nginx: 1. 发起秒杀请求 nginx\u0026lt;-\u0026gt;redis: 验证码是否正确 nginx\u0026lt;-\u0026gt;nginx: 是否限流 note over nginx 这里可以做限流判断，如果出售1000个商品 消息队列存在1000个请求，后续请求直接返回已售完 end note nginx-\u0026gt;nginx: 加入消息队列 nginx-\u0026gt;user: 发送排队界面 nginx-\u0026gt;service loop user-\u0026gt;nginx: 2. 短轮询探测是否获得秒杀资格 nginx-\u0026gt;redis: 查询是否生成Token nginx-\u0026gt;user end alt 异步执行 service-\u0026gt;service: 活动是否结束 service-\u0026gt;service: 是否黑名单（拦截器统计访问频次） service\u0026lt;-\u0026gt;redis: 扣减缓存中的库存 service-\u0026gt;redis: 生成Token end alt Token过期 service-\u0026gt;redis: 回滚秒杀商品库存 end user-\u0026gt;nginx: 3. 秒杀结算 nginx\u0026lt;-\u0026gt;redis: 验证下单Token nginx-\u0026gt;service service-\u0026gt;service: 加入秒杀购物车 service-\u0026gt;user user-\u0026gt;nginx: 4. 提交订单 nginx-\u0026gt;service service-\u0026gt;mysql: 订单入库 service-\u0026gt;mysql: 扣减真实库存 service-\u0026gt;redis: 删除Token service-\u0026gt;user @enduml 这里我们把限流前置，将高并发的削峰前置到请求阶段，业务层的流量就不是很高了。如果同步里面将限流放到业务层会让业务层压力大增，很有可能限流无法正常运行\n6. 高并发“黑科技”与制胜奇招 # 假设使用redis做缓存，redis的并发量在5W左右，而商城需要支持并发到100W左右，全部打到redis上会导致redis挂掉，如何解决这个问题。\n6.1. 分库 # 在Redis存储秒杀商品的库存数量可以分割来存储，对于每个id加上数字标识来存储。对key进行hash运算时，得到的结果不一样，大概率不在同一个槽位中。这样可以提升Redis处理请求的性能和并发量\n6.2. 移花接木 # 秒杀场景中，秒杀商品被瞬间抢购一空。如果用户再进行请求，转到业务层处理，再由业务层访问缓存或数据库，而业务层并发访问量是以百为单位的，大量请求积压也会降低并发度\n解决这个问题我们将商品扣减判断放到负载均衡层，使用lua脚本直接计算是否存在库存，不存在直接返回已售完，不再经过业务层处理。\n"},{"id":63,"href":"/docs/leetcode/simple/leetcode101/","title":"101. Symmetric Tree","section":"简单","content":" 题目 # Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\n思路1 # 分析 # 就是递归看节点左右子树是否对称嘛 代码实现 # 1func checkSymmetric(a *TreeNode, b *TreeNode) bool { 2\tif a == nil \u0026amp;\u0026amp; b == nil { 3\treturn true 4\t} 5\tif a == nil || b == nil { 6\treturn false 7\t} 8 9\treturn a.Val == b.Val \u0026amp;\u0026amp; checkSymmetric(a.Left, b.Right) \u0026amp;\u0026amp; checkSymmetric(a.Right, b.Left) 10} 11 12func isSymmetric(root *TreeNode) bool { 13\treturn checkSymmetric(root.Left, root.Right) 14} 思路2 # 分析 # 不用递归，搞两个链表，广度优先遍历，只不过顺序反一下 代码实现 # 1func isSymmetric(root *TreeNode) bool { 2\tif root.Left == nil \u0026amp;\u0026amp; root.Right == nil { 3\treturn true 4\t} 5\tif root.Left == nil || root.Right == nil { 6\treturn false 7\t} 8\tvar l list.List 9\tvar r list.List 10\tl.PushBack(root.Left) 11\tr.PushBack(root.Right) 12\tfor l.Len() != 0 { 13\tlt := l.Front().Value.(*TreeNode) 14\tl.Remove(l.Front()) 15\trt := r.Front().Value.(*TreeNode) 16\tr.Remove(r.Front()) 17\tif lt == nil \u0026amp;\u0026amp; rt == nil { 18\tcontinue 19\t} 20\tif (lt == nil || rt == nil) || lt.Val != rt.Val { 21\treturn false 22\t} 23 24\tl.PushBack(lt.Left) 25\tr.PushBack(rt.Right) 26\tl.PushBack(lt.Right) 27\tr.PushBack(rt.Left) 28\t} 29\treturn true 30} "},{"id":64,"href":"/docs/leetcode/medium/leetcode155/","title":"155. Min Stack","section":"中等","content":" 题目 # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.\nExample 1:\nInput [\u0026#34;MinStack\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;push\u0026#34;,\u0026#34;getMin\u0026#34;,\u0026#34;pop\u0026#34;,\u0026#34;top\u0026#34;,\u0026#34;getMin\u0026#34;] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 Constraints:\n$-2^{31} \u0026lt;= val \u0026lt;= 2^{31} - 1$ Methods pop, top and getMin operations will always be called on non-empty stacks. At most $3 \\times 10^4$ calls will be made to push, pop, top, and getMin. 思路1 两个栈 # 分析 # 用一个栈存最小值，一个栈存值 节省空间就当值小于等于最小值才入最小值栈，同理只要出栈等于最小值，就出最小值栈 代码 # 1type MinStack3 struct { 2\tstack []int 3\tminStack []int 4} 5 6func Constructor3() MinStack { 7\treturn \u0026amp;MinStack3{ 8\tstack: make([]int, 0), 9\tminStack: make([]int, 0), 10\t} 11} 12 13func (this *MinStack3) Push(val int) { 14\tthis.stack = append(this.stack, val) 15\tif len(this.minStack) == 0 || val \u0026lt;= this.minStack[len(this.minStack)-1] { 16\tthis.minStack = append(this.minStack, val) 17\t} 18} 19 20func (this *MinStack3) Pop() { 21\tif len(this.stack) == 0 { 22\treturn 23\t} 24\tv := this.stack[len(this.stack)-1] 25\tthis.stack = this.stack[:len(this.stack)-1] 26\tif this.minStack[len(this.minStack)-1] == v { 27\tthis.minStack = this.minStack[:len(this.minStack)-1] 28\t} 29} 30 31func (this *MinStack3) Top() int { 32\treturn this.stack[len(this.stack)-1] 33} 34 35func (this *MinStack3) GetMin() int { 36\treturn this.minStack[len(this.minStack)-1] 37} 思路2 一个栈，存放值和最小值 # 分析 # 如何使用一个栈，考虑将最小值也放到这个栈里面，那么就是当值小于等于最小值时，先push前一次最小值，再push值 出栈时，如果值和当前最小值一样，下一个就是前一次最小值 代码 # 1type MinStack2 struct { 2\tstack []int 3\tmin int 4} 5 6func Constructor2() MinStack { 7\treturn \u0026amp;MinStack2{ 8\tstack: make([]int, 0), 9\tmin: math.MaxInt, 10\t} 11} 12 13func (this *MinStack2) Push(val int) { 14\tif val \u0026lt;= this.min { 15\tthis.stack = append(this.stack, this.min) 16\tthis.min = val 17\t} 18\tthis.stack = append(this.stack, val) 19} 20 21func (this *MinStack2) Pop() { 22\tif len(this.stack) == 0 { 23\treturn 24\t} 25\tv := this.stack[len(this.stack)-1] 26\tthis.stack = this.stack[:len(this.stack)-1] 27\tif v == this.min { 28\tthis.min = this.stack[len(this.stack)-1] 29\tthis.stack = this.stack[:len(this.stack)-1] 30\t} 31} 32 33func (this *MinStack2) Top() int { 34\treturn this.stack[len(this.stack)-1] 35} 36 37func (this *MinStack2) GetMin() int { 38\treturn this.min 39} 思路3 一个栈，存放值和最小值的差值 # 分析 # 一个栈加当前的int可以存放两个信息，如果栈里面存放的是值和当前最小值的差值就可以办到 入栈没什么说的，先入差值再判断是不是要更新最小值，因为先更新最小值会把前一次最小值的信息丢失掉 出栈就比较精髓了，当出栈的值小于0，说明入栈时值小于最小值，那么最小值就是当前值，而前一次最小值可以用当前值减去差值算出来 代码 # 1type MinStack1 struct { 2\tstack []int 3\tmin int 4} 5 6func Constructor() MinStack { 7\treturn \u0026amp;MinStack1{ 8\tstack: make([]int, 0), 9\tmin: math.MaxInt, 10\t} 11} 12 13func (this *MinStack1) Push(val int) { 14\tif len(this.stack) == 0 { 15\tthis.min = val 16\tthis.stack = append(this.stack, val-this.min) 17\t} else { 18\tthis.stack = append(this.stack, val-this.min) 19\tif val \u0026lt; this.min { 20\tthis.min = val 21\t} 22\t} 23} 24 25func (this *MinStack1) Pop() { 26\tif len(this.stack) == 0 { 27\treturn 28\t} 29\tv := this.stack[len(this.stack)-1] 30\tthis.stack = this.stack[:len(this.stack)-1] 31\tif v \u0026lt; 0 { 32\tthis.min -= v 33\t} 34} 35 36func (this *MinStack1) Top() int { 37\tv := this.stack[len(this.stack)-1] 38\tif v \u0026lt; 0 { 39\treturn this.min 40\t} 41\treturn this.min + v 42} 43 44func (this *MinStack1) GetMin() int { 45\treturn this.min 46} "},{"id":65,"href":"/docs/leetcode/medium/leetcode322/","title":"322. Coin Change","section":"中等","content":" 题目 # You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.\n思路1 # 分析 # 自己想的记忆化搜索，假设凑够钱数为n的最小硬币数为 $f(n)$ $$ f(n) = \\left\\{ \\begin{array}{ll} 1 \u0026amp; n == coins[i] \\\\ MaxInt \u0026amp; n \u0026lt; coins[i] \\\\ \\min(f(n-coins[0]), f(n-coins[1]\u0026hellip;)) + 1 \u0026amp; other \\end{array} \\right. $$\n代码实现 # 1func getMinCount(coins []int, amount int, amountMap []int) int { 2\tif amount \u0026lt; 0 { 3\treturn -1 4\t} 5\tif amount == 0 { 6\treturn 0 7\t} 8\tif amountMap[amount] != 0 { 9\treturn amountMap[amount] 10\t} 11 12\t// 根据coins遍历，取所有方案最小的 13\tminCount := -1 14\tfor i := len(coins); i \u0026gt; 0; i-- { 15\tif amount \u0026lt; coins[i-1] { 16\tcontinue 17\t} 18\tif amount == coins[i-1] { 19\tamountMap[amount] = 1 20\treturn 1 21\t} 22\ttmp := getMinCount(coins, amount-coins[i-1], amountMap) 23\tif tmp \u0026lt; 0 { 24\tcontinue 25\t} 26\tif minCount \u0026lt; 0 { 27\tminCount = tmp 28\tcontinue 29\t} 30\tif tmp \u0026lt; minCount { 31\tminCount = tmp 32\t} 33\t} 34\tif minCount \u0026gt;= 0 { 35\tamountMap[amount] = minCount + 1 36\treturn minCount + 1 37\t} 38\tamountMap[amount] = -1 39\treturn -1 40} 思路2 # 分析 # 记忆化搜索转换一下思路就是动态规划，从0开始计算，一直计算到amount 代码实现 # 1func min(a, b int) int { 2\tif a \u0026gt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func coinChange1(coins []int, amount int) int { 9\tif amount == 0 { 10\treturn 0 11\t} 12\tamountMap := make([]int, amount+1) 13\tfor i := 1; i \u0026lt;= amount; i++ { 14\tamountMap[i] = math.MaxInt 15\tfor _, v := range coins { 16\tif i \u0026lt; v { 17\tcontinue 18\t} 19\tamountMap[i] = min(amountMap[i]-1, amountMap[i-v]) + 1 20\t} 21\t} 22\tif amountMap[amount] == math.MaxInt { 23\treturn -1 24\t} 25\treturn amountMap[amount] 26} "},{"id":66,"href":"/docs/leetcode/hard/leetcode327/","title":"327. Count of Range Sum","section":"困难","content":" 题目 # Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i \u0026lt;= j.\nExample 1:\nInput: nums = [-2,5,-1], lower = -2, upper = 2 Output: 3 Explanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2. Example 2:\nInput: nums = [0], lower = 0, upper = 0 Output: 1 Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $-2^{31} \u0026lt;= nums[i] \u0026lt;= 2^{31} - 1$ $-10^5 \u0026lt;= lower \u0026lt;= upper \u0026lt;= 10^5$ The answer is guaranteed to fit in a 32-bit integer. 思路1 线段树 # 分析 # 先把问题转化一下，求某个区间和，使用前缀和进行简化。区间和变成端点之间的差，问题转化为对于固定右端点j，在[0, j)之间找符合lower \u0026lt;= preSum[j]-preSum[i] \u0026lt;= upper 转成，在[0, j)找preSum[j]-upper \u0026lt;= preSum[i] \u0026lt;= preSum[j]-lower的数量 代码 # 1func min(a, b int) int { 2\tif a \u0026gt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func paintWalls(cost []int, time []int) int { 9\tn := len(cost) 10 11\tmMap := make([]map[int]int, n) 12\tfor i := range mMap { 13\tmMap[i] = make(map[int]int) 14\t} 15\t// 选和不选代价和时间花费不一样，可以认为付费的时间和花费是正的，免费的时间是负的，花费为0 16\t// 最终求得是时间不为负数的花费最小值 17\tvar dfs func(i, t int) int 18\tdfs = func(i, t int) int { 19\tif t \u0026gt; i { 20\treturn 0 21\t} 22\tif i \u0026lt; 0 { 23\treturn math.MaxInt / 2 24\t} 25\tif mMap[i][t] \u0026gt; 0 { 26\treturn mMap[i][t] 27\t} 28\t// 为当前免费和当前不免费的最小值 29\tres := min(dfs(i-1, t-1), dfs(i-1, t+time[i])+cost[i]) 30\tmMap[i][t] = res 31\treturn res 32\t} 33\treturn dfs(n-1, 0) 34} "},{"id":67,"href":"/docs/leetcode/hard/leetcode440/","title":"440. K-th Smallest in Lexicographical Order","section":"困难","content":" 题目 # Given two integers n and k, return the $k^{th}$ lexicographically smallest integer in the range [1, n].\nExample 1:\nInput: n = 13, k = 2 Output: 10 Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10. Example 2:\nInput: n = 1, k = 1 Output: 1 Constraints:\n$1 \\le k \\le n \\le 10^9$\n思路1，字典树 # 分析 # 字典序，那么使用一个树进行整理更加清晰一些\n前序遍历就是字典序\n关键点1，第k个怎么找。从图中可以看出来，使用前序遍历\n如果某个节点的所有子节点个数小于k，那么第k个节点一定不在此节点的子树内，找下一个兄弟节点 如果某个节点的所有子节点个数大于k，那么第k个节点一定在此节点的子树内，可以从此节点的子节点继续计算 关键点2，如何计算当前节点的子节点个数。可以一层一层计算，假设取1的子节点。\n第一层，10-19 第二层，100-199 第三层，1000-1999 如果k是1开头的，那么在某一层，一定存在k。如果k不是1开头的，那么存在一层，起始就大于k\n代码实现 # 因为用go写，int在64位是64位，所以不存在使用c++时需要考虑32位溢出的情况 1func min(a, b int) int { 2\tif a \u0026lt; b { 3\treturn a 4\t} 5\treturn b 6} 7 8// 获取当前节点的子节点个数，n为总数 9func getChildCount(cur int, n int) int { 10\t// 假设cur为1，第一层为10-19 11\t// 第二层100-199 12\t// 第三层1000-1999 13\tcount := 0 14\tstart := cur * 10 15\tend := start + 9 16\tfor start \u0026lt;= n { 17\t// n为13，那么这一层就是13-10+1=4个节点 18\tcount += min(end, n) - start + 1 19\tstart *= 10 20\tend = end*10 + 9 21\t} 22\treturn count 23} 24 25func findKthNumber(n int, k int) int { 26\tcur := 1 27\tk-- // k为0时，cur就是所求。如果k为1，那么返回第一个也就是1，所以这里减一 28\tfor k \u0026gt; 0 { 29\t// 获取当前节点的子节点个数 30\tcount := getChildCount(cur, n) 31\t// 当k大于当前节点的子节点数，假设n为11，k为4。 1 10 11 2 3 4 5 6 7 8 9 32\t// 到这里k为3，count为2，计算后k为0，cur为2 33\tif k \u0026gt; count { 34\tk -= count + 1 35\tcur++ 36\tcontinue 37\t} 38\t// k小于等于count 39\t// 小于的情况，假设n为11，k为2。 1 10 11 2 3 4 5 6 7 8 9 40\t// 到这里k为1，count为2，计算后k为0，cur为10 41\t// 等于的情况，假设k为3 42\t// 到这里k为2，计算后k为1，cur为10 43\tcur *= 10 44\tk-- 45\t} 46\treturn cur 47} 考虑32位溢出的情况 1func min(a, b int64) int64 { 2\tif a \u0026lt; b { 3\treturn a 4\t} 5\treturn b 6} 7 8// 获取当前节点的子节点个数，n为总数 9func getChildCount(cur int32, n int32) int64 { 10\t// 假设cur为1，第一层为10-19 11\t// 第二层100-199 12\t// 第三层1000-1999 13\tvar count int64 = 0 14\tvar start int64 = int64(cur * 10) 15\tvar end int64 = start + 9 16\tfor start \u0026lt;= int64(n) { 17\t// n为13，那么这一层就是13-10+1=4个节点 18\tcount += min(end, int64(n)) - start + 1 19\tstart *= 10 20\tend = end*10 + 9 21\t} 22\treturn count 23} 24 25func findKthNumber(n int32, k int32) int32 { 26\tvar cur int32 = 1 27\tk-- // k为0时，cur就是所求。如果k为1，那么返回第一个也就是1，所以这里减一 28\tfor k \u0026gt; 0 { 29\t// 获取当前节点的子节点个数 30\tcount := getChildCount(cur, n) 31\t// 当k大于当前节点的子节点数，假设n为11，k为4。 1 10 11 2 3 4 5 6 7 8 9 32\t// 到这里k为3，count为2，计算后k为0，cur为2 33\tif int64(k) \u0026gt; count { 34\tk -= int32(count + 1) 35\tcur++ 36\tcontinue 37\t} 38\t// k小于等于count 39\t// 小于的情况，假设n为11，k为2。 1 10 11 2 3 4 5 6 7 8 9 40\t// 到这里k为1，count为2，计算后k为0，cur为10 41\t// 等于的情况，假设k为3 42\t// 到这里k为2，计算后k为1，cur为10 43\tcur *= 10 44\tk-- 45\t} 46\treturn cur 47} "},{"id":68,"href":"/docs/leetcode/medium/leetcode658/","title":"658. Find K Closest Elements","section":"中等","content":" 题目 # Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.\nAn integer a is closer to x than an integer b if:\n|a - x| \u0026lt; |b - x|, or |a - x| == |b - x| and a \u0026lt; b 思路1 # 分析 # 双指针法，找到最接近x的数字，然后直接两边开始遍历 代码实现 # 1func findClosestElements2(arr []int, k int, x int) []int { 2\tright := sort.SearchInts(arr, x) 3\tleft := right - 1 4\tif left \u0026lt; 0 { 5\treturn arr[:k] 6\t} 7\tfor right-left \u0026lt; k+1 { 8\tif left \u0026lt; 0 { 9\tright++ 10\t} else if right \u0026gt;= len(arr) || arr[left]+arr[right] \u0026gt;= x+x { 11\tleft-- 12\t} else { 13\tright++ 14\t} 15\t} 16\treturn arr[left+1 : right] 17} 思路2 # 分析 # 写一个自定义cmp，直接排序取前k个 代码实现 # 1func abs(x int) int { 2\tif x \u0026lt; 0 { 3\treturn -x 4\t} 5\treturn x 6} 7 8func findClosestElements1(arr []int, k int, x int) []int { 9\tsort.SliceStable(arr, func(i, j int) bool { return abs(arr[i]-x) \u0026lt; abs(arr[j]-x) }) 10\tarr = arr[:k] 11\tsort.Ints(arr) 12\treturn arr 13} "},{"id":69,"href":"/docs/leetcode/simple/leetcode706/","title":"706. Design HashMap","section":"简单","content":" 题目 # Design a HashMap without using any built-in hash table libraries.\nImplement the MyHashMap class:\nMyHashMap() initializes the object with an empty map. void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. 思路1 # 分析 # key是int的hashMap，那不是直接初始化一个int大小的数组，直接索引就好了 没值的是-1，那就直接初始化为-1 尝试出来最大的key是1000000，那就直接上代码 代码实现 # 1package main 2 3type MyHashMap struct { 4\tdata []int 5} 6 7func Constructor() (this MyHashMap) { 8\tthis.data = make([]int, 1e6 + 1) 9\tfor i := range this.data { 10\tthis.data[i] = -1 11\t} 12\treturn 13} 14 15func (this *MyHashMap) Put(key int, value int) { 16\tthis.data[key] = value 17} 18 19func (this *MyHashMap) Get(key int) int { 20\treturn this.data[key] 21} 22 23func (this *MyHashMap) Remove(key int) { 24\tthis.data[key] = -1 25} 26 27/** 28 * Your MyHashMap object will be instantiated and called as such: 29 * obj := Constructor(); 30 * obj.Put(key,value); 31 * param_2 := obj.Get(key); 32 * obj.Remove(key); 33 */ 思路2 # 分析 # 上面方法纯属搞笑，忽略即可，只是因为思维局限在使用数组实现hash，嫌数组实现链表太麻烦不想写，没有想到可以直接使用链表 正常hashMap使用数组和链表进行实现 除数使用素数，找了个1000以内的最大素数也就是997 代码实现 # 1package main 2 3import ( 4\t\u0026#34;container/list\u0026#34; 5) 6 7const base = 997 8 9type dataT struct { 10\tkey int 11\tvalue int 12} 13 14type MyHashMap struct { 15\tdata []list.List 16} 17 18func Constructor1() (this MyHashMap) { 19\tthis.data = make([]list.List, base, base) 20\treturn 21} 22 23func (this *MyHashMap) Put(key int, value int) { 24\th := key % base 25\tfor e := this.data[h].Front(); e != nil; e = e.Next() { 26\tif et := e.Value.(dataT); et.key == key { 27\te.Value = dataT{key, value} 28\treturn 29\t} 30\t} 31\tthis.data[h].PushBack(dataT{key, value}) 32} 33 34func (this *MyHashMap) Get(key int) int { 35\th := key % base 36\tfor e := this.data[h].Front(); e != nil; e = e.Next() { 37\tif et := e.Value.(dataT); et.key == key { 38\treturn et.value 39\t} 40\t} 41\treturn -1 42} 43 44func (this *MyHashMap) Remove(key int) { 45\th := key % base 46\tfor e := this.data[h].Front(); e != nil; e = e.Next() { 47\tif et := e.Value.(dataT); et.key == key { 48\tthis.data[h].Remove(e) 49\treturn 50\t} 51\t} 52} 53 54/** 55 * Your MyHashMap object will be instantiated and called as such: 56 * obj := Constructor(); 57 * obj.Put(key,value); 58 * param_2 := obj.Get(key); 59 * obj.Remove(key); 60 */ "},{"id":70,"href":"/docs/leetcode/hard/leetcode736/","title":"736. Parse Lisp Expression","section":"困难","content":" 题目 # You are given a string expression representing a Lisp-like expression to return the integer value of.\nThe syntax for these expressions is given as follows.\nAn expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer. (An integer could be positive or negative.) A let expression takes the form \u0026ldquo;(let v1 e1 v2 e2 \u0026hellip; vn en expr)\u0026rdquo;, where let is always the string \u0026ldquo;let\u0026rdquo;, then there are one or more pairs of alternating variables and expressions, meaning that the first variable v1 is assigned the value of the expression e1, the second variable v2 is assigned the value of the expression e2, and so on sequentially; and then the value of this let expression is the value of the expression expr. An add expression takes the form \u0026ldquo;(add e1 e2)\u0026rdquo; where add is always the string \u0026ldquo;add\u0026rdquo;, there are always two expressions e1, e2 and the result is the addition of the evaluation of e1 and the evaluation of e2. A mult expression takes the form \u0026ldquo;(mult e1 e2)\u0026rdquo; where mult is always the string \u0026ldquo;mult\u0026rdquo;, there are always two expressions e1, e2 and the result is the multiplication of the evaluation of e1 and the evaluation of e2. For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names \u0026ldquo;add\u0026rdquo;, \u0026ldquo;let\u0026rdquo;, and \u0026ldquo;mult\u0026rdquo; are protected and will never be used as variable names. Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope. Example 1:\nInput: expression = \u0026#34;(let x 2 (mult x (let x 3 y 4 (add x y))))\u0026#34; Output: 14 Explanation: In the expression (add x y), when checking for the value of the variable x, we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate. Since x = 3 is found first, the value of x is 3. Example 2:\nInput: expression = \u0026#34;(let x 3 x 2 x)\u0026#34; Output: 2 Explanation: Assignment in let statements is processed sequentially. Example 3:\nInput: expression = \u0026#34;(let x 1 y 2 x (add x y) (add x y))\u0026#34; Output: 5 Explanation: The first (add x y) evaluates as 3, and is assigned to x. The second (add x y) evaluates as 3+2 = 5. Constraints:\n1 \u0026lt;= expression.length \u0026lt;= 2000 There are no leading or trailing spaces in expression. All tokens are separated by a single space in expression. The answer and all intermediate calculations of that answer are guaranteed to fit in a 32-bit integer. The expression is guaranteed to be legal and evaluate to an integer. 思路1 # 分析 # 分析此题是要用递归，并且要注意表达式作用域 首先需要对表达式进行解析，将每一个表达式解析成数组，这一步是需要将括号完整解析 1// parseExpression, preprocess the expression 2// convert \u0026#39;(let x 1 y 2 (let x 2 y (add 1 2) x))\u0026#39; to [\u0026#39;let\u0026#39; \u0026#39;x\u0026#39; \u0026#39;1\u0026#39; \u0026#39;y\u0026#39; \u0026#39;2\u0026#39; \u0026#39;(let x 2 y (add 1 2) x)\u0026#39;] 3func parseExpression(expression string) (result []string) 然后需要解析value value是变量，从作用域中取值 表达式，递归求值传入作用域 数字，解析 1// getValue, get value of input 2// number =\u0026gt; number 3// var =\u0026gt; paramMap[var] 4// expression =\u0026gt; parse(expression) 5func getValue(input string, paramMap map[string]int) int 重点来了，真正解析的函数，需要控制变量作用域，每一次递归，将上层的变量拷贝一份，生成自己的变量map 1// parse (let e1 v1 e2 v2 expr) 2// will copy paramMap and make itself paramMap1 3func parse(expression string, paramMap map[string]int) int 代码实现 # 1package main 2 3import ( 4\t_ \u0026#34;fmt\u0026#34; 5\t\u0026#34;strconv\u0026#34; 6) 7 8// parseExpression, preprocess the expression 9// convert \u0026#39;(let x 1 y 2 (let x 2 y (add 1 2) x))\u0026#39; to [\u0026#39;let\u0026#39; \u0026#39;x\u0026#39; \u0026#39;1\u0026#39; \u0026#39;y\u0026#39; \u0026#39;2\u0026#39; \u0026#39;(let x 2 y (add 1 2) x)\u0026#39;] 10func parseExpression(expression string) (result []string) { 11\tif expression[0] != \u0026#39;(\u0026#39; || expression[len(expression)-1] != \u0026#39;)\u0026#39; { 12\tpanic(\u0026#34;expression not valid\u0026#34;) 13\t} 14 15\tfor index := 1; index \u0026lt; len(expression)-1; index++ { 16\t// find full () 17\tif expression[index] == \u0026#39;(\u0026#39; { 18\tstack := 1 19\ti := index + 1 20\tfor ; i \u0026lt; len(expression); i++ { 21\tif expression[i] == \u0026#39;(\u0026#39; { 22\tstack++ 23\tcontinue 24\t} 25 26\tif expression[i] == \u0026#39;)\u0026#39; { 27\tstack-- 28\tif stack == 0 { 29\tbreak 30\t} 31\t} 32\t} 33 34\tresult = append(result, expression[index:i+1]) 35\tindex = i + 1 36\tcontinue 37\t} 38 39\t// find next space 40\ti := index + 1 41\tfor ; i \u0026lt; len(expression); i++ { 42\tif expression[i] == \u0026#39; \u0026#39; { 43\tbreak 44\t} 45\t} 46\tif i == len(expression) { 47\tresult = append(result, expression[index:len(expression)-1]) 48\tbreak 49\t} 50\tresult = append(result, expression[index:i]) 51\tindex = i 52\t} 53\treturn 54} 55 56// getValue, get value of input 57// number =\u0026gt; number 58// var =\u0026gt; paramMap[var] 59// expression =\u0026gt; parse(expression) 60func getValue(input string, paramMap map[string]int) int { 61\tif input[0] == \u0026#39;(\u0026#39; { 62\treturn parse(input, paramMap) 63\t} 64\tif v, ok := paramMap[input]; ok { 65\treturn v 66\t} 67\ttmp, err := strconv.ParseInt(input, 10, 64) 68\tif err != nil { 69\tpanic(err) 70\t} 71\treturn int(tmp) 72} 73 74// parse (let e1 v1 e2 v2 expr) 75// will copy paramMap and make itself paramMap1 76func parse(expression string, paramMap map[string]int) int { 77\tif expression[0] != \u0026#39;(\u0026#39; || expression[len(expression)-1] != \u0026#39;)\u0026#39; { 78\tpanic(\u0026#34;expression not valid\u0026#34;) 79\t} 80\tparamMap1 := make(map[string]int) 81\t// copy paramMap 82\tfor k, v := range paramMap { 83\tparamMap1[k] = v 84\t} 85 86\t// split expression to array 87\tarr := parseExpression(expression) 88\tif arr[0] == \u0026#34;add\u0026#34; || arr[0] == \u0026#34;mult\u0026#34; { 89\tif len(arr) != 3 { 90\tpanic(\u0026#34;add need three element, \u0026#34; + expression) 91\t} 92 93\tif arr[0] == \u0026#34;add\u0026#34; { 94\treturn getValue(arr[1], paramMap1) + getValue(arr[2], paramMap1) 95\t} 96\treturn getValue(arr[1], paramMap1) * getValue(arr[2], paramMap1) 97\t} 98 99\tif arr[0] == \u0026#34;let\u0026#34; { 100\t// make self scope 101\tfor i := 2; i \u0026lt; len(arr)-1; i += 2 { 102\tparamMap1[arr[i-1]] = getValue(arr[i], paramMap1) 103\t} 104\treturn getValue(arr[len(arr)-1], paramMap1) 105\t} 106\tpanic(\u0026#34;not support \u0026#34; + arr[0]) 107} 108 109func evaluate(expression string) int { 110\treturn parse(expression, nil) 111} "},{"id":71,"href":"/docs/leetcode/hard/leetcode864/","title":"864. Shortest Path to Get All Keys","section":"困难","content":" 题目 # You are given an m x n grid grid where:\n\u0026lsquo;.\u0026rsquo; is an empty cell. \u0026lsquo;#\u0026rsquo; is a wall. \u0026lsquo;@\u0026rsquo; is the starting point. Lowercase letters represent keys. Uppercase letters represent locks. You start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 \u0026lt;= k \u0026lt;= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n思路1 # 分析 # 自己没想出来，使用官方解法 使用bfs可以计算点到其他点的距离 使用全排列将所有钥匙位置顺序给出来，使用bfs直接找所有方案步数，然后返回最小 代码实现 # 1type pointT struct { 2\tx int 3\ty int 4} 5 6var ( 7\t// 按照上下左右的相对位置设定，用于后面方便找四周的点 8\tkRoundPoints = [][]int{ 9\t{0, -1}, 10\t{0, 1}, 11\t{-1, 0}, 12\t{1, 0}, 13\t} 14) 15 16func shortestPathAllKeys(grid []string) int { 17\t// location[\u0026#39;a\u0026#39;] is the (x, y) of a 18\tlocation := make(map[byte]pointT) 19\tfor i := 0; i \u0026lt; len(grid); i++ { 20\tfor j := 0; j \u0026lt; len(grid[0]); j++ { 21\tch := grid[i][j] 22\tif ch != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; ch != \u0026#39;#\u0026#39; { 23\tlocation[ch] = pointT{j, i} 24\t} 25\t} 26\t} 27\tkeyNums := len(location) / 2 28\t// 枚举到所有的钥匙，题目条件只会从a-b、a-c、a-d、a-e、a-f几种情况 29\talphabet := make([]byte, keyNums) 30\tfor i := 0; i \u0026lt; keyNums; i++ { 31\talphabet[i] = byte(\u0026#39;a\u0026#39; + i) 32\t} 33 34\tres := -1 35\tpermutation(alphabet, 0, func(str []byte) { 36\tans := 0 37\tkeymask := 0 38\tfor i := 0; i \u0026lt; len(str); i++ { 39\tvar src byte 40\tif i == 0 { 41\tsrc = \u0026#39;@\u0026#39; 42\t} else { 43\tsrc = alphabet[i-1] 44\t} 45\ttmp := bfs(location[src], location[alphabet[i]], grid, keymask) 46\tif tmp == -1 { 47\treturn 48\t} 49\tans += tmp 50\tkeymask |= 1 \u0026lt;\u0026lt; (alphabet[i] - \u0026#39;a\u0026#39;) 51\t} 52\tif res == -1 || ans \u0026lt; res { 53\tres = ans 54\t} 55\t}) 56\treturn res 57} 58 59// 全排列 60func permutation(str []byte, index int, f func(str []byte)) { 61\tif len(str) == index { 62\tf(str) 63\treturn 64\t} 65 66\t// 不交换的场景 67\tpermutation(str, index+1, f) 68\t// index对应位置向后交换 69\tfor i := index + 1; i \u0026lt; len(str); i++ { 70\tstr[i], str[index] = str[index], str[i] 71\tpermutation(str, index+1, f) 72\tstr[i], str[index] = str[index], str[i] 73\t} 74} 75 76// 计算src到dst的最短路径长度，keymask为按位标记某个钥匙是否已找到 77// 返回从src到dst的最短路径长度 78func bfs(src pointT, dst pointT, grid []string, keymask int) int { 79\t// 减小计算量，走过的路不再走，记录一下哪里走过了 80\tseen := make([][]bool, len(grid)) 81\tfor i := range seen { 82\tseen[i] = make([]bool, len(grid[0])) 83\t} 84\t// 源地址记录走过了，注意x是第二维的坐标 85\tseen[src.y][src.x] = true 86 87\t// 使用层数作为步数 88\tcurDepth := 0 89\tvar queue list.List 90\t// 插入源地址，作为第一层，使用nil作为层间隔 91\tqueue.PushBack(src) 92\tqueue.PushBack(nil) 93\t// 队列一定含有一个层间隔，不在头就在尾，如果只剩一个层间隔，说明没路可走 94\tfor queue.Len() \u0026gt; 1 { 95\ttmp := queue.Front().Value 96\tqueue.Remove(queue.Front()) 97\tif tmp == nil { 98\t// 找到层间隔，说明当前层遍历完了，步数加一准备下一层 99\tcurDepth++ 100\t// 当前层遍历完，队列剩余的都是下一层，加入一个层间隔 101\tqueue.PushBack(nil) 102\tcontinue 103\t} 104 105\t// 判断当前点是不是目标点，如果是，说明走到了，返回步数 106\ttx, ty := tmp.(pointT).x, tmp.(pointT).y 107\tif tx == dst.x \u0026amp;\u0026amp; ty == dst.y { 108\treturn curDepth 109\t} 110\t// 不是目标点，从此点出发，向四周走一下 111\tfor i := range kRoundPoints { 112\tpx, py := tx+kRoundPoints[i][0], ty+kRoundPoints[i][1] 113\t// 如果超出边界或者已经走过了或者碰到墙，就继续 114\tif py \u0026lt; 0 || py \u0026gt;= len(grid) || px \u0026lt; 0 || px \u0026gt;= len(grid[0]) || seen[py][px] || grid[py][px] == \u0026#39;#\u0026#39; { 115\tcontinue 116\t} 117\tch := grid[py][px] 118\t// 如果是锁，看一下有没有钥匙，没有钥匙就跳过 119\tif (ch \u0026lt;= \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; ch \u0026gt;= \u0026#39;A\u0026#39;) \u0026amp;\u0026amp; ((1\u0026lt;\u0026lt;(ch-\u0026#39;A\u0026#39;))\u0026amp;keymask) == 0 { 120\tcontinue 121\t} 122\t// 这个点可以走，走上去，记录到队列中，作为下一层的起点 123\tseen[py][px] = true 124\tqueue.PushBack(pointT{px, py}) 125\t} 126\t} 127\treturn -1 128} 思路2 # 分析 # 来自网上其他网友的方案，使用bfs，但是将状态加到bfs判断中，也就是三维的bfs 代码 # 1type pointST struct { 2\tx int 3\ty int 4\tstep int 5\tstate int 6} 7 8func shortestPathAllKeys1(grid []string) int { 9\t// location[\u0026#39;a\u0026#39;] is the (x, y) of a 10\tlocation := make(map[byte]pointST) 11\tfor i := 0; i \u0026lt; len(grid); i++ { 12\tfor j := 0; j \u0026lt; len(grid[0]); j++ { 13\tch := grid[i][j] 14\tif ch != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; ch != \u0026#39;#\u0026#39; { 15\tlocation[ch] = pointST{j, i, 0, 0} 16\t} 17\t} 18\t} 19\tkeyNums := len(location) / 2 20\tfinalState := (1 \u0026lt;\u0026lt; keyNums) - 1 21 22\t// 将钥匙的持有状态作为判断成三维的bfs 23\treturn bfsThree(location[\u0026#39;@\u0026#39;], grid, finalState) 24} 25 26// 将钥匙的持有状态作为判断成三维的bfs 27func bfsThree(src pointST, grid []string, finalState int) int { 28\tsx, sy := src.x, src.y 29 30\t// 减小计算量，走过的路不再走，记录一下哪里走过了 31\tseen := make([][][]bool, len(grid)) 32\tfor i := range seen { 33\tseen[i] = make([][]bool, len(grid[0])) 34\tfor j := range seen[i] { 35\tseen[i][j] = make([]bool, finalState+1) 36\t} 37\t} 38\tseen[sy][sx][0] = true 39 40\tvar queue list.List 41\tqueue.PushBack(src) 42\tfor queue.Len() \u0026gt; 0 { 43\ttmp := queue.Front().Value 44\tqueue.Remove(queue.Front()) 45 46\t// 判断当前点是不是已经达成目标 47\ttx, ty, step, state := tmp.(pointST).x, tmp.(pointST).y, tmp.(pointST).step, tmp.(pointST).state 48\tif state == finalState { 49\treturn step 50\t} 51\t// 不是目标点，从此点出发，向四周走一下 52\tfor i := range kRoundPoints { 53\tpx, py := tx+kRoundPoints[i][0], ty+kRoundPoints[i][1] 54\t// 如果超出边界或者碰到墙，就继续 55\tif py \u0026lt; 0 || py \u0026gt;= len(grid) || px \u0026lt; 0 || px \u0026gt;= len(grid[0]) || grid[py][px] == \u0026#39;#\u0026#39; { 56\tcontinue 57\t} 58\t// 判断是否曾以相同状态要走过这个点 59\tif seen[py][px][state] { 60\tcontinue 61\t} 62\tch := grid[py][px] 63\t// 如果是锁，看一下有没有钥匙，没有钥匙就跳过 64\tif (ch \u0026lt;= \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; ch \u0026gt;= \u0026#39;A\u0026#39;) \u0026amp;\u0026amp; ((1\u0026lt;\u0026lt;(ch-\u0026#39;A\u0026#39;))\u0026amp;state) == 0 { 65\tcontinue 66\t} 67\t// 可以踩上去，就记录踩上去前的状态 68\tseen[py][px][state] = true 69\t// 如果是钥匙，保存新的状态到队列中 70\ttmpState := state 71\tif ch \u0026lt;= \u0026#39;z\u0026#39; \u0026amp;\u0026amp; ch \u0026gt;= \u0026#39;a\u0026#39; { 72\ttmpState |= (1 \u0026lt;\u0026lt; (ch - \u0026#39;a\u0026#39;)) 73\t} 74\t// 记录到队列中，作为下一层的点 75\tqueue.PushBack(pointST{px, py, step + 1, tmpState}) 76\t} 77\t} 78\treturn -1 79} 思路3 # 分析 # 来自官方的方案，将每个钥匙和key都作为关键点，计算出所有关键点之间的距离（不解锁） 相当于如果要从a解锁A到达b，那么关键点就是a -\u0026gt; A+A -\u0026gt; b，而不是a到b 计算出来之后，这个map进行Dijkastra算法，计算到达某个状态下的最低步数 代码 # 1type pointTT struct { 2\tx int 3\ty int 4\tstep int 5\tstate int 6} 7 8type littleQueue []pointTT 9 10func (q *littleQueue) Push(v interface{}) { 11\t*q = append(*q, v.(pointTT)) 12} 13func (q *littleQueue) Pop() interface{} { 14\tx := (*q)[len(*q)-1] 15\t*q = (*q)[:len(*q)-1] 16\treturn x 17} 18func (q *littleQueue) Len() int { return len(*q) } 19func (q *littleQueue) Less(i, j int) bool { return (*q)[i].step \u0026lt; (*q)[j].step } 20func (q *littleQueue) Swap(i, j int) { (*q)[i], (*q)[j] = (*q)[j], (*q)[i] } 21 22func shortestPathAllKeys2(grid []string) int { 23\tlocation := make(map[byte]pointTT) 24\t// 小根堆，用于Djikastra算法 25\tpq := make(littleQueue, 0, 1) 26\t// 距离矩阵，保存每个点到其他关键点的距离 27\tdistMaps := make(map[byte]map[byte]int) 28\theap.Init(\u0026amp;pq) 29\tfor i := 0; i \u0026lt; len(grid); i++ { 30\tfor j := 0; j \u0026lt; len(grid[0]); j++ { 31\tch := grid[i][j] 32\tif ch != \u0026#39;.\u0026#39; \u0026amp;\u0026amp; ch != \u0026#39;#\u0026#39; { 33\tp := pointTT{j, i, 0, 0} 34\tlocation[ch] = p 35\tdistMaps[ch] = bpfFrom(p, grid) 36\t} 37\tif ch == \u0026#39;@\u0026#39; { 38\theap.Push(\u0026amp;pq, pointTT{j, i, 0, 0}) 39\t} 40\t} 41\t} 42\tkeyNums := len(location) / 2 43\tfinalState := (1 \u0026lt;\u0026lt; keyNums) - 1 44 45\tfinalDistMap := make(map[string]int) 46\tfinalDistMap[fmt.Sprintf(\u0026#34;%c%d\u0026#34;, \u0026#39;@\u0026#39;, 0)] = 0 47 48\t// Dijkstra算法 49\tfor pq.Len() \u0026gt; 0 { 50\t// 每次取队列中最小的距离 51\tp := heap.Pop(\u0026amp;pq).(pointTT) 52\t// finalState还是队列中最小的步数，说明已经到了最小的步数 53\tif p.state == finalState { 54\treturn p.step 55\t} 56\t// 从此点开始走，找到所有关键点 57\tch := grid[p.y][p.x] 58\tdistMap := distMaps[ch] 59\tfor i, v := range distMap { 60\tstate := p.state 61\tif i \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; i \u0026lt;= \u0026#39;Z\u0026#39; { 62\t// 走到锁，判断是否可以走，不可以走就不走 63\tif (state \u0026amp; (1 \u0026lt;\u0026lt; (i - \u0026#39;A\u0026#39;))) == 0 { 64\tcontinue 65\t} 66\t} else if i \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; i \u0026lt;= \u0026#39;z\u0026#39; { 67\t// 走到钥匙，拿起钥匙 68\tstate |= (1 \u0026lt;\u0026lt; (i - \u0026#39;a\u0026#39;)) 69\t} 70\t// 能走的点，如果没到达过，或者到达过但比之前距离更短，才加入队列 71\tt := location[i] 72\tt.state = state 73\tt.step = p.step + v 74\tkey := fmt.Sprintf(\u0026#34;%c%d\u0026#34;, i, state) 75\tif d, ok := finalDistMap[key]; ok \u0026amp;\u0026amp; t.step \u0026gt;= d { 76\tcontinue 77\t} 78\tfinalDistMap[key] = t.step 79\theap.Push(\u0026amp;pq, t) 80\t} 81\t} 82\treturn -1 83} 84 85func bpfFrom(src pointTT, grid []string) map[byte]int { 86\tresult := make(map[byte]int) 87\tsx, sy := src.x, src.y 88\t// 减小计算量，走过的路不再走，记录一下哪里走过了 89\tseen := make([][]bool, len(grid)) 90\tfor i := range seen { 91\tseen[i] = make([]bool, len(grid[0])) 92\t} 93\tseen[sy][sx] = true 94 95\tvar queue list.List 96\tqueue.PushBack(src) 97\tfor queue.Len() \u0026gt; 0 { 98\tt := queue.Front().Value.(pointTT) 99\tqueue.Remove(queue.Front()) 100 101\t// 向四周走一次 102\tfor i := range kRoundPoints { 103\tpx, py := t.x+kRoundPoints[i][0], t.y+kRoundPoints[i][1] 104\t// 如果超出边界或者碰到墙或者走过了，就继续 105\tif py \u0026lt; 0 || py \u0026gt;= len(grid) || px \u0026lt; 0 || px \u0026gt;= len(grid[0]) || seen[py][px] || grid[py][px] == \u0026#39;#\u0026#39; { 106\tcontinue 107\t} 108\t// 判断是否是空位，空位就继续走 109\tseen[py][px] = true 110\tch := grid[py][px] 111\tif ch == \u0026#39;.\u0026#39; { 112\t// 记录到队列中，作为下一层的点 113\tqueue.PushBack(pointTT{px, py, t.step + 1, 0}) 114\tcontinue 115\t} 116\t// 关键点插入map，这个时候还没走上去，所以步数+1才走上去 117\tresult[ch] = t.step + 1 118\t} 119\t} 120\treturn result 121} "},{"id":72,"href":"/docs/leetcode/medium/leetcode948/","title":"948. Bag of Tokens","section":"中等","content":" 题目 # You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the $i^{th}$ token (0-indexed).\nYour goal is to maximize your total score by potentially playing each token in one of two ways:\nIf your current power is at least tokens[i], you may play the $i^{th}$ token face up, losing tokens[i] power and gaining 1 score. If your current score is at least 1, you may play the $i^{th}$ token face down, gaining tokens[i] power and losing 1 score. Each token may be played at most once and in any order. You do not have to play all the tokens. Return the largest possible score you can achieve after playing any number of tokens.\n思路1 # 分析 # 卖小的，买大的才能获得最大收益，排序必不可少 如果买了大的，卖不了小的，就可以不用继续了 这里注意，如果买了大的，却只能卖一个小的。这里不能停，因为可能再买一个大的，可以卖两个小的，还是赚的 用双指针进行运算 代码实现 # 1func bagOfTokensScore(tokens []int, power int) (score int) { 2\tsort.Ints(tokens) // Ascending 3 4\tl := 0 5\tr := len(tokens) - 1 6\tpoint := 0 7\t// token isn\u0026#39;t used up and point can pay for one token or power can be used for one token 8\tfor l \u0026lt;= r \u0026amp;\u0026amp; (power \u0026gt; tokens[l] || point \u0026gt; 0) { 9\tif power \u0026gt;= tokens[l] { 10\tpower -= tokens[l] 11\tl++ 12\tpoint++ 13\tcontinue 14\t} 15 16\t// can\u0026#39;t pay at least one tokens 17\tif point \u0026lt; score { 18\tbreak 19\t} 20\tscore = point 21\tpower += tokens[r] 22\tr-- 23\tpoint-- 24\t} 25\tif point \u0026gt; score { 26\treturn point 27\t} 28\treturn 29} 思路2 # 分析 # 官方的贪心算法 将所有tokens走一遍，过程中的最大收益返回 代码实现 # 1func bagOfTokensScore(tokens []int, power int) (score int) { 2\tsort.Ints(tokens) // Ascending 3 4\tl := 0 5\tr := len(tokens) - 1 6\tpoint := 0 7\tfor l \u0026lt;= r \u0026amp;\u0026amp; (power \u0026gt;= tokens[l] || point \u0026gt; 0) { 8\tfor l \u0026lt;= r \u0026amp;\u0026amp; power \u0026gt;= tokens[l] { 9\tpower -= tokens[l] 10\tl++ 11\tpoint++ 12\t} 13 14\tif score \u0026lt; point { 15\tscore = point 16\t} 17\tif l \u0026lt;= r \u0026amp;\u0026amp; point \u0026gt; 0 { 18\tpower += tokens[r] 19\tr-- 20\tpoint-- 21\t} 22\t} 23\treturn 24} "},{"id":73,"href":"/docs/books/","title":"读书笔记","section":"Docs","content":" Introduction # 读书笔记\n"},{"id":74,"href":"/docs/leetcode/medium/leetcode1169/","title":"1169. Invalid Transactions","section":"中等","content":" 题目 # A transaction is possibly invalid if:\nthe amount exceeds $1000, or; if it occurs within (and including) 60 minutes of another transaction with the same name in a different city. You are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.\n思路1 # 分析 # 自己想的，记录之前的交易信息，新的交易信息和之前进行对比，如果出现问题就记录 使用map查找，加快速度 代码实现 # 1type transactionInfo struct { 2\tname string 3\ttime int64 4\tamount int64 5\tcity string 6\thasOut bool 7\toriginStr string 8} 9 10func parseTransaction(str string) (info transactionInfo) { 11\tarr := strings.Split(str, \u0026#34;,\u0026#34;) 12\tinfo.name = arr[0] 13\tinfo.time, _ = strconv.ParseInt(arr[1], 10, 64) 14\tinfo.amount, _ = strconv.ParseInt(arr[2], 10, 64) 15\tinfo.city = arr[3] 16\tinfo.hasOut = false 17\tinfo.originStr = str 18\treturn 19} 20 21func appendResult(info *transactionInfo, result *[]string) { 22\tif info.hasOut { 23\treturn 24\t} 25\t*result = append(*result, info.originStr) 26\tinfo.hasOut = true 27} 28 29func invalidTransactions(transactions []string) []string { 30\trecordMap := make(map[string][]transactionInfo) 31 32\tvar result []string 33\tfor _, v := range transactions { 34\tinfo := parseTransaction(v) 35 36\t// 先判断是否超出1000 37\tif info.amount \u0026gt; 1000 { 38\tappendResult(\u0026amp;info, \u0026amp;result) 39\t} 40 41\t// 判断是否之前有记录，不存在直接继续 42\tlastInfos, ok := recordMap[info.name] 43\tif !ok { 44\trecordMap[info.name] = []transactionInfo{info} 45\tcontinue 46\t} 47 48\t// 判断是否是小于60并不在同一个城市 49\tfor i, lastInfo := range lastInfos { 50\tif lastInfo.city != info.city \u0026amp;\u0026amp; (info.time-lastInfo.time \u0026lt;= 60 \u0026amp;\u0026amp; info.time-lastInfo.time \u0026gt;= -60) { 51\tappendResult(\u0026amp;info, \u0026amp;result) 52\tappendResult(\u0026amp;lastInfos[i], \u0026amp;result) 53\t} 54\t} 55\tlastInfos = append(lastInfos, info) 56\trecordMap[info.name] = lastInfos 57\t} 58 59\treturn result 60} 思路2 # 分析 # 官方的也挺暴力的，就是全遍历，当前交易和后面所有对比一遍，出现问题就记录 代码实现 # 1func invalidTransactions1(transactions []string) []string { 2\tvar result []string 3 4\t// 遍历当前交易，和后面冲突就记录，跳出继续 5\tfor i, v := range transactions { 6\tinfo := parseTransaction(v) 7 8\tif info.amount \u0026gt; 1000 { 9\tresult = append(result, info.originStr) 10\tcontinue 11\t} 12 13\tfor j, v1 := range transactions { 14\tif j == i { 15\tcontinue 16\t} 17\tinfo1 := parseTransaction(v1) 18\tif info.name == info1.name \u0026amp;\u0026amp; info1.city != info.city \u0026amp;\u0026amp; (info.time-info1.time \u0026lt;= 60 \u0026amp;\u0026amp; info.time-info1.time \u0026gt;= -60) { 19\tresult = append(result, info.originStr) 20\tbreak 21\t} 22 23\t} 24\t} 25\treturn result 26} "},{"id":75,"href":"/docs/leetcode/medium/leetcode1352/","title":"1352. Product of the Last K Numbers","section":"中等","content":" 题目 # Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.\nImplement the ProductOfNumbers class:\nProductOfNumbers() Initializes the object with an empty stream. void add(int num) Appends the integer num to the stream. int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers. The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.\n思路1 # 分析 # 第一想法，放一个链表或者数组，存放传入的数字，然后返回后k个数字的乘积 这题这么简单？？超时了。。。 思路2 # 分析 # 嫌弃计算时间长，我先计算，然后需要的是否返回结果 放一个数组，传入一个数字，把后k个数字的乘积算好 新传入，把前面的结果每个都乘以新数字，把新数字放到最后 要结果就直接返回，不给你算，就不会超时 提交过了。。。时间打败0%。。。内存也打败0% 思路3 # 分析 # 内存优化一下，好像我不用存所有的数字，只用存结果就好了 计算的方面，每次都要所有结果乘以这个数字，好像确实要时间 偷偷看一眼官方解答，考虑0的情况！！！所得寺内~~~ 发现数字为0，清理结果，判断要结果小于数组长度直接返回0就好了 提交过了，内存倒是打败80%，但是时间打败10%。。。 思路4 # 分析 # 再偷瞄一眼官方解答，不用每次来个数字把所有结果都乘一遍，换个思路 存前n个数的乘积而不是后n个数的乘积，这样来的数字只用乘以结果最后一个，然后插入到数组中就好了 但是要结果的时候，需要后k个数的乘积 $$ 后k个数的乘积 = \\frac{前n个数的乘积}{前n-k个数的乘积} $$\n终于内存70%，时间80%了 代码实现 # 上面的公式是示意公式，我们设数组result[i]代表前i个数的乘积，那么边界result[0]代表前0个数，为了表示方便，设置成1 结果需要前k个数的乘积，按照上面的数据举个例子，假设n为5，数组长度为6（包含第0个） 需要后3个数的乘积，有 $n=6, k=3$ $$ 后3个数的乘积 = \\frac{1 \\times a_1 \\times a_2 \\times a_3 \\times a_4 \\times a_5}{1 \\times a_1 \\times a_2} = \\frac{result[n-1]}{result[n-k-1]} $$\n由于 $n-k-1$ 需要大于等于0，所以 $k \\le n - 1$ 1type ProductOfNumbers struct { 2\tresult []int 3} 4 5func Constructor() (this ProductOfNumbers) { 6\tthis.result = append(this.result, 1) 7\treturn 8} 9 10func (this *ProductOfNumbers) Add(num int) { 11\tif num == 0 { 12\tthis.result = this.result[:1] 13\treturn 14\t} 15\tthis.result = append(this.result, this.result[len(this.result)-1]*num) 16} 17 18func (this *ProductOfNumbers) GetProduct(k int) int { 19\tif k \u0026gt; len(this.result)-1 { 20\treturn 0 21\t} 22\treturn this.result[len(this.result)-1] / this.result[len(this.result)-k-1] 23} 24 25/** 26 * Your ProductOfNumbers object will be instantiated and called as such: 27 * obj := Constructor(); 28 * obj.Add(num); 29 * param_2 := obj.GetProduct(k); 30 */ 思路5 # 分析 # 第一个1占内存，优化一下 代码实现 # 再来一次，我们设数组result[i]代表前 $i-1$ 个数的乘积，那么边界result[0]代表前1个数 结果需要前k个数的乘积，按照上面的数据举个例子，假设n为5，数组长度为5 需要后3个数的乘积，有 $n=5, k=3$ $$ 后3个数的乘积 = \\frac{a_1 \\times a_2 \\times a_3 \\times a_4 \\times a_5}{a_1 \\times a_2} = \\frac{result[n-1]}{result[n-k-1]} $$\n边界情况，k和n相等，没有被除数，所以 $k = n$ 直接返回 $result[n-1]$ 1type ProductOfNumbers struct { 2\tresult []int 3} 4 5func Constructor() (this ProductOfNumbers) { 6\treturn 7} 8 9func (this *ProductOfNumbers) Add(num int) { 10\tif num == 0 { 11\tthis.result = this.result[:0] 12\treturn 13\t} 14\tif len(this.result) == 0 { 15\tthis.result = append(this.result, num) 16\treturn 17\t} 18\tthis.result = append(this.result, this.result[len(this.result)-1]*num) 19} 20 21func (this *ProductOfNumbers) GetProduct(k int) int { 22\tif k == len(this.result) { 23\treturn this.result[len(this.result)-1] 24\t} 25\tif k \u0026gt; len(this.result) { 26\treturn 0 27\t} 28\treturn this.result[len(this.result)-1] / this.result[len(this.result)-k-1] 29} 30 31/** 32 * Your ProductOfNumbers object will be instantiated and called as such: 33 * obj := Constructor(); 34 * obj.Add(num); 35 * param_2 := obj.GetProduct(k); 36 */ 思路6 # 分析 # 官方的第二种解法，感觉更加厉害 由于要求的是乘积，并且规定返回的一定在32位以内，所以推断非0和1的部分最多不超过32个数 记录所有的非0和1的数，然后一个一个乘即可 代码实现 # 转化成代码语言，取三个数组储存数据\nvec[i]: 储存所有数据 cnt[i]: 储存前i个数据中0的个数 pre[i]: 前 $i-1$ 个数据最后一个非0和1的数的位置 其中cnt[i]有\n$$ cnt[i] = \\left\\{ \\begin{array}{ll} cnt[i-1] \u0026amp; if \u0026amp; vec[i] \\ne 0 \\\\ cnt[i-1]+1 \u0026amp; if \u0026amp; vec[i] = 0 \\end{array} \\right. $$\npre[i]有\n$$ pre[i] = \\left\\{ \\begin{array}{ll} pre[i-1] \u0026amp; if \u0026amp; vec[i-1] \\le 1 \\\\ i-1 \u0026amp; if \u0026amp; vec[i-1] \\gt 0 \\end{array} \\right. $$\n获取数据时有\n$$ GetProduct(k) = \\left\\{ \\begin{array}{ll} 0 \u0026amp; if \u0026amp; cnt[n-1]-cnt[n-1-k] \\gt 0 \\\\ other \u0026amp; if \u0026amp; cnt[n-1]-cnt[n-1-k] = 0 \\end{array} \\right. $$\n1type ProductOfNumbers struct { 2\tvec []int 3\tcnt []int 4\tpre []int 5} 6 7func Constructor() (this ProductOfNumbers) { 8\treturn 9} 10 11func (this *ProductOfNumbers) Add(num int) { 12\tn := len(this.vec) 13\tthis.vec = append(this.vec, num) 14\tthis.pre = append(this.pre, -1) 15 16\t// update cnt 17\tcnt := 0 18\tif n \u0026gt; 0 { 19\t// get last result 20\tcnt = this.cnt[n-1] 21\t} 22\tif num == 0 { 23\tcnt++ 24\t} 25\tthis.cnt = append(this.cnt, cnt) 26 27\t// update pre 28\tif n == 0 { 29\treturn 30\t} 31\tif this.vec[n-1] \u0026lt;= 1 { 32\tthis.pre[n] = this.pre[n-1] 33\t} else { 34\tthis.pre[n] = n - 1 35\t} 36} 37 38func (this *ProductOfNumbers) GetProduct(k int) int { 39\tn := len(this.vec) 40\ttot := this.cnt[n-1] 41\tif k \u0026lt; n { 42\ttot -= this.cnt[n-1-k] 43\t} 44\tif tot \u0026gt; 0 { 45\treturn 0 46\t} 47 48\tresult := 1 49\t// n-i-1 represent the next number to be used from the bottom 50\t// eg: i = n - 1, n-i-1 = 0, will use the 0th number from the bottom 51\t// which also represent the result contains 0 numbers 52\tfor i := n - 1; (n - i - 1) \u0026lt; k; i = this.pre[i] { 53\tresult *= this.vec[i] 54\t} 55\treturn result 56} "},{"id":76,"href":"/docs/leetcode/simple/leetcode1694/","title":"1694. Reformat Phone Number","section":"简单","content":" 题目 # You are given a phone number as a string number. number consists of digits, spaces \u0026rsquo; \u0026lsquo;, and/or dashes \u0026lsquo;-\u0026rsquo;.\nYou would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:\n2 digits: A single block of length 2. 3 digits: A single block of length 3. 4 digits: Two blocks of length 2 each. The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2.\nReturn the phone number after formatting.\n思路1 # 分析 # 自己想的，保留一个数组，如果大于4个，直接拆出前三个加一个- 最后如果剩余4个，拆成22-22，剩余不足4个，直接拼接到后面 代码实现 # 1func reformatNumber(number string) (result string) { 2\tvar addStr []byte 3\tfor i := range number { 4\tif number[i] == \u0026#39; \u0026#39; || number[i] == \u0026#39;-\u0026#39; { 5\tcontinue 6\t} 7\taddStr = append(addStr, number[i]) 8\tif len(addStr) \u0026gt; 4 { 9\tresult += string(addStr[:3]) + \u0026#34;-\u0026#34; 10\taddStr = addStr[3:] 11\t} 12\t} 13\tif len(addStr) == 4 { 14\tresult += string(addStr[:2]) + \u0026#34;-\u0026#34; + string(addStr[2:]) 15\t} else { 16\tresult += string(addStr) 17\t} 18\treturn 19} 思路2 # 分析 # 直接三个三个拼接一个- 最后判断，最后一位是-，删掉 如果倒数第二位是-，和倒数第三位交换值 代码实现 # 1func reformatNumber(number string) string { 2\taddStr := make([]byte, 0, 4) 3\tresult := make([]byte, 0, len(number)) 4\tfor i := range number { 5\tif number[i] == \u0026#39; \u0026#39; || number[i] == \u0026#39;-\u0026#39; { 6\tcontinue 7\t} 8\taddStr = append(addStr, number[i]) 9\tif len(addStr) == 3 { 10\taddStr = append(addStr, \u0026#39;-\u0026#39;) 11\tresult = append(result, addStr...) 12\taddStr = addStr[:0] 13\t} 14\t} 15\tresult = append(result, addStr...) 16\tif result[len(result)-1] == \u0026#39;-\u0026#39; { 17\treturn string(result[:len(result)-1]) 18\t} else if len(result) \u0026gt; 4 \u0026amp;\u0026amp; result[len(result)-2] == \u0026#39;-\u0026#39; { 19\tresult[len(result)-2] = result[len(result)-3] 20\tresult[len(result)-3] = \u0026#39;-\u0026#39; 21\t} 22\treturn string(result) 23} "},{"id":77,"href":"/docs/leetcode/simple/leetcode2399/","title":"2399. Check Distances Between Same Letters","section":"简单","content":" 题目 # You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.\nEach letter in the alphabet is numbered from 0 to 25 (i.e. \u0026lsquo;a\u0026rsquo; -\u0026gt; 0, \u0026lsquo;b\u0026rsquo; -\u0026gt; 1, \u0026lsquo;c\u0026rsquo; -\u0026gt; 2, \u0026hellip; , \u0026lsquo;z\u0026rsquo; -\u0026gt; 25).\nIn a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.\nReturn true if s is a well-spaced string, otherwise return false.\n思路1 # 分析 # 最简单的使用数组当map存一下上次的位置，然后遍历一遍搞定 代码实现 # 1func checkDistances(s string, distance []int) bool { 2\t// 使用数组作为map存储，0到128 3\tshowMap := make([]int, 128) 4\tfor i := range showMap { 5\tshowMap[i] = -1 6\t} 7\tfor i := range s { 8\tindex := s[i]-\u0026#39;a\u0026#39; 9\tif showMap[index] == -1 { 10\tshowMap[index] = i 11\tcontinue 12\t} 13 14\td := i-showMap[index]-1 15\tif distance[index] != d { 16\treturn false 17\t} 18\t} 19\treturn true 20} "},{"id":78,"href":"/docs/leetcode/medium/leetcode2400/","title":"2400. Number of Ways to Reach a Position After Exactly k Steps","section":"中等","content":" 题目 # You are given two positive integers startPos and endPos. Initially, you are standing at position startPos on an infinite number line. With one step, you can move either one position to the left, or one position to the right.\nGiven a positive integer k, return the number of different ways to reach the position endPos starting from startPos, such that you perform exactly k steps. Since the answer may be very large, return it modulo $10^9 + 7$.\nTwo ways are considered different if the order of the steps made is not exactly the same.\nNote that the number line includes negative integers.\n思路1 # 分析 # 自己虽然想到了动态规划，但是实现的时候没有把动态规划进一步简化，直接超过时间复杂度。。。 直接上简化后的动态规划思路 这道题从数学上分析，就是给定k个空格，存在两种固定数量的棋子，一个向前，一个向后。问在这k个空格中有多少种摆法 那么仔细想一下就推出来，假设n为向前的棋子数，k为空格数，有 $$ f(n, k) = f(n, k-1) + f(n-1, k-1) $$\n也就是，第一个棋子直接落到第一个位置，剩下的就是n-1和k-1，或者第一个不落这个棋子，就是n和k-1 边界条件，n == k为1，n == 1为k 代码实现 # 数组中int初始化为0，那么不用关心n == k的情况，因为n == k计算的 $f(n, k-1) = 0$，而 $f(n-1, k-1)$ 追溯到 $f(1, 1) = 1$ 1const maxSum int = 1e9 + 7 2 3func abs(x int) int { 4\tif x \u0026lt; 0 { 5\treturn -x 6\t} 7\treturn x 8} 9 10func numberOfWays(startPos int, endPos int, k int) int { 11\tdiff := abs(startPos - endPos) 12\t// 首先判断是否可达 13\tif k \u0026lt; diff { 14\treturn 0 15\t} 16\tif k == diff { 17\treturn 1 18\t} 19\t// 判断是否奇偶不同 20\tif (k % 2) != (diff % 2) { 21\treturn 0 22\t} 23 24\tn := (k - diff) / 2 25 26\tdp := make([][]int, n+1) 27\tfor i := range dp { 28\tdp[i] = make([]int, k+1) 29\t} 30 31\tfor i := 1; i \u0026lt; k+1; i++ { 32\tdp[1][i] = i 33\t// j最大不超过i 34\tfor j := 2; j \u0026lt; n+1 \u0026amp;\u0026amp; j \u0026lt;= i; j++ { 35\tdp[j][i] = (dp[j][i-1] + dp[j-1][i-1]) % maxSum 36\t} 37\t} 38 39\treturn dp[n][k] 40} "},{"id":79,"href":"/docs/leetcode/medium/leetcode2401/","title":"2401. Longest Nice Subarray","section":"中等","content":" 题目 # You are given an array nums consisting of positive integers.\nWe call a subarray of nums nice if the bitwise AND of every pair of elements that are in different positions in the subarray is equal to 0.\nReturn the length of the longest nice subarray.\nA subarray is a contiguous part of an array.\nNote that subarrays of length 1 are always considered nice.\n思路1 # 分析 # 自己想的，先找到每一个数字向后有几个数字和它优雅 然后倒着找，以每一个数字为最后一个数字，找到前面第几个数字的底线超过或等于此数字 代码实现 # 1func longestNiceSubarray(nums []int) int { 2\t// 记录每一个数字向后的优雅数量 3\tniceMap := make([]int, len(nums)) 4\tfor i := range nums { 5\tniceMap[i] = 1 6\tj := i + 1 7\tfor ; j \u0026lt; len(nums); j++ { 8\tif nums[i]\u0026amp;nums[j] != 0 { 9\tbreak 10\t} 11\t} 12\tif j-i \u0026gt; 1 { 13\tniceMap[i] = j - i 14\t} 15\t} 16\t// 遍历niceMap查看最大相互优雅数量 17\tresult := 1 18\t// 倒序遍历，在范围内就++ 19\tfor i := len(nums) - 1; i \u0026gt;= result; i-- { 20\tj := i - 1 21\tfor ; j \u0026gt;= 0; j-- { 22\tif niceMap[j] \u0026lt; i-j+1 { 23\tbreak 24\t} 25\t} 26\tif i-j \u0026gt; result { 27\tresult = i - j 28\t} 29\t} 30\treturn result 31} 思路2 # 分析 # 看网上其他人写的，还是自己想简单了，对按位操作不敏感 首先确定一个事实，如果一个数和另一个数按位与为0，说明在二进制上，两个数字的1都分布在不同的位置上 进一步推出，如果一个数组中，所有数字相互之间按位与都为0，说明他们的二进制数字中，没有任何一个1在同一个位置上 我们再次推出，如果一个数字和另外两个数字按位与为0，那么和他们或起来的数字按位与同样为0 那么找一个数字保存前面所有数字的按位与的结果，如果后一个数字和此数字按位与为0，就按位或加进来，否则，将最左边的移出去，也就是异或出去 代码 # 1func max(a, b int) int { 2\tif b \u0026gt; a { 3\treturn b 4\t} 5\treturn a 6} 7 8func longestNiceSubarray1(nums []int) int { 9\tresult := 1 // 记录最终结果，最少为1 10\tleft := 0 11\tmask := 0 // 记录或的值 12\tfor right, v := range nums { 13\t// 排除不符合条件的 14\tfor (v \u0026amp; mask) != 0 { 15\tmask ^= nums[left] 16\tleft++ 17\t} 18\tmask |= v 19\tresult = max(result, right-left+1) 20\t} 21\treturn result 22} "},{"id":80,"href":"/docs/leetcode/simple/leetcode2413/","title":"2413. Smallest Even Multiple","section":"简单","content":" 题目 # Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.\nExample 1:\nInput: n = 5 Output: 10 Explanation: The smallest multiple of both 5 and 2 is 10. Example 2:\nInput: n = 6 Output: 6 Explanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself. Constraints:\n$1 \\le n \\le 150$ 思路1 数学思想 # 分析 # 就是一道数学题，奇数乘以2，偶数就是本身 代码实现 # 1func smallestEvenMultiple(n int) int { 2\tif n % 2 == 0 { 3\treturn n 4\t} 5\treturn 2 * n 6} "},{"id":81,"href":"/docs/leetcode/medium/leetcode2414/","title":"2414. Length of the Longest Alphabetical Continuous Substring","section":"中等","content":" 题目 # An alphabetical continuous string is a string consisting of consecutive letters in the alphabet. In other words, it is any substring of the string \u0026ldquo;abcdefghijklmnopqrstuvwxyz\u0026rdquo;.\nFor example, \u0026ldquo;abc\u0026rdquo; is an alphabetical continuous string, while \u0026ldquo;acb\u0026rdquo; and \u0026ldquo;za\u0026rdquo; are not.\nGiven a string s consisting of lowercase letters only, return the length of the longest alphabetical continuous substring.\nExample 1:\nInput: s = \u0026ldquo;abacaba\u0026rdquo; Output: 2 Explanation: There are 4 distinct continuous substrings: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo; and \u0026ldquo;ab\u0026rdquo;. \u0026ldquo;ab\u0026rdquo; is the longest continuous substring. Example 2:\nInput: s = \u0026ldquo;abcde\u0026rdquo; Output: 5 Explanation: \u0026ldquo;abcde\u0026rdquo; is the longest continuous substring. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 105 s consists of only English lowercase letters. 思路1 滑动窗口 # 分析 # 从第一个开始找一个段里面都是相差1的，发现一个不符合，判断是不是最大值，然后把窗口起始点移动过去 可以直接将长度作为窗口，当不满足条件，长度回到1重新加 代码实现 # 1func longestContinuousSubstring(s string) int { 2\tresult := 0 3\tcurLen := 0 4\tfor i := range s { 5\tif curLen == 0 { 6\tcurLen = 1 7\tcontinue 8\t} 9 10\tif s[i]-s[i-1] == 1 { 11\tcurLen++ 12\tcontinue 13\t} 14\tif curLen \u0026gt; result { 15\tresult = curLen 16\t} 17\tcurLen = 1 18\t} 19\tif curLen \u0026gt; result { 20\tresult = curLen 21\t} 22\treturn result 23} "},{"id":82,"href":"/docs/leetcode/medium/leetcode2415/","title":"2415. Reverse Odd Levels of Binary Tree","section":"中等","content":" 题目 # Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.\nExample 1:\nInput: root = [2,3,5,8,13,21,34] Output: [2,5,3,8,13,21,34] Explanation: The tree has only one odd level. The nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3. Example 2:\nInput: root = [7,13,11] Output: [7,11,13] Explanation: The nodes at level 1 are 13, 11, which are reversed and become 11, 13. Example 3:\nInput: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2] Output: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1] Explanation: The odd levels have non-zero values. The nodes at level 1 were 1, 2, and are 2, 1 after the reversal. The nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal. Constraints:\nThe number of nodes in the tree is in the range [1, 214]. 0 \u0026lt;= Node.val \u0026lt;= 105 root is a perfect binary tree. 思路1 广度优先遍历反转 # 分析 # 自己想的，先拿到广度优先遍历的结果 再遍历一遍，奇数层从右向左重新找子节点，偶数层从左向右找子节点 代码实现 # 1func reverseOddLevels(root *TreeNode) *TreeNode { 2\tif root == nil { 3\treturn nil 4\t} 5\t// 转成广度遍历的数组 6\tnodeArr := []*TreeNode{root} 7\tfor i := 0; i \u0026lt; len(nodeArr); i++ { 8\ttmp := nodeArr[i] 9\tif tmp.Left != nil { 10\tnodeArr = append(nodeArr, tmp.Left) 11\ttmp.Left = nil 12\t} 13\tif tmp.Right != nil { 14\tnodeArr = append(nodeArr, tmp.Right) 15\ttmp.Right = nil 16\t} 17\t} 18 19\t// 用数学计算遍历将对应的left和right全部替换完成 20\tlayer := 0 // 层数 21\tlayerItemSum := 1 22\tfor index := 0; index \u0026lt; len(nodeArr); { 23\tnextBegin := index + layerItemSum 24\tif layer%2 == 1 { 25\t// 奇数层，倒序遍历添加孩子 26\tfor i := layerItemSum - 1; i \u0026gt;= 0; i-- { 27\tif index+i \u0026gt;= len(nodeArr) { 28\tcontinue 29\t} 30\t// 下一层是偶数层，从头遍历 31\tleftIndex := nextBegin + (layerItemSum-1-i)*2 32\trightIndex := leftIndex + 1 33\tif leftIndex \u0026lt; len(nodeArr) { 34\tnodeArr[index+i].Left = nodeArr[leftIndex] 35\t} 36\tif rightIndex \u0026lt; len(nodeArr) { 37\tnodeArr[index+i].Right = nodeArr[rightIndex] 38\t} 39 40\t} 41\t} else { 42\t// 偶数层，正序遍历添加孩子 43\tfor i := 0; i \u0026lt; layerItemSum \u0026amp;\u0026amp; index+i \u0026lt; len(nodeArr); i++ { 44\t// 下一层是奇数层，从尾部遍历 45\tleftIndex := nextBegin + layerItemSum*2 - 1 - i*2 46\trightIndex := leftIndex - 1 47\tif leftIndex \u0026lt; len(nodeArr) { 48\tnodeArr[index+i].Left = nodeArr[leftIndex] 49\t} 50\tif rightIndex \u0026lt; len(nodeArr) { 51\tnodeArr[index+i].Right = nodeArr[rightIndex] 52\t} 53 54\t} 55\t} 56\tindex += layerItemSum 57\tlayer++ 58\tlayerItemSum *= 2 59\t} 60 61\treturn root 62} 思路2 bfs 交换值 # 分析 # 思路1想复杂了，实际上，只要交换值就可以了，不用动左右子节点的指针 还是广度优先遍历，获取到每一层，为奇数层时，遍历交换两边的值 代码实现 # 1func reverseOddLevels1(root *TreeNode) *TreeNode { 2\tif root == nil { 3\treturn nil 4\t} 5 6\tq := []*TreeNode{root} 7\tfor isOdd := 1; q[0].Left != nil; isOdd ^= 1 { 8\t// 将下一层放到一个新的数组中 9\tnext := make([]*TreeNode, 0, len(q)*2) 10\tfor _, node := range q { 11\tnext = append(next, node.Left, node.Right) 12\t} 13\tq = next 14 15\tif isOdd == 0 { 16\tcontinue 17\t} 18\t// 如果是奇数层，将这一层反转值 19\tfor i, n := 0, len(q); i \u0026lt; n/2; i++ { 20\tq[i].Val, q[n-1-i].Val = q[n-1-i].Val, q[i].Val 21\t} 22\t} 23\treturn root 24} 思路2 dfs 交换值 # 分析 # 使用dfs同样可以实现 此问题可以转成对称树的问题，奇数层交换，偶数层不交换 那么对左右子节点同时进行dfs，左边遍历到的节点和右边遍历到的节点，如果是奇数层交换值 然后对左右节点的左右子节点反过来 代码实现 # 1func dfs(node1 *TreeNode, node2 *TreeNode, isOdd bool) { 2\tif node1 == nil { 3\treturn 4\t} 5\tif isOdd { 6\tnode1.Val, node2.Val = node2.Val, node1.Val 7\t} 8\tdfs(node1.Left, node2.Right, !isOdd) 9\tdfs(node1.Right, node2.Left, !isOdd) 10} 11 12func reverseOddLevels2(root *TreeNode) *TreeNode { 13\tif root == nil { 14\treturn nil 15\t} 16\tdfs(root.Left, root.Right, true) 17\treturn root 18} "},{"id":83,"href":"/docs/leetcode/simple/leetcode2418/","title":"2418. Sort the People","section":"简单","content":" 题目 # You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.\nFor each index i, names[i] and heights[i] denote the name and height of the ith person.\nReturn names sorted in descending order by the people\u0026rsquo;s heights.\nExample 1:\nInput: names = [\u0026#34;Mary\u0026#34;,\u0026#34;John\u0026#34;,\u0026#34;Emma\u0026#34;], heights = [180,165,170] Output: [\u0026#34;Mary\u0026#34;,\u0026#34;Emma\u0026#34;,\u0026#34;John\u0026#34;] Explanation: Mary is the tallest, followed by Emma and John. Example 2:\nInput: names = [\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;,\u0026#34;Bob\u0026#34;], heights = [155,185,150] Output: [\u0026#34;Bob\u0026#34;,\u0026#34;Alice\u0026#34;,\u0026#34;Bob\u0026#34;] Explanation: The first Bob is the tallest, followed by Alice and the second Bob. Constraints:\nn == names.length == heights.length $1 \\le n \\le 10^3$ $1 \\le names[i].length \\le 20$ $1 \\le heights[i] \\le 10^5$ names[i] consists of lower and upper case English letters. All the values of heights are distinct. 思路1 排序 # 分析 # 使用go的sort，写一个对应的类型，调用Sort排序就好了 代码实现 # 1type NameSlice struct { 2\tnames []string 3\theights []int 4} 5 6func (x NameSlice) Len() int { return len(x.names) } 7func (x NameSlice) Less(i, j int) bool { return x.heights[i] \u0026gt; x.heights[j] } 8func (x NameSlice) Swap(i, j int) { 9\tx.heights[i], x.heights[j] = x.heights[j], x.heights[i] 10\tx.names[i], x.names[j] = x.names[j], x.names[i] 11} 12 13func sortPeople(names []string, heights []int) []string { 14\ttmp := NameSlice{ 15\tnames: names, 16\theights: heights, 17\t} 18\tsort.Sort(tmp) 19\treturn tmp.names 20} "},{"id":84,"href":"/docs/leetcode/medium/leetcode2419/","title":"2419. Longest Subarray With Maximum Bitwise AND","section":"中等","content":" 题目 # You are given an integer array nums of size n.\nConsider a non-empty subarray from nums that has the maximum possible bitwise AND.\nIn other words, let k be the maximum value of the bitwise AND of any subarray of nums. Then, only subarrays with a bitwise AND equal to k should be considered. Return the length of the longest such subarray.\nThe bitwise AND of an array is the bitwise AND of all the numbers in it.\nA subarray is a contiguous sequence of elements within an array.\nExample 1:\nInput: nums = [1,2,3,3,2,2] Output: 2 Explanation: The maximum possible bitwise AND of a subarray is 3. The longest subarray with that value is [3,3], so we return 2. Example 2:\nInput: nums = [1,2,3,4] Output: 1 Explanation: The maximum possible bitwise AND of a subarray is 4. The longest subarray with that value is [4], so we return 1. Constraints:\n$1 \\le nums.length \\le 10^5$ $1 \\le nums[i] \\le 10^6$ 思路1 找最大值连续最多出现几次 # 分析 # 按位与只会将数字变小，那么最大值只能是最大的那个数字 这题就是求最大的数字最多连续出现了几次 代码实现 # 1func longestSubarray(nums []int) int { 2\tmax := nums[0] 3\tresult := 1 4\tlength := 1 5\tfor i, v := range nums { 6\tif i == 0 { 7\tcontinue 8\t} 9\tif v \u0026gt; max { 10\tmax = v 11\tlength = 1 12\tresult = 1 13\t} else if v == max { 14\tlength++ 15\tif length \u0026gt; result { 16\tresult = length 17\t} 18\t} else { 19\tlength = 0 20\t} 21\t} 22\treturn result 23} "},{"id":85,"href":"/docs/leetcode/medium/leetcode2420/","title":"2420. Find All Good Indices","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums of size n and a positive integer k.\nWe call an index i in the range k \u0026lt;= i \u0026lt; n - k good if the following conditions are satisfied:\nThe k elements that are just before the index i are in non-increasing order. The k elements that are just after the index i are in non-decreasing order. Return an array of all good indices sorted in increasing order.\nExample 1:\nInput: nums = [2,1,1,1,3,4,1], k = 2 Output: [2,3] Explanation: There are two good indices in the array: - Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order. - Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order. Note that the index 4 is not good because [4,1] is not non-decreasing. Example 2:\nInput: nums = [2,1,1,2], k = 2 Output: [] Explanation: There are no good indices in this array. Constraints:\n$n == nums.length$ $3 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^6$ $1 \u0026lt;= k \u0026lt;= n / 2$ 思路1 右边确认了就不用确认了 # 分析 # 为了减少时间复杂度，右边确认了n个非递增后，那么判断下一个时就可以认定已经存在n-1个非递增数 代码实现 # 1func goodIndices(nums []int, k int) []int { 2\tleftK := k - 1 3\trn := 1 // 代表index右侧多少个确认了非递减 4\tresult := []int{} 5\tfor index := range nums { 6\tif index == 0 { 7\tcontinue 8\t} 9\t// 下一个循环，上次遍历过的非递增数量-1 10\tif rn \u0026gt; 1 { 11\trn-- 12\t} 13\tif leftK \u0026gt; 0 { 14\t// 先找k个非递增元素 15\tif nums[index] \u0026lt;= nums[index-1] { 16\tleftK-- 17\t} else { 18\t// 否则，左指针移到当前 19\tleftK = k - 1 20\t} 21\tcontinue 22\t} 23\t// 剩余的不到k 24\tif len(nums)-index-1 \u0026lt; k { 25\tbreak 26\t} 27\t// 查看右侧k个元素是否非递减 28\ti := rn 29\tfor ; i \u0026lt; k; i++ { 30\tif nums[index+i+1] \u0026lt; nums[index+i] { 31\tbreak 32\t} 33\trn++ 34\t} 35\tif i == k { 36\tresult = append(result, index) 37\t} 38\tif nums[index] \u0026gt; nums[index-1] { 39\tleftK = k - 1 40\t} 41\t} 42\treturn result 43} 思路2 动态规划 # 分析 # 官方解法就是厉害，一直想如何一遍遍历出结果，但是发现最终写出来的还是遍历了很多遍 其实思路差不多，我先算出来每一个元素的左侧多少非递增，如果和前一个比为非递增，则为前一个的结果加一，否则就是1 同理，计算每一个元素右侧多少非递减，如果和右边比非递减，则为右侧结果加一，否则就是一 最终遍历一遍找到左右分别满足要求的输出即可 动态规划在哪里，就是计算left和right时，使用前一个的结果来计算当前结果就是动态规划 代码 # 1func goodIndices1(nums []int, k int) []int { 2\tn := len(nums) 3\tleft := make([]int, n) // left[i]表示包括i在内，左侧多少满足非递增 4\tright := make([]int, n) // right[i]表示包括i在内，右侧多少满足非递减 5\tfor i := range nums { 6\tleft[i] = 1 7\tright[i] = 1 8\t} 9 10\t// 计算left和right 11\tfor i := range nums { 12\tif i == 0 { 13\tcontinue 14\t} 15\tif nums[i] \u0026lt;= nums[i-1] { 16\tleft[i] = left[i-1] + 1 17\t} 18\tif nums[n-i-1] \u0026lt;= nums[n-i] { 19\tright[n-i-1] = right[n-i] + 1 20\t} 21\t} 22 23\t// 如果某个元素左侧非递增大于等于k且右侧非递减大于等于k，则满足要求 24\tresult := []int{} 25\tfor i := k; i \u0026lt; n-k; i++ { 26\tif left[i-1] \u0026gt;= k \u0026amp;\u0026amp; right[i+1] \u0026gt;= k { 27\tresult = append(result, i) 28\t} 29\t} 30\treturn result 31} 思路3 动态规划优化版 # 分析 # 在上述代码基础上，倒序遍历无法省略，但是正序和本身的判断可以一起做，所以可以先计算倒序的结果，然后再正序进行边计算边判断 代码 # 1func goodIndices2(nums []int, k int) []int { 2\tn := len(nums) 3\tright := make([]int, n) // right[i]表示包括i在内，右侧多少满足非递减 4 5\t// 计算right 6\tfor i := range nums { 7\tif i != 0 \u0026amp;\u0026amp; nums[n-i-1] \u0026lt;= nums[n-i] { 8\tright[n-i-1] = right[n-i] + 1 9\tcontinue 10\t} 11\tright[n-i-1] = 1 12\t} 13 14\t// 如果某个元素左侧非递增大于等于k且右侧非递减大于等于k，则满足要求 15\tresult := []int{} 16\tleft := 1 17\tfor i := 1; i \u0026lt; n-k; i++ { 18\tif left \u0026gt;= k \u0026amp;\u0026amp; right[i+1] \u0026gt;= k { 19\tresult = append(result, i) 20\t} 21\tif nums[i] \u0026lt;= nums[i-1] { 22\tleft++ 23\t} else { 24\tleft = 1 25\t} 26\t} 27\treturn result 28} "},{"id":86,"href":"/docs/leetcode/simple/leetcode2441/","title":"2441. Largest Positive Integer That Exists With Its Negative","section":"简单","content":" 题目 # Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.\nExample 1:\nInput: nums = [-1,2,-3,3] Output: 3 Explanation: 3 is the only valid k we can find in the array. Example 2:\nInput: nums = [-1,10,6,7,-7,1] Output: 7 Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value. Example 3:\nInput: nums = [-10,8,6,7,-2,-3] Output: -1 Explanation: There is no a single valid k, we return -1. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 1000$ $-1000 \u0026lt;= nums[i] \u0026lt;= 1000$ $nums[i] != 0$ 思路1 排序+双指针 # 分析 # 排序，左右两个指针，相加等于0直接返回右指针；大于0，右指针移动；小于0，左指针移动。 代码 # 1func findMaxK2(nums []int) int { 2\tsort.Ints(nums) 3\tl, r := 0, len(nums)-1 4\tfor l \u0026lt; r { 5\taddResult := nums[l] + nums[r] 6\tif addResult == 0 { 7\treturn nums[r] 8\t} else if addResult \u0026gt; 0 { 9\tr-- 10\t} else { 11\tl++ 12\t} 13\t} 14\treturn -1 15} 思路2 使用map查找遍历解决 # 分析 # 使用map记录每一个数字，遍历找对应的相反数是否出现过，出现过就记录，最终返回最大的 代码 # 1func abs(v int) int { 2\tif v \u0026lt; 0 { 3\treturn -v 4\t} 5\treturn v 6} 7 8func findMaxK1(nums []int) int { 9\tnumMap := make(map[int]bool) 10\tresult := -1 11\tfor _, v := range nums { 12\tif _, ok := numMap[-v]; ok { 13\tif result \u0026lt; abs(v) { 14\tresult = abs(v) 15\t} 16\t} 17\tnumMap[v] = true 18\t} 19\treturn result 20} "},{"id":87,"href":"/docs/leetcode/medium/leetcode2442/","title":"2442. Count Number of Distinct Integers After Reverse Operations","section":"中等","content":" 题目 # You are given an array nums consisting of positive integers.\nYou have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.\nReturn the number of distinct integers in the final array.\nExample 1:\nInput: nums = [1,13,10,12,31] Output: 6 Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13]. The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1. The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31). Example 2:\nInput: nums = [2,2,2] Output: 1 Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2]. The number of distinct integers in this array is 1 (The number 2). Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^6$ 思路1 使用map进行去重 # 分析 # 去重直接用map，写个反转函数，不断插入map，最终返回map的大小，搞定 代码实现 # 1func reverse(num int) int { 2\tresult := 0 3\tfor ; num != 0; num /= 10 { 4\tresult *= 10 5\tresult += num % 10 6\t} 7\treturn result 8} 9 10func countDistinctIntegers(nums []int) int { 11\tnumMap := make(map[int]bool) 12\tfor _, v := range nums { 13\tnumMap[v] = true 14\tnumMap[reverse(v)] = true 15\t} 16\treturn len(numMap) 17} "},{"id":88,"href":"/docs/leetcode/medium/leetcode2443/","title":"2443. Sum of Number and Its Reverse","section":"中等","content":" 题目 # Given a non-negative integer num, return true if num can be expressed as the sum of any non-negative integer and its reverse, or false otherwise.\nExample 1:\nInput: num = 443 Output: true Explanation: 172 + 271 = 443 so we return true. Example 2:\nInput: num = 63 Output: false Explanation: 63 cannot be expressed as the sum of a non-negative integer and its reverse so we return false. Example 3:\nInput: num = 181 Output: true Explanation: 140 + 041 = 181 so we return true. Note that when a number is reversed, there may be leading zeros. Constraints:\n$0 \u0026lt;= num \u0026lt;= 10^5$ 思路1 暴力破解遍历 # 分析 # 时间复杂度大致为 $O(n)$ 暴力，但是带一点分析。如果大于n/2的数，翻转小于自己的，都遍历过了，除非是末尾是0 所以对于大于n/2的只用判断是不是整十就好了 代码实现 # 1func reverse(num int) int { 2\tresult := 0 3\tfor ; num != 0; num /= 10 { 4\tresult *= 10 5\tresult += num % 10 6\t} 7\treturn result 8} 9 10func sumOfNumberAndReverse(num int) bool { 11\tfor i := 0; i \u0026lt;= num; i++ { 12\tif i \u0026gt; num/2 \u0026amp;\u0026amp; i%10 != 0 { 13\tcontinue 14\t} 15\tif i+reverse(i) == num { 16\treturn true 17\t} 18\t} 19\treturn false 20} 思路2 双指针 # 分析 # 时间复杂度只和num的位数有关，空间复杂度同样 一个数加上它的取反，假设没有进位，可以得到一个中心对称的数字。就算进行进位，也最多进位一位 那么我们就从左右两个点开始向内收缩，查看是否可以找到一个数加上翻转自身得到 分两种情况 进位，那么低位和高位之间相差1 没进位，地位和高位一样 考虑最高位的情况，如果是1，可能是进位的，也可能是本身加出来的，这两种情况分别计算一下取或即可 取pre为左侧前一位是否有进位，suf为右侧是否给后一位进了位，可以得到 pre存在进位，那么下一轮的suf就存在进位 pre的值取决于左右两个位是否相差1 考虑边界情况 如果左侧第一个为1（不考虑1是被进位的情况），右侧最后一位不能为0，否则就会出现100 =\u0026gt; 050 + 050的情况 如果左侧存在进位，那么两个数最大加出来只能到18 如果存在进位，那么两个数加起来加上进位最小不可能到0，最大可以到19 如果不存在进位，两个数加起来最大到18，最小到0 如果左右都符合，到中间一位（181），因为中间的数是自己加自己，那么必须是复数 如果没有正中间一位（2321 = 1660 + 0661），遍历到最后，l指向中间偏右一个，r指向中间偏左一个，那么pre和suf应该相等 代码 # 1// s数字的字符串形式 2// l，r 左右指针 3// pre 左侧是否被进位的标识 4func existReverseSum(s string, l, r int, pre int) bool { 5\t// 左侧第一个为1，不考虑进位的情况，右侧必须为1，否则就是 100 = 050 + 050的情况 6\tif l == 0 \u0026amp;\u0026amp; s[l] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; s[r] == \u0026#39;0\u0026#39; { 7\treturn false 8\t} 9\tsuf := 0 // 右侧是否进位的标识 10\tfor l \u0026lt; r { 11\tcheckLeft := int(s[l] - \u0026#39;0\u0026#39;) 12\tcheckRight := int(s[r] - \u0026#39;0\u0026#39;) 13\tl++ 14\tr-- 15 16\t// 存在进位，右侧最小到1 17\tif suf == 1 \u0026amp;\u0026amp; checkRight == 0 { 18\treturn false 19\t} 20\t// 本身要进位，两数相加最多到18，也就是右侧不可能为9（存在进位上面判断过不可能为0，那么就是不存在进位不可能为9） 21\tif pre == 1 \u0026amp;\u0026amp; suf == 0 \u0026amp;\u0026amp; checkRight == 9 { 22\treturn false 23\t} 24 25\tif checkLeft == checkRight-suf { 26\t// 如果左侧存在进位，那么两个数最大加出来只能到18 27\tsuf = pre 28\tpre = 0 29\t} else if checkLeft-1+suf == checkRight { 30\tsuf = pre 31\tpre = 1 32\t} else { 33\treturn false 34\t} 35\t} 36\tif l == r \u0026amp;\u0026amp; (int(s[l]-\u0026#39;0\u0026#39;)-suf)%2 == 1 { 37\t// 13121 中间剩个奇数，就找不到 38\treturn false 39\t} else if l != r \u0026amp;\u0026amp; suf != pre { 40\t// 21 剩余一个suf没人认领 41\treturn false 42\t} 43\treturn true 44} 45 46func sumOfNumberAndReverse1(num int) bool { 47\ts := fmt.Sprint(num) 48\tn := len(s) 49 50\treturn existReverseSum(s, 0, n-1, 0) || (s[0] == \u0026#39;1\u0026#39; \u0026amp;\u0026amp; n \u0026gt; 1 \u0026amp;\u0026amp; existReverseSum(s, 1, n-1, 1)) 51} "},{"id":89,"href":"/docs/leetcode/hard/leetcode2444/","title":"2444. Count Subarrays With Fixed Bounds","section":"困难","content":" 题目 # You are given an integer array nums and two integers minK and maxK.\nA fixed-bound subarray of nums is a subarray that satisfies the following conditions:\nThe minimum value in the subarray is equal to minK. The maximum value in the subarray is equal to maxK. Return the number of fixed-bound subarrays.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [1,3,5,2,7,5], minK = 1, maxK = 5 Output: 2 Explanation: The fixed-bound subarrays are [1,3,5] and [1,3,5,2]. Example 2:\nInput: nums = [1,1,1,1], minK = 1, maxK = 1 Output: 10 Explanation: Every subarray of nums is a fixed-bound subarray. There are 10 possible subarrays. Constraints:\n$2 \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i], minK, maxK \u0026lt;= 10^6$ 思路1 分析性质一次遍历 # 分析 # 定界子数组里面只有minK和maxK之间的数，并且要求包含minK和maxK 可以找一个起点和终点，如果中间包含minK和maxK就代表一个满足条件的子数组，起点到第一个minK或maxK之间的每个点都可以和终点组成一个子数组 如果出现一个大于maxK或小于minK的，就将起点设置成下一个 minK和maxK所在索引都大于起点，就可以计算子数组数量 代码实现 # 1func min(a, b int) int { 2\tif a \u0026lt; b { 3\treturn a 4\t} 5\treturn b 6} 7 8func max(a, b int) int { 9\tif a \u0026gt; b { 10\treturn a 11\t} 12\treturn b 13} 14 15func countSubarrays(nums []int, minK int, maxK int) int64 { 16\ts, minI, maxI := -1, -1, -1 17\tvar result int64 = 0 18\tfor e, v := range nums { 19\tif v \u0026lt; minK || v \u0026gt; maxK { 20\ts = e // 子数组不包含s 21\tcontinue 22\t} 23\tif v == minK { 24\tminI = e 25\t} 26\tif v == maxK { 27\tmaxI = e 28\t} 29\t// 1 2 3 4 5 30\t// s i e 31\t// minI或maxI有一个小于s就不用计算，也就是+0 32\t// 都大于s，就是起点到较小的那个之间的数量都满足要求 33\tresult += int64(max(min(minI, maxI)-s, 0)) 34\t} 35\treturn result 36} "},{"id":90,"href":"/docs/leetcode/simple/leetcode2446/","title":"2446. Determine if Two Events Have Conflict","section":"简单","content":" 题目 # You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:\nevent1 = [startTime1, endTime1] and event2 = [startTime2, endTime2]. Event times are valid 24 hours format in the form of HH:MM.\nA conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).\nReturn true if there is a conflict between two events. Otherwise, return false.\nExample 1:\nInput: event1 = [\u0026#34;01:15\u0026#34;,\u0026#34;02:00\u0026#34;], event2 = [\u0026#34;02:00\u0026#34;,\u0026#34;03:00\u0026#34;] Output: true Explanation: The two events intersect at time 2:00. Example 2:\nInput: event1 = [\u0026#34;01:00\u0026#34;,\u0026#34;02:00\u0026#34;], event2 = [\u0026#34;01:20\u0026#34;,\u0026#34;03:00\u0026#34;] Output: true Explanation: The two events intersect starting from 01:20 to 02:00. Example 3:\nInput: event1 = [\u0026#34;10:00\u0026#34;,\u0026#34;11:00\u0026#34;], event2 = [\u0026#34;14:00\u0026#34;,\u0026#34;15:00\u0026#34;] Output: false Explanation: The two events do not intersect. Constraints:\nevnet1.length == event2.length == 2. event1[i].length == event2[i].length == 5 startTime1 \u0026lt;= endTime1 startTime2 \u0026lt;= endTime2 All the event times follow the HH:MM format. 思路1 字符串比较 # 分析 # 直接比较字符串就好了，字符串大的就是时间靠后 代码 # 1func haveConflict(event1 []string, event2 []string) bool { 2\treturn strings.Compare(event1[0], event2[1]) \u0026lt;= 0 \u0026amp;\u0026amp; strings.Compare(event1[1], event2[0]) \u0026gt;= 0 3} "},{"id":91,"href":"/docs/leetcode/medium/leetcode2447/","title":"2447. Number of Subarrays With GCD Equal to K","section":"中等","content":" 题目 # Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray\u0026rsquo;s elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.\nExample 1:\nInput: nums = [9,3,1,2,6,3], k = 3 Output: 4 Explanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray\u0026#39;s elements are: - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] - [9,3,1,2,6,3] Example 2:\nInput: nums = [4], k = 7 Output: 0 Explanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray\u0026#39;s elements. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 $1 \u0026lt;= nums[i], k \u0026lt;= 10^9$ 思路1 # 分析 # 遍历起点，找所有的子数组 使用最大公约数的传递性计算 代码 # 1func mgcd(a int, b int) int { 2\tfor a != 0 { 3\ta, b = b%a, a 4\t} 5\treturn b 6} 7 8func subarrayGCD(nums []int, k int) int { 9\tresult := 0 10\tfor i := range nums { 11\t// 从起点向后最大公约数设为tmp 12\t// 向后遍历查看有几个子数组 13\tfor tmp, j := nums[i], i; j \u0026lt; len(nums); j++ { 14\tif nums[j]%k != 0 { 15\t// 数组中存在一个不是k的倍数的值，就不用继续找了 16\tbreak 17\t} 18 19\t// 倍数的最大公约数向后传递，如 gcd(8, 4) = 4 =\u0026gt; gcd(8, 4, 6) = gcd(4, 6) = 2 20\tif tmp != k { 21\ttmp = mgcd(tmp, nums[j]) 22\t} 23 24\tif tmp == k { 25\tresult++ 26\t} 27\t} 28\t} 29\treturn result 30} "},{"id":92,"href":"/docs/leetcode/hard/leetcode2448/","title":"2448. Minimum Cost to Make Array Equal","section":"困难","content":" 题目 # You are given two 0-indexed arrays nums and cost consisting each of n positive integers.\nYou can do the following operation any number of times:\nIncrease or decrease any element of the array nums by 1. The cost of doing one operation on the ith element is cost[i].\nReturn the minimum total cost such that all the elements of the array nums become equal.\nExample 1:\nInput: nums = [1,3,5,2], cost = [2,3,1,14] Output: 8 Explanation: We can make all the elements equal to 2 in the following way: - Increase the 0th element one time. The cost is 2. - Decrease the 1st element one time. The cost is 3. - Decrease the 2nd element three times. The cost is 1 + 1 + 1 = 3. The total cost is 2 + 3 + 3 = 8. It can be shown that we cannot make the array equal with a smaller cost. Example 2:\nInput: nums = [2,2,2,2,2], cost = [4,2,8,1,3] Output: 0 Explanation: All the elements are already equal, so no operations are needed. Constraints:\nn == nums.length == cost.length $1 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= nums[i], cost[i] \u0026lt;= 10^6$ 思路1 中位数 # 分析 # 把cost看成数字的数量 从最小的数开始，向上加一，比选择的数小的都要加一，大的都要减一 最小的cost就是不管向上还是向下，比选择的数大的和小的应该相等，那不就是中位数 代码 # 1func abs(x int) int { 2\tif x \u0026lt; 0 { 3\treturn -x 4\t} 5\treturn x 6} 7 8func minCost(nums []int, cost []int) int64 { 9\ttype item struct { 10\tval, count int 11\t} 12\tcountMap := make([]item, len(nums)) 13\tsum := 0 14\tfor i, v := range nums { 15\tcountMap[i] = item{ 16\tval: v, 17\tcount: cost[i], 18\t} 19\tsum += cost[i] 20\t} 21\tsort.Slice(countMap, func(i, j int) bool { return countMap[i].val \u0026lt; countMap[j].val }) 22\tmidI := sum / 2 23\tmedian := 0 24\tfor _, v := range countMap { 25\tif midI \u0026lt; v.count { 26\tmedian = v.val 27\tbreak 28\t} 29\tmidI -= v.count 30\t} 31\tvar res int64 = 0 32\t// 所有数变成中位数 33\tfor _, v := range countMap { 34\tres += int64(abs(median-v.val) * v.count) 35\t} 36\treturn res 37} "},{"id":93,"href":"/docs/leetcode/simple/leetcode2455/","title":"2455. Average Value of Even Numbers That Are Divisible by Three","section":"简单","content":" 题目 # Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.\nExample 1:\nInput: nums = [1,3,6,10,12,15] Output: 9 Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9. Example 2:\nInput: nums = [1,2,4,7,10] Output: 0 Explanation: There is no single number that satisfies the requirement, so return 0. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 1000 思路1 # 分析 # 照着做 代码 # 1func averageValue(nums []int) int { 2\tresult := 0 3\tcount := 0 4\tfor _, v := range nums { 5\tif v%6 == 0 { 6\tresult += v 7\tcount++ 8\t} 9\t} 10\tif count == 0 { 11\treturn 0 12\t} 13\treturn (result / count) 14} "},{"id":94,"href":"/docs/leetcode/medium/leetcode2456/","title":"2456. Most Popular Video Creator","section":"中等","content":" 题目 # You are given two string arrays creators and ids, and an integer array views, all of length n. The ith video on a platform was created by creator[i], has an id of ids[i], and has views[i] views.\nThe popularity of a creator is the sum of the number of views on all of the creator\u0026rsquo;s videos. Find the creator with the highest popularity and the id of their most viewed video.\nIf multiple creators have the highest popularity, find all of them. If multiple videos have the highest view count for a creator, find the lexicographically smallest id. Return a 2D array of strings answer where answer[i] = [creatori, idi] means that creatori has the highest popularity and idi is the id of their most popular video. The answer can be returned in any order.\nExample 1:\nInput: creators = [\u0026#34;alice\u0026#34;,\u0026#34;bob\u0026#34;,\u0026#34;alice\u0026#34;,\u0026#34;chris\u0026#34;], ids = [\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;], views = [5,10,5,4] Output: [[\u0026#34;alice\u0026#34;,\u0026#34;one\u0026#34;],[\u0026#34;bob\u0026#34;,\u0026#34;two\u0026#34;]] Explanation: The popularity of alice is 5 + 5 = 10. The popularity of bob is 10. The popularity of chris is 4. alice and bob are the most popular creators. For bob, the video with the highest view count is \u0026#34;two\u0026#34;. For alice, the videos with the highest view count are \u0026#34;one\u0026#34; and \u0026#34;three\u0026#34;. Since \u0026#34;one\u0026#34; is lexicographically smaller than \u0026#34;three\u0026#34;, it is included in the answer. Example 2:\nInput: creators = [\u0026#34;alice\u0026#34;,\u0026#34;alice\u0026#34;,\u0026#34;alice\u0026#34;], ids = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;], views = [1,2,2] Output: [[\u0026#34;alice\u0026#34;,\u0026#34;b\u0026#34;]] Explanation: The videos with id \u0026#34;b\u0026#34; and \u0026#34;c\u0026#34; have the highest view count. Since \u0026#34;b\u0026#34; is lexicographically smaller than \u0026#34;c\u0026#34;, it is included in the answer. Constraints:\nn == creators.length == ids.length == views.length $1 \u0026lt;= n \u0026lt;= 10^5$ 1 \u0026lt;= creators[i].length, ids[i].length \u0026lt;= 5 creators[i] and ids[i] consist only of lowercase English letters. $0 \u0026lt;= views[i] \u0026lt;= 10^5$ 思路1 使用map整理 # 分析 # 按照题意模拟即可，为了查找方便，使用map管理 代码 # 1type Author struct { 2\tid string 3\tidPop int // id对应的popular 4\tpopular int 5} 6 7func mostPopularCreator(creators []string, ids []string, views []int) [][]string { 8\tallAuthor := make(map[string]Author) 9\tmaxPopular := 0 10\tfor i, name := range creators { 11\tid, view := ids[i], views[i] 12\ttmp := allAuthor[name] 13\tif tmp.id == \u0026#34;\u0026#34; { 14\ttmp = Author{ 15\tid: id, 16\tpopular: view, 17\tidPop: view, 18\t} 19\t} else { 20\ttmp.popular += view 21\tif view \u0026gt; tmp.idPop || (view == tmp.idPop \u0026amp;\u0026amp; id \u0026lt; tmp.id) { 22\ttmp.id = id 23\ttmp.idPop = view 24\t} 25\t} 26\tif tmp.popular \u0026gt; maxPopular { 27\tmaxPopular = tmp.popular 28\t} 29\tallAuthor[name] = tmp 30\t} 31 32\tresult := make([][]string, 0) 33\tfor k, v := range allAuthor { 34\tif v.popular == maxPopular { 35\ttmp := []string{k, v.id} 36\tresult = append(result, tmp) 37\t} 38\t} 39 40\treturn result 41} "},{"id":95,"href":"/docs/leetcode/medium/leetcode2457/","title":"2457. Minimum Addition to Make Integer Beautiful","section":"中等","content":" 题目 # You are given two positive integers n and target.\nAn integer is considered beautiful if the sum of its digits is less than or equal to target.\nReturn the minimum non-negative integer x such that n + x is beautiful. The input will be generated such that it is always possible to make n beautiful.\nExample 1:\nInput: n = 16, target = 6 Output: 4 Explanation: Initially n is 16 and its digit sum is 1 + 6 = 7. After adding 4, n becomes 20 and digit sum becomes 2 + 0 = 2. It can be shown that we can not make n beautiful with adding non-negative integer less than 4. Example 2:\nInput: n = 467, target = 6 Output: 33 Explanation: Initially n is 467 and its digit sum is 4 + 6 + 7 = 17. After adding 33, n becomes 500 and digit sum becomes 5 + 0 + 0 = 5. It can be shown that we can not make n beautiful with adding non-negative integer less than 33. Example 3:\nInput: n = 1, target = 1 Output: 0 Explanation: Initially n is 1 and its digit sum is 1, which is already smaller than or equal to target. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^{12}$ 1 \u0026lt;= target \u0026lt;= 150 The input will be generated such that it is always possible to make n beautiful. 思路1 拆分计算 # 分析 # 先将数拆分为一个一个数字，计算目标值和当前值差多少 然后一位一位进，进到差值一样即可 代码 # 1func makeIntegerBeautiful(n int64, target int) int64 { 2\tcurSum := 0 3\tnums := make([]int, 0, 12) 4\tfor n != 0 { 5\tt := int(n % 10) 6\tcurSum += t 7\tnums = append(nums, t) 8\tn = n / 10 9\t} 10 11\tif curSum \u0026lt;= target { 12\treturn 0 13\t} 14 15\tvar result int64 = 0 16\taa := 1 17\tfor _, v := range nums { 18\t// 先假设每一位都加到9，最终返回结果要加一 19\tresult += int64(9-v) * int64(aa) 20\tcurSum -= v 21\t// 排除一位，但是高位要进一，所以判断小于即可 22\tif curSum \u0026lt; target { 23\treturn result + 1 24\t} 25\taa *= 10 26\t} 27\treturn result + 1 28} "},{"id":96,"href":"/docs/leetcode/simple/leetcode2460/","title":"2460. Apply Operations to an Array","section":"简单","content":" 题目 # You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation. After performing all the operations, shift all the 0\u0026rsquo;s to the end of the array.\nFor example, the array [1,0,2,0,0,1] after shifting all its 0\u0026rsquo;s to the end, is [1,2,1,0,0,0]. Return the resulting array.\nNote that the operations are applied sequentially, not all at once.\nExample 1:\nInput: nums = [1,2,2,1,1,0] Output: [1,4,2,0,0,0] Explanation: We do the following operations: - i = 0: nums[0] and nums[1] are not equal, so we skip this operation. - i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0]. - i = 2: nums[2] and nums[3] are not equal, so we skip this operation. - i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0]. - i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0]. After that, we shift the 0\u0026#39;s to the end, which gives the array [1,4,2,0,0,0]. Example 2:\nInput: nums = [0,1] Output: [1,0] Explanation: No operation can be applied, we just shift the 0 to the end. Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 2000 = 0 \u0026lt;= nums[i] \u0026lt;= 1000 思路1 # 分析 # 照着做，复用原数组，搞一个非0的索引 代码 # 1func applyOperations(nums []int) []int { 2\tn := len(nums) 3\tj := 0 // j是非0的索引 4\tfor i := 0; i \u0026lt; n; i++ { 5\tif i == n-1 { 6\tnums[j] = nums[i] 7\tj++ 8\tcontinue 9\t} 10\tif nums[i] \u0026gt; 0 { 11\tif nums[i] == nums[i+1] { 12\tnums[j] = nums[i] * 2 13\tnums[i+1] = 0 14\ti++ 15\t} else { 16\tnums[j] = nums[i] 17\t} 18\tj++ 19\t} 20\t} 21\tfor ; j \u0026lt; n; j++ { 22\tnums[j] = 0 23\t} 24\treturn nums 25} "},{"id":97,"href":"/docs/leetcode/medium/leetcode2461/","title":"2461. Maximum Sum of Distinct Subarrays With Length K","section":"中等","content":" 题目 # You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\nThe length of the subarray is k, and All the elements of the subarray are distinct. Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,5,4,2,9,9,9], k = 3 Output: 15 Explanation: The subarrays of nums with length 3 are: - [1,5,4] which meets the requirements and has a sum of 10. - [5,4,2] which meets the requirements and has a sum of 11. - [4,2,9] which meets the requirements and has a sum of 15. - [2,9,9] which does not meet the requirements because the element 9 is repeated. - [9,9,9] which does not meet the requirements because the element 9 is repeated. We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions Example 2:\nInput: nums = [4,4,4], k = 3 Output: 0 Explanation: The subarrays of nums with length 3 are: - [4,4,4] which does not meet the requirements because the element 4 is repeated. We return 0 because no subarrays meet the conditions. Constraints:\n$1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^5$ 思路1 # 分析 # 双指针或者叫滑动窗口 用一个map存上一次出现的索引，就不用删除了 遇到有的直接左指针移到上一次出现的右边即可 代码 # 1func maximumSubarraySum(nums []int, k int) int64 { 2\tnumMap := make(map[int]int) // value为最近一次出现的索引 3\tvar res int64 = 0 4\tvar add int64 = 0 5\tl := 0 // 左指针，包含 6\tfor r, v := range nums { 7\tadd += int64(v) 8\tindex, ok := numMap[v] 9\tif ok \u0026amp;\u0026amp; index \u0026gt;= l { 10\t// 找到相等的，并且就在范围内，将左侧左移到index右边 11\tfor i := l; i \u0026lt;= index; i++ { 12\tadd -= int64(nums[i]) 13\t} 14\tl = index + 1 15\t} else if r-l == k-1 { 16\tif add \u0026gt; res { 17\tres = add 18\t} 19\tadd -= int64(nums[l]) 20\tl++ 21\t} 22\tnumMap[v] = r 23\t} 24\treturn res 25} "},{"id":98,"href":"/docs/leetcode/medium/leetcode2462/","title":"2462. Total Cost to Hire K Workers","section":"中等","content":" 题目 # You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\nYou will run k sessions and hire exactly one worker in each session. In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index. For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2]. In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process. If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index. A worker can only be chosen once. Return the total cost to hire exactly k workers.\nExample 1:\nInput: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4 Output: 11 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2. - In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4. - In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers. The total hiring cost is 11. Example 2:\nInput: costs = [1,2,4,1], k = 3, candidates = 3 Output: 4 Explanation: We hire 3 workers in total. The total cost is initially 0. - In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers. - In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2. - In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4. The total hiring cost is 4. Constraints:\n$1 \u0026lt;= costs.length \u0026lt;= 10^5$ $1 \u0026lt;= costs[i] \u0026lt;= 10^5$ 1 \u0026lt;= k, candidates \u0026lt;= costs.length 思路1 # 分析 小根堆 # 将candicate建堆，索引和cost一起作为小根堆的less，然后k次选择，出堆入堆即可 代码 # 1func maximumSubarraySum(nums []int, k int) int64 { 2\tnumMap := make(map[int]int) // value为最近一次出现的索引 3\tvar res int64 = 0 4\tvar add int64 = 0 5\tl := 0 // 左指针，包含 6\tfor r, v := range nums { 7\tadd += int64(v) 8\tindex, ok := numMap[v] 9\tif ok \u0026amp;\u0026amp; index \u0026gt;= l { 10\t// 找到相等的，并且就在范围内，将左侧左移到index右边 11\tfor i := l; i \u0026lt;= index; i++ { 12\tadd -= int64(nums[i]) 13\t} 14\tl = index + 1 15\t} else if r-l == k-1 { 16\tif add \u0026gt; res { 17\tres = add 18\t} 19\tadd -= int64(nums[l]) 20\tl++ 21\t} 22\tnumMap[v] = r 23\t} 24\treturn res 25} 思路2 两个小根堆 # 分析 # 灵神的写法，复用原数组做两个最小堆 重叠的话就将最小堆合并然后排序选取 代码 # go里面建堆直接复用原数组，没有申请空间 1// 用不着Push和Pop，随便实现一下 2type lhp struct{ sort.IntSlice } 3 4func (lhp) Push(interface{}) {} 5func (lhp) Pop() (_ interface{}) { return } 6 7func totalCost1(costs []int, k int, candidates int) int64 { 8\tvar ans int64 = 0 9\t// 在原始数据上进行建堆 10\tn := len(costs) 11\tif candidates*2 \u0026lt; n { 12\t// 比n小就建两个堆 13\tpre := lhp{costs[:candidates]} 14\tsuf := lhp{costs[n-candidates:]} 15\theap.Init(\u0026amp;pre) 16\theap.Init(\u0026amp;suf) 17\tfor i, j := candidates, n-candidates-1; i \u0026lt;= j \u0026amp;\u0026amp; k \u0026gt; 0; k-- { 18\tif pre.IntSlice[0] \u0026lt;= suf.IntSlice[0] { 19\t// 选前面的 20\tans += int64(pre.IntSlice[0]) 21\t// 将中间的赋值给前面的 22\tpre.IntSlice[0] = costs[i] 23\theap.Fix(\u0026amp;pre, 0) 24\ti++ 25\t} else { 26\tans += int64(suf.IntSlice[0]) 27\tsuf.IntSlice[0] = costs[j] 28\theap.Fix(\u0026amp;suf, 0) 29\tj-- 30\t} 31\t} 32\tif k == 0 { 33\treturn ans 34\t} 35\t// 取了几个后，重叠了，剩下的合并成一个数组 36\tcosts = append(pre.IntSlice, suf.IntSlice...) 37\t} 38\tsort.Ints(costs) 39\tfor _, c := range costs[:k] { 40\tans += int64(c) 41\t} 42\treturn ans 43} "},{"id":99,"href":"/docs/leetcode/simple/leetcode2469/","title":"2469. Convert the Temperature","section":"简单","content":" 题目 # You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\nKelvin = Celsius + 273.15 Fahrenheit = Celsius * 1.80 + 32.00 Example 1:\nInput: celsius = 36.50 Output: [309.65000,97.70000] Explanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70. Example 2:\nInput: celsius = 122.11 Output: [395.26000,251.79800] Explanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798. Constraints:\n0 \u0026lt;= celsius \u0026lt;= 1000 思路1 # 分析 # 照着做 代码 # 1func convertTemperature(celsius float64) []float64 { 2\treturn []float64{celsius + 273.15, celsius*1.80 + 32.00} 3} "},{"id":100,"href":"/docs/leetcode/simple/leetcode2475/","title":"2475. Number of Unequal Triplets in Array","section":"简单","content":" 题目 # You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:\n0 \u0026lt;= i \u0026lt; j \u0026lt; k \u0026lt; nums.length nums[i], nums[j], and nums[k] are pairwise distinct. In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k]. Return the number of triplets that meet the conditions.\nExample 1:\nInput: nums = [4,4,2,4,3] Output: 3 Explanation: The following triplets meet the conditions: - (0, 2, 4) because 4 != 2 != 3 - (1, 2, 4) because 4 != 2 != 3 - (2, 3, 4) because 2 != 4 != 3 Since there are 3 triplets, we return 3. Note that (2, 0, 4) is not a valid triplet because 2 \u0026gt; 0. Example 2:\nInput: nums = [1,1,1,1,1] Output: 0 Explanation: No triplets meet the conditions so we return 0. Constraints:\n3 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 1000 思路1 爆破 # 分析 # 照着做 代码 # 1func unequalTriplets(nums []int) int { 2\tresult := 0 3\tfor i := 0; i \u0026lt; len(nums)-2; i++ { 4\tfor j := i + 1; j \u0026lt; len(nums)-1; j++ { 5\tif nums[j] == nums[i] { 6\tcontinue 7\t} 8\tfor k := j + 1; k \u0026lt; len(nums); k++ { 9\tif nums[k] == nums[j] || nums[k] == nums[i] { 10\tcontinue 11\t} 12\tresult++ 13\t} 14\t} 15\t} 16\treturn result 17} 思路2 排序+分组 # 分析 # 只要数量，那么顺序就无所谓了，那么先排序 排完序之后可以认为中间的数是x，那么小于x的有a个，x有b个，大于x的有c个，x在中间的数对有abc个 代码 # 1func unequalTriplets1(nums []int) int { 2\tsort.Ints(nums) 3\tn := len(nums) 4\t// x作为中间的数，那么小于x的有a个，x有b个，大于x的有c个，x在中间的数对有abc个 5\tstart, res := 0, 0 // start为x的起始位置 6\tfor i, x := range nums[:n-1] { 7\tif x != nums[i+1] { 8\tres += start * (i + 1 - start) * (n - i - 1) 9\tstart = i + 1 10\t} 11\t} 12\treturn res 13} 思路3 分组+计算 # 分析 # 思路和上面一样，不过排完序再算abc不太优雅，用分组来直接统计数量更好 使用hashmap来统计 代码 # 1func unequalTriplets2(nums []int) int { 2\th := make(map[int]int) 3\tfor _, v := range nums { 4\th[v]++ 5\t} 6\ta, c, res := 0, len(nums), 0 7\tfor _, b := range h { 8\tc -= b 9\tres += a * b * c 10\ta += b 11\t} 12\treturn res 13} "},{"id":101,"href":"/docs/leetcode/medium/leetcode2476/","title":"2476. Closest Nodes Queries in a Binary Search Tree","section":"中等","content":" 题目 # You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead. maxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead. Return the array answer.\nExample 1:\nInput: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16] Output: [[2,2],[4,6],[15,-1]] Explanation: We answer the queries in the following way: - The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2]. - The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6]. - The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1]. Example 2:\nInput: root = [4,null,9], queries = [3] Output: [[-1,4]] Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]. Constraints:\nThe number of nodes in the tree is in the range [2, 105]. $1 \u0026lt;= Node.val \u0026lt;= 10^6$ n == queries.length $1 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= queries[i] \u0026lt;= 10^6$ 思路1 二分 # 分析 # 二叉搜索树，直接查会超时，还是中序遍历成有序数组，然后二分 代码 # 1var arr []int = make([]int, 1e5) 2 3func closestNodes(root *TreeNode, queries []int) [][]int { 4\tarr = arr[:0] 5\tvar dfs func(r *TreeNode) 6\tdfs = func(r *TreeNode) { 7\tif r.Left != nil { 8\tdfs(r.Left) 9\t} 10\tarr = append(arr, r.Val) 11\tif r.Right != nil { 12\tdfs(r.Right) 13\t} 14\t} 15\tdfs(root) 16 17\tn := len(arr) 18\tresult := make([][]int, len(queries)) 19\tfor j, v := range queries { 20\tmin, max := -1, -1 21\ti := sort.SearchInts(arr, v) 22\tif i == n { 23\tmin = arr[i-1] 24\t} else if arr[i] == v { 25\tmin, max = v, v 26\t} else if i == 0 { 27\tmax = arr[i] 28\t} else { 29\tmin, max = arr[i-1], arr[i] 30\t} 31\tresult[j] = []int{min, max} 32\t} 33\treturn result 34} "},{"id":102,"href":"/docs/leetcode/simple/leetcode2485/","title":"2485. Find the Pivot Integer","section":"简单","content":" 题目 # Given a positive integer n, find the pivot integer x such that:\nThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively. Return the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.\nExample 1:\nInput: n = 8 Output: 6 Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21. Example 2:\nInput: n = 1 Output: 1 Explanation: 1 is the pivot integer since: 1 = 1. Example 3:\nInput: n = 4 Output: -1 Explanation: It can be proved that no such integer exist. Constraints:\n1 \u0026lt;= n \u0026lt;= 1000\n思路1 暴力破解 # 分析 # 用等差数列的求和公式，遍历1到n计算一下，相等就返回 化简求和公式可以得到 $2i^2 = n^2+n$ 代码 # 1func pivotInteger1(n int) int { 2\tm := n * (n + 1) / 2 3\tfor i := 1; i \u0026lt;= n; i++ { 4\tif i*i == m { 5\treturn i 6\t} 7\t} 8\treturn -1 9} 思路2 双指针 # 分析 # 自己想的，不做暴力破解 加左边减右边，到中间的时候最终结果一定是0 代码 # 1func pivotInteger(n int) int { 2\tl, r := 1, n 3\ttmp := 0 // 加左边减右边 4\t// 两边遍历直到中间 5\tfor l != r { 6\tif tmp \u0026gt; 0 { 7\ttmp -= r 8\tr-- 9\t} else { 10\ttmp += l 11\tl++ 12\t} 13\t} 14\tif tmp == 0 { 15\treturn l 16\t} 17\treturn -1 18} 思路3 数学公式 # 分析 # 由思路一，直接求$x = \\sqrt{\\frac{n(n+1)}{2}}$ 判断x是不是整数就好了 代码 # 1func pivotInteger(n int) int { 2\tm := n * (n + 1) / 2 3\tx := int(math.Sqrt(float64(m))) 4\tif x * x == m { 5\treturn x 6\t} 7\treturn -1 8} "},{"id":103,"href":"/docs/leetcode/medium/leetcode2486/","title":"2486. Append Characters to String to Make Subsequence","section":"中等","content":" 题目 # You are given two strings s and t consisting of only lowercase English letters.\nReturn the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nExample 1:\nInput: s = \u0026#34;coaching\u0026#34;, t = \u0026#34;coding\u0026#34; Output: 4 Explanation: Append the characters \u0026#34;ding\u0026#34; to the end of s so that s = \u0026#34;coachingding\u0026#34;. Now, t is a subsequence of s (\u0026#34;coachingding\u0026#34;). It can be shown that appending any 3 characters to the end of s will never make t a subsequence. Example 2:\nInput: s = \u0026#34;abcde\u0026#34;, t = \u0026#34;a\u0026#34; Output: 0 Explanation: t is already a subsequence of s (\u0026#34;abcde\u0026#34;). Example 3:\nInput: s = \u0026#34;z\u0026#34;, t = \u0026#34;abcde\u0026#34; Output: 5 Explanation: Append the characters \u0026#34;abcde\u0026#34; to the end of s so that s = \u0026#34;zabcde\u0026#34;. Now, t is a subsequence of s (\u0026#34;zabcde\u0026#34;). It can be shown that appending any 4 characters to the end of s will never make t a subsequence. Constraints:\n$1 \u0026lt;= s.length, t.length \u0026lt;= 10^5$ s and t consist only of lowercase English letters. 思路1 双指针 # 分析 # 由于需要按顺序找子序列，所以便利两个字符串，找到s中按顺序的t中有多少字母 排除这些剩余的就是需要追加的字符数量 代码 # 1func appendCharacters(s string, t string) int { 2\ti := 0 3\tfor _, v := range s { 4\tif byte(v) == t[i] { 5\ti++ 6\tif i == len(t) { 7\treturn 0 8\t} 9\t} 10\t} 11\treturn len(t) - i 12} "},{"id":104,"href":"/docs/leetcode/medium/leetcode2487/","title":"2487. Remove Nodes From Linked List","section":"中等","content":" 题目 # You are given the head of a linked list.\nRemove every node which has a node with a strictly greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\nExample 1:\nInput: head = [5,2,13,3,8] Output: [13,8] Explanation: The nodes that should be removed are 5, 2 and 3. - Node 13 is to the right of node 5. - Node 13 is to the right of node 2. - Node 8 is to the right of node 3. Example 2:\nInput: head = [1,1,1,1] Output: [1,1,1,1] Explanation: Every node has value 1, so no nodes are removed. Constraints:\nThe number of the nodes in the given list is in the range $[1, 10^5]$. $1 \u0026lt;= Node.val \u0026lt;= 10^5$ 思路1 反向最大值遍历 # 分析 # 自己想的 将链表所有的val存到数组中，然后处理数据，让 $arr[i] = \\max \\limits_{i \\le x \u0026lt; n}$ arr 遍历链表，如果当前小于 $arr[i]$ ，就跳过，相等就赋值 代码 # 1func removeNodes(head *ListNode) *ListNode { 2\tcur := head 3\tarr := make([]int, 0, 1) 4\tfor cur != nil { 5\tarr = append(arr, cur.Val) 6\tcur = cur.Next 7\t} 8\tmax := arr[len(arr)-1] 9\tfor i := len(arr) - 2; i \u0026gt;= 0; i-- { 10\tif max \u0026lt; arr[i] { 11\tmax = arr[i] 12\t} else { 13\tarr[i] = max 14\t} 15\t} 16 17\tcur = head 18\tresultTmp := \u0026amp;ListNode{ 19\tNext: head, 20\t} 21\tlast := resultTmp 22\tfor i := 0; i \u0026lt; len(arr); i++ { 23\tif cur.Val \u0026lt; arr[i] { 24\tlast.Next = cur.Next 25\t} else { 26\tlast = cur 27\t} 28\tcur = cur.Next 29\t} 30\treturn resultTmp.Next 31} 思路2 链表转数组处理 # 分析 # 将链表所有节点放到数组中 每放一个节点，查看前面的节点是否比它小，如果比它小就替代 代码 # 1func removeNodes1(head *ListNode) *ListNode { 2\tarr := make([]*ListNode, 0, 1) 3\tfor p := head; p != nil; p = p.Next { 4\tt := len(arr) - 1 5\tfor t \u0026gt;= 0 \u0026amp;\u0026amp; arr[t].Val \u0026lt; p.Val { 6\tarr = arr[:t] 7\tt-- 8\t} 9\tarr = append(arr, p) 10\t} 11\tfor i := 0; i \u0026lt; len(arr)-1; i++ { 12\tarr[i].Next = arr[i+1] 13\t} 14\treturn arr[0] 15} "},{"id":105,"href":"/docs/leetcode/hard/leetcode2488/","title":"2488. Count Subarrays With Median K","section":"困难","content":" 题目 # You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k.\nNote:\nThe median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element. For example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4. A subarray is a contiguous part of an array. Example 1:\nInput: nums = [3,2,1,4,5], k = 4 Output: 3 Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5]. Example 2:\nInput: nums = [2,3,1], k = 3 Output: 1 Explanation: [3] is the only subarray that has a median equal to 3. Constraints:\nn == nums.length $1 \u0026lt;= n \u0026lt;= 10^5$ 1 \u0026lt;= nums[i], k \u0026lt;= n The integers in nums are distinct. 思路1 统计一边大于或小于等于，然后计算另一边 # 分析 # 此题目中的中位数可以推出来 奇数长度下 $$左侧小于+右侧小于 = 左侧大于+右侧大于$$ $$左侧小于-左侧大于 = 右侧大于-右侧小于$$\n偶数长度下 $$左侧小于-左侧大于+1 = 右侧大于-右侧小于$$\n从中位数开始，向左就是大于为-1，小于为1，累加之后如果左侧和右侧相等就找到一个子数组 那么步骤就是先统计左边，然后去右边找有没有匹配的 边界情况，中位数既要算到左边也要算到右边，可以认为是以中位数为边界，向右找要算上，中位数本身也要统计向左边有几个0或-1 代码 # 1func countSubarrays1(nums []int, k int) int { 2\t// 1. 先找中位数的位置 3\tv := 0 4\tfor i := range nums { 5\tif nums[i] == k { 6\tv = i 7\tbreak 8\t} 9\t} 10 11\t// 2. 向左开始进行累加，使用map进行存储 12\trecordMap := make(map[int]int) 13\trecordMap[0] = 1 // 中位数的位置本身就是0 14\ttmp := 0 15\tfor i := v - 1; i \u0026gt;= 0; i-- { 16\tif nums[i] \u0026gt; k { 17\ttmp-- 18\t} else { 19\ttmp++ 20\t} 21\tif _, ok := recordMap[tmp]; !ok { 22\trecordMap[tmp] = 0 23\t} 24\trecordMap[tmp]++ 25\t} 26 27\t// 向右开始查找 28\tresult := 0 29\ttmp = 0 30\tfor i := v; i \u0026lt; len(nums); i++ { 31\tif nums[i] \u0026gt; k { 32\ttmp++ 33\t} else if nums[i] \u0026lt; k { 34\ttmp-- 35\t} 36\t// 左侧小于-左侧大于 = 右侧大于-右侧小于 37\tif count, ok := recordMap[tmp]; ok { 38\tresult += count 39\t} 40\t// 左侧小于-左侧大于+1 = 右侧大于-右侧小于 41\tif count, ok := recordMap[tmp-1]; ok { 42\tresult += count 43\t} 44\t} 45\treturn result 46} 思路2 简化成一次遍历 # 分析 # 还是上面的思路，最左侧其实等于 $\\sum 左侧小于 - \\sum 左侧大于$ 整体统计数据加上 $\\sum 左侧大于 - \\sum 左侧小于$，那么最左边的就是0，第二个就是大于加一，小于减一，和右边计算是一致的 只需要考虑边界情况，将中位数计算到两边即可，那么一次遍历就解决了问题 第一位是按照0开始计算的，所以每个i都是在算i+1的结果，所以左边的遍历只需要到k所在位置前一个就好 代码 # 1func countSubarrays(nums []int, k int) int { 2\tresult := 0 3\tv := len(nums) 4\ttmp := 0 5\trecordMap := make(map[int]int) 6\trecordMap[0] = 1 // 第一位是0 7\tfor i := range nums { 8\tif nums[i] \u0026gt; k { 9\ttmp++ 10\t} else if nums[i] \u0026lt; k { 11\ttmp-- 12\t} else { 13\tv = i 14\t} 15\t// 每个i计算的都是下一位的值，所以不需要到中位数所在的位置 16\tif i \u0026lt; v { 17\tif _, ok := recordMap[tmp]; !ok { 18\trecordMap[tmp] = 0 19\t} 20\trecordMap[tmp]++ 21\t} else { 22\tif count, ok := recordMap[tmp]; ok { 23\tresult += count 24\t} 25\tif count, ok := recordMap[tmp-1]; ok { 26\tresult += count 27\t} 28\t} 29\t} 30\treturn result 31} "},{"id":106,"href":"/docs/leetcode/simple/leetcode2490/","title":"2490. Circular Sentence","section":"简单","content":" 题目 # A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\nFor example, \u0026ldquo;Hello World\u0026rdquo;, \u0026ldquo;HELLO\u0026rdquo;, \u0026ldquo;hello world hello world\u0026rdquo; are all sentences. Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\nA sentence is circular if:\nThe last character of a word is equal to the first character of the next word. The last character of the last word is equal to the first character of the first word. For example, \u0026ldquo;leetcode exercises sound delightful\u0026rdquo;, \u0026ldquo;eetcode\u0026rdquo;, \u0026ldquo;leetcode eats soul\u0026rdquo; are all circular sentences. However, \u0026ldquo;Leetcode is cool\u0026rdquo;, \u0026ldquo;happy Leetcode\u0026rdquo;, \u0026ldquo;Leetcode\u0026rdquo; and \u0026ldquo;I like Leetcode\u0026rdquo; are not circular sentences.\nGiven a string sentence, return true if it is circular. Otherwise, return false.\nExample 1:\nInput: sentence = \u0026#34;leetcode exercises sound delightful\u0026#34; Output: true Explanation: The words in sentence are [\u0026#34;leetcode\u0026#34;, \u0026#34;exercises\u0026#34;, \u0026#34;sound\u0026#34;, \u0026#34;delightful\u0026#34;]. - leetcode\u0026#39;s last character is equal to exercises\u0026#39;s first character. - exercises\u0026#39;s last character is equal to sound\u0026#39;s first character. - sound\u0026#39;s last character is equal to delightful\u0026#39;s first character. - delightful\u0026#39;s last character is equal to leetcode\u0026#39;s first character. The sentence is circular. Example 2:\nInput: sentence = \u0026#34;eetcode\u0026#34; Output: true Explanation: The words in sentence are [\u0026#34;eetcode\u0026#34;]. - eetcode\u0026#39;s last character is equal to eetcode\u0026#39;s first character. The sentence is circular. Example 3:\nInput: sentence = \u0026#34;Leetcode is cool\u0026#34; Output: false Explanation: The words in sentence are [\u0026#34;Leetcode\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;cool\u0026#34;]. - Leetcode\u0026#39;s last character is not equal to is\u0026#39;s first character. The sentence is not circular. Constraints:\n$1 \u0026lt;= sentence.length \u0026lt;= 500$ sentence consist of only lowercase and uppercase English letters and spaces. The words in sentence are separated by a single space. There are no leading or trailing spaces. 思路1 正面解决 # 分析 # 按照题目要求正常解 代码 # 1func getLast(str string) byte { 2\treturn str[len(str)-1] 3} 4 5func isCircularSentence(sentence string) bool { 6\tarr := strings.Split(sentence, \u0026#34; \u0026#34;) 7\tif arr[0][0] != getLast(arr[len(arr)-1]) { 8\treturn false 9\t} 10 11\tfor i := 1; i \u0026lt; len(arr); i++ { 12\tif getLast(arr[i-1]) != arr[i][0] { 13\treturn false 14\t} 15\t} 16\treturn true 17} 思路2 稍加分析 # 分析 # 整体句子第一个和最后一个是否一样 空格两边的字母相等 代码 # 1func getLast(str string) byte { 2\treturn str[len(str)-1] 3} 4 5func isCircularSentence(sentence string) bool { 6\tif sentence[0] != getLast(sentence) { 7\treturn false 8\t} 9\tfor i := range sentence { 10\tif sentence[i] == \u0026#39; \u0026#39; { 11\tif sentence[i-1] != sentence[i+1] { 12\treturn false 13\t} 14\t} 15\t} 16\treturn true 17} "},{"id":107,"href":"/docs/leetcode/medium/leetcode2491/","title":"2491. Circular Sentence","section":"中等","content":" 题目 # You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal. Example 1:\nInput: skill = [3,2,5,1,3,4] Output: 22 Explanation: Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6. The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22. Example 2:\nInput: skill = [3,4] Output: 12 Explanation: The two players form a team with a total skill of 7. The chemistry of the team is 3 * 4 = 12. Example 3:\nInput: skill = [1,1,2,3] Output: -1 Explanation: There is no way to divide the players into teams such that the total skill of each team is equal. Constraints:\n$2 \u0026lt;= skill.length \u0026lt;= 10^5$ skill.length is even. 1 \u0026lt;= skill[i] \u0026lt;= 1000 思路1 排序后遍历 # 分析 # 自己的想法麻烦得很，还是北大的牛逼 因为所有组相加都相等，所以最大的和最小的一起，中等和中等一起 那么先排序，计算最大和最小的和，然后遍历计算result，不符合相加等于对应值就是-1 代码 # 1func dividePlayers(skill []int) int64 { 2\tn := len(skill) 3\tsort.Ints(skill) 4\ttmp := skill[0] + skill[n-1] 5\tvar result int64 = 0 6\tfor i := 0; i \u0026lt; n/2; i++ { 7\tif tmp != skill[i] + skill[n-i-1] { 8\treturn -1 9\t} 10\tresult += int64(skill[i]*skill[n-i-1]) 11\t} 12\treturn result 13} "},{"id":108,"href":"/docs/leetcode/medium/leetcode2492/","title":"2492. Circular Sentence","section":"中等","content":" 题目 # You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\nA path is a sequence of roads between two cities. It is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path. The test cases are generated such that there is at least one path between 1 and n. Example 1:\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]] Output: 5 Explanation: The path from city 1 to 4 with the minimum score is: 1 -\u0026gt; 2 -\u0026gt; 4. The score of this path is min(9,5) = 5. It can be shown that no other path has less score. Example 2:\nInput: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]] Output: 2 Explanation: The path from city 1 to 4 with the minimum score is: 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 3 -\u0026gt; 4. The score of this path is min(2,2,4,7) = 2. Constraints:\n$2 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= roads.length \u0026lt;= 10^5$ roads[i].length == 3 $1 \u0026lt;= a_i, b_i \u0026lt;= n$ $a_i != b_i$ $1 \u0026lt;= distancei \u0026lt;= 10^4$ There are no repeated edges. There is at least one path between 1 and n. 思路1 并查集 # 分析 # 读清楚题目，其实就是找从1出发的所有连通路上的最短的路 本身就是两个思路bfs和并查集 并查集在这里就是找到所有的和1在一条连通路的点，然后从道路中找到这些点的最短道路 代码 # 1type unionFind struct { 2\tparent []int 3} 4 5func initUnionFind(n int) unionFind { 6\tu := unionFind{} 7\tu.parent = make([]int, n) 8\tfor i := range u.parent { 9\tu.parent[i] = i 10\t} 11\treturn u 12} 13 14func (u unionFind) find(a int) int { 15\tap := u.parent[a] 16\t// 找到最终节点 17\tfor ap != u.parent[ap] { 18\tap = u.parent[ap] 19\t} 20\t// 沿途都赋值最终节点 21\tfor a != ap { 22\tu.parent[a], a = ap, u.parent[a] 23\t} 24\treturn ap 25} 26 27func (u unionFind) merge(a, b int) { 28\t// b的父节点等于a的父节点，就是将两个点合并 29\tu.parent[u.find(b)] = u.find(a) 30} 31 32func min(a, b int) int { 33\tif b \u0026lt; a { 34\treturn b 35\t} 36\treturn a 37} 38 39func minScore(n int, roads [][]int) int { 40\tunion := initUnionFind(n + 1) 41\tfor _, v := range roads { 42\tx, y := v[0], v[1] 43\t// 建立关系 44\tunion.merge(x, y) 45\t} 46\tresult := math.MaxInt 47\tfor _, item := range roads { 48\tx, v := item[0], item[2] 49\t// 如果点和第一个点有关系代表能到达，那么就看路径是不是最小 50\tif union.find(x) == union.find(1) { 51\tresult = min(result, v) 52\t} 53\t} 54\treturn result 55} 思路2 bfs # 思路 # 使用bfs将所有路都走一边，然后从能走到所有节点中找到连接的最短路径 "},{"id":109,"href":"/docs/leetcode/simple/leetcode2500/","title":"2500. Delete Greatest Value in Each Row","section":"简单","content":" 题目 # You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them. Add the maximum of deleted elements to the answer. Note that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\nExample 1:\nInput: grid = [[1,2,4],[3,3,1]] Output: 8 Explanation: The diagram above shows the removed values in each step. - In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer. - In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer. - In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer. The final answer = 4 + 3 + 1 = 8. Example 2:\nInput: grid = [[10]] Output: 10 Explanation: The diagram above shows the removed values in each step. - In the first operation, we remove 10 from the first row. We add 10 to the answer. The final answer = 10. Constraints:\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= grid[i][j] \u0026lt;= 100 思路1 # 分析 # 读读题，想一想，就是将矩阵每一行从大到小排一下序，然后再对列找最大值加到一起完事 代码 # 1func deleteGreatestValue(grid [][]int) int { 2\tfor i := range grid { 3\tsort.Ints(grid[i]) 4\t} 5 6\tresult := 0 7\tfor i := range grid[0] { 8\tmax := grid[0][i] 9\tfor j := range grid { 10\tif max \u0026lt; grid[j][i] { 11\tmax = grid[j][i] 12\t} 13\t} 14\tresult += max 15\t} 16 17\treturn result 18} "},{"id":110,"href":"/docs/leetcode/medium/leetcode2501/","title":"2501. Longest Square Streak in an Array","section":"中等","content":" 题目 # You are given an integer array nums. A subsequence of nums is called a square streak if:\nThe length of the subsequence is at least 2, and after sorting the subsequence, each element (except the first element) is the square of the previous number. Return the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\nExample 1:\nInput: nums = [4,3,6,16,8,2] Output: 3 Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16]. - 4 = 2 * 2. - 16 = 4 * 4. Therefore, [4,16,2] is a square streak. It can be shown that every subsequence of length 4 is not a square streak. Example 2:\nInput: nums = [2,3,5,6,7] Output: -1 Explanation: There is no square streak in nums so return -1. Constraints:\n$2 \u0026lt;= nums.length \u0026lt;= 10^5$ $2 \u0026lt;= nums[i] \u0026lt;= 10^5$ 思路1 暴力破解 # 分析 # 由于平方最多也就32次左右，所以爆破遍历的时间复杂度并不高，直接存入一个map，然后暴力遍历就好 代码 # 1func longestSquareStreak(nums []int) int { 2\tset := make(map[int]bool) 3\tfor _, v := range nums { 4\tset[v] = true 5\t} 6 7\tans := 1 8\tfor _, v := range nums { 9\tcnt := 1 10\tfor v *= v; set[v]; v *= v { 11\tcnt++ 12\t} 13\tif cnt \u0026gt; ans { 14\tans = cnt 15\t} 16\t} 17\tif ans == 1 { 18\treturn -1 19\t} 20\treturn ans 21} 思路2 排序+哈希 # 分析 # 效率和空间占用比上面的暴力还高，大致是因为暴力循环没那么多，而排序是 $O(n\\log n)$ 从最小的数开始，将它的数量记录到自己的平方上，这里取巧在于每个数拿到的都是自己的子项累加的数量，不需要再进行去重和反向查找等 代码 # 1func longestSquareStreak(nums []int) int { 2\tdp := make(map[int]int) 3\tsort.Ints(nums) 4\tans := 1 5\tfor _, v := range nums { 6\tc := 0 7\tvar ok bool 8\tif c, ok = dp[v]; ok { 9\tc += 1 10\t} else { 11\tc = 1 12\t} 13\tdp[v*v] = c 14\tif c \u0026gt; ans { 15\tans = c 16\t} 17\t} 18 19\tif ans == 1 { 20\treturn -1 21\t} 22\treturn ans 23} "},{"id":111,"href":"/docs/leetcode/medium/leetcode2502/","title":"2502. Longest Square Streak in an Array","section":"中等","content":" 题目 # You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\nYou have a memory allocator with the following functionalities:\nAllocate a block of size consecutive free memory units and assign it the id mID. Free all memory units with the given id mID. Note that:\nMultiple blocks can be allocated to the same mID. You should free all the memory units with mID, even if they were allocated in different blocks. Implement the Allocator class:\nAllocator(int n) Initializes an Allocator object with a memory array of size n. int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block\u0026rsquo;s first index. If such a block does not exist, return -1. int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed. Example 1:\nInput [\u0026#34;Allocator\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;free\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;free\u0026#34;, \u0026#34;allocate\u0026#34;, \u0026#34;free\u0026#34;] [[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]] Output [null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0] Explanation Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free. loc.allocate(1, 1); // The leftmost block\u0026#39;s first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0. loc.allocate(1, 2); // The leftmost block\u0026#39;s first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1. loc.allocate(1, 3); // The leftmost block\u0026#39;s first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2. loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2. loc.allocate(3, 4); // The leftmost block\u0026#39;s first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3. loc.allocate(1, 1); // The leftmost block\u0026#39;s first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1. loc.allocate(1, 1); // The leftmost block\u0026#39;s first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6. loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1. loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1. loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0. Constraints:\n1 \u0026lt;= n, size, mID \u0026lt;= 1000 At most 1000 calls will be made to allocate and free. 思路1 # 分析 # 就是设计一个内存池，删除全部清理，分配取最左侧匹配的 使用一个链表存储所有已分配内存，取第一个和最后一个为边界 再使用一个map存储清理时的mID对应在链表的迭代器 代码 # 1type mem struct { 2\tstart int 3\tend int // end不属于范围 4\tmID int 5} 6 7type Allocator struct { 8\tmemMap *list.List 9\tfreeMap map[int][]*list.Element 10} 11 12func Constructor(n int) Allocator { 13\tres := Allocator{} 14\tres.memMap = list.New() 15\t// 放一个头节点进去 16\tres.memMap.PushFront(mem{ 17\tstart: 0, 18\tend: 0, 19\tmID: -1, 20\t}) 21\t// 放一个尾节点进去 22\tres.memMap.PushBack(mem{ 23\tstart: n, 24\tend: n, 25\tmID: -1, 26\t}) 27\tres.freeMap = make(map[int][]*list.Element) 28\tfmt.Printf(\u0026#34;init %p\\r\\n\u0026#34;, \u0026amp;(res.memMap)) 29\treturn res 30} 31 32func (this *Allocator) Allocate(size int, mID int) int { 33\t// 从第一个开始找所有间隔是否有空位 34\tp := this.memMap.Front() 35\tfor n := p.Next(); n != nil; p, n = n, n.Next() { 36\tif n.Value.(mem).start-p.Value.(mem).end \u0026lt; size { 37\tcontinue 38\t} 39\tstart := p.Value.(mem).end 40\tfmt.Printf(\u0026#34;insert %p\\r\\n\u0026#34;, \u0026amp;(this.memMap)) 41\tthis.memMap.InsertAfter(mem{ 42\tstart: start, 43\tend: start + size, 44\tmID: mID, 45\t}, p) 46\tif _, ok := this.freeMap[mID]; !ok { 47\tthis.freeMap[mID] = make([]*list.Element, 0, 1) 48\t} 49\tthis.freeMap[mID] = append(this.freeMap[mID], p.Next()) 50\treturn start 51\t} 52\treturn -1 53} 54 55func (this *Allocator) Free(mID int) int { 56\tans := 0 57\tif idMap, ok := this.freeMap[mID]; ok { 58\tfor _, v := range idMap { 59\tans += v.Value.(mem).end - v.Value.(mem).start 60\tthis.memMap.Remove(v) 61\t} 62\tthis.freeMap[mID] = this.freeMap[mID][:0] 63\t} 64\treturn ans 65} 66 67/** 68 * Your Allocator object will be instantiated and called as such: 69 * obj := Constructor(n); 70 * param_1 := obj.Allocate(size,mID); 71 * param_2 := obj.Free(mID); 72 */ "},{"id":112,"href":"/docs/leetcode/simple/leetcode2515/","title":"2515. Shortest Distance to Target String in a Circular Array","section":"简单","content":" 题目 # You are given a 0-indexed circular string array words and a string target. A circular array means that the array\u0026rsquo;s end connects to the array\u0026rsquo;s beginning.\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words. Starting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\nExample 1:\nInput: words = [\u0026#34;hello\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;am\u0026#34;,\u0026#34;leetcode\u0026#34;,\u0026#34;hello\u0026#34;], target = \u0026#34;hello\u0026#34;, startIndex = 1 Output: 1 Explanation: We start from index 1 and can reach \u0026#34;hello\u0026#34; by - moving 3 units to the right to reach index 4. - moving 2 units to the left to reach index 4. - moving 4 units to the right to reach index 0. - moving 1 unit to the left to reach index 0. The shortest distance to reach \u0026#34;hello\u0026#34; is 1. Example 2:\nInput: words = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;leetcode\u0026#34;], target = \u0026#34;leetcode\u0026#34;, startIndex = 0 Output: 1 Explanation: We start from index 0 and can reach \u0026#34;leetcode\u0026#34; by - moving 2 units to the right to reach index 3. - moving 1 unit to the left to reach index 3. The shortest distance to reach \u0026#34;leetcode\u0026#34; is 1. Example 3:\nInput: words = [\u0026#34;i\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;leetcode\u0026#34;], target = \u0026#34;ate\u0026#34;, startIndex = 0 Output: -1 Explanation: Since \u0026#34;ate\u0026#34; does not exist in words, we return -1. Constraints:\n1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] and target consist of only lowercase English letters. 0 \u0026lt;= startIndex \u0026lt; words.length 思路1 # 分析 # 按照题目找，从起点开始，左右开工，找到相同的就返回 代码 # 1func closetTarget(words []string, target string, startIndex int) int { 2\tif words[startIndex] == target { 3\treturn 0 4\t} 5\tl, r := startIndex, startIndex 6\tn := 0 7\tfor { 8\tl-- 9\tif l \u0026lt; 0 { 10\tl = len(words) - 1 11\t} 12\tr++ 13\tif r == len(words) { 14\tr = 0 15\t} 16\tn++ 17\tif words[l] == target || words[r] == target { 18\treturn n 19\t} 20\tif r == l { 21\treturn -1 22\t} 23\t} 24} 思路2 # 分析 # 遍历一遍，找正向和反向最小的 时间复杂度比上面高点，不过还是O(n) 代码 # 1func abs(x int) int { 2\tif x \u0026lt; 0 { 3\treturn -x 4\t} 5\treturn x 6} 7 8func min(a, b int) int { 9\tif a \u0026gt; b { 10\treturn b 11\t} 12\treturn a 13} 14 15func closetTarget1(words []string, target string, startIndex int) int { 16\tresult := math.MaxInt 17\tfor i := range words { 18\tif words[i] != target { 19\tcontinue 20\t} 21\td := abs(startIndex - i) 22\td = min(d, len(words)-d) 23\tresult = min(result, d) 24\t} 25\tif result == math.MaxInt { 26\treturn -1 27\t} 28\treturn result 29} "},{"id":113,"href":"/docs/leetcode/medium/leetcode2516/","title":"2516. Take K of Each Character From Left and Right","section":"中等","content":" 题目 # You are given a string s consisting of the characters \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, and \u0026lsquo;c\u0026rsquo; and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\nExample 1:\nInput: s = \u0026#34;aabaaaacaabc\u0026#34;, k = 2 Output: 8 Explanation: Take three characters from the left of s. You now have two \u0026#39;a\u0026#39; characters, and one \u0026#39;b\u0026#39; character. Take five characters from the right of s. You now have four \u0026#39;a\u0026#39; characters, two \u0026#39;b\u0026#39; characters, and two \u0026#39;c\u0026#39; characters. A total of 3 + 5 = 8 minutes is needed. It can be proven that 8 is the minimum number of minutes needed. Example 2:\nInput: s = \u0026#34;a\u0026#34;, k = 1 Output: -1 Explanation: It is not possible to take one \u0026#39;b\u0026#39; or \u0026#39;c\u0026#39; so return -1. Constraints:\n$1 \u0026lt;= s.length \u0026lt;= 10^5$ s consists of only the letters \u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, and \u0026lsquo;c\u0026rsquo;. $0 \u0026lt;= k \u0026lt;= s.length$ 思路1 双指针 # 分析 # 先假设左侧没有，全部取右侧，能否满足要求，不满足就返回-1 满足要求开始缩减，右侧对应的位置的字母统计大于k就右移，右移到不能大于为止，判断和result是不是最小 然后将左侧指向的字符加入，下一个循环判断 当左侧大于当前最小结果就不用继续了，因为一定左侧加右侧大于当前结果 代码 # 1func min(a, b int) int { 2\tif a \u0026lt; b { 3\treturn a 4\t} 5\treturn b 6} 7 8func takeCharacters(s string, k int) int { 9\tif k == 0 { 10\treturn 0 11\t} 12\tchCount := make([]int, 3) 13\t// 第一个for循环，查看左侧为0，右侧需要有多长 14\tfor r := len(s) - 1; r \u0026gt;= 0; r-- { 15\tchCount[int(s[r]-\u0026#39;a\u0026#39;)]++ 16\t} 17\tfor _, v := range chCount { 18\tif v \u0026lt; k { 19\treturn -1 20\t} 21\t} 22 23\tresult := len(s) 24\tr := 0 25\t// l所在位置还没有被选入，下一个循环被选入，不用考虑最后一个，因为最后一个和r到第一个一样 26\tfor l := 0; l \u0026lt; result; l++ { 27\t// 右侧对应的字符大于k，说明右侧可以移动 28\tfor r \u0026lt; len(s) \u0026amp;\u0026amp; chCount[int(s[r]-\u0026#39;a\u0026#39;)] \u0026gt; k { 29\tchCount[int(s[r]-\u0026#39;a\u0026#39;)]-- 30\tr++ 31\t} 32\tresult = min(result, l+len(s)-r) 33\tchCount[int(s[l]-\u0026#39;a\u0026#39;)]++ 34\t} 35 36\treturn result 37} "},{"id":114,"href":"/docs/leetcode/medium/leetcode2517/","title":"2517. Maximum Tastiness of Candy Basket","section":"中等","content":" 题目 # You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.\nThe store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.\nReturn the maximum tastiness of a candy basket.\nExample 1:\nInput: price = [13,5,1,8,21,2], k = 3 Output: 8 Explanation: Choose the candies with the prices [13,5,21]. The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8. It can be proven that 8 is the maximum tastiness that can be achieved. Example 2:\nInput: price = [1,3,1], k = 2 Output: 2 Explanation: Choose the candies with the prices [1,3]. The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2. It can be proven that 2 is the maximum tastiness that can be achieved. Example 3:\nInput: price = [7,7,7,7], k = 2 Output: 0 Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0. Constraints:\n$2 \u0026lt;= k \u0026lt;= price.length \u0026lt;= 10^5$ $1 \u0026lt;= price[i] \u0026lt;= 10^9$ 思路1 二分查找 # 分析 # 间隔越大，越不容易满足条件，那么正好可以使用二分查找第一个不满足条件的间隔，减一就是答案 二分想要认为从第一个找k个间隔大于等于d的，那么存在两种情况，第一个真的在里面，第一个不在里面 第一个在里面 # 分为第二个是要找的，和第二个不是要找的 第二个是要找的不用关心，第二个不是要找的，那么第二个实际肯定比当前要大，那么间隔d的第三个肯定满足比错误的第二个间隔大于d，不影响后续结果 第一个不是真实找的 # 同样分为第二个不是要找的和第二个是要找的 如果第二个是要找的，那么第一个和第二个间隔大于d，同样不影响 第二个不是要找的，第二个比真实第二个肯定要小，对应第三个肯定间隔也大于d，同样不影响 结论 # 直接从第一个开始找间隔大于等于d的是否存在即可 代码 # 1func maximumTastiness(price []int, k int) int { 2\tsort.Ints(price) 3\treturn sort.Search((price[len(price)-1]-price[0])/(k-1), func(d int) bool { 4\t// 二分查找从0开始，而间隔最小是1，那么换算一下，真实间隔是d+1 5\td++ 6\tcnt, x := 1, price[0] 7\tfor _, v := range price[1:] { 8\tif v \u0026gt;= x+d { 9\tcnt++ 10\tx = v 11\t} 12\t} 13\t// 因为间隔越小越容易满足，那么二分的条件就是找到第一个不符合条件的d，那么减一就是要求的最大值 14\t// 正好d是间隔减一，直接返回即可 15\treturn cnt \u0026lt; k 16\t}) 17} "},{"id":115,"href":"/docs/leetcode/hard/leetcode2518/","title":"2518. Number of Great Partitions","section":"困难","content":" 题目 # You are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo $10^9 + 7$.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\nExample 1:\nInput: nums = [1,2,3,4], k = 4 Output: 6 Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]). Example 2:\nInput: nums = [3,3,3], k = 4 Output: 0 Explanation: There are no great partitions for this array. Example 3:\nInput: nums = [6,6], k = 2 Output: 2 Explanation: We can either put nums[0] in the first partition or in the second partition. The great partitions will be ([6], [6]) and ([6], [6]). Constraints:\n1 \u0026lt;= nums.length, k \u0026lt;= 1000 $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 逆向思维+背包方案数 # 分析 # 计算两边都大于不如计算一边小于的方案总数，然后用总方案减去 就是从nums取值，小于k就是一种，在另一个盒子中就是另一种，总数乘以2 计算小于k的方案数，可以使用动态规划，定义f[i][j]为前i个糖果取若干元素和为j的方案数，转移方程为 不选第i个数：f[i][j] = f[i-1][j] 选第i个数：f[i][j] = f[i-1][j-nums[i]] 综合f[i][j] = f[i-1][j] + f[i-1][j-nums[i]] 初始值f[0][0] = 1 坏分区个数为 $$ \\sum_{0 \\le i \\le k-1} f[n][i] $$\n动态规划方程中，i只和i-1相关，代码上只需要记录j即可，节省空间 总方案数为每个元素要么放左边要么放右边，也就是 $2^n$，边界情况一边没有计算到坏分区个数中 代码 # 1func countPartitions(nums []int, k int) int { 2\tconst mod int = 1e9 + 7 3\tsum := 0 4\tfor _, v := range nums { 5\tsum += v 6\t} 7\tif sum \u0026lt; k*2 { 8\treturn 0 9\t} 10 11\tans := 1 12\tf := make([]int, k) 13\tf[0] = 1 14\t// 从0算到n，不需要记录已经算过的值，即计算i时，使用i-1的结果，不关心i-2的 15\tfor _, v := range nums { 16\tans = ans * 2 % mod 17\t// 要加上j和j-nums[i]，那么j肯定要大于等于nums[i] 18\t// j只需要计算到k-1即可 19\tfor j := k - 1; j \u0026gt;= v; j-- { 20\t// f[i][j] = f[i-1][j] + f[i-1][j-nums[i]] 21\t// 对于当前i来说，f存储的是i-1的值，那么就是f[j] = f[j] + f[j-nums[i]] 22\tf[j] = (f[j] + f[j-v]) % mod 23\t} 24\t} 25\tfor _, v := range f { 26\tans -= v * 2 27\t} 28\treturn (ans%mod + mod) % mod 29} "},{"id":116,"href":"/docs/leetcode/simple/leetcode2520/","title":"2520. Count the Digits That Divide a Number","section":"简单","content":" 题目 # Given an integer num, return the number of digits in num that divide num.\nAn integer val divides nums if nums % val == 0.\nExample 1:\nInput: num = 7 Output: 1 Explanation: 7 divides itself, hence the answer is 1. Example 2:\nInput: num = 121 Output: 2 Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2. Example 3:\nInput: num = 1248 Output: 4 Explanation: 1248 is divisible by all of its digits, hence the answer is 4. Constraints:\n$1 \u0026lt;= num \u0026lt;= 10^9$ num does not contain 0 as one of its digits. 思路1 # 分析 # 按照题目要求正常解，转string比较方便遍历 代码 # 1func countDigits(num int) int { 2\tresult := 0 3\tfor _, v := range fmt.Sprint(num) { 4\tif v != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; num%int(v-\u0026#39;0\u0026#39;) == 0 { 5\tresult++ 6\t} 7\t} 8\treturn result 9} "},{"id":117,"href":"/docs/leetcode/medium/leetcode2521/","title":"2521. Distinct Prime Factors of Product of Array","section":"中等","content":" 题目 # Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\nA number greater than 1 is called prime if it is divisible by only 1 and itself. An integer val1 is a factor of another integer val2 if val2 / val1 is an integer. Example 1:\nInput: nums = [2,4,3,7,10,6] Output: 4 Explanation: The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7. There are 4 distinct prime factors so we return 4. Example 2:\nInput: nums = [2,4,8,16] Output: 1 Explanation: The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210. There is 1 distinct prime factor so we return 1. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^4$ 2 \u0026lt;= nums[i] \u0026lt;= 1000 思路1 分别计算 # 分析 # 每一个数从2开始找因数，找到重新来 因数一定都是质数，因为合数可以由质数乘出来，那么到质数的时候已经为因数了 代码 # 1func distinctPrimeFactors(nums []int) int { 2\tset := make(map[int]bool) 3\tfor _, v := range nums { 4\t// 从2开始除，因为如果找到质数直接除就好，找到合数能整除，在质数时已经除了 5\tfor i := 2; i \u0026lt;= v; i++ { 6\tif v%i == 0 { 7\tset[i] = true 8\tv, i = v/i, 1 9\t} 10\t} 11\t} 12\treturn len(set) 13} "},{"id":118,"href":"/docs/leetcode/medium/leetcode2522/","title":"2522. Partition String Into Substrings With Values at Most K","section":"中等","content":" 题目 # You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\nEach digit of s is part of exactly one substring. The value of each substring is less than or equal to k. Return the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\nThe value of a string is its result when interpreted as an integer. For example, the value of \u0026ldquo;123\u0026rdquo; is 123 and the value of \u0026ldquo;1\u0026rdquo; is 1. A substring is a contiguous sequence of characters within a string. Example 1:\nInput: s = \u0026#34;165462\u0026#34;, k = 60 Output: 4 Explanation: We can partition the string into substrings \u0026#34;16\u0026#34;, \u0026#34;54\u0026#34;, \u0026#34;6\u0026#34;, and \u0026#34;2\u0026#34;. Each substring has a value less than or equal to k = 60. It can be shown that we cannot partition the string into less than 4 substrings. Example 2:\nInput: s = \u0026#34;238182\u0026#34;, k = 5 Output: -1 Explanation: There is no good partition for this string. Constraints:\n$1 \u0026lt;= s.length \u0026lt;= 105$ s[i] is a digit from \u0026lsquo;1\u0026rsquo; to \u0026lsquo;9\u0026rsquo;. $1 \u0026lt;= k \u0026lt;= 10^9$ 思路1 正面查找 # 分析 # 其实每一个数都尽可能大就好了，不用担心因为多找了一位而导致后面不好整 假设abcd四个数，如果bcd \u0026lt; k，abc \u0026gt; k，分为ab、cd与a、bcd一个效果 所以从第一个开始尽可能找匹配的即可 为-1仅有一种可能，某一位本身大于k，否则肯定有值，那么就可以提前将最后一个计算进去，count从1开始 代码 # 1func minimumPartition(s string, k int) int { 2\tt := 0 3\tresult := 1 4\tfor _, v := range s { 5\td := int(byte(v) - \u0026#39;0\u0026#39;) 6\tif d \u0026gt; k { 7\treturn -1 8\t} 9\ttmp := t*10 + d 10\tif tmp \u0026gt; k { 11\tt = d 12\tresult++ 13\t} else { 14\tt = tmp 15\t} 16\t} 17\treturn result 18} "},{"id":119,"href":"/docs/leetcode/medium/leetcode2523/","title":"2523. Closest Prime Numbers in Range","section":"中等","content":" 题目 # Given two positive integers left and right, find the two integers num1 and num2 such that:\nleft \u0026lt;= nums1 \u0026lt; nums2 \u0026lt;= right . nums1 and nums2 are both prime numbers. nums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions. Return the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.\nExample 1:\nInput: left = 10, right = 19 Output: [11,13] Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19. The closest gap between any pair is 2, which can be achieved by [11,13] or [17,19]. Since 11 is smaller than 17, we return the first pair. Example 2:\nInput: left = 4, right = 6 Output: [-1,-1] Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied. Constraints:\n$1 \u0026lt;= left \u0026lt;= right \u0026lt;= 10^6$ 思路1 查找质数+状态机 # 分析 # 自己想的，从left到right，每个数都试试是不是质数，是质数就放到状态机计算 因为时间复杂度太高，优化了一下，因为质数最小差是2和3之间差1，后面基本最小都是相差2，那么找到相差小于等于2就可以直接返回了，后面不可能比此数更小了 代码 # 1func isPrime(num int) bool { 2\tif num \u0026lt;= 1 { 3\treturn false 4\t} 5\ttarget := int(math.Sqrt(float64(num))) + 1 6\tfor i := 2; i \u0026lt; target; i++ { 7\tif num%i == 0 { 8\treturn false 9\t} 10\t} 11\treturn true 12} 13 14func closestPrimes(left int, right int) []int { 15\tstate := 0 16\tp, n := 0, 0 17\tresult := []int{-1, -1} 18\tmin := math.MaxInt 19\tfor i := left; i \u0026lt;= right; i++ { 20\tif !isPrime(i) { 21\tcontinue 22\t} 23\tswitch state { 24\tcase 0: 25\t// 未找到第一个质数 26\tstate = 1 27\tp = i 28\tcase 1: 29\t// 找到第一个质数，未找到第二个 30\tstate = 2 31\tn = i 32\tresult[0], result[1] = p, n 33\tmin = n - p 34\tcase 2: 35\t// 两个都找到了，找个最小的 36\tp, n = n, i 37\tif min \u0026gt; n-p { 38\tresult[0], result[1] = p, n 39\tmin = n - p 40\t} 41\t} 42\tif min \u0026lt;= 2 { 43\treturn result 44\t} 45\t} 46\treturn result 47} 思路2 欧拉线性筛+状态机 # 分析 # 第一的想法，不过没我快 先使用欧拉线性筛先提前筛出来 $10^6$ 以内所有的质数，然后再使用上面的状态机进行选择 代码 # 1var primes []int = make([]int, 0, 78500) 2 3func oulerPrimes(mx int, primes *[]int) { 4\tflag := make([]bool, mx+1) // 标记数有没有被筛掉，false就是没有 5\tfor i := 2; i \u0026lt; mx+1; i++ { 6\tif !flag[i] { 7\t// 数没有被比自己小的数筛掉，就代表是质数 8\t*primes = append(*primes, i) 9\t} 10\tfor _, v := range *primes { 11\tif i*v \u0026gt; mx { 12\tbreak 13\t} 14\t// 每一个数都作为因子乘以比自己小的素数筛掉后面的数 15\tflag[i*v] = true 16\tif i%v == 0 { 17\t// 减少时间复杂度的关键算法 18\t// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除 19\t// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv 20\t// 那么存在一个数 i \u0026lt; km \u0026lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度 21\tbreak 22\t} 23\t} 24\t} 25} 26 27func init() { 28\toulerPrimes(1e6, \u0026amp;primes) 29\tprimes = append(primes, 1e6+1) // 加一个边界防止越界 30} 31 32func closestPrimes1(left int, right int) []int { 33\ti := sort.SearchInts(primes, left) 34\tstate := 0 35\tp, n := 0, 0 36\tresult := []int{-1, -1} 37\tmin := math.MaxInt 38\tfor ; primes[i] \u0026lt;= right; i++ { 39\tswitch state { 40\tcase 0: 41\t// 未找到第一个质数 42\tstate = 1 43\tp = primes[i] 44\tcase 1: 45\t// 找到第一个质数，未找到第二个 46\tstate = 2 47\tn = primes[i] 48\tresult[0], result[1] = p, n 49\tmin = n - p 50\tcase 2: 51\t// 两个都找到了，找个最小的 52\tp, n = n, primes[i] 53\tif min \u0026gt; n-p { 54\tresult[0], result[1] = p, n 55\tmin = n - p 56\t} 57\t} 58\t} 59\treturn result 60} "},{"id":120,"href":"/docs/leetcode/simple/leetcode2529/","title":"2529. Maximum Count of Positive Integer and Negative Integer","section":"简单","content":" 题目 # Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\nIn other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg. Note that 0 is neither positive nor negative.\nExample 1:\nInput: nums = [-2,-1,-1,1,2,3] Output: 3 Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3. Example 2:\nInput: nums = [-3,-2,-1,0,0,1,2] Output: 3 Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3. Example 3:\nInput: nums = [5,20,66,1314] Output: 4 Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 2000 -2000 \u0026lt;= nums[i] \u0026lt;= 2000 nums is sorted in a non-decreasing order. 思路1 两次二分 # 分析 # 给的数组排好序了，二分查一下第一个0，再对剩下的二分查一下第一个正数 代码 # 1func maximumCount(nums []int) int { 2\tneg := sort.Search(len(nums), func(i int) bool { 3\treturn nums[i] \u0026gt;= 0 4\t}) 5\tpos := sort.Search(len(nums)-neg, func(i int) bool { 6\treturn nums[i+neg] \u0026gt; 0 7\t}) + neg 8\tif neg \u0026lt; len(nums)-pos { 9\treturn len(nums) - pos 10\t} 11\treturn neg 12} "},{"id":121,"href":"/docs/leetcode/medium/leetcode2530/","title":"2530. Maximum Count of Positive Integer and Negative Integer","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\nchoose an index i such that 0 \u0026lt;= i \u0026lt; nums.length, increase your score by nums[i], and replace nums[i] with ceil(nums[i] / 3). Return the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.\nExample 1:\nInput: nums = [10,10,10,10,10], k = 5 Output: 50 Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50. Example 2:\nInput: nums = [1,10,3,3,3], k = 3 Output: 17 Explanation: You can do the following operations: Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10. Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4. Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3. The final score is 10 + 4 + 3 = 17. Constraints:\n$1 \u0026lt;= nums.length, k \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 大根堆 # 分析 # 每次取最大的相加，那么就是大根堆嘛 代码 # 1type BigHeap []int 2 3func (h *BigHeap) Len() int { return len(*h) } 4 5// less必须满足当Less(i, j)和Less(j, i)都为false，则两个索引对应的元素相等 6// 为true，i向栈顶移动；为false，j向栈顶移动 7func (h *BigHeap) Less(i, j int) bool { return (*h)[i] \u0026gt; (*h)[j] } 8func (h *BigHeap) Swap(i, j int) { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] } 9func (h *BigHeap) Push(x interface{}) { 10\t*h = append(*h, x.(int)) 11} 12 13func (h *BigHeap) Pop() interface{} { 14\tx := (*h)[len(*h)-1] 15\t*h = (*h)[:len(*h)-1] 16\treturn x 17} 18 19func maxKelements(nums []int, k int) int64 { 20\tvar bigHeap BigHeap = nums 21\theap.Init(\u0026amp;bigHeap) 22\tvar result int64 = 0 23\tfor i := 0; i \u0026lt; k; i++ { 24\tv := heap.Pop(\u0026amp;bigHeap).(int) 25\tresult += int64(v) 26\theap.Push(\u0026amp;bigHeap, (v+2)/3) 27\t} 28\treturn result 29} "},{"id":122,"href":"/docs/leetcode/medium/leetcode2531/","title":"2531. Make Number of Distinct Characters Equal","section":"中等","content":" 题目 # You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 \u0026lt;= i \u0026lt; word1.length and 0 \u0026lt;= j \u0026lt; word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\nExample 1:\nInput: word1 = \u0026#34;ac\u0026#34;, word2 = \u0026#34;b\u0026#34; Output: false Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string. Example 2:\nInput: word1 = \u0026#34;abcc\u0026#34;, word2 = \u0026#34;aab\u0026#34; Output: true Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \u0026#34;abac\u0026#34; and word2 = \u0026#34;cab\u0026#34;, which both have 3 distinct characters. Example 3:\nInput: word1 = \u0026#34;abcde\u0026#34;, word2 = \u0026#34;fghij\u0026#34; Output: true Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap. Constraints:\n$1 \u0026lt;= word1.length, word2.length \u0026lt;= 10^5$ word1 and word2 consist of only lowercase English letters. 思路1 统计加各种情况枚举 # 分析 # 自己想得，其实想复杂了，具体看注释吧 代码 # 1func abs(a int) int { 2\tif a \u0026lt; 0 { 3\treturn -a 4\t} 5\treturn a 6} 7 8func isItPossible(word1 string, word2 string) bool { 9\tset1 := make(map[byte]int) 10\tset2 := make(map[byte]int) 11\tfor _, t := range word1 { 12\tv := byte(t) 13\tif set1[v] \u0026gt; 0 { 14\tset1[v]++ 15\t} else { 16\tset1[v] = 1 17\t} 18\t} 19\tfor _, t := range word2 { 20\tv := byte(t) 21\tif set2[v] \u0026gt; 0 { 22\tset2[v]++ 23\t} else { 24\tset2[v] = 1 25\t} 26\t} 27 28\t// 两个字符串中不同字符个数相等直接返回成功 29\tdiff := abs(len(set1) - len(set2)) 30\tmore, less := set1, set2 31\tif len(set1) \u0026lt; len(set2) { 32\tmore, less = set2, set1 33\t} 34\tif diff == 0 { 35\t// 多不变少不变，多的和少的有相同的 36\t//\t多的和少的各有一个只有一个但对方没有的 37\t// 多加少加\t多的和少的各有一个有两个的 38\tfor k := range more { 39\tif less[k] \u0026gt; 0 { 40\treturn true 41\t} 42\tif more[k] \u0026gt;= 2 { 43\tfor k1 := range less { 44\tif less[k1] \u0026gt;= 2 { 45\treturn true 46\t} 47\t} 48\t} else if more[k] == 1 \u0026amp;\u0026amp; less[k] == 0 { 49\tfor k1 := range less { 50\tif less[k1] == 1 \u0026amp;\u0026amp; more[k1] == 0 { 51\treturn true 52\t} 53\t} 54\t} 55\t} 56\treturn false 57\t} 58\tif diff == 1 { 59\t// 多减少不变，多的要替换的只有1个的并且替换来的是替换后已经有的 60\t//\t少的要替换的是有2个的并且替换来的是已经有的 61\t// 多减少动了一下还是没变，多的要替换的只有1个的并且替换来的是替换后已经有的 62\t//\t少的要替换的是有1个的并且替换来的是少的没有的 63\t// 多不变少加，多的要替换的是有2个的并且替换来的是已经有的 64\t// 少的要替换的是有2个的并且替换来的是没有的 65\t// 多变了一下但还是没变少加，多的要替换的是只有1个的并且是少的没有的，少的替换过来的是有两个的也是多的没有的 66\tfor k := range less { 67\tif less[k] \u0026gt;= 2 \u0026amp;\u0026amp; more[k] \u0026gt; 0 { 68\tfor k1 := range more { 69\tif more[k1] == 1 \u0026amp;\u0026amp; less[k1] \u0026gt; 0 \u0026amp;\u0026amp; k1 != k { 70\treturn true 71\t} 72\tif more[k1] \u0026gt;= 2 \u0026amp;\u0026amp; less[k1] == 0 { 73\treturn true 74\t} 75\t} 76\t} 77\tif less[k] \u0026gt;= 2 \u0026amp;\u0026amp; more[k] == 0 { 78\tfor k1 := range more { 79\tif more[k1] == 1 \u0026amp;\u0026amp; less[k1] == 0 { 80\treturn true 81\t} 82\t} 83\t} 84\tif less[k] == 1 \u0026amp;\u0026amp; more[k] \u0026gt; 0 { 85\tfor k1 := range more { 86\tif k != k1 \u0026amp;\u0026amp; more[k1] == 1 \u0026amp;\u0026amp; less[k1] == 0 { 87\treturn true 88\t} 89\t} 90\t} 91\t} 92\treturn false 93\t} 94\tif diff == 2 { 95\t// 多减少加，多的要替换的是只有1个的并且替换来的是替换后已经有的 96\t// 少的要替换的是有2个的并且替换来的是没有的 97\tfor k := range more { 98\tif more[k] == 1 \u0026amp;\u0026amp; less[k] == 0 { 99\tfor k1 := range less { 100\tif less[k1] \u0026gt;= 2 \u0026amp;\u0026amp; more[k1] \u0026gt; 0 \u0026amp;\u0026amp; k1 != k { 101\treturn true 102\t} 103\t} 104\t} 105\t} 106\treturn false 107\t} 108\treturn false 109} 思路2 和上面思路一样，只不过换了遍历方式 # 分析 # 第一步统计少不了 第二步判断是否不可行也少不了 第三步遍历所有的交换可能，有一种满足就返回 代码 # 1func isItPossible1(word1 string, word2 string) bool { 2\tset1 := make(map[rune]int) 3\tset2 := make(map[rune]int) 4\tfor _, t := range word1 { 5\tset1[t]++ 6\t} 7\tfor _, t := range word2 { 8\tset2[t]++ 9\t} 10 11\tdiff := len(set1) - len(set2) 12\tif diff \u0026gt; 2 || diff \u0026lt; -2 { 13\treturn false 14\t} 15 16\tgetInt := func(x bool) int { 17\tif x { 18\treturn 1 19\t} 20\treturn 0 21\t} 22 23\tfor k1, c1 := range set1 { 24\tfor k2, c2 := range set2 { 25\tif k1 == k2 { 26\t// 相等，交换不改变，那么长度差为0就可以 27\tif diff == 0 { 28\treturn true 29\t} 30\t} else { 31\t// 不相等，交换会变化，变化后相等即可 32\t// 当前长度 - k1是否唯一 + k2是否存在 33\tif (len(set1) - getInt(c1 == 1) + getInt(set1[k2] == 0)) == (len(set2) - getInt(c2 == 1) + getInt(set2[k1] == 0)) { 34\treturn true 35\t} 36\t} 37\t} 38\t} 39\treturn false 40} "},{"id":123,"href":"/docs/leetcode/simple/leetcode2535/","title":"2535. Difference Between Element Sum and Digit Sum of an Array","section":"简单","content":" 题目 # You are given a positive integer array nums.\nThe element sum is the sum of all the elements in nums. The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums. Return the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.\nExample 1:\nInput: nums = [1,15,6,3] Output: 9 Explanation: The element sum of nums is 1 + 15 + 6 + 3 = 25. The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16. The absolute difference between the element sum and digit sum is |25 - 16| = 9. Example 2:\nInput: nums = [1,2,3,4] Output: 0 Explanation: The element sum of nums is 1 + 2 + 3 + 4 = 10. The digit sum of nums is 1 + 2 + 3 + 4 = 10. The absolute difference between the element sum and digit sum is |10 - 10| = 0. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 2000 1 \u0026lt;= nums[i] \u0026lt;= 2000 思路1 正常写就好 # 分析 # 数字和肯定大于等于位和，不用写绝对值 代码 # 1func differenceOfSum(nums []int) int { 2\tl, r := 0, 0 3\tfor _, v := range nums { 4\tl += v 5\tfor _, v1 := range fmt.Sprint(v) { 6\tr += int(v1 - \u0026#39;0\u0026#39;) 7\t} 8\t} 9\treturn l - r 10} "},{"id":124,"href":"/docs/leetcode/medium/leetcode2536/","title":"2536. Increment Submatrices by One","section":"中等","content":" 题目 # You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.\nYou are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\nAdd 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat [y] for for all row1i \u0026lt;= x \u0026lt;= row2i and col1i \u0026lt;= y \u0026lt;= col2i. Return the matrix mat after performing every query.\nExample 1:\nInput: n = 3, queries = [[1,1,2,2],[0,0,1,1]] Output: [[1,1,0],[1,2,1],[0,1,1]] Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query. - In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2). - In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1). Example 2:\nInput: n = 2, queries = [[0,0,1,1]] Output: [[1,1],[1,1]] Explanation: The diagram above shows the initial matrix and the matrix after the first query. - In the first query we add 1 to every element in the matrix. Constraints:\n1 \u0026lt;= n \u0026lt;= 500 $1 \u0026lt;= queries.length \u0026lt;= 10^4$ 0 \u0026lt;= row1i \u0026lt;= row2i \u0026lt; n 0 \u0026lt;= col1i \u0026lt;= col2i \u0026lt; n 思路1 直接写 # 分析 # 据说会超时，不过我使用go好像处于C和python的中间状态，没有给超时 代码 # 1func rangeAddQueries(n int, queries [][]int) [][]int { 2\tresult := make([][]int, n) 3\tfor i := range result { 4\tresult[i] = make([]int, n) 5\t} 6 7\tfor _, v := range queries { 8\tfor i := v[0]; i \u0026lt;= v[2]; i++ { 9\tfor j := v[1]; j \u0026lt;= v[3]; j++ { 10\tresult[i][j]++ 11\t} 12\t} 13\t} 14\treturn result 15} 思路2 二维差分 # 分析 # 假设每一个query都是左上角到右下角，那么上面的时间复杂度就有点恐怖了 使用二维差分来做，每个元素影响自己右下角所有的点，那么query的左上就是1，右上就是-1，左下也是-1，右下就是1 0 0 0 0 0 0 0 0 0 query = [0, 0, 1, 1]\n1 0 -1 0 0 0 -1 0 1 可以看出每个点的值都是包含自己的左上所有元素的和 1 1 0 1 1 0 0 0 0 那么可以得出每个点的值是 $自己 + 左邻居 + 上邻居 - 左上邻居$ 代码 # 1func rangeAddQueries1(n int, queries [][]int) [][]int { 2\t// 防止越界 3\tresult := make([][]int, n+1) 4\tfor i := range result { 5\tresult[i] = make([]int, n+1) 6\t} 7 8\tfor _, v := range queries { 9\tr1, c1, r2, c2 := v[0], v[1], v[2]+1, v[3]+1 10\tresult[r1][c1] += 1 11\tresult[r1][c2] -= 1 12\tresult[r2][c1] -= 1 13\tresult[r2][c2] += 1 14\t} 15 16\tfor i := range result { 17\tresult[i] = result[i][:n] 18\tfor j := range result[i] { 19\t// 每个点都是其自身和左上所有元素的和 20\t// 那么每个点都是自己+左邻居+上邻居-坐上邻居 21\tadd := 0 22\tif i \u0026gt; 0 { 23\tadd += result[i-1][j] 24\t} 25\tif j \u0026gt; 0 { 26\tadd += result[i][j-1] 27\t} 28\tif i \u0026gt; 0 \u0026amp;\u0026amp; j \u0026gt; 0 { 29\tadd -= result[i-1][j-1] 30\t} 31\tresult[i][j] += add 32\t} 33\t} 34\treturn result[:n] 35} "},{"id":125,"href":"/docs/leetcode/medium/leetcode2537/","title":"2537. Count the Number of Good Subarrays","section":"中等","content":" 题目 # Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i \u0026lt; j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,1,1,1,1], k = 10 Output: 1 Explanation: The only good subarray is the array nums itself. Example 2:\nInput: nums = [3,1,4,3,2,2,4], k = 2 Output: 4 Explanation: There are 4 different good subarrays: - [3,1,4,3,2,2] that has 2 pairs. - [3,1,4,3,2,2,4] that has 3 pairs. - [1,4,3,2,2,4] that has 2 pairs. - [4,3,2,2,4] that has 2 pairs. ``` Constraints: - $1 \u0026lt;= nums.length \u0026lt;= 10^5$ - $1 \u0026lt;= nums[i], k \u0026lt;= 10^9$ # 思路1 双指针滑动窗口 ## 分析 - 找子数组，而且是大于等于k都满足，直接使用滑动窗口解题 - 如果确定左端点，不太好写。确定右端点来写滑动窗口 - 右端点右移，右端点的字母在窗口中存在几个，那么就增加几个对 - 左端点右移，左端点字母在除了左端点有几个，就减少几个对 - 当满足大于等于k时，以右端点为终点的子数组有左端点左边所有的点 ## 代码 ```go func countGood(nums []int, k int) int64 { l := 0 countMap := make(map[int]int) check := 0 var result int64 // 右侧遍历端点 for _, v := range nums { check += countMap[v] countMap[v]++ for check-countMap[nums[l]]+1 \u0026gt;= k { countMap[nums[l]]-- check -= countMap[nums[l]] l++ } if check \u0026gt;= k { result += int64(l + 1) } } return result } "},{"id":126,"href":"/docs/leetcode/simple/leetcode2562/","title":"2562. Find the Array Concatenation Value","section":"简单","content":" 题目 # You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\nFor example, the concatenation of 15, 49 is 1549. The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums. If one element exists, add its value to the concatenation value of nums, then delete it. Return the concatenation value of the nums.\nExample 1:\nInput: nums = [7,52,2,4] Output: 596 Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0. - In the first operation: We pick the first element, 7, and the last element, 4. Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74. Then we delete them from nums, so nums becomes equal to [52,2]. - In the second operation: We pick the first element, 52, and the last element, 2. Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596. Then we delete them from the nums, so nums becomes empty. Since the concatenation value is 596 so the answer is 596. Example 2:\nInput: nums = [5,14,13,8,12] Output: 673 Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0. - In the first operation: We pick the first element, 5, and the last element, 12. Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512. Then we delete them from the nums, so nums becomes equal to [14,13,8]. - In the second operation: We pick the first element, 14, and the last element, 8. Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660. Then we delete them from the nums, so nums becomes equal to [13]. - In the third operation: nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673. Then we delete it from nums, so nums become empty. Since the concatenation value is 673 so the answer is 673. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 $1 \u0026lt;= nums[i] \u0026lt;= 10^4$ 思路1 正常解即可 # 分析 # 转字符串遍历位数 代码 # 1func findTheArrayConcVal(nums []int) int64 { 2\tvar result int64 = 0 3\tfor i, j := 0, len(nums)-1; i \u0026lt;= j; i, j = i+1, j-1 { 4\tif i == j { 5\tresult += int64(nums[i]) 6\tbreak 7\t} 8\tvar tmp int64 = int64(nums[i]) 9\tfor _ = range fmt.Sprint(nums[j]) { 10\ttmp *= 10 11\t} 12\ttmp += int64(nums[j]) 13\tresult += tmp 14\t} 15\treturn result 16} "},{"id":127,"href":"/docs/leetcode/medium/leetcode2563/","title":"2563. Count the Number of Fair Pairs","section":"中等","content":" 题目 # Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.\nA pair (i, j) is fair if:\n0 \u0026lt;= i \u0026lt; j \u0026lt; n, and lower \u0026lt;= nums[i] + nums[j] \u0026lt;= upper Example 1:\nInput: nums = [0,1,7,4,4,5], lower = 3, upper = 6 Output: 6 Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5). Example 2: Input: nums = [1,7,9,2,5], lower = 11, upper = 11 Output: 1 Explanation: There is a single fair pair: (2,3). Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $nums.length == n$ $-10^9 \u0026lt;= nums[i] \u0026lt;= 10^9$ $-10^9 \u0026lt;= lower \u0026lt;= upper \u0026lt;= 10^9$ 思路1 二分 # 分析 # 排序后才能二分 右端点区间左侧是查找第一个大于等于lower，随着左端点增大，区间左侧减小，二分查找[i+1, l) 右端点区间右侧查找第一个大于upper的，同上要减小，二分查找[l, r) 代码 # 1func countFairPairs(nums []int, lower int, upper int) int64 { 2\tsort.Ints(nums) 3\tl, r := len(nums), len(nums)\t// l代表大于i的第一个下界，r代表大于l的第一个上界 4\tvar result int64 = 0 5\t// 6\tfor i := 0; i \u0026lt; len(nums) \u0026amp;\u0026amp; r \u0026gt; i+1; i++ { 7\t// i增加后，l应该减小，那么就要查找 [i+1, l) 区间范围 8\tl = sort.Search(l-i-1, func(index int) bool { 9\tindex += i + 1 10\treturn nums[index]+nums[i] \u0026gt;= lower 11\t}) + i + 1 12\t// i增加后，r也应该减小，查找范围为，[l, r) 13\tr = sort.Search(r-l, func(index int) bool { 14\tindex += l 15\treturn nums[index]+nums[i] \u0026gt; upper 16\t}) + l 17\tresult += int64(r - l) 18\t} 19\treturn result 20} "},{"id":128,"href":"/docs/leetcode/medium/leetcode2564/","title":"2564. Substring XOR Queries","section":"中等","content":" 题目 # You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].\nFor the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.\nThe answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.\nReturn an array ans where ans[i] = [lefti, righti] is the answer to the ith query.\nA substring is a contiguous non-empty sequence of characters within a string.\nExample 1:\nInput: s = \u0026#34;101101\u0026#34;, queries = [[0,5],[1,2]] Output: [[0,2],[2,3]] Explanation: For the first query the substring in range [0,2] is \u0026#34;101\u0026#34; which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is \u0026#34;11\u0026#34;, and has a decimal value of 3, and 3 ^ 1 = 2. So, [2,3] is returned for the second query. Example 2:\nInput: s = \u0026#34;0101\u0026#34;, queries = [[12,8]] Output: [[-1,-1]] Explanation: In this example there is no substring that answers the query, hence [-1,-1] is returned. Example 3:\nInput: s = \u0026#34;1\u0026#34;, queries = [[4,5]] Output: [[0,0]] Explanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0]. Constraints:\n$1 \u0026lt;= s.length \u0026lt;= 10^4$ s[i] is either \u0026lsquo;0\u0026rsquo; or \u0026lsquo;1\u0026rsquo;. $1 \u0026lt;= queries.length \u0026lt;= 10^5$ $0 \u0026lt;= firsti, secondi \u0026lt;= 10^9$ 思路1 字符串查找 # 分析 # 按位异或两次就得到原始数字，那么就是找原始数字在字符串的索引 代码 # 1func substringXorQueries(s string, queries [][]int) [][]int { 2\tresult := make([][]int, len(queries)) 3\tfor i, v := range queries { 4\tfindStr := fmt.Sprintf(\u0026#34;%b\u0026#34;, v[1]^v[0]) 5\tl := strings.Index(s, findStr) 6\tif l == -1 { 7\tresult[i] = []int{l, l} 8\t} else { 9\tresult[i] = []int{l, l + len(findStr) - 1} 10\t} 11\t} 12\treturn result 13} 思路2 枚举后O(1)查找 # 分析 # 字符串查找还是很费时间的，提前枚举一下然后直接查找看是否时间更短 数字最大也就是 $10^9 \\lt 2^{30}$ ，那么只需要枚举30位即可 枚举可能第一位是0，那么用长度作为判断，如果长度更短就代表去0了 果然时间缩短到 $\\frac{1}{4}$ 代码 # 1func substringXorQueries1(s string, queries [][]int) [][]int { 2\ttype pair struct{ l, r int } 3\tcheckMap := make(map[int]pair) 4\tfor l := range s { 5\tfor r, x := l, 0; r \u0026lt; l+30 \u0026amp;\u0026amp; r \u0026lt; len(s); r++ { 6\tx = (x \u0026lt;\u0026lt; 1) | int(s[r]\u0026amp;1) 7\tif p, ok := checkMap[x]; !ok || r-l \u0026lt; p.r-p.l { 8\tcheckMap[x] = pair{l, r} 9\t} 10\t} 11\t} 12\tresult := make([][]int, len(queries)) 13\tnotFound := []int{-1, -1} 14\tfor i, v := range queries { 15\tif p, ok := checkMap[v[1]^v[0]]; ok { 16\tresult[i] = []int{p.l, p.r} 17\t} else { 18\tresult[i] = notFound 19\t} 20\t} 21\treturn result 22} "},{"id":129,"href":"/docs/leetcode/simple/leetcode2570/","title":"2570. Merge Two 2D Arrays by Summing Values","section":"简单","content":" 题目 # You are given two 2D integer arrays nums1 and nums2.\nnums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali. nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali. Each array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\nOnly ids that appear in at least one of the two arrays should be included in the resulting array. Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0. Return the resulting array. The returned array must be sorted in ascending order by id.\nExample 1:\nInput: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]] Output: [[1,6],[2,3],[3,2],[4,6]] Explanation: The resulting array contains the following: - id = 1, the value of this id is 2 + 4 = 6. - id = 2, the value of this id is 3. - id = 3, the value of this id is 2. - id = 4, the value of this id is 5 + 1 = 6. Example 2:\nInput: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]] Output: [[1,3],[2,4],[3,6],[4,3],[5,5]] Explanation: There are no common ids, so we just include each id with its value in the resulting list. Constraints:\n1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 200 nums1[i].length == nums2[j].length == 2 1 \u0026lt;= idi, vali \u0026lt;= 1000 Both arrays contain unique ids. Both arrays are in strictly ascending order by id. 思路1 归并方法合并两个数组 # 分析 # 直接合并两个数组 代码 # 1func mergeArrays(nums1 [][]int, nums2 [][]int) [][]int { 2\ti, j := 0, 0 3\tn1, n2 := len(nums1), len(nums2) 4\tresult := make([][]int, 0, n1+n2) 5\tfor i != n1 \u0026amp;\u0026amp; j != n2 { 6\tid1, v1, id2, v2 := nums1[i][0], nums1[i][1], nums2[j][0], nums2[j][1] 7\tif id1 == id2 { 8\tresult = append(result, []int{id1, v1 + v2}) 9\ti++ 10\tj++ 11\t} else if id1 \u0026lt; id2 { 12\tresult = append(result, nums1[i]) 13\ti++ 14\t} else { 15\tresult = append(result, nums2[j]) 16\tj++ 17\t} 18\t} 19\tfor ; i \u0026lt; n1; i++ { 20\tresult = append(result, nums1[i]) 21\ti++ 22\t} 23\tfor ; j \u0026lt; n2; j++ { 24\tresult = append(result, nums2[j]) 25\t} 26\treturn result 27} 思路2 存map，然后排序 # 分析 # 可以直接用红黑树存，不用排序 不过go里面的map是hash，还是随机的 这种方法其实没上面好，但是实现简单 代码 # 1type IntsSlice [][]int 2 3func (x IntsSlice) Len() int { return len(x) } 4 5// 为true，i向前；false，j向前。要满足相等时返回false 6func (x IntsSlice) Less(i, j int) bool { return x[i][0] \u0026lt; x[j][0] } 7func (x IntsSlice) Swap(i, j int) { 8\tx[i], x[j] = x[j], x[i] 9} 10 11func mergeArrays1(nums1 [][]int, nums2 [][]int) [][]int { 12\tintMap := make(map[int]int) 13\tfor _, v := range nums1 { 14\tintMap[v[0]] += v[1] 15\t} 16\tfor _, v := range nums2 { 17\tintMap[v[0]] += v[1] 18\t} 19\tresult := make(IntsSlice, 0, len(intMap)) 20\tfor k, v := range intMap { 21\tresult = append(result, []int{k, v}) 22\t} 23\tsort.Sort(result) 24\treturn result 25} "},{"id":130,"href":"/docs/leetcode/medium/leetcode2571/","title":"2571. Minimum Operations to Reduce an Integer to 0","section":"中等","content":" 题目 # You are given a positive integer n, you can do the following operation any number of times:\nAdd or subtract a power of 2 from n. Return the minimum number of operations to make n equal to 0.\nA number x is power of 2 if $x == 2^i$ where i \u0026gt;= 0.\nExample 1:\nInput: n = 39 Output: 3 Explanation: We can do the following operations: - Add 2^0 = 1 to n, so now n = 40. - Subtract 2^3 = 8 from n, so now n = 32. - Subtract 2^5 = 32 from n, so now n = 0. It can be shown that 3 is the minimum number of operations we need to make n equal to 0. Example 2:\nInput: n = 54 Output: 3 Explanation: We can do the following operations: - Add 2^1 = 2 to n, so now n = 56. - Add 2^3 = 8 to n, so now n = 64. - Subtract 26 = 64 from n, so now n = 0. So the minimum number of operations is 3. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^5$ 思路1 数学分析 # 分析 # 连续的1可以用加再减消除，分析一下就会发现 01要减一次 011要么减两次，要么加一次减一次，同样两次 011111加一次减一次，两次 也就是说，超过1个连续的1都是两次解决 那么超过1次的1可以转成加一剩一个1未消除 代码 # 1func minOperations(n int) int { 2\tresult := 0 3\tcount := 0 4\tfor n \u0026gt; 0 { 5\tif n\u0026amp;1 == 1 { 6\tcount++ 7\tn \u0026gt;\u0026gt;= 1 8\tcontinue 9\t} 10\tn \u0026gt;\u0026gt;= 1 11\tif count == 0 { 12\tcontinue 13\t} 14\t// 超过1个的1转成加1，剩余一个1 15\t// 只有1个1，就只加一消掉 16\tresult++ 17\tif count == 1 { 18\tcount = 0 19\t} else { 20\tcount = 1 21\t} 22\t} 23\tif count \u0026gt; 2 { 24\tresult += 2 25\t} else { 26\tresult += count 27\t} 28 29\treturn result 30} "},{"id":131,"href":"/docs/leetcode/medium/leetcode2572/","title":"2572. Count the Number of Square-Free Subsets","section":"中等","content":" 题目 # You are given a positive integer 0-indexed array nums.\nA subset of the array nums is square-free if the product of its elements is a square-free integer.\nA square-free integer is an integer that is divisible by no square number other than 1.\nReturn the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7.\nA non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\nExample 1:\nInput: nums = [3,4,4,5] Output: 3 Explanation: There are 3 square-free subsets in this example: - The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer. - The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer. - The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer. It can be proven that there are no more than 3 square-free subsets in the given array. Example 2:\nInput: nums = [1] Output: 1 Explanation: There is 1 square-free subset in this example: - The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer. It can be proven that there is no more than 1 square-free subset in the given array. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 30 思路1 01背包 # 分析 # 集合乘积没有平方代表分解质因数没有重复的，每个数都不大于30，说明质因数都不会超过30 30以内的质数有2, 3, 5, 7, 11, 13, 17, 19, 23, 29这10个，转bit也就10位 每个集合就可以用一个10位的数表示，0代表没有或者只有1 用01背包去解，考虑集合为一个背包，那么背包中物品价值最大为全部质数都在里面，也就是1024 那么每一个数都可以装或不装背包，可以用一个map去存，key为背包的价值，value为达到这个价值的方案数 那么每一个数如果可以装背包，那么装进去的价值对应的方案数为 $f(i|target) += f(i)$ ，即不带这个数之前已有的方案数加上这个数装进去后可以达成的方案数 初始空背包需要计算，但是最终不能用空背包就需要减去 代码 # 1// 将x根据p转成对应的二进制bit数 2func getTarget(x int, p []int) int { 3\tresult := 0 4\tfor i, t := 0, 1; i \u0026lt; len(p) \u0026amp;\u0026amp; x \u0026gt;= p[i]; { 5\tif x%p[i] != 0 { 6\ti, t = i+1, t\u0026lt;\u0026lt;1 7\tcontinue 8\t} 9\tif result\u0026amp;t != 0 { 10\treturn -1 11\t} 12\tresult |= t 13\tx /= p[i] 14\t} 15\treturn result 16} 17 18func squareFreeSubsets(nums []int) int { 19\tp := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29} 20\tvar mod int = 1e9 + 7 21\t// 构建背包 22\tf := make(map[int]int) 23\tf[0] = 1 // 空背包代表一种方案，所有元素要放到空背包中 24\tfor _, v := range nums { 25\ttarget := getTarget(v, p) 26\tif target == -1 { 27\tcontinue 28\t} 29\t// 这个元素可以放到背包，找现在所有的方案中可以放进去的 30\tfor i, v := range f { 31\tif i\u0026amp;target == 0 { 32\tv1 := i | target 33\tf[v1] = (f[v1] + v) % mod 34\t} 35\t} 36\t} 37\tans := 0 38\tfor _, v := range f { 39\tans = (ans + v) % mod 40\t} 41\t// 最终返回的不包含空背包方案 42\treturn ans - 1 43} 思路2 01背包优化时间 # 分析 # 使用map存有一个问题，就是可能会不断扩容 反正背包状态数最大也就1024，那么直接搞1024的数组，不需要的设置成0 遍历虽然多了，但是没有空间申请 然后发现时间是原来的 $\\frac{1}{10}$，空间也少了一半，不知道怎么算的 代码 # 1// 将x根据p转成对应的二进制bit数 2func getTarget(x int, p []int) int { 3\tresult := 0 4\tfor i, t := 0, 1; i \u0026lt; len(p) \u0026amp;\u0026amp; x \u0026gt;= p[i]; { 5\tif x%p[i] != 0 { 6\ti, t = i+1, t\u0026lt;\u0026lt;1 7\tcontinue 8\t} 9\tif result\u0026amp;t != 0 { 10\treturn -1 11\t} 12\tresult |= t 13\tx /= p[i] 14\t} 15\treturn result 16} 17 18func squareFreeSubsets(nums []int) int { 19\tp := []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29} 20\tvar mod int = 1e9 + 7 21\tn := 1 \u0026lt;\u0026lt; len(p) 22\tf := make([]int, n) 23\tf[0] = 1 // 空背包代表一种方案，所有元素要放到空背包中 24\tfor _, v := range nums { 25\ttarget := getTarget(v, p) 26\tif target == -1 { 27\tcontinue 28\t} 29\t// 这个元素可以放到背包，找现在所有的方案中可以放进去的 30\tfor i, v := range f { 31\tif v != 0 \u0026amp;\u0026amp; i\u0026amp;target == 0 { 32\tv1 := i | target 33\tf[v1] = (f[v1] + v) % mod 34\t} 35\t} 36\t} 37\tans := 0 38\tfor _, v := range f { 39\tans = (ans + v) % mod 40\t} 41\treturn ans - 1 42} "},{"id":132,"href":"/docs/leetcode/hard/leetcode2573/","title":"2573. Count the Number of Square-Free Subsets","section":"困难","content":" 题目 # We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1]. Given an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \u0026ldquo;aabd\u0026rdquo; is lexicographically smaller than \u0026ldquo;aaca\u0026rdquo; because the first position they differ is at the third letter, and \u0026lsquo;b\u0026rsquo; comes before \u0026lsquo;c\u0026rsquo;.\nExample 1:\nInput: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]] Output: \u0026#34;abab\u0026#34; Explanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \u0026#34;abab\u0026#34;. Example 2:\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]] Output: \u0026#34;aaaa\u0026#34; Explanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \u0026#34;aaaa\u0026#34;. Example 3:\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]] Output: \u0026#34;\u0026#34; Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists. Constraints:\n1 \u0026lt;= n == lcp.length == lcp[i].length \u0026lt;= 1000 0 \u0026lt;= lcp[i][j] \u0026lt;= n 思路1 # 分析 # 从题目分析，lcp满足下面几个性质\nlcp[i][i] = n - i，就是从某一个下标后面的自己和自己肯定相等 lcp左右对称 lcp[i][j] \u0026lt;= n - max(i, j) 先全部设置初始值为\u0026rsquo;\\0\u0026rsquo;，然后根据lcp开始构造，首先假设第一个是a，遇到和第一个相等的都是a。然后从第一个\u0026rsquo;\\0\u0026rsquo;设置成b，同上\n注意: 字符串中不能存在字符超过z 代码 # 想在一个循环中实现，就右上角用于设置字符串，因为每个字符需要先看后面有没有和它相等的 左下角就用于判断是否是对称矩阵 1func findTheString(lcp [][]int) string { 2\tn := len(lcp) 3\ts := make([]byte, n) 4\tvar c byte = \u0026#39;a\u0026#39; 5\tfor i := range lcp { 6\tif s[i] == 0 { 7\tif c \u0026gt; \u0026#39;z\u0026#39; { 8\treturn \u0026#34;\u0026#34; 9\t} 10\ts[i] = c 11\tc++ 12\t} 13\tfor j := range lcp { 14\tif i == j { 15\t// 判断对角线 16\tif lcp[i][j] != n-i { 17\treturn \u0026#34;\u0026#34; 18\t} 19\tcontinue 20\t} 21\tif j \u0026lt; i { 22\t// 左下角用于判断是否对称 23\tif lcp[j][i] != lcp[i][j] { 24\treturn \u0026#34;\u0026#34; 25\t} 26\t// 右上角用于拼接字符串，所以左下角的返回 27\tcontinue 28\t} 29\tif lcp[i][j] \u0026gt; (n - i) { 30\treturn \u0026#34;\u0026#34; 31\t} 32\tif lcp[i][j] \u0026gt; 0 { 33\ts[j] = s[i] 34\t} 35\t} 36\t} 37\t// 动态规划验证矩阵，倒序验证 38\tfor i := n - 2; i \u0026gt;= 0; i-- { 39\tfor j := n - 1; j \u0026gt; i; j-- { 40\tif s[i] != s[j] { 41\tif lcp[i][j] != 0 { 42\treturn \u0026#34;\u0026#34; 43\t} 44\t} else if j == n-1 { 45\tif lcp[i][j] != 1 { 46\treturn \u0026#34;\u0026#34; 47\t} 48\t} else { 49\tif lcp[i][j] != lcp[i+1][j+1]+1 { 50\treturn \u0026#34;\u0026#34; 51\t} 52\t} 53\t} 54\t} 55\treturn string(s) 56} "},{"id":133,"href":"/docs/leetcode/simple/leetcode2574/","title":"2574. Left and Right Sum Differences","section":"简单","content":" 题目 # Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:\nanswer.length == nums.length. answer[i] = |leftSum[i] - rightSum[i]|. Where:\nleftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0. rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0. Return the array answer.\nExample 1:\nInput: nums = [10,4,8,3] Output: [15,1,11,22] Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]. The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22]. Example 2:\nInput: nums = [1] Output: [0] Explanation: The array leftSum is [0] and the array rightSum is [0]. The array answer is [|0 - 0|] = [0]. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 $1 \u0026lt;= nums[i] \u0026lt;= 10^5$ 思路1 # 分析 # 照着做 代码 # 1func abs(a int) int { 2\tif a \u0026lt; 0 { 3\treturn -a 4\t} 5\treturn a 6} 7 8func leftRigthDifference(nums []int) []int { 9\tresult := make([]int, len(nums)) 10\trsum := 0 11\tfor _, v := range nums { 12\trsum += v 13\t} 14\tlsum := 0 15\tfor i, v := range nums { 16\trsum -= v 17\tresult[i] = abs(lsum - rsum) 18\tlsum += v 19\t} 20\treturn result 21} "},{"id":134,"href":"/docs/leetcode/medium/leetcode2575/","title":"2575. Find the Divisibility Array of a String","section":"中等","content":" 题目 # You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.\nThe divisibility array div of word is an integer array of length n such that:\ndiv[i] = 1 if the numeric value of word[0,\u0026hellip;,i] is divisible by m, or div[i] = 0 otherwise. Return the divisibility array of word.\nExample 1:\nInput: word = \u0026#34;998244353\u0026#34;, m = 3 Output: [1,1,0,0,0,1,1,0,0] Explanation: There are only 4 prefixes that are divisible by 3: \u0026#34;9\u0026#34;, \u0026#34;99\u0026#34;, \u0026#34;998244\u0026#34;, and \u0026#34;9982443\u0026#34;. Example 2:\nInput: word = \u0026#34;1010\u0026#34;, m = 10 Output: [0,1,0,1] Explanation: There are only 2 prefixes that are divisible by 10: \u0026#34;10\u0026#34;, and \u0026#34;1010\u0026#34;. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^5$ word.length == n word consists of digits from 0 to 9 $1 \u0026lt;= m \u0026lt;= 10^9$ 思路1 # 分析 # 因为位数不确定，基本可以确定一定会超过64位长度 那么分析一下在某个下标下，num = x * m + y，下一个下标整体乘10加下一位也就是10x * m + 10y + z，算余数时发现其实是算10y+z对m取余 所以每个循环保留余数即可，余数为0就直接设置成1 代码 # 1func divisibilityArray(word string, m int) []int { 2\tresult := make([]int, len(word)) 3\tn := 0 4\tfor i, v := range word { 5\tn = n*10 + int(v-\u0026#39;0\u0026#39;) 6\tn %= m 7\tif n == 0 { 8\tresult[i] = 1 9\t} 10\t} 11\treturn result 12} "},{"id":135,"href":"/docs/leetcode/medium/leetcode2576/","title":"2576. Find the Maximum Number of Marked Indices","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums.\nInitially, all of the indices are unmarked. You are allowed to make this operation any number of times:\nPick two different unmarked indices i and j such that 2 * nums[i] \u0026lt;= nums[j], then mark i and j. Return the maximum possible number of marked indices in nums using the above operation any number of times.\nExample 1:\nInput: nums = [3,5,2,4] Output: 2 Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] \u0026lt;= nums[1]. Then mark index 2 and 1. It can be shown that there\u0026#39;s no other valid operation so the answer is 2. Example 2:\nInput: nums = [9,2,5,4] Output: 4 Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] \u0026lt;= nums[0]. Then mark index 3 and 0. In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] \u0026lt;= nums[2]. Then mark index 1 and 2. Since there is no other operation, the answer is 4. Example 3:\nInput: nums = [7,6,8] Output: 0 Explanation: There is no valid operation to do, so the answer is 0. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 二分 # 分析 # 从最小的开始，最小的可以匹配某一个数之后的所有数 那么可以从小的找到大于等于k个可以找到另一半的数 选取2k个数有很多种选法，但可以选前k个数和后k个数 证明：反证，假设存在一个选法不是前k个数和后k个数。假设是前k个数中有一个空位，那么此空位可以替换第k+1个数，同样满足条件，因为数更小，乘以2也满足小于等于的条件 那么就简单了，直接二分查找k即可 代码 # k的范围是0到 $\\frac{n}{2}$ 二分查找第一个不满足条件的，所以二分的范围应该是1到 $\\frac{n}{2} + 1$ 1func maxNumOfMarkedIndices(nums []int) int { 2\tsort.Ints(nums) 3\tn := len(nums) 4 5\t// 二分的范围是1到n/2 + 1 6\t// 转化一下初始值为1，二分进去的数要加一，出来的数是第一个不满足条件的，需要减一乘2 7\t// 可是初始值加了1就不用减了，直接乘2返回 8\treturn sort.Search(n/2, func(k int) bool { 9\tk++ 10\tfor i := 0; i \u0026lt; k; i++ { 11\tif nums[i]*2 \u0026gt; nums[n-k+i] { 12\treturn true 13\t} 14\t} 15\treturn false 16\t}) * 2 17} "},{"id":136,"href":"/docs/leetcode/hard/leetcode2577/","title":"2577. 在网格图中访问一个格子的最少时间","section":"困难","content":" 题目 # You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\nExample 1:\nInput: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]] Output: 7 Explanation: One of the paths that we can take is the following: - at t = 0, we are on the cell (0,0). - at t = 1, we move to the cell (0,1). It is possible because grid[0][1] \u0026lt;= 1. - at t = 2, we move to the cell (1,1). It is possible because grid[1][1] \u0026lt;= 2. - at t = 3, we move to the cell (1,2). It is possible because grid[1][2] \u0026lt;= 3. - at t = 4, we move to the cell (1,1). It is possible because grid[1][1] \u0026lt;= 4. - at t = 5, we move to the cell (1,2). It is possible because grid[1][2] \u0026lt;= 5. - at t = 6, we move to the cell (1,3). It is possible because grid[1][3] \u0026lt;= 6. - at t = 7, we move to the cell (2,3). It is possible because grid[1][3] \u0026lt;= 7. The final time is 7. It can be shown that it is the minimum time possible. Example 2:\nInput: grid = [[0,2,4],[3,2,1],[1,0,4]] Output: -1 Explanation: There is no path from the top left to the bottom-right cell. Constraints:\nm == grid.length n == grid[i].length 2 \u0026lt;= m, n \u0026lt;= 1000 $4 \u0026lt;= m * n \u0026lt;= 10^5$ $0 \u0026lt;= grid[i][j] \u0026lt;= 10^5$ grid[0][0] == 0 思路1 Dijkstra # 分析 # 由于可以两个格子跳来跳去来耗时间，那么不能到达的情况只有从第一个格子就跳不出去 除了这种情况，每个格子到下一个格子的时间要么是当前时间加一，要么是跳来跳去几次后加一（达到下一个格子的要求时间） 抽象想一下，好像是一个相邻格子的花费时间不一样的路径问题 距离不一样使用bfs不好写，使用Dijkstra算法写更好，相邻格子的距离就是当前时间加一和目的格子要求的时间的较大的那一个 因为跳来跳去加的是2，所以要注意奇偶，奇偶和当前的位置m+n一致 代码 # 1type locationT struct { 2\tx, y int 3\tdistance int 4} 5type LittleHeap []locationT 6 7func (h *LittleHeap) Len() int { return len(*h) } 8 9// less必须满足当Less(i, j)和Less(j, i)都为false，则两个索引对应的元素相等 10// 为true，i向栈顶移动；为false，j向栈顶移动 11func (h *LittleHeap) Less(i, j int) bool { return (*h)[i].distance \u0026lt; (*h)[j].distance } 12func (h *LittleHeap) Swap(i, j int) { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] } 13func (h *LittleHeap) Push(x interface{}) { 14\t*h = append(*h, x.(locationT)) 15} 16 17func (h *LittleHeap) Pop() interface{} { 18\tx := (*h)[len(*h)-1] 19\t*h = (*h)[:len(*h)-1] 20\treturn x 21} 22 23func max(a, b int) int { 24\tif a \u0026lt; b { 25\treturn b 26\t} 27\treturn a 28} 29 30func minimumTime(grid [][]int) int { 31\tif grid[1][0] \u0026gt; 1 \u0026amp;\u0026amp; grid[0][1] \u0026gt; 1 { 32\treturn -1 33\t} 34\tvar arrLoc [][]int = [][]int{ 35\t{1, 0}, 36\t{-1, 0}, 37\t{0, 1}, 38\t{0, -1}, 39\t} 40 41\tm, n := len(grid), len(grid[0]) 42\tvar lHeap LittleHeap = make([]locationT, 0, m*n) 43\tlHeap = append(lHeap, locationT{ 44\tx: 0, y: 0, distance: 0, 45\t}) 46 47\tdisMap := make([][]int, m) 48\tfor i := range disMap { 49\tdisMap[i] = make([]int, n) 50\tfor j := range disMap[i] { 51\tdisMap[i][j] = math.MaxInt 52\t} 53\t} 54\t// 一定能到，所以不用加判断条件 55\t// 不能到的上面干掉了 56\tfor { 57\ttmp := heap.Pop(\u0026amp;lHeap).(locationT) 58\tif tmp.x == m-1 \u0026amp;\u0026amp; tmp.y == n-1 { 59\treturn tmp.distance 60\t} 61\tfor _, v := range arrLoc { 62\tx, y := tmp.x+v[0], tmp.y+v[1] 63\tif x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n { 64\tcontinue 65\t} 66\tdis := max(tmp.distance+1, grid[x][y]) 67\tdis += (dis - x - y) % 2 68\tif dis \u0026lt; disMap[x][y] { 69\tdisMap[x][y] = dis 70\theap.Push(\u0026amp;lHeap, locationT{ 71\tx: x, y: y, distance: dis, 72\t}) 73 74\t} 75\t} 76\t} 77} 思路2 二分+bfs # 分析 # 找单调性，假设结果为endTime，大于endTime肯定能到达，小于endTime到达不了，那么就可以用二分 上限就是最大值加上路上花费的时间，理解就是时间先达到最大，那么每个点都可以到，直接走就可以到达终点，时间 $10^5 + m + n$ 二分的中间结果如何判断，直接使用bfs即可，但是从起点走算结果比较复杂，所以从终点走，看能不能到达起点 节省空间的写法，走过的点可以使用当前结果作为true，非当前结果作为false，二分一定不会重复判断同一个结果 因为从终点走，需要注意终点的耗时需要进行判断，小于终点的耗时是不可达的。并且需要根据m+n的奇偶性做结果的修正，参考上面 代码 # 1func minimumTime1(grid [][]int) int { 2\tif grid[1][0] \u0026gt; 1 \u0026amp;\u0026amp; grid[0][1] \u0026gt; 1 { 3\treturn -1 4\t} 5\tvar arrLoc [][]int = [][]int{ 6\t{1, 0}, 7\t{-1, 0}, 8\t{0, 1}, 9\t{0, -1}, 10\t} 11 12\tm, n := len(grid), len(grid[0]) 13\t// 用是否等于当前的endTime来标记是否走过 14\tseen := make([][]int, m) 15\tfor i := range seen { 16\tseen[i] = make([]int, n) 17\t} 18\ttype pointT struct { 19\tx, y int 20\t} 21\tq1 := make([]pointT, 0, m+n) 22\tq2 := make([]pointT, 0, m+n) 23\tendTime := sort.Search(1e5+m+n, func(endTime int) bool { 24\tif endTime \u0026lt; grid[m-1][n-1] { 25\treturn false 26\t} 27\tq1 = q1[:0] 28\tq1 = append(q1, pointT{ 29\tx: m - 1, y: n - 1, 30\t}) 31\tseen[m-1][n-1] = endTime 32\tfor t := endTime - 1; len(q1) \u0026gt; 0; t-- { 33\tq2 = q2[:0] 34\tfor _, point := range q1 { 35\tfor _, v := range arrLoc { 36\tx, y := point.x+v[0], point.y+v[1] 37\tif x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || seen[x][y] == endTime || grid[x][y] \u0026gt; t { 38\tcontinue 39\t} 40\tif x == 0 \u0026amp;\u0026amp; y == 0 { 41\treturn true 42\t} 43\tseen[x][y] = endTime 44\tq2 = append(q2, pointT{ 45\tx: x, y: y, 46\t}) 47\t} 48\t} 49\tq1, q2 = q2, q1 50\t} 51\treturn false 52\t}) 53\treturn endTime + (endTime+m+n)%2 54} "},{"id":137,"href":"/docs/leetcode/simple/leetcode2582/","title":"2582. Pass the Pillow","section":"简单","content":" 题目 # There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on. Given the two positive integers n and time, return the index of the person holding the pillow after time seconds.\nExample 1:\nInput: n = 4, time = 5 Output: 2 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 3 -\u0026gt; 2. Afer five seconds, the pillow is given to the 2nd person. Example 2:\nInput: n = 3, time = 2 Output: 3 Explanation: People pass the pillow in the following way: 1 -\u0026gt; 2 -\u0026gt; 3. Afer two seconds, the pillow is given to the 3rd person. Constraints:\n2 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= time \u0026lt;= 1000 思路1 # 分析 # 数学题，n个人，就是2(n-1)的周期 余数就开始算，小于n-1就是1+tmp 大于就是2(n-1)-tmp+1 代码 # 1func passThePillow(n int, time int) int { 2\ttmp := time % (n + n - 2) 3\tif tmp \u0026gt;= n-1 { 4\treturn n + n - tmp - 1 5\t} 6\treturn tmp + 1 7} "},{"id":138,"href":"/docs/leetcode/medium/leetcode2583/","title":"2583. Kth Largest Sum in a Binary Tree","section":"中等","content":" 题目 # You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.\nExample 1:\nInput: root = [5,8,9,2,1,3,7,4,6], k = 2 Output: 13 Explanation: The level sums are the following: - Level 1: 5. - Level 2: 8 + 9 = 17. - Level 3: 2 + 1 + 3 + 7 = 13. - Level 4: 4 + 6 = 10. The 2nd largest level sum is 13. Example 2:\nInput: root = [1,2,null,3], k = 1 Output: 3 Explanation: The largest level sum is 3. Constraints:\nThe number of nodes in the tree is n. $2 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= Node.val \u0026lt;= 10^6$ 1 \u0026lt;= k \u0026lt;= n 思路1 bfs+小根堆 # 分析 # bfs遍历每一层 最小堆找第k大 代码 # 1type LittleHeap []int64 2 3func (h *LittleHeap) Len() int { return len(*h) } 4 5// less必须满足当Less(i, j)和Less(j, i)都为false，则两个索引对应的元素相等 6// 为true，i向栈顶移动；为false，j向栈顶移动 7func (h *LittleHeap) Less(i, j int) bool { return (*h)[i] \u0026lt; (*h)[j] } 8func (h *LittleHeap) Swap(i, j int) { (*h)[i], (*h)[j] = (*h)[j], (*h)[i] } 9func (h *LittleHeap) Push(x interface{}) { 10\t*h = append(*h, x.(int64)) 11} 12 13func (h *LittleHeap) Pop() interface{} { 14\tx := (*h)[len(*h)-1] 15\t*h = (*h)[:len(*h)-1] 16\treturn x 17} 18 19/** 20 * Definition for a binary tree node. 21 * type TreeNode struct { 22 * Val int 23 * Left *TreeNode 24 * Right *TreeNode 25 * } 26 */ 27func kthLargestLevelSum(root *TreeNode, k int) int64 { 28\tq := make([]*TreeNode, 0, 1) 29\ttmp := make([]*TreeNode, 0, 1) 30\tbHeap := make(LittleHeap, 0, k) 31 32\tq = append(q, root) 33\tfor len(q) \u0026gt; 0 { 34\ttmp, q = q, tmp 35\tvar s int64 = 0 36\tq = q[:0] 37\tfor _, node := range tmp { 38\ts += int64(node.Val) 39\tif node.Left != nil { 40\tq = append(q, node.Left) 41\t} 42\tif node.Right != nil { 43\tq = append(q, node.Right) 44\t} 45\t} 46\tif len(bHeap) \u0026lt; k { 47\theap.Push(\u0026amp;bHeap, s) 48\t} else if s \u0026gt; bHeap[0] { 49\theap.Pop(\u0026amp;bHeap) 50\theap.Push(\u0026amp;bHeap, s) 51\t} 52\t} 53\tif len(bHeap) \u0026lt; k { 54\treturn -1 55\t} 56\treturn bHeap[0] 57} "},{"id":139,"href":"/docs/leetcode/hard/leetcode2584/","title":"2584. Split the Array to Make Coprime Products","section":"困难","content":" 题目 # You are given a 0-indexed integer array nums of length n.\nA split at an index i where 0 \u0026lt;= i \u0026lt;= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\nFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1. Return the smallest index i at which the array can be split validly or -1 if there is no such split.\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\nExample 1:\nInput: nums = [4,7,8,15,3,5] Output: 2 Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. The only valid split is at index 2. Example 2:\nInput: nums = [4,7,15,8,3,5] Output: -1 Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i. There is no valid split. Constraints:\nn == nums.length $1 \u0026lt;= n \u0026lt;= 10^4$ $1 \u0026lt;= nums[i] \u0026lt;= 10^6$ 思路1 合并区间 # 分析 # 找一个点，让前后互质。就是找一个点，前面的质因子和后面的质因子都不相同 转化一下，好像可以用区间来抽象这道题。每个质因子是一个区间，有最左边和最右边。 分割点就是找到一个点正好没有切到某个区间，就是说某个左端点大于其左侧的最大的右端点 代码 # 需要的数据只有左端点对应的最大的右端点，并不需要每个质数的区间，所以代码上来了个区间合并 只需要统计某个点为左端点时，右端点最大的值就好。map存每个质数对应的左端点，数组存每个左端点对应的最大的右端点 1func getPrimeFactor(n int, handle func(prime int)) { 2\tmax := int(math.Sqrt(float64(n))) + 1 3\tfor i := 2; i \u0026lt; max \u0026amp;\u0026amp; i \u0026lt; n; i++ { 4\tif n%i == 0 { 5\thandle(i) 6\tn /= i 7\ti = 1 8\t} 9\t} 10\tif n \u0026gt; 1 { 11\thandle(n) 12\t} 13} 14 15func findValidSplit(nums []int) int { 16\tleft := make(map[int]int) 17\tright := make([]int, len(nums)) // 左端点为i的右端点最大值 18\tfor i, v := range nums { 19\tgetPrimeFactor(v, func(prime int) { 20\tif l, ok := left[prime]; ok { 21\tright[l] = i 22\t} else { 23\tleft[prime] = i 24\t} 25\t}) 26\t} 27\tmaxR := 0 28\tfor l, r := range right { 29\tif l \u0026gt; maxR { 30\treturn maxR 31\t} 32\tif r \u0026gt; maxR { 33\tmaxR = r 34\t} 35\t} 36\treturn -1 37} "},{"id":140,"href":"/docs/leetcode/simple/leetcode2595/","title":"2595. Number of Even and Odd Bits","section":"简单","content":" 题目 # You are given a positive integer n.\nLet even denote the number of even indices in the binary representation of n (0-indexed) with value 1.\nLet odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.\nReturn an integer array answer where answer = [even, odd].\nExample 1:\nInput: n = 17 Output: [2,0] Explanation: The binary representation of 17 is 10001. It contains 1 on the 0th and 4th indices. There are 2 even and 0 odd indices. Example 2:\nInput: n = 2 Output: [0,1] Explanation: The binary representation of 2 is 10. It contains 1 on the 1st index. There are 0 even and 1 odd indices. ``` Constraints: - 1 \u0026lt;= n \u0026lt;= 1000 # 思路1 ## 分析 - 照着做 ## 代码 ```go func evenOddBit(n int) []int { res := []int{0, 0} isOdd := false for n \u0026gt; 0 { if n\u0026amp;0x01 == 1 { if isOdd { res[1]++ } else { res[0]++ } } n \u0026gt;\u0026gt;= 1 isOdd = !isOdd } return res } "},{"id":141,"href":"/docs/leetcode/medium/leetcode2596/","title":"2596. Check Knight Tour Configuration","section":"中等","content":" 题目 # There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight\u0026rsquo;s movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\nExample 1:\nInput: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]] Output: true Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration. Example 2:\nInput: grid = [[0,3,6],[5,8,1],[2,7,4]] Output: false Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move. Constraints:\nn == grid.length == grid[i].length 3 \u0026lt;= n \u0026lt;= 7 0 \u0026lt;= grid[row][col] \u0026lt; n * n All integers in grid are unique. 思路1 按题意模拟即可 # 分析 # 按照题意模拟即可，为了索引方便，根据数字将坐标存到一个数组中，然后判断相邻点的间隔是否合法即可 注意题目要求左上角是0 代码 # 1func abs(x int) int { 2\tif x \u0026lt; 0 { 3\treturn -x 4\t} 5\treturn x 6} 7 8func checkValidGrid(grid [][]int) bool { 9\ttype pos struct { 10\tx, y int 11\t} 12\tif grid[0][0] != 0 { 13\treturn false 14\t} 15\tn := len(grid) 16\tposList := make([]pos, n*n) 17\tfor i, v := range grid { 18\tfor j, p := range v { 19\tposList[p] = pos{ 20\tx: j, 21\ty: i, 22\t} 23\t} 24\t} 25\tfor i := 1; i \u0026lt; len(posList); i++ { 26\txd, yd := abs(posList[i].x-posList[i-1].x), abs(posList[i].y-posList[i-1].y) 27\tif xd+yd != 3 || abs(xd-yd) != 1 { 28\treturn false 29\t} 30\t} 31\treturn true 32} "},{"id":142,"href":"/docs/leetcode/medium/leetcode2597/","title":"2597. The Number of Beautiful Subsets","section":"中等","content":" 题目 # You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\nExample 1:\nInput: nums = [2,4,6], k = 2 Output: 4 Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6]. It can be proved that there are only 4 beautiful subsets in the array [2,4,6]. Example 2:\nInput: nums = [1], k = 1 Output: 1 Explanation: The beautiful subset of the array nums is [1]. It can be proved that there is only 1 beautiful subset in the array [1]. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 20 1 \u0026lt;= nums[i], k \u0026lt;= 1000 思路1 枚举 # 分析 # 使用hash表存储是否选了某个数，然后直接枚举 代码 # 1func beautifulSubsets(nums []int, k int) int { 2\tresult := make(map[int]int) 3\tres := 0 4\tn := len(nums) 5\tvar dfs func(i int) 6\tdfs = func(i int) { 7\tif i == n { 8\tres++ 9\treturn 10\t} 11\t// 不选 12\tdfs(i + 1) 13\tv := nums[i] 14\tif result[v-k] \u0026gt; 0 || result[v+k] \u0026gt; 0 { 15\t// 存在间隔为k的数 16\treturn 17\t} 18\t// 可以选就选一下 19\tresult[v]++ 20\tdfs(i + 1) 21\tresult[v]-- 22\t} 23\tdfs(0) 24\treturn res - 1 // 去除空集 25} 思路2 分组+打家劫舍 # 分析 # 分成公差为k的等差数列，看有多少组 相邻的不能选，非相邻的可以选，那么就是打家劫舍的变形 代码 # 1func beautifulSubsets1(nums []int, k int) int { 2\tgrp := make([]map[int]int, k) 3\tfor _, v := range nums { 4\ti := v % k 5\tif grp[i] == nil { 6\tgrp[i] = map[int]int{} 7\t} 8\tgrp[i][v]++ 9\t} 10 11\tres := 1 12\ttype pair struct { 13\tx, cnt int 14\t} 15\tfor _, v := range grp { 16\tif len(v) == 0 { 17\tcontinue 18\t} 19 20\tarr := make([]pair, 0, len(v)) 21\tfor k, val := range v { 22\tarr = append(arr, pair{x: k, cnt: val}) 23\t} 24\tsort.Slice(arr, func(i, j int) bool { return arr[i].x \u0026lt; arr[j].x }) 25 26\t// 打家劫舍，选和不选分开统计 27\tch, nch := 1\u0026lt;\u0026lt;arr[0].cnt-1, 1 28\tfor i := 1; i \u0026lt; len(arr); i++ { 29\tch1 := 1\u0026lt;\u0026lt;arr[i].cnt - 1\t// 当前选的方案数 30\tif arr[i].x-k == arr[i-1].x { 31\tch1 *= nch\t// 相差为k，当前选的只能是前一个不选的数量乘以选的方案数 32\t} else { 33\tch1 *= (ch + nch)\t// 相差不是k，那么当前选的方案数就是前一个选和不选一起乘以当前的方案数 34\t} 35\tnch = ch + nch\t// 不选的一定是前一个选和不选相加 36\tch = ch1 37\t} 38\tres *= (ch + nch) 39\t} 40\treturn res - 1 // 去除空集 41} "},{"id":143,"href":"/docs/leetcode/medium/leetcode2598/","title":"2598. Smallest Missing Non-negative Integer After Operations","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums and an integer value.\nIn one operation, you can add or subtract value from any element of nums.\nFor example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3]. The MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\nFor example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2. Return the maximum MEX of nums after applying the mentioned operation any number of times.\nExample 1:\nInput: nums = [1,-10,7,13,6,8], value = 5 Output: 4 Explanation: One can achieve this result by applying the following operations: - Add value to nums[1] twice to make nums = [1,0,7,13,6,8] - Subtract value from nums[2] once to make nums = [1,0,2,13,6,8] - Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8] The MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve. Example 2:\nInput: nums = [1,-10,7,13,6,8], value = 7 Output: 2 Explanation: One can achieve this result by applying the following operation: - subtract value from nums[2] once to make nums = [1,-10,0,13,6,8] The MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve. Constraints:\n$1 \u0026lt;= nums.length, value \u0026lt;= 10^5$ $-10^9 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 同余分组 # 分析 # 为了凑非负整数，每个数都可以加减任意的value的值，那么每个数都可以表示成x%value + n * value 那么就以value为周期，如果某个周期不能达成0到value-1各有一个数，那么空出来的就是答案 所以将所有的数按照value取余来分组 代码 # 1func findSmallestInteger(nums []int, value int) int { 2\tgrp := make([]int, value) 3\tfor _, v := range nums { 4\ti := 0 5\tif v \u0026gt;= 0 { 6\ti = v % value 7\t} else { 8\ti = (value - (-v)%value) % value 9\t} 10\tgrp[i]++ 11\t} 12 13\tmin, index := math.MaxInt, -1 14\tfor i, v := range grp { 15\tif v \u0026lt; min { 16\t// 找到数量最小的某个位置和数量 17\tmin = v 18\tindex = i 19\t} 20\t} 21\treturn index + min*value 22} "},{"id":144,"href":"/docs/leetcode/simple/leetcode2600/","title":"2600. K Items With the Maximum Sum","section":"简单","content":" 题目 # There is a bag that consists of items, each item has a number 1, 0, or -1 written on it.\nYou are given four non-negative integers numOnes, numZeros, numNegOnes, and k.\nThe bag initially contains:\nnumOnes items with 1s written on them. numZeroes items with 0s written on them. numNegOnes items with -1s written on them. We want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.\nExample 1:\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2 Output: 2 Explanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2. It can be proven that 2 is the maximum possible sum. Example 2:\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4 Output: 3 Explanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3. It can be proven that 3 is the maximum possible sum. Constraints:\n0 \u0026lt;= numOnes, numZeros, numNegOnes \u0026lt;= 50 0 \u0026lt;= k \u0026lt;= numOnes + numZeros + numNegOnes 思路1 # 分析 # 照着做 代码 # 1func kItemsWithMaximumSum(numOnes int, numZeros int, numNegOnes int, k int) int { 2\tif numOnes \u0026gt;= k { 3\treturn k 4\t} 5\tk -= numOnes 6\tif numZeros \u0026gt;= k { 7\treturn numOnes 8\t} 9\tk -= numZeros 10\treturn numOnes - k 11} "},{"id":145,"href":"/docs/leetcode/medium/leetcode2601/","title":"2601. Prime Subtraction Operation","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\nPick an index i that you haven’t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i]. Return true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.\nExample 1:\nInput: nums = [4,9,6,10] Output: true Explanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10]. In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10]. After the second operation, nums is sorted in strictly increasing order, so the answer is true. Example 2:\nInput: nums = [6,8,11,12] Output: true Explanation: Initially nums is sorted in strictly increasing order, so we don\u0026#39;t need to make any operations. Example 3:\nInput: nums = [5,8,3] Output: false Explanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 1000 nums.length == n 思路1 筛质数+二分 # 分析 # 1000以内的质数全部先找出来 每个数都尽可能小就好了，那么就是找质数里面小于当前到前一个差值的最大的那个 代码 # 1func oulerPrimes(mx int, primes *[]int) { 2\tflag := make([]bool, mx+1) // 标记数有没有被筛掉，false就是没有 3\tfor i := 2; i \u0026lt; mx+1; i++ { 4\tif !flag[i] { 5\t// 数没有被比自己小的数筛掉，就代表是质数 6\t*primes = append(*primes, i) 7\t} 8\tfor _, v := range *primes { 9\tif i*v \u0026gt; mx { 10\tbreak 11\t} 12\t// 每一个数都作为因子乘以比自己小的素数筛掉后面的数 13\tflag[i*v] = true 14\tif i%v == 0 { 15\t// 减少时间复杂度的关键算法 16\t// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除 17\t// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv 18\t// 那么存在一个数 i \u0026lt; km \u0026lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度 19\tbreak 20\t} 21\t} 22\t} 23} 24 25var primes []int = make([]int, 0, 168) 26 27func init() { 28\toulerPrimes(1000, \u0026amp;primes) 29} 30 31func primeSubOperation1(nums []int) bool { 32\tpre := 0 33\tfor _, v := range nums { 34\t// 每个数都尽可能小 35\tif v \u0026lt;= pre { 36\treturn false 37\t} 38\t// 找到能尽可能接近pre的最大质数，反过来就是找v-pre之间的最大质数 39\ti := sort.SearchInts(primes, v-pre) - 1 40\tif i \u0026lt; 0 { 41\tpre = v 42\t} else { 43\tpre = v - primes[i] 44\t} 45\t} 46\treturn true 47} 思路2 倒着做 # 分析 # 和上面一样，只是上面不好理解，倒着好理解，没上面写的快 尽可能让每一个数减去质数后小于但最接近后一个 代码 # 1func oulerPrimes(mx int, primes *[]int) { 2\tflag := make([]bool, mx+1) // 标记数有没有被筛掉，false就是没有 3\tfor i := 2; i \u0026lt; mx+1; i++ { 4\tif !flag[i] { 5\t// 数没有被比自己小的数筛掉，就代表是质数 6\t*primes = append(*primes, i) 7\t} 8\tfor _, v := range *primes { 9\tif i*v \u0026gt; mx { 10\tbreak 11\t} 12\t// 每一个数都作为因子乘以比自己小的素数筛掉后面的数 13\tflag[i*v] = true 14\tif i%v == 0 { 15\t// 减少时间复杂度的关键算法 16\t// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除 17\t// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv 18\t// 那么存在一个数 i \u0026lt; km \u0026lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度 19\tbreak 20\t} 21\t} 22\t} 23} 24 25var primes []int = make([]int, 0, 168) 26 27func init() { 28\toulerPrimes(1000, \u0026amp;primes) 29} 30 31func primeSubOperation(nums []int) bool { 32\tn := len(nums) 33\tlast := nums[n-1] 34\tfor i := n - 2; i \u0026gt;= 0; i-- { 35\tv := nums[i] 36\tif v \u0026lt; last { 37\tlast = v 38\tcontinue 39\t} 40\tfor _, vp := range primes { 41\tif vp \u0026gt;= v { 42\treturn false 43\t} 44\tif v-vp \u0026lt; last { 45\tv -= vp 46\tbreak 47\t} 48\t} 49\tif v \u0026gt;= last { 50\treturn false 51\t} 52\tlast = v 53\tcontinue 54\t} 55\treturn true 56} "},{"id":146,"href":"/docs/leetcode/medium/leetcode2602/","title":"2602. Minimum Operations to Make All Array Elements Equal","section":"中等","content":" 题目 # You are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\nIncrease or decrease an element of the array by 1. Return an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.\nExample 1:\nInput: nums = [3,1,6,8], queries = [1,5] Output: [14,10] Explanation: For the first query we can do the following operations: - Decrease nums[0] 2 times, so that nums = [1,1,6,8]. - Decrease nums[2] 5 times, so that nums = [1,1,1,8]. - Decrease nums[3] 7 times, so that nums = [1,1,1,1]. So the total number of operations for the first query is 2 + 5 + 7 = 14. For the second query we can do the following operations: - Increase nums[0] 2 times, so that nums = [5,1,6,8]. - Increase nums[1] 4 times, so that nums = [5,5,6,8]. - Decrease nums[2] 1 time, so that nums = [5,5,5,8]. - Decrease nums[3] 3 times, so that nums = [5,5,5,5]. So the total number of operations for the second query is 2 + 4 + 1 + 3 = 10. Example 2:\nInput: nums = [2,9,6,3], queries = [10] Output: [20] Explanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20. Constraints:\nn == nums.length m == queries.length $1 \u0026lt;= n, m \u0026lt;= 10^5$ $1 \u0026lt;= nums[i], queries[i] \u0026lt;= 10^9$ 思路1 提前处理 # 分析 # 虽然写出来了，但是写的复杂了，不过多讲了 代码 # 1func minOperations(nums []int, queries []int) []int64 { 2\tsort.Ints(nums) 3\tn := len(nums) 4\ttmp := make([]int64, n) 5\tfor _, v := range nums { 6\ttmp[0] += int64(v - nums[0]) 7\t} 8\tfor i, v := range nums { 9\tif i == 0 { 10\tcontinue 11\t} 12\ttmp[i] = tmp[i-1] - int64((n-i-i)*(v-nums[i-1])) 13\t} 14\tres := make([]int64, len(queries)) 15\tfor j, v := range queries { 16\tindex := sort.Search(n, func(i int) bool { 17\treturn nums[i] \u0026gt;= v 18\t}) 19\tif index == n { 20\tres[j] = tmp[index-1] + int64(n*(v-nums[index-1])) 21\t} else { 22\tres[j] = tmp[index] + int64((nums[index]-v)*(n-index-index)) 23\t} 24\t} 25\treturn res 26} 思路2 前缀和+二分 # 分析 # 灵神的解法，还是厉害，此类题直接前缀和求解最方便 假设要让数据所有数到达k，比k小的数到达k就是每一个都被k减去再加起来 $$ \\sum_{i=1}^{x}k-nums[i] = x \\times k - \\sum_{i=1}^{x}nums[i] $$\n比k大的数为 $$ \\sum_{i=x}^{n}nums[i]-k = \\sum_{i=x}^{n}nums[i] - (n - x) \\times k $$\n那么先求出所有的前缀和，再计算就很方便 代码 # 前缀和多一个防止越界 二分查找到的index为可以插入v的最合适位置 比k小的数计算为index*k - prefixSum[index] 比k大的数计算为sum - prefixSum[index] - v * (n - index) 合并化简sum + v * (index * 2 - n) - prefixSum[index] * 2 1func minOperations1(nums []int, queries []int) []int64 { 2\tsort.Ints(nums) 3\tn := len(nums) 4\tprefixSum := make([]int64, n+1) // 多一个防止越界 5\tvar sum int64 = 0 6\tfor i, v := range nums { 7\tsum += int64(v) 8\tprefixSum[i+1] = sum 9\t} 10 11\t// 开始二分找queries的位置计算 12\tres := make([]int64, len(queries)) 13\tfor i, v := range queries { 14\tindex := sort.SearchInts(nums, v) 15\tres[i] = int64((index*2-n)*v) + sum - prefixSum[index] * 2 16\t} 17\treturn res 18} "},{"id":147,"href":"/docs/leetcode/simple/leetcode2609/","title":"2609. Find the Longest Balanced Substring of a Binary String","section":"简单","content":" 题目 # You are given a binary string s consisting only of zeroes and ones.\nA substring of s is considered balanced if all zeroes are before ones and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\nReturn the length of the longest balanced substring of s.\nA substring is a contiguous sequence of characters within a string.\nExample 1:\nInput: s = \u0026#34;01000111\u0026#34; Output: 6 Explanation: The longest balanced substring is \u0026#34;000111\u0026#34;, which has length 6. Example 2:\nInput: s = \u0026#34;00111\u0026#34; Output: 4 Explanation: The longest balanced substring is \u0026#34;0011\u0026#34;, which has length 4. Example 3:\nInput: s = \u0026#34;111\u0026#34; Output: 0 Explanation: There is no balanced substring except the empty substring, so the answer is 0. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 50 \u0026lsquo;0\u0026rsquo; \u0026lt;= s[i] \u0026lt;= \u0026lsquo;1\u0026rsquo; 思路1 # 分析 # 遍历一遍，对每一组01进行统计，在1到0的时候更新最大值 代码 # 1func max(a, b int) int { 2\tif a \u0026lt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func min(a, b int) int { 9\tif a \u0026gt; b { 10\treturn b 11\t} 12\treturn a 13} 14 15func findTheLongestBalancedSubstring(s string) int { 16\tres := 0 17\tpre, cnt := 0, 0 // pre为0的数量，cnt为当前字符连续的数量 18\tn := len(s) 19\tfor i, v := range s { 20\tcnt++ 21\tif i == n-1 || byte(v) != s[i+1] { 22\tif v == \u0026#39;0\u0026#39; { 23\t// 0到1变化，pre等于cnt 24\tpre = cnt 25\t} else { 26\t// 1到0变化，判断是否可以更新res 27\tres = max(res, min(pre, cnt)*2) 28\t} 29\t// 变化重新统计 30\tcnt = 0 31\t} 32\t} 33\treturn res 34} "},{"id":148,"href":"/docs/leetcode/medium/leetcode2610/","title":"2610. Convert an Array Into a 2D Array With Conditions","section":"中等","content":" 题目 # You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:\nThe 2D array should contain only the elements of the array nums. Each row in the 2D array contains distinct integers. The number of rows in the 2D array should be minimal. Return the resulting array. If there are multiple answers, return any of them.\nNote that the 2D array can have a different number of elements on each row.\nExample 1:\nInput: nums = [1,3,4,1,2,3,1] Output: [[1,3,4,2],[1,3],[1]] Explanation: We can create a 2D array that contains the following rows: - 1,3,4,2 - 1,3 - 1 All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer. It can be shown that we cannot have less than 3 rows in a valid array. Example 2:\nInput: nums = [1,2,3,4] Output: [[4,3,2,1]] Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= nums.length 思路1 提前处理 # 分析 # 用hash表先统计一下，然后每个元素取一个 没取完就再加一行继续取 代码 # 1func findMatrix(nums []int) [][]int { 2\tarrMap := make(map[int]int) 3\tfor _, v := range nums { 4\tarrMap[v]++ 5\t} 6\tres := make([][]int, 0, 1) 7\tfor len(arrMap) \u0026gt; 0 { 8\tarr := make([]int, 0, 1) 9\tfor k, v := range arrMap { 10\tarr = append(arr, k) 11\tif v == 1 { 12\tdelete(arrMap, k) 13\t} else { 14\tarrMap[k]-- 15\t} 16\t} 17\tres = append(res, arr) 18\t} 19\treturn res 20} "},{"id":149,"href":"/docs/leetcode/medium/leetcode2611/","title":"2611. Mice and Cheese","section":"中等","content":" 题目 # There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.\nA point of the cheese with index i (0-indexed) is:\nreward1[i] if the first mouse eats it. reward2[i] if the second mouse eats it. You are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.\nExample 1:\nInput: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2 Output: 15 Explanation: In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese. The total points are 4 + 4 + 3 + 4 = 15. It can be proven that 15 is the maximum total points that the mice can achieve. Example 2:\nInput: reward1 = [1,1], reward2 = [1,1], k = 2 Output: 2 Explanation: In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese. The total points are 1 + 1 = 2. It can be proven that 2 is the maximum total points that the mice can achieve. Constraints:\n$1 \u0026lt;= n == reward1.length == reward2.length \u0026lt;= 10^5$ 1 \u0026lt;= reward1[i], reward2[i] \u0026lt;= 1000 0 \u0026lt;= k \u0026lt;= n 思路1 贪心 # 分析 # 先全部给第二只老鼠吃，然后选k个给第一个老鼠吃 选的都是收益最大化的k个，那么就把差异排个序，取最大的k个 代码 # 1func miceAndCheese(reward1 []int, reward2 []int, k int) int { 2\tres := 0 3\tn := len(reward1) 4\tdiff := make([]int, n) 5\t// 全部让老鼠2吃 6\tfor i, v := range reward2 { 7\tres += v 8\tdiff[i] = reward1[i] - reward2[i] 9\t} 10\tsort.Ints(diff) 11\tfor i := 0; i \u0026lt; k; i++ { 12\tres += diff[n-1-i] 13\t} 14\treturn res 15} "},{"id":150,"href":"/docs/leetcode/hard/leetcode2612/","title":"2612. Minimum Reverse Operations","section":"困难","content":" 题目 # You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr of length n where all positions are set to 0\u0026rsquo;s, except position p which is set to 1.\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\nA subarray is a contiguous non-empty sequence of elements within an array. The values of ans[i] are independent for all i\u0026rsquo;s. The reverse of an array is an array containing the values in reverse order. Example 1:\nInput: n = 4, p = 0, banned = [1,2], k = 4 Output: [0,-1,-1,1] Explanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. Example 2:\nInput: n = 5, p = 0, banned = [2,4], k = 3 Output: [0,-1,-1,-1,-1] Explanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn\u0026#39;t happen. So, we can\u0026#39;t move the 1 from position 0, making the result for all the other positions -1. Example 3:\nInput: n = 4, p = 2, banned = [0,1,3], k = 1 Output: [-1,-1,0,-1] Explanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^5$ 0 \u0026lt;= p \u0026lt;= n - 1 0 \u0026lt;= banned.length \u0026lt;= n - 1 0 \u0026lt;= banned[i] \u0026lt;= n - 1 1 \u0026lt;= k \u0026lt;= n banned[i] != p all values in banned are unique 思路1 bfs # 分析 # 不断反转，找步数，有点类似于最短路径，直接用bfs做 对于反转，从一个点开始不断反转，到一个点就是当前点步数加一，注意判断对应的点是否在banned和是否走过 代码 # 1func minReverseOperations(n int, p int, banned []int, k int) []int { 2\tres := make([]int, n) 3\tfor _, v := range banned { 4\tres[v] = -1 5\t} 6\t// bfs开始跳 7\tpq := make([]int, 0, n) 8\ttmp := make([]int, 0, n) 9\tpq = append(pq, p) 10\tfor len(pq) \u0026gt; 0 { 11\tpq, tmp = tmp, pq 12\tpq = pq[:0] 13\tfor _, v := range tmp { 14\t// 以此点为跳板开始跳 15\t// i为v在翻转数组的下标，翻转数组最左边为0，最右边为n-1 16\ti := k - n + v 17\tif i \u0026lt; 0 { 18\ti = 0 19\t} 20\tfor ; i \u0026lt; k \u0026amp;\u0026amp; i \u0026lt;= v; i++ { 21\t// i是v在k中的位置，k的0在v-i 22\t// 要翻转到的位置为0才能去 23\tt := k - 1 - i + v - i 24\tif t != v \u0026amp;\u0026amp; res[t] == 0 { 25\tres[t] = res[v] + 1 26\tpq = append(pq, t) 27\t} 28\t} 29\t} 30\t} 31\tfor i, v := range res { 32\tif v == 0 { 33\tres[i] = -1 34\t} 35\t} 36\tres[p] = 0 37\treturn res 38} "},{"id":151,"href":"/docs/leetcode/simple/leetcode2614/","title":"2614. Prime In Diagonal","section":"简单","content":" 题目 # You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself. An integer val is on one of thediagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1]= val. In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].\nExample 1:\nInput: nums = [[1,2,3],[5,6,7],[9,10,11]] Output: 11 Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11. Example 2:\nInput: nums = [[1,2,3],[5,17,7],[9,11,10]] Output: 17 Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 300 nums.length == numsi.length $1 \u0026lt;= nums[i][j] \u0026lt;= 4*10^6$ 思路1 # 分析 # 照着做 代码 # 1func diagonalPrime(nums [][]int) int { 2\tres := 0 3\tn := len(nums) 4\tisprime := func(x int) bool { 5\tmx := int(math.Sqrt(float64(x))) + 1 6\tfor i := 2; i \u0026lt; mx; i++ { 7\tif x%i == 0 { 8\treturn false 9\t} 10\t} 11\treturn x \u0026gt;= 2 12\t} 13\tfor i := range nums { 14\tv := nums[i][i] 15\tif v \u0026gt; res \u0026amp;\u0026amp; isprime(v) { 16\tres = v 17\t} 18\tv = nums[i][n-i-1] 19\tif v \u0026gt; res \u0026amp;\u0026amp; isprime(v) { 20\tres = v 21\t} 22\t} 23\treturn res 24} "},{"id":152,"href":"/docs/leetcode/medium/leetcode2615/","title":"2615. Sum of Distances","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.\nReturn the array arr.\nExample 1:\nInput: nums = [1,3,1,1,2] Output: [5,0,3,4,0] Explanation: When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. When i = 1, arr[1] = 0 because there is no other index with value 3. When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. When i = 4, arr[4] = 0 because there is no other index with value 2. Example 2:\nInput: nums = [0,5,3] Output: [0,0,0] Explanation: Since each element in nums is distinct, arr[i] = 0 for all i. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $0 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 正序+倒序计算 # 分析 # 把索引的差值分成两部分，当前索引减去前面的和当前索引被后面的减去的两部分 那么只算作为被减数的话，只有当前减去前面的，每一个数都是前一个数的和加上 $已知相同的数的数量 \\times 当前索引减去前一个索引的差值$ 只算作为减数的部分，倒序更好计算，每一个结果都是前一个数的结果加上 $已知相同数的数量 \\times 前一个计算的索引减去当前索引的差值$ 代码 # 1func distance(nums []int) []int64 { 2\tres := make([]int64, len(nums)) 3\tn := len(nums) 4\t// key均为值 5\tinMap := make(map[int]int) // 正序的索引 6\tcntMap := make(map[int]int) // 正序的数量 7\t// 正序遍历 8\tfor i, v := range nums { 9\tif j, ok := inMap[v]; ok { 10\t// 前面有 11\tres[i] = res[j] + int64(cntMap[v] * (i - j)) 12\t} 13\tcntMap[v]++ 14\tinMap[v] = i 15\t} 16\tinMap = make(map[int]int) // 倒序的索引 17\tcntMap = make(map[int]int) // 倒序的数量 18\tsumMap := make(map[int]int64) // 倒序的和 19\tfor i := range nums { 20\ti = n - 1 - i 21\tv := nums[i] 22\tif j, ok := inMap[v]; ok { 23\t// 前面有 24\tsumMap[v] += int64(cntMap[v] * (j - i)) 25\tres[i] += sumMap[v] 26\t} 27\tcntMap[v]++ 28\tinMap[v] = i 29\t} 30\treturn res 31} 思路2 分组+前缀和 # 分析 # 要求的其实是上图的绿色面积的和 分成两段，都可以用前缀和与当前数乘以n来处理 那么第一步先分组，将相同数分到一起，然后计算前缀和，最后合并成结果 代码 # 1func distance1(nums []int) []int64 { 2\tgrp := make(map[int][]int) // 数组存放索引 3\tfor i, v := range nums { 4\tt := grp[v] 5\tif t == nil { 6\tt = make([]int, 0, 1) 7\t} 8\tt = append(t, i) 9\tgrp[v] = t 10\t} 11 12\tres := make([]int64, len(nums)) 13\t// 遍历分组计算结果 14\tfor _, v := range grp { 15\tn := len(v) 16\tif n == 1 { 17\tcontinue 18\t} 19\ts := make([]int, n) // 计算前缀和 20\ts[0] = v[0] 21\tfor i := 1; i \u0026lt; n; i++ { 22\ts[i] = s[i-1] + v[i] 23\t} 24\tfor i := range v { 25\tres[v[i]] = int64((i+1)*v[i] - s[i] + (s[n-1] - s[i]) - (n-1-i)*v[i]) 26\t} 27\t} 28\treturn res 29} 思路3 分组+数学分析 # 分析 # 分组不变，想一下对每一个分组v来说，如果有了所有数到第一个数的距离和a[0]，那么有 $$ a[1] = a[0] + (v[1] - v[0]) - (n-1) * (v[1] - v[0]) $$\n推出 $$ a[i] = a[i-1] - (n-i-i) * (v[i]-v[i-1]) $$\n代码 # 1func distance2(nums []int) []int64 { 2\tgrp := make(map[int][]int) // 数组存放索引 3\tfor i, v := range nums { 4\tgrp[v] = append(grp[v], i) 5\t} 6 7\tres := make([]int64, len(nums)) 8\t// 遍历分组计算结果 9\tfor _, v := range grp { 10\tn := len(v) 11\tif n == 1 { 12\tcontinue 13\t} 14\tvar s int64 = 0 15\tfor _, v1 := range v[1:] { 16\ts += int64(v1 - v[0]) 17\t} 18\tres[v[0]] = s 19\tfor i := 1; i \u0026lt; n; i++ { 20\tres[v[i]] = res[v[i-1]] - int64((n-i-i)*(v[i]-v[i-1])) 21\t} 22\t} 23\treturn res 24} "},{"id":153,"href":"/docs/leetcode/simple/leetcode2643/","title":"2643. Row With Maximum Ones","section":"简单","content":" 题目 # Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\nExample 1:\nInput: mat = [[0,1],[1,0]] Output: [0,1] Explanation: Both rows have the same number of 1\u0026#39;s. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. Example 2:\nInput: mat = [[0,0,0],[0,1,1]] Output: [1,2] Explanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2]. Example 3:\nInput: mat = [[0,0],[1,1],[0,0]] Output: [1,2] Explanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2]. Constraints:\nm == mat.length n == mat[i].length 1 \u0026lt;= m, n \u0026lt;= 100 mat[i][j] is either 0 or 1. 思路1 # 分析 # 照着做 代码 # 1func rowAndMaximumOnes(mat [][]int) []int { 2\tres := []int{0, 0} 3\tfor i, v := range mat { 4\tcnt := 0 5\tfor _, v1 := range v { 6\tif v1 == 1 { 7\tcnt++ 8\t} 9\t} 10\tif cnt \u0026gt; res[1] { 11\tres[0], res[1] = i, cnt 12\t} 13\t} 14\treturn res 15} "},{"id":154,"href":"/docs/leetcode/simple/leetcode2644/","title":"2644. Find the Maximum Divisibility Score","section":"简单","content":" 题目 # You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\nExample 1:\nInput: nums = [4,7,9,3,9], divisors = [5,2,3] Output: 3 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 0 since no number in nums is divisible by 5. The divisibility score of divisors[1] is 1 since nums[0] is divisible by 2. The divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3. Since divisors[2] has the maximum divisibility score, we return it. Example 2:\nInput: nums = [20,14,21,10], divisors = [5,7,5] Output: 5 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5. The divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7. The divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5. Since divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]). Example 3:\nInput: nums = [12], divisors = [10,16] Output: 10 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 0 since no number in nums is divisible by 10. The divisibility score of divisors[1] is 0 since no number in nums is divisible by 16. Since divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]). Constraints:\n1 \u0026lt;= nums.length, divisors.length \u0026lt;= 1000 $1 \u0026lt;= nums[i], divisors[i] \u0026lt;= 10^9$ 思路1 # 分析 # 照着做，爆破 代码 # 1func maxDivScore(nums []int, divisors []int) int { 2\tres, rc := math.MaxInt, -1 3\tfor _, v := range divisors { 4\tcnt := 0 5\tfor _, v1 := range nums { 6\tif v1%v == 0 { 7\tcnt++ 8\t} 9\t} 10\tif cnt \u0026gt; rc || (rc == cnt \u0026amp;\u0026amp; res \u0026gt; v) { 11\tres, rc = v, cnt 12\t} 13\t} 14\treturn res 15} "},{"id":155,"href":"/docs/leetcode/medium/leetcode2645/","title":"2645. Find the Maximum Divisibility Score","section":"中等","content":" 题目 # You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\nExample 1:\nInput: nums = [4,7,9,3,9], divisors = [5,2,3] Output: 3 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 0 since no number in nums is divisible by 5. The divisibility score of divisors[1] is 1 since nums[0] is divisible by 2. The divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3. Since divisors[2] has the maximum divisibility score, we return it. Example 2:\nInput: nums = [20,14,21,10], divisors = [5,7,5] Output: 5 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5. The divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7. The divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5. Since divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]). Example 3:\nInput: nums = [12], divisors = [10,16] Output: 10 Explanation: The divisibility score for every element in divisors is: The divisibility score of divisors[0] is 0 since no number in nums is divisible by 10. The divisibility score of divisors[1] is 0 since no number in nums is divisible by 16. Since divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]). Constraints:\n1 \u0026lt;= nums.length, divisors.length \u0026lt;= 1000 $1 \u0026lt;= nums[i], divisors[i] \u0026lt;= 10^9$ 思路1 状态机 # 分析 # 因为是周期性，所以状态机直接统计 代码 # 1func addMinimum(word string) int { 2\tres := 0 3\tstate := 0 4\tfor i := 0; i \u0026lt; len(word); i++ { 5\tv := word[i] 6\tswitch state { 7\tcase 0: 8\tif v != \u0026#39;a\u0026#39; { 9\tres++ 10\ti-- 11\t} 12\tstate = 1 13\tcase 1: 14\tif v != \u0026#39;b\u0026#39; { 15\tres++ 16\ti-- 17\t} 18\tstate = 2 19\tcase 2: 20\tif v != \u0026#39;c\u0026#39; { 21\tres++ 22\ti-- 23\t} 24\tstate = 0 25\t} 26\t} 27\tif state != 0 { 28\tres += 3 - state 29\t} 30\treturn res 31} 思路2 分组 # 分析 # 统计分组，一组的一定后一个大于前一个 代码 # 1func addMinimum1(word string) int { 2\tt := 1 3\tfor i := 1; i \u0026lt; len(word); i++ { 4\tif word[i] \u0026lt;= word[i-1] { 5\tt++ 6\t} 7\t} 8\treturn 3*t - len(word) 9} "},{"id":156,"href":"/docs/leetcode/hard/leetcode2646/","title":"2646. Minimize the Total Price of the Trips","section":"困难","content":" 题目 # There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\nExample 1:\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]] Output: 23 Explanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half. For the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6. For the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7. For the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10. The total price sum of all trips is 6 + 7 + 10 = 23. It can be proven, that 23 is the minimum answer that we can achieve. Example 2:\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]] Output: 1 Explanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half. For the 1st trip, we choose path [0]. The price sum of that path is 1. The total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve. Constraints:\n1 \u0026lt;= n \u0026lt;= 50 edges.length == n - 1 0 \u0026lt;= ai, bi \u0026lt;= n - 1 edges represents a valid tree. price.length == n price[i] is an even integer. 1 \u0026lt;= price[i] \u0026lt;= 1000 1 \u0026lt;= trips.length \u0026lt;= 100 0 \u0026lt;= starti, endi \u0026lt;= n - 1 思路1 dfs+dfs # 分析 # 因为是无环树，直接使用dfs找路径更简单，用bfs复杂了 路径是固定的，那么就是将所有的点走了几次统计出来，然后找最小的价格即可 选几个节点降价，并且要求不相邻，那么也是用dfs 从某个点开始，选和不选有两种价格，对于下一个相邻点也有选和不选两个价格 选当前点，那么就是下个相邻的点一定不能选 不选当前点，那么下个相邻的点可选可不选，找最小的即可 最终返回选和不选当前点的较小的那个即可 代码 # 1func min(a, b int) int { 2\tif a \u0026gt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func minimumTotalPrice(n int, edges [][]int, price []int, trips [][]int) int { 9\trel := make([][]int, n) 10\tfor _, v := range edges { 11\tx, y := v[0], v[1] 12\trel[x] = append(rel[x], y) 13\trel[y] = append(rel[y], x) 14\t} 15\t// 因为只有一条路，所以深度优先 16\t// 起点、终点、上一步（因为不存在环路，所以判断不回来即可） 17\tvar dfs func(s, e, last int) bool 18\tcnt := make(map[int]int) 19\tdfs = func(s, e, last int) bool { 20\tif s == e { 21\tcnt[e]++ 22\treturn true 23\t} 24\tfor _, v := range rel[s] { 25\tif v != last \u0026amp;\u0026amp; dfs(v, e, s) { 26\tcnt[s]++ 27\treturn true 28\t} 29\t} 30\treturn false 31\t} 32\tfor _, v := range trips { 33\tdfs(v[0], v[1], -1) 34\t} 35 36\t// 单向，使用last即可防止回路 37\t// 返回选和不选的两个大小 38\tvar dfs1 func(s, last int) (nch, ch int) 39\tdfs1 = func(s, last int) (nch int, ch int) { 40\tnch = cnt[s] * price[s] 41\tch = nch / 2 42\tfor _, v := range rel[s] { 43\tif v == last { 44\tcontinue 45\t} 46\tvnch, vch := dfs1(v, s) 47\tch += vnch // 当前选中了就只能选择没选中的 48\tnch += min(vnch, vch) 49\t} 50\treturn 51\t} 52\t// 随便找一个要走的点开始遍历 53\tnch, ch := dfs1(trips[0][0], -1) 54\treturn min(nch, ch) 55} 思路2 树上差分+dfs # 分析 # 后面的计算最小值没什么好说的，但是前面的计算每个点走过的次数倒是可以优化 cnt每个trip查询一遍整体时间复杂度为 $O(nq)$，那么可以使用树上差分配合Tarjan算法的LCA处理将此时间复杂度降到 $O(n + q)$ 树上差分和Tarjan算法处理LCA自己搜一下，也可以看 Tarjan处理LCA 和 树上差分 代码 # 1func minimumTotalPrice1(n int, edges [][]int, price []int, trips [][]int) int { 2\trel := make([][]int, n) 3\tfor _, v := range edges { 4\tx, y := v[0], v[1] 5\trel[x] = append(rel[x], y) 6\trel[y] = append(rel[y], x) 7\t} 8 9\t// 树上差分计算cnt 10\tdiff := make([]int, n) 11\t// 把查询都取出来，一次遍历全部查一遍 12\tqs := make(map[int][]int) 13\tfor _, v := range trips { 14\tx, y := v[0], v[1] 15\tqs[x] = append(qs[x], y) 16\tif x != y { 17\tqs[y] = append(qs[y], x) 18\t} 19\t} 20\t// 并查集模板 21\tuf := make([]int, n) 22\tfor i := range uf { 23\tuf[i] = i 24\t} 25\tfind := func(x int) int { 26\tap := uf[x] 27\t// 找到最终节点 28\tfor ap != uf[ap] { 29\tap = uf[ap] 30\t} 31\t// 沿途都赋值最终节点 32\tfor x != ap { 33\tuf[x], x = ap, uf[x] 34\t} 35\treturn ap 36\t} 37\t// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b 38\tmerge := func(a, b int) { 39\tuf[find(a)] = find(b) 40\t} 41\t// Tarjan算法计算公共祖先 42\tcolor := make([]bool, n) 43\tfather := make([]int, n) // 每个节点的父节点 44\tvar tarjan func(a, fa int) 45\ttarjan = func(a, fa int) { 46\tfather[a] = fa 47\tfor _, v := range rel[a] { 48\tif v == fa { 49\tcontinue 50\t} 51\ttarjan(v, a) 52\t// 进去出来后，将v为根节点的子树设置公共祖先为a 53\tmerge(v, a) 54\t} 55 56\t// 查一下有没有要求的LCA 57\tfor _, v := range qs[a] { 58\tif v != a \u0026amp;\u0026amp; !color[v] { 59\t// 自己走到自己是可以计算的，要判断 60\t// v还没走到，继续 61\tcontinue 62\t} 63\tlca := find(v) 64\tdiff[a]++ 65\tdiff[v]++ 66\tdiff[lca]-- 67\tif lcaFa := father[lca]; lcaFa \u0026gt;= 0 { 68\tdiff[lcaFa]-- 69\t} 70\t} 71\tcolor[a] = true // a被灌了岩浆，也就是a的子树走完了，要向上走了 72\t} 73\t// 从0向下走 74\ttarjan(0, -1) 75 76\t// dfs，同时计算差分 77\t// 返回选和不选的两个大小 78\tvar dfs1 func(s, fa int) (nch, ch, cnt int) 79\tdfs1 = func(s, fa int) (nch, ch, cnt int) { 80\tcnt = diff[s] 81\tfor _, v := range rel[s] { 82\tif v == fa { 83\tcontinue 84\t} 85\tvnch, vch, ccnt := dfs1(v, s) 86\tch += vnch // 当前选中了就只能选择没选中的 87\tnch += min(vnch, vch) 88\tcnt += ccnt // 当前节点cnt为自己的差分加上所有子节点cnt之和 89\t} 90\tnch += cnt * price[s] 91\tch += cnt * price[s] / 2 92\treturn 93\t} 94\t// 从根节点遍历 95\tnch, ch, _ := dfs1(0, -1) 96\treturn min(nch, ch) 97} "},{"id":157,"href":"/docs/leetcode/simple/leetcode2682/","title":"2682. Find the Losers of the Circular Game","section":"简单","content":" 题目 # There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 \u0026lt;= i \u0026lt; n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n1st friend receives the ball.\nAfter that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction. After that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction. After that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth. In other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.\nThe game is finished when some friend receives the ball for the second time.\nThe losers of the game are friends who did not receive the ball in the entire game.\nGiven the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.\nExample 1:\nInput: n = 5, k = 2 Output: [4,5] Explanation: The game goes as follows: 1) Start at 1st friend and pass the ball to the friend who is 2 steps away from them - 3rd friend. 2) 3rd friend passes the ball to the friend who is 4 steps away from them - 2nd friend. 3) 2nd friend passes the ball to the friend who is 6 steps away from them - 3rd friend. 4) The game ends as 3rd friend receives the ball for the second time. Example 2:\nInput: n = 4, k = 4 Output: [2,3,4] Explanation: The game goes as follows: 1) Start at the 1st friend and pass the ball to the friend who is 4 steps away from them - 1st friend. 2) The game ends as 1st friend receives the ball for the second time. Constraints:\n1 \u0026lt;= k \u0026lt;= n \u0026lt;= 50 思路1 # 分析 # 照着做 代码 # 1func circularGameLosers(n int, k int) []int { 2\tfetchMap := make([]bool, n) 3\tfor cur, i := 0, k; !fetchMap[cur]; i += k { 4\tfetchMap[cur] = true 5\t// 下一个接球的人 6\tcur = (cur + i) % n 7\t} 8\tres := make([]int, 0, n) 9\tfor i, c := range fetchMap { 10\tif !c { 11\tres = append(res, i+1) 12\t} 13\t} 14\treturn res 15} "},{"id":158,"href":"/docs/leetcode/medium/leetcode2683/","title":"2683. Neighboring Bitwise XOR","section":"中等","content":" 题目 # A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\nIf i = n - 1, then derived[i] = original[i] ⊕ original[0]. Otherwise, derived[i] = original[i] ⊕ original[i + 1]. Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\nA binary array is an array containing only 0\u0026rsquo;s and 1\u0026rsquo;s Example 1:\nInput: derived = [1,1,0] Output: true Explanation: A valid original array that gives derived is [0,1,0]. derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1 derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0 Example 2:\nInput: derived = [1,1] Output: true Explanation: A valid original array that gives derived is [0,1]. derived[0] = original[0] ⊕ original[1] = 1 derived[1] = original[1] ⊕ original[0] = 1 Example 3:\nInput: derived = [1,0] Output: false Explanation: There is no valid original array that gives derived. Constraints:\nn == derived.length $1 \u0026lt;= n \u0026lt;= 10^5$ The values in derived are either 0\u0026rsquo;s or 1\u0026rsquo;s 思路1 # 分析 # 就假设原数组的第一个数为0，然后向后推所有的元素，看最后能否形成闭环 闭环就是最后一个元素和第一个元素也就是0异或能否等于derived最后一个元素，反过来说是最后一个元素和derived最后一个元素异或是否为0 最终简化的代码就是用0异或所有的元素，最后等于0就代表可以，否则就是不可以 代码 # 1func doesValidArrayExist(derived []int) bool { 2\tcheck := 0 // 第一个数默认为0 3\tfor i := 0; i \u0026lt; len(derived); i++ { 4\tcheck ^= derived[i] 5\t} 6\treturn check == 0 7} "},{"id":159,"href":"/docs/leetcode/medium/leetcode2684/","title":"2684. Maximum Number of Moves in a Grid","section":"中等","content":" 题目 # You are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell. Return the maximum number of moves that you can perform.\nExample 1:\nInput: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]] Output: 3 Explanation: We can start at the cell (0, 0) and make the following moves: - (0, 0) -\u0026gt; (0, 1). - (0, 1) -\u0026gt; (1, 2). - (1, 2) -\u0026gt; (2, 3). It can be shown that it is the maximum number of moves that can be made. Example 2:\nInput: grid = [[3,2,4],[2,1,9],[1,1,7]] Output: 0 Explanation: Starting from any cell in the first column we cannot perform any moves. Constraints:\nm == grid.length n == grid[i].length 2 \u0026lt;= m, n \u0026lt;= 1000 $4 \u0026lt;= m * n \u0026lt;= 10^5$ $1 \u0026lt;= grid[i][j] \u0026lt;= 10^6$ 思路1 BFS 一列一列算 # 分析 # 每走一步一定会到下一列，那么最多的步数也就是列数减一 每一列开始推下一列可以走到哪些点，直到没有幸存者或到最后一列 代码 # 1func maxMoves(grid [][]int) int { 2\tm, n := len(grid), len(grid[0]) 3\tpre := make([]bool, m) // 前一列 4\tcur := make([]bool, m) // 当前列 5\t// 从第一列出发，都能到 6\tfor i := 0; i \u0026lt; m; i++ { 7\tcur[i] = true 8\t} 9\tfor i := 1; i \u0026lt; n; i++ { 10\tpre, cur = cur, pre 11\tcnt := 0 12\tfor j := 0; j \u0026lt; m; j++ { 13\tv := grid[j][i] 14\tcheck := (j \u0026gt; 0 \u0026amp;\u0026amp; pre[j-1] \u0026amp;\u0026amp; v \u0026gt; grid[j-1][i-1]) || 15\t(pre[j] \u0026amp;\u0026amp; v \u0026gt; grid[j][i-1]) || 16\t(j \u0026lt; m-1 \u0026amp;\u0026amp; pre[j+1] \u0026amp;\u0026amp; v \u0026gt; grid[j+1][i-1]) 17\tif check { 18\tcnt++ 19\t} 20\tcur[j] = check 21\t} 22\tif cnt == 0 { 23\treturn i - 1 24\t} 25\t} 26\treturn n - 1 27} 思路2 动态规划 # 分析 # 每个点都有一个答案，答案为可以走到的三个点的答案的最大值加一 代码 # 1func max(a, b int) int { 2\tif b \u0026gt; a { 3\treturn b 4\t} 5\treturn a 6} 7 8func maxMoves1(grid [][]int) int { 9\tm, n := len(grid), len(grid[0]) 10\tlast, cur := make([]int, m), make([]int, m) 11\t// 从最后一列向前递推，最后一列都是0步，不能再走了 12\tfor i := n - 2; i \u0026gt;= 0; i-- { 13\tcur, last = last, cur 14\tfor j := 0; j \u0026lt; m; j++ { 15\tv := grid[j][i] 16\tvc := 0 17\t// 取下面三个点可以到的点，取答案较大的那个 18\tif j \u0026gt; 0 \u0026amp;\u0026amp; v \u0026lt; grid[j-1][i+1] { 19\tvc = max(vc, last[j-1]+1) 20\t} 21\tif v \u0026lt; grid[j][i+1] { 22\tvc = max(vc, last[j]+1) 23\t} 24\tif j \u0026lt; m-1 \u0026amp;\u0026amp; v \u0026lt; grid[j+1][i+1] { 25\tvc = max(vc, last[j+1]+1) 26\t} 27\tcur[j] = vc 28\t} 29\t} 30\tres := 0 31\tfor _, v := range cur { 32\tres = max(res, v) 33\t} 34\treturn res 35} "},{"id":160,"href":"/docs/leetcode/medium/leetcode2685/","title":"2685. Count the Number of Complete Components","section":"中等","content":" 题目 # You are given an integer n. There is an undirected graph with n vertices, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting vertices ai and bi.\nReturn the number of complete connected components of the graph.\nA connected component is a subgraph of a graph in which there exists a path between any two vertices, and no vertex of the subgraph shares an edge with a vertex outside of the subgraph.\nA connected component is said to be complete if there exists an edge between every pair of its vertices.\nExample 1:\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4]] Output: 3 Explanation: From the picture above, one can see that all of the components of this graph are complete. Example 2:\nInput: n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]] Output: 1 Explanation: The component containing vertices 0, 1, and 2 is complete since there is an edge between every pair of two vertices. On the other hand, the component containing vertices 3, 4, and 5 is not complete since there is no edge between vertices 4 and 5. Thus, the number of complete components in this graph is 1. Constraints:\n1 \u0026lt;= n \u0026lt;= 50 0 \u0026lt;= edges.length \u0026lt;= n * (n - 1) / 2 edges[i].length == 2 0 \u0026lt;= ai, bi \u0026lt;= n - 1 ai != bi There are no repeated edges. 思路1 并查集找关系，计算边数量 # 分析 # 并查集可以将在一起的点合并成一个集合 对每个集合计算边的数量，每个集合v个节点，边的数量为 $\\frac{v(v-1)}{2}$ 代码 # 1func countCompleteComponents(n int, edges [][]int) int { 2\t// 使用并查集合并所有的点 3\t// 并查集模板 4\tuf := make([]int, n) 5\tfor i := range uf { 6\tuf[i] = i 7\t} 8\tfind := func(x int) int { 9\tap := uf[x] 10\t// 找到最终节点 11\tfor ap != uf[ap] { 12\tap = uf[ap] 13\t} 14\t// 沿途都赋值最终节点 15\tfor x != ap { 16\tuf[x], x = ap, uf[x] 17\t} 18\treturn ap 19\t} 20\t// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b 21\tmerge := func(a, b int) { 22\tuf[find(a)] = find(b) 23\t} 24 25\t// 并查集整理好 26\tfor _, v := range edges { 27\tmerge(v[0], v[1]) 28\t} 29 30\t// 并查集的每个集合统计点数和边数 31\tpCnt := make([]int, n) 32\teCnt := make([]int, n) 33\tfor i := 0; i \u0026lt; n; i++ { 34\tpCnt[find(i)]++ 35\t} 36\tfor _, v := range edges { 37\teCnt[find(v[0])]++ 38\t} 39 40\t// 判断数量 41\tres := 0 42\tfor i, v := range pCnt { 43\tif v == 0 { 44\tcontinue 45\t} 46\tif v*(v-1)/2 == eCnt[i] { 47\tres++ 48\t} 49\t} 50\treturn res 51} 思路2 # 分析 # 使用dfs从每个点开始走，能走到的点都是联通块的点 统计这个联通块所有点的边数，联通块的点数，按照 $eCnt = pCnt \\times (pCnt-1)$ 计算 代码 # 1func countCompleteComponents(n int, edges [][]int) int { 2\tg := make([][]int, n) 3\tfor _, e := range edges { 4\tx, y := e[0], e[1] 5\tg[y] = append(g[y], x) 6\tg[x] = append(g[x], y) 7\t} 8 9\tvis := make([]bool, n) 10\tpCnt := 0 11\teCnt := 0 12\tvar dfs func(x int) 13\tdfs = func(x int) { 14\tvis[x] = true 15\tpCnt++ 16\teCnt += len(g[x]) 17\tfor _, v := range g[x] { 18\tif !vis[v] { 19\tdfs(v) 20\t} 21\t} 22\t} 23\tres := 0 24\tfor i := 0; i \u0026lt; n; i++ { 25\tif !vis[i] { 26\teCnt, pCnt = 0, 0 27\tdfs(i) 28\tif pCnt*(pCnt-1) == eCnt { 29\tres++ 30\t} 31\t} 32\t} 33\treturn res 34} "},{"id":161,"href":"/docs/leetcode/simple/leetcode2710/","title":"2710. Remove Trailing Zeros From a String","section":"简单","content":" 题目 # Given a positive integer num represented as a string, return the integer num without trailing zeros as a string.\nExample 1:\nInput: num = \u0026#34;51230100\u0026#34; Output: \u0026#34;512301\u0026#34; Explanation: Integer \u0026#34;51230100\u0026#34; has 2 trailing zeros, we remove them and return integer \u0026#34;512301\u0026#34;. Example 2:\nInput: num = \u0026#34;123\u0026#34; Output: \u0026#34;123\u0026#34; Explanation: Integer \u0026#34;123\u0026#34; has no trailing zeros, we return integer \u0026#34;123\u0026#34;. Constraints:\n1 \u0026lt;= num.length \u0026lt;= 1000 num consists of only digits. num doesn\u0026rsquo;t have any leading zeros. 思路1 # 分析 # 照着做，倒着找第一个非0的位置，裁剪 代码 # 1func removeTrailingZeros(num string) string { 2\ti := len(num)-1 3\tfor ; i \u0026gt;= 0 \u0026amp;\u0026amp; num[i] == \u0026#39;0\u0026#39;; i-- { 4\t} 5\treturn num[:i+1] 6} "},{"id":162,"href":"/docs/leetcode/medium/leetcode2711/","title":"2711. Difference of Number of Distinct Values on Diagonals","section":"中等","content":" 题目 # Given a 0-indexed 2D grid of size m x n, you should find the matrix answer of size m x n.\nThe value of each cell (r, c) of the matrix answer is calculated in the following way:\nLet topLeft[r][c] be the number of distinct values in the top-left diagonal of the cell (r, c) in the matrix grid. Let bottomRight[r][c] be the number of distinct values in the bottom-right diagonal of the cell (r, c) in the matrix grid. Then answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|.\nReturn the matrix answer.\nA matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix\u0026rsquo;s end.\nA cell (r1, c1) belongs to the top-left diagonal of the cell (r, c), if both belong to the same diagonal and r1 \u0026lt; r. Similarly is defined bottom-right diagonal.\nExample 1:\nInput: grid = [[1,2,3],[3,1,5],[3,2,1]] Output: [[1,1,0],[1,0,1],[0,1,1]] Explanation: The 1st diagram denotes the initial grid. The 2nd diagram denotes a grid for cell (0,0), where blue-colored cells are cells on its bottom-right diagonal. The 3rd diagram denotes a grid for cell (1,2), where red-colored cells are cells on its top-left diagonal. The 4th diagram denotes a grid for cell (1,1), where blue-colored cells are cells on its bottom-right diagonal and red-colored cells are cells on its top-left diagonal. - The cell (0,0) contains [1,1] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |1 - 0| = 1. - The cell (1,2) contains [] on its bottom-right diagonal and [2] on its top-left diagonal. The answer is |0 - 1| = 1. - The cell (1,1) contains [1] on its bottom-right diagonal and [1] on its top-left diagonal. The answer is |1 - 1| = 0. The answers of other cells are similarly calculated. Example 2:\nInput: grid = [[1]] Output: [[0]] Explanation: - The cell (0,0) contains [] on its bottom-right diagonal and [] on its top-left diagonal. The answer is |0 - 0| = 0. Constraints:\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n, grid[i][j] \u0026lt;= 50 思路1 暴力破解 # 分析 # 第一行和第一列开始，找对角线每个元素的左上不同元素个数，找一个数组统计出来 然后再次遍历此对角线，统计出右下的不同元素个数，右下可以用总个数减去当前来进行计算 整体所有元素遍历了两遍，复杂度 $O(mn)$ 代码 # 1func abs(x int) int { 2\tif x \u0026lt; 0 { 3\treturn -x 4\t} 5\treturn x 6} 7 8func differenceOfDistinctValues(grid [][]int) [][]int { 9\tm, n := len(grid), len(grid[0]) 10\tres := make([][]int, m) 11\tfor i := range res { 12\tres[i] = make([]int, n) 13\t} 14\ttl := make([]int, 0, m) 15\tgetAns := func(is, js int) { 16\ttlMap := make(map[int]int) 17\ttl = tl[:0] 18\t// 第一遍统计左上角的数量并记录在tl中 19\tfor i, j := is, js; i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n; i, j = i+1, j+1 { 20\ttl = append(tl, len(tlMap)) 21\ttlMap[grid[i][j]]++ 22\t} 23\t// 第二遍计算右下角数量 24\tfor i, j, k := is, js, 0; i \u0026lt; m \u0026amp;\u0026amp; j \u0026lt; n; i, j, k = i+1, j+1, k+1 { 25\tv := grid[i][j] 26\tif tlMap[v] \u0026lt;= 1 { 27\tdelete(tlMap, v) 28\t} else { 29\ttlMap[v]-- 30\t} 31\tres[i][j] = abs(len(tlMap) - tl[k]) 32\t} 33\t} 34\tfor i := 0; i \u0026lt; n; i++ { 35\tgetAns(0, i) 36\t} 37\tfor i := 1; i \u0026lt; m; i++ { 38\tgetAns(i, 0) 39\t} 40\treturn res 41} "},{"id":163,"href":"/docs/leetcode/medium/leetcode2712/","title":"2712. Minimum Cost to Make All Characters Equal","section":"中等","content":" 题目 # You are given a 0-indexed binary string s of length n on which you can apply two types of operations:\nChoose an index i and invert all characters from index 0 to index i (both inclusive), with a cost of i + 1 Choose an index i and invert all characters from index i to index n - 1 (both inclusive), with a cost of n - i Return the minimum cost to make all characters of the string equal.\nInvert a character means if its value is \u0026lsquo;0\u0026rsquo; it becomes \u0026lsquo;1\u0026rsquo; and vice-versa.\nExample 1:\nInput: s = \u0026#34;0011\u0026#34; Output: 2 Explanation: Apply the second operation with i = 2 to obtain s = \u0026#34;0000\u0026#34; for a cost of 2. It can be shown that 2 is the minimum cost to make all characters equal. Example 2:\nInput: s = \u0026#34;010101\u0026#34; Output: 9 Explanation: Apply the first operation with i = 2 to obtain s = \u0026#34;101101\u0026#34; for a cost of 3. Apply the first operation with i = 1 to obtain s = \u0026#34;011101\u0026#34; for a cost of 2. Apply the first operation with i = 0 to obtain s = \u0026#34;111101\u0026#34; for a cost of 1. Apply the second operation with i = 4 to obtain s = \u0026#34;111110\u0026#34; for a cost of 2. Apply the second operation with i = 5 to obtain s = \u0026#34;111111\u0026#34; for a cost of 1. The total cost to make all characters equal is 9. It can be shown that 9 is the minimum cost to make all characters equal. Constraints:\n$1 \u0026lt;= s.length == n \u0026lt;= 10^5$ s[i] is either \u0026lsquo;0\u0026rsquo; or \u0026lsquo;1\u0026rsquo; 思路1 遍历一遍进行翻转 # 分析 # 两个相邻不一样，肯定要翻转，但是翻后面还是翻前面效果一样，肯定取小的那个 代码 # 1func min(a, b int) int { 2\tif a \u0026gt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func minimumCost(s string) int64 { 9\tvar res int64 = 0 10\tn := len(s) 11\tfor i := 1; i \u0026lt; n; i++ { 12\tif s[i] == s[i-1] { 13\tcontinue 14\t} 15\tres += int64(min(i, n-i)) 16\t} 17\treturn res 18} "},{"id":164,"href":"/docs/leetcode/hard/leetcode2713/","title":"2713. Maximum Strictly Increasing Cells in a Matrix","section":"困难","content":" 题目 # Given a 1-indexed m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.\nExample 1:\nInput: mat = [[3,1],[3,4]] Output: 2 Explanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2. Example 2:\nInput: mat = [[1,1],[1,1]] Output: 1 Explanation: Since the cells must be strictly increasing, we can only visit one cell in this example. Example 3:\nInput: mat = [[3,1,6],[-9,5,7]] Output: 4 Explanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4. Constraints:\nm == mat.length n == mat[i].length $1 \u0026lt;= m, n \u0026lt;= 10^5$ $1 \u0026lt;= m * n \u0026lt;= 10^5$ $-10^5 \u0026lt;= mat[i][j] \u0026lt;= 10^5$ 思路1 从最小向最大进行动态规划 # 分析 # 直接找点遍历时间复杂度太高，动态的想一下，每个点为终点的值是其所在行和列的最大值加一 那么把每个点的最大值都算出来，找到整个矩阵最大的那个点就好了，怎么知道这个最大值一定是最大的呢 从最小的点开始，最小的点没人可以到，所以一定是1，那么向上一步一步算，每个算出来的都一定是最大值 优化时间复杂度，记录一下每行和每列的最大值方便计算 代码 # 1func maxIncreasingCells(mat [][]int) int { 2\tm, n := len(mat), len(mat[0]) 3\ttype pair struct{ i, j int } 4\tgrp := make(map[int][]pair) 5\trowMax := make([]int, m) 6\tcolMax := make([]int, n) 7\tfor i := range mat { 8\tfor j, v := range mat[i] { 9\tgrp[v] = append(grp[v], pair{i, j}) 10\t} 11\t} 12\tkeys := make([]int, 0, len(grp)) 13\tfor i := range grp { 14\tkeys = append(keys, i) 15\t} 16\tsort.Ints(keys) 17 18\tres := 0 19\tfor _, v := range keys { 20\t// 找这一行的最大值和这一列的最大值，因为从小到大遍历的，所以直接为其加一即可 21\tmaxNums := make([]int, len(grp[v])) 22\tfor i, p := range grp[v] { 23\tmaxNums[i] = max(rowMax[p.i], colMax[p.j]) + 1 24\tres = max(res, maxNums[i]) 25\t} 26\tfor i, p := range grp[v] { 27\trowMax[p.i] = max(rowMax[p.i], maxNums[i]) 28\tcolMax[p.j] = max(colMax[p.j], maxNums[i]) 29\t} 30\t} 31\treturn res 32} 33 34func max(a, b int) int { 35\tif a \u0026lt; b { 36\treturn b 37\t} 38\treturn a 39} "},{"id":165,"href":"/docs/leetcode/simple/leetcode2716/","title":"2716. Minimize String Length","section":"简单","content":" 题目 # Given a 0-indexed string s, repeatedly perform the following operation any number of times:\nChoose an index i in the string, and let c be the character in position i. Delete the closest occurrence of c to the left of i (if any) and the closest occurrence of c to the right of i (if any). Your task is to minimize the length of s by performing the above operation any number of times.\nReturn an integer denoting the length of the minimized string.\nExample 1:\nInput: s = \u0026#34;aaabc\u0026#34; Output: 3 Explanation: In this example, s is \u0026#34;aaabc\u0026#34;. We can start by selecting the character \u0026#39;a\u0026#39; at index 1. We then remove the closest \u0026#39;a\u0026#39; to the left of index 1, which is at index 0, and the closest \u0026#39;a\u0026#39; to the right of index 1, which is at index 2. After this operation, the string becomes \u0026#34;abc\u0026#34;. Any further operation we perform on the string will leave it unchanged. Therefore, the length of the minimized string is 3. Example 2:\nInput: s = \u0026#34;cbbd\u0026#34; Output: 3 Explanation: For this we can start with character \u0026#39;b\u0026#39; at index 1. There is no occurrence of \u0026#39;b\u0026#39; to the left of index 1, but there is one to the right at index 2, so we delete the \u0026#39;b\u0026#39; at index 2. The string becomes \u0026#34;cbd\u0026#34; and further operations will leave it unchanged. Hence, the minimized length is 3. Example 3:\nInput: s = \u0026#34;dddaaa\u0026#34; Output: 2 Explanation: For this, we can start with the character \u0026#39;d\u0026#39; at index 1. The closest occurrence of a \u0026#39;d\u0026#39; to its left is at index 0, and the closest occurrence of a \u0026#39;d\u0026#39; to its right is at index 2. We delete both index 0 and 2, so the string becomes \u0026#34;daaa\u0026#34;. In the new string, we can select the character \u0026#39;a\u0026#39; at index 2. The closest occurrence of an \u0026#39;a\u0026#39; to its left is at index 1, and the closest occurrence of an \u0026#39;a\u0026#39; to its right is at index 3. We delete both of them, and the string becomes \u0026#34;da\u0026#34;. We cannot minimize this further, so the minimized length is 2. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 100 s contains only lowercase English letters 思路1 哈希map # 分析 # 有重复就可以继续做，那么剩余的就是不同字母的数量，直接哈希map做就好了 代码 # 1func minimizedStringLength(s string) int { 2\tsMap := make(map[byte]bool) 3\tfor _, v := range s { 4\tsMap[byte(v)] = true 5\t} 6\treturn len(sMap) 7} "},{"id":166,"href":"/docs/leetcode/simple/leetcode2717/","title":"2717. Semi-Ordered Permutation","section":"简单","content":" 题目 # You are given a 0-indexed permutation of n integers nums.\nA permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation:\nPick two adjacent elements in nums, then swap them. Return the minimum number of operations to make nums a semi-ordered permutation.\nA permutation is a sequence of integers from 1 to n of length n containing each number exactly once.\nExample 1:\nInput: nums = [2,1,4,3] Output: 2 Explanation: We can make the permutation semi-ordered using these sequence of operations: 1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3]. 2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4]. It can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. Example 2:\nInput: nums = [2,4,1,3] Output: 3 Explanation: We can make the permutation semi-ordered using these sequence of operations: 1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3]. 2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3]. 3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4]. It can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation. Example 3:\nInput: nums = [1,3,4,2,5] Output: 0 Explanation: The permutation is already a semi-ordered permutation. Constraints:\n2 \u0026lt;= nums.length == n \u0026lt;= 50 1 \u0026lt;= nums[i] \u0026lt;= 50 nums is a permutation. 思路1 分析+数学计算 # 分析 # 只要第一个和最后一个对上即可，那么计算一下第一个和最后一个差多少步，走过去即可 注意走的过程中，如果两个数交换了，需要减去一步 代码 # 1func semiOrderedPermutation(nums []int) int { 2\t// 先找到1和n的位置 3\tindex1, indexn := 0, 0 4\tn := len(nums) 5\tfor i, v := range nums { 6\tif v == 1 { 7\tindex1 = i 8\t} else if v == n { 9\tindexn = i 10\t} 11\t} 12 13\tsum := (index1 - 0) + (n - 1 - indexn) 14\tif index1 \u0026gt; indexn { 15\tsum-- 16\t} 17\treturn sum 18} "},{"id":167,"href":"/docs/leetcode/medium/leetcode2718/","title":"2718. Sum of Matrix After Queries","section":"中等","content":" 题目 # You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typei, indexi, vali].\nInitially, there is a 0-indexed n x n matrix filled with 0\u0026rsquo;s. For each query, you must apply one of the following changes:\nif typei == 0, set the values in the row with indexi to vali, overwriting any previous values. if typei == 1, set the values in the column with indexi to vali, overwriting any previous values. Return the sum of integers in the matrix after all queries are applied.\nExample 1:\nInput: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]] Output: 23 Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. Example 2:\nInput: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]] Output: 17 Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^4$ $1 \u0026lt;= queries.length \u0026lt;= 5 * 10^4$ queries[i].length == 3 0 \u0026lt;= typei \u0026lt;= 1 0 \u0026lt;= indexi \u0026lt; n $0 \u0026lt;= vali \u0026lt;= 10^5$ 思路1 倒序处理 # 分析 # 正序处理要考虑可能会被后面给覆盖，要记录每一个位置的数值，覆盖要替换 倒序处理只需要考虑前面有没有处理过即可，只需要记录处理过的行号和列号，处理过不计算即可 使用一个map的数组，0代表行的哈希map，1代表列的哈希map 0和1的互转使用x^1 代码 # 1func matrixSumQueries(n int, queries [][]int) int64 { 2\t// 倒序处理queries 3\tgMap := [2]map[int]bool{{}, {}} 4\tvar sum int64 = 0 5\tfor i := len(queries) - 1; i \u0026gt;= 0; i-- { 6\tt, i, v := queries[i][0], queries[i][1], queries[i][2] 7\tif gMap[t][i] { 8\t// 已经操作过，跳过 9\tcontinue 10\t} 11\tgMap[t][i] = true 12\tsum += int64(v * (n - len(gMap[t^1]))) 13\t} 14\treturn sum 15} "},{"id":168,"href":"/docs/leetcode/hard/leetcode2719/","title":"2719. Count of Integers","section":"困难","content":" 题目 # You are given two numeric strings num1 and num2 and two integers max_sum and min_sum. We denote an integer x to be good if:\nnum1 \u0026lt;= x \u0026lt;= num2 min_sum \u0026lt;= digit_sum(x) \u0026lt;= max_sum. Return the number of good integers. Since the answer may be large, return it modulo 109 + 7.\nNote that digit_sum(x) denotes the sum of the digits of x.\nExample 1:\nInput: num1 = \u0026#34;1\u0026#34;, num2 = \u0026#34;12\u0026#34;, min_num = 1, max_num = 8 Output: 11 Explanation: There are 11 integers whose sum of digits lies between 1 and 8 are 1,2,3,4,5,6,7,8,10,11, and 12. Thus, we return 11. Example 2:\nInput: num1 = \u0026#34;1\u0026#34;, num2 = \u0026#34;5\u0026#34;, min_num = 1, max_num = 5 Output: 5 Explanation: The 5 integers whose sum of digits lies between 1 and 5 are 1,2,3,4, and 5. Thus, we return 5. Constraints:\n$1 \u0026lt;= num1 \u0026lt;= num2 \u0026lt;= 10^{22}$ 1 \u0026lt;= min_sum \u0026lt;= max_sum \u0026lt;= 400 思路1 数位dp（记忆化搜索） # 分析 # 直接使用数位dp的记忆化搜索写法，求小于某个数的，所有位加在一起在给定范围的数量总和 小于num2大于num1可以用，小于num2的数量减去小于num1-1的数量得到 代码 # 1func count(num1 string, num2 string, min_sum int, max_sum int) int { 2\tvar mod int = 1e9 + 7 3\t// 返回小于s的满足条件的数量 4\tgetCount := func(s string) int { 5\t// 状态记忆数组，第一维是位数，第二维是状态（当前表示为前面数字的和），value是数量 6\tmemo := make([][]int, len(s)) 7\tfor i := range memo { 8\tmemo[i] = make([]int, max_sum+1) 9\tfor j := range memo[i] { 10\tmemo[i][j] = -1 11\t} 12\t} 13 14\t// p为当前要枚举的位，0是最高位，len(s)-1是最低位 15\t// sum是前面位数的和 16\t// limitUp代表前面的数位是否都到达上界 17\tvar dfs func(p, sum int, limitUp bool) (res int) 18\tdfs = func(p, sum int, limitUp bool) (res int) { 19\tif sum \u0026gt; max_sum { 20\treturn 21\t} 22\tif p == len(s) { 23\t// 到头了，sum必须大于等于最小sum 24\tif sum \u0026gt;= min_sum { 25\treturn 1 26\t} 27\treturn 28\t} 29 30\tif !limitUp { 31\t// 没到上界才能取状态，否则状态是假的 32\ttmp := memo[p][sum] 33\tif tmp \u0026gt;= 0 { 34\treturn tmp 35\t} 36\tdefer func() { memo[p][sum] = res }() 37\t} 38\tup := 9 39\tif limitUp { 40\tup = int(s[p] - \u0026#39;0\u0026#39;) 41\t} 42\tfor d := 0; d \u0026lt;= up; d++ { 43\tres = (res + dfs(p+1, sum+d, limitUp \u0026amp;\u0026amp; d == int(s[p]-\u0026#39;0\u0026#39;))) % mod 44\t} 45\treturn 46\t} 47\treturn dfs(0, 0, true) 48\t} 49 50\tans := getCount(num2) - getCount(num1) + mod 51\t// 判断一下num1是否合法，上面直接减去了num1而不是num1-1，少算了num1 52\tsumNum1 := 0 53\tfor _, c := range num1 { 54\tsumNum1 += int(c - \u0026#39;0\u0026#39;) 55\t} 56\tif sumNum1 \u0026gt;= min_sum \u0026amp;\u0026amp; sumNum1 \u0026lt;= max_sum { 57\tans++ 58\t} 59\treturn ans % mod 60} 思路2 数位dp（递推） # 分析 # 从最高位开始构造，记录一个数组保存每一位可以到达的sum对应的数量，不包含上界，因为每一位都可以从0到9，到了上界就不能到9了 单独统计一下上界，假设前面的都到上界，当前位除了到上界的情况都可以统计到数组中 到最后一位时，需要判断最小值，前面不考虑最小值，只考虑最大值 代码 # 1func count2(num1 string, num2 string, min_sum int, max_sum int) int { 2\tvar mod int = 1e9 + 7 3 4\t// 返回能取到的最大值 5\tgetMax := func(s int) int { 6\tmaxNum := 9 7\tif s+maxNum \u0026gt; max_sum { 8\tmaxNum = max_sum - s 9\t} 10\treturn maxNum 11\t} 12\tgetMin := func(s int) int { 13\tminNum := min_sum - s 14\tif minNum \u0026lt; 0 { 15\tminNum = 0 16\t} 17\treturn minNum 18\t} 19 20\t// 返回小于s的满足条件的数量 21\tgetCount := func(s string) int { 22\tn := len(s) 23\t// 最后一位要特殊处理，所以这里要对只有一位的情况单独计算 24\tif n == 1 { 25\tnum := int(s[0] - \u0026#39;0\u0026#39;) 26\tif num \u0026lt; min_sum { 27\treturn 0 28\t} 29\treturn num - min_sum + 1 30\t} 31\t// 记录前一位可以到达某个sum的统计数量，要求下一位可以从0算到9，也就是当前不能到上界 32\tpreState := make([]int, max_sum+1) 33\tlimitSum := 0 34\t// 遍历到除最后一位，最后一位要判断最小值 35\tfor _, v := range s[:n-1] { 36\tnum := int(v - \u0026#39;0\u0026#39;) 37\tcurState := make([]int, max_sum+1) 38\t// 到前一位已经得到的sum为st 39\tfor st, c := range preState { 40\tif c == 0 { 41\tcontinue 42\t} 43\tmaxNum := getMax(st) 44\tfor d := 0; d \u0026lt;= maxNum; d++ { 45\tcurState[d+st] = (curState[d+st] + c) % mod 46\t} 47\t} 48\t// 算一下上界的情况，当前位除了到达上界，下一位都可以按照0到9算，所以直接加到状态中 49\tmaxNum := getMax(limitSum) 50\tfor d := 0; d \u0026lt;= maxNum \u0026amp;\u0026amp; d \u0026lt; num; d++ { 51\tcurState[d+limitSum] = (curState[d+limitSum] + 1) % mod 52\t} 53\tlimitSum += num 54\tpreState = curState 55\t} 56 57\t// 遍历最后一位 58\tres := 0 59\tfor st, c := range preState { 60\tif c == 0 { 61\tcontinue 62\t} 63\tminNum := getMin(st) 64\tmaxNum := getMax(st) 65\tfor d := minNum; d \u0026lt;= maxNum; d++ { 66\tres = (res + c) % mod 67\t} 68\t} 69\t// 算一下上界 70\tmaxNum := getMax(limitSum) 71\tminNum := getMin(limitSum) 72\tfor d := minNum; d \u0026lt;= maxNum \u0026amp;\u0026amp; d \u0026lt;= int(s[n-1]-\u0026#39;0\u0026#39;); d++ { 73\tres = (res + 1) % mod 74\t} 75\treturn res 76\t} 77 78\tans := getCount(num2) - getCount(num1) + mod 79\t// 判断一下num1是否合法，上面直接减去了num1而不是num1-1，少算了num1 80\tsumNum1 := 0 81\tfor _, c := range num1 { 82\tsumNum1 += int(c - \u0026#39;0\u0026#39;) 83\t} 84\tif sumNum1 \u0026gt;= min_sum \u0026amp;\u0026amp; sumNum1 \u0026lt;= max_sum { 85\tans++ 86\t} 87\treturn ans % mod 88} "},{"id":169,"href":"/docs/leetcode/simple/leetcode2733/","title":"2733. Neither Minimum nor Maximum","section":"简单","content":" 题目 # Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.\nReturn the selected integer.\nExample 1:\nInput: nums = [3,2,1,4] Output: 2 Explanation: In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers. Example 2:\nInput: nums = [1,2] Output: -1 Explanation: Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer. Example 3:\nInput: nums = [2,1,3] Output: 2 Explanation: Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100 All values in nums are distinct 思路1 前3个数一定有答案 # 分析 # 小于等于2肯定没答案，题目条件，数字互不相同，那么前三个数中一定有一个在中间 排序前三个即可，取第二个 代码 # 1func findNonMinOrMax(nums []int) int { 2\tif len(nums) \u0026lt;= 2 { 3\treturn -1 4\t} 5\tsort.Ints(nums[:3]) 6\treturn nums[1] 7} "},{"id":170,"href":"/docs/leetcode/medium/leetcode2734/","title":"2734. Lexicographically Smallest String After Substring Operation","section":"中等","content":" 题目 # You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, \u0026lsquo;b\u0026rsquo; is converted to \u0026lsquo;a\u0026rsquo;, and \u0026lsquo;a\u0026rsquo; is converted to \u0026lsquo;z\u0026rsquo;. Return the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].\nExample 1:\nInput: s = \u0026#34;cbabc\u0026#34; Output: \u0026#34;baabc\u0026#34; Explanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. It can be proven that the resulting string is the lexicographically smallest. Example 2:\nInput: s = \u0026#34;acbbc\u0026#34; Output: \u0026#34;abaab\u0026#34; Explanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. It can be proven that the resulting string is the lexicographically smallest. Example 3:\nInput: s = \u0026#34;leetcode\u0026#34; Output: \u0026#34;kddsbncd\u0026#34; Explanation: We apply the operation on the entire string. It can be proven that the resulting string is the lexicographically smallest. Constraints:\n$1 \u0026lt;= s.length \u0026lt;= 3 * 10^5$ s consists of lowercase English letters 思路1 贪心 # 分析 # 字典序最小，肯定越前面的小越好 但是a不能减，变成z就更小了 那么从左向右，第一个不为a的开始，一个一个减，当遇到a或到最后停止 由于必须减一个，所以都是a就得把最后一个减一 代码 # 1func findNonMinOrMax(nums []int) int { 2\tif len(nums) \u0026lt;= 2 { 3\treturn -1 4\t} 5\tsort.Ints(nums[:3]) 6\treturn nums[1] 7} "},{"id":171,"href":"/docs/leetcode/medium/leetcode2735/","title":"2735. Collecting Chocolates","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums of size n representing the cost of collecting different chocolates. Each chocolate is of a different type, and originally, the chocolate at ith index is of ith type.\nIn one operation, you can do the following with an incurred cost of x:\nSimultaneously change the chocolate of ith type to (i + 1)th type for all indexes i where 0 \u0026lt;= i \u0026lt; n - 1. When i == n - 1, that chocolate will be changed to type of the chocolate at index 0. Return the minimum cost to collect chocolates of all types, given that you can perform as many operations as you would like.\nExample 1:\nInput: nums = [20,1,15], x = 5 Output: 13 Explanation: Initially, the chocolate types are [0,1,2]. We will buy the 1st type of chocolate at a cost of 1. Now, we will perform the operation at a cost of 5, and the types of chocolates will become [2,0,1]. We will buy the 0th type of chocolate at a cost of 1. Now, we will again perform the operation at a cost of 5, and the chocolate types will become [1,2,0]. We will buy the 2nd type of chocolate at a cost of 1. Thus, the total cost will become (1 + 5 + 1 + 5 + 1) = 13. We can prove that this is optimal. Example 2:\nInput: nums = [1,2,3], x = 4 Output: 6 Explanation: We will collect all three types of chocolates at their own price without performing any operations. Therefore, the total cost is 1 + 2 + 3 = 6. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ $1 \u0026lt;= x \u0026lt;= 10^9$ 思路1 枚举操作次数 # 分析 # 每次操作，所有数字都会变，那么只能枚举操作次数，计算最小值 找一个数组记录从操作0次操作n次之间的最小值 每一次操作，算一边和，操作最多n次，找到和的最小值 代码 # 1func minCost(nums []int, x int) int64 { 2\tn := len(nums) 3\tminNums := make([]int, n) 4\tcopy(minNums, nums) 5\tvar res int64 = math.MaxInt64 6\tfor i := 0; i \u0026lt; n; i++ { 7\tvar sum int64 = int64(i * x) 8\tfor j, v := range minNums { 9\tk := (i + j) % n 10\tminNums[j] = min(v, nums[k]) 11\tsum += int64(minNums[j]) 12\t} 13\tif sum \u0026lt; res { 14\tres = sum 15\t} 16\t} 17\treturn res 18} "},{"id":172,"href":"/docs/leetcode/simple/leetcode2739/","title":"2739. Total Distance Traveled","section":"简单","content":" 题目 # A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.\nThe truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.\nReturn the maximum distance which can be traveled.\nNote: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.\nExample 1:\nInput: mainTank = 5, additionalTank = 10 Output: 60 Explanation: After spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km. After spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty. Total distance traveled is 60km. Example 2:\nInput: mainTank = 1, additionalTank = 2 Output: 10 Explanation: After spending 1 litre of fuel, the main tank becomes empty. Total distance traveled is 10km. Constraints:\n1 \u0026lt;= mainTank, additionalTank \u0026lt;= 100 思路1 照着做 # 分析 # 照着做就好了，需要用个循环，防止副油箱补充后又超过5L了 代码 # 1func distanceTraveled(mainTank int, additionalTank int) int { 2\tres := 0 3\tfor mainTank \u0026gt;= 5 { 4\tvar add int 5\tadd, mainTank = mainTank/5, mainTank%5 6\tres += add * 50 7\tif additionalTank \u0026lt; add { 8\tadd = additionalTank 9\t} 10\tadditionalTank -= add 11\tmainTank += add 12\t} 13\tres += mainTank * 10 14\treturn res 15} "},{"id":173,"href":"/docs/leetcode/medium/leetcode2740/","title":"2740. Find the Value of the Partition","section":"中等","content":" 题目 # You are given a positive integer array nums.\nPartition nums into two arrays, nums1 and nums2, such that:\nEach element of the array nums belongs to either the array nums1 or the array nums2. Both arrays are non-empty. The value of the partition is minimized. The value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.\nExample 1:\nInput: nums = [1,3,2,4] Output: 1 Explanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4]. - The maximum element of the array nums1 is equal to 2. - The minimum element of the array nums2 is equal to 3. The value of the partition is |2 - 3| = 1. It can be proven that 1 is the minimum value out of all partitions. Example 2:\nInput: nums = [100,1,10] Output: 9 Explanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1]. - The maximum element of the array nums1 is equal to 10. - The minimum element of the array nums2 is equal to 1. The value of the partition is |10 - 1| = 9. It can be proven that 9 is the minimum value out of all partitions. Constraints:\n$2 \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 分析+排序 # 分析 # 看似分两个数组，规定了nums1取max，nums2取min，那么找到两个相邻最近的数字a \u0026gt;= b 比b小的都放到nums1中，最大值就是b 比a大的都放到nums2中，最小值就是a 结果就是a - b 排序找最小间隔返回即可 代码 # 1func findValueOfPartition(nums []int) int { 2\tsort.Ints(nums) 3\tres := math.MaxInt 4\tfor i := range nums[1:] { 5\tdiff := nums[i+1] - nums[i] 6\tif diff \u0026lt; res { 7\tres = diff 8\t} 9\t} 10\treturn res 11} "},{"id":174,"href":"/docs/leetcode/medium/leetcode2741/","title":"2741. Special Permutations","section":"中等","content":" 题目 # You are given a 0-indexed integer array nums containing n distinct positive integers. A permutation of nums is called special if:\nFor all indexes 0 \u0026lt;= i \u0026lt; n - 1, either nums[i] % nums[i+1] == 0 or nums[i+1] % nums[i] == 0. Return the total number of special permutations. As the answer could be large, return it modulo $10^9 + 7$.\nExample 1:\nInput: nums = [2,3,6] Output: 2 Explanation: [3,6,2] and [2,6,3] are the two special permutations of nums. Example 2:\nInput: nums = [1,4,3] Output: 2 Explanation: [3,1,4] and [4,1,3] are the two special permutations of nums. Constraints:\n2 \u0026lt;= nums.length \u0026lt;= 14 $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 dp递推 # 分析 # 一位一位数放，将某个数是否出现过记录在二进制数中 记录上一位出现的数字，枚举下一位可以出现什么数字，记录的是第i位是x的某个状态的数量 代码 # 1func specialPerm1(nums []int) int { 2\tvar mod int = 1e9 + 7 3\tn := len(nums) 4\t// 第一维是上一位是什么数字，第二维是状态（保存什么数字出现过的二进制），value为数量 5\tstMap := map[int]map[uint16]int{} 6\tfor i, v := range nums { 7\tstMap[v] = map[uint16]int{ 8\t1 \u0026lt;\u0026lt; i: 1, 9\t} 10\t} 11\tfor i := 1; i \u0026lt; n; i++ { 12\ttmp := stMap 13\tstMap = make(map[int]map[uint16]int) 14\t// 遍历map，找state中没出现过的数字，看能否填到此位，能填就加上数量 15\tfor l, vMap := range tmp { 16\t// 遍历所有的状态，然后遍历所有的nums，没出现过且可以放就放进去 17\tfor j, v := range nums { 18\tfor st, c := range vMap { 19\t// 出现过或不能放到下一位就跳过 20\tif st\u0026amp;(1\u0026lt;\u0026lt;j) \u0026gt; 0 || (v%l != 0 \u0026amp;\u0026amp; l%v != 0) { 21\tcontinue 22\t} 23\tif stMap[v] == nil { 24\tstMap[v] = make(map[uint16]int) 25\t} 26\tst |= (1 \u0026lt;\u0026lt; j) 27\tstMap[v][st] = (stMap[v][st] + c) % mod 28\t} 29\t} 30\t} 31\t} 32\tres := 0 33\tfor _, c := range stMap { 34\tfor _, c1 := range c { 35\tres = (res + c1) % mod 36\t} 37\t} 38\treturn res 39} 思路2 优化时间复杂度 # 分析 # 在上一步的基础上，发现每次要遍历所有的数，如果提前把某个数下一个数能选啥给找出来可以遍历少一点 代码 # 1func specialPerm(nums []int) int { 2\tvar mod int = 1e9 + 7 3\t// 先找出谁能和谁做邻居 4\t// key为数字值，v为index 5\tpMap := map[int][]int{} 6\tn := len(nums) 7\tfor i, v := range nums { 8\tfor j := i + 1; j \u0026lt; n; j++ { 9\tv1 := nums[j] 10\tif v%v1 == 0 || v1%v == 0 { 11\tpMap[v] = append(pMap[v], j) 12\tpMap[v1] = append(pMap[v1], i) 13\t} 14\t} 15\t} 16\tstMap := map[int]map[uint16]int{} 17\tfor i, v := range nums { 18\tstMap[v] = map[uint16]int{ 19\t1 \u0026lt;\u0026lt; i: 1, 20\t} 21\t} 22\tfor range nums[:n-1] { 23\ttmp := stMap 24\tstMap = make(map[int]map[uint16]int) 25\t// 遍历map，找state中没出现过的数字，看能否填到此位，能填就加上数量 26\tfor k, v := range tmp { 27\tfor _, v1 := range pMap[k] { 28\tfor st, c := range v { 29\tif st\u0026amp;(1\u0026lt;\u0026lt;v1) \u0026gt; 0 { 30\tcontinue 31\t} 32\tst |= 1 \u0026lt;\u0026lt; v1 33\tif stMap[nums[v1]] == nil { 34\tstMap[nums[v1]] = make(map[uint16]int) 35\t} 36\tstMap[nums[v1]][st] = (stMap[nums[v1]][st] + c) % mod 37\t} 38\t} 39\t} 40\t} 41\tres := 0 42\tfor _, c := range stMap { 43\tfor _, c1 := range c { 44\tres = (res + c1) % mod 45\t} 46\t} 47\treturn res 48} "},{"id":175,"href":"/docs/leetcode/hard/leetcode2742/","title":"2742. Painting the Walls","section":"困难","content":" 题目 # You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:\nA paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money. A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied. Return the minimum amount of money required to paint the n walls.\nExample 1:\nInput: cost = [1,2,3,2], time = [1,2,3,2] Output: 3 Explanation: The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3. Example 2:\nInput: cost = [2,3,4,2], time = [1,1,1,1] Output: 4 Explanation: The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4. Constraints:\n1 \u0026lt;= cost.length \u0026lt;= 500 cost.length == time.length $1 \u0026lt;= cost[i] \u0026lt;= 10^6$ 1 \u0026lt;= time[i] \u0026lt;= 500 思路1 # 分析 记忆化搜索 # 选了，时间为正，花费为正；不选，时间为-1，花费为0 要求的是时间不为负时，花费最小值 再有，设f(i, j)为前i面墙在j的时间下，时间不为负花费最小的值，那么 $$ f(i, j) = min(f(i-1, j-1), f(i-1, j+time[i])+cost[i]) $$\n中间可能i和j相同的数会重复计算，加一个map进行保存，整体就是一个记忆化搜索的过程 代码 # 1func min(a, b int) int { 2\tif a \u0026gt; b { 3\treturn b 4\t} 5\treturn a 6} 7 8func paintWalls(cost []int, time []int) int { 9\tn := len(cost) 10 11\tmMap := make([]map[int]int, n) 12\tfor i := range mMap { 13\tmMap[i] = make(map[int]int) 14\t} 15\t// 选和不选代价和时间花费不一样，可以认为付费的时间和花费是正的，免费的时间是负的，花费为0 16\t// 最终求得是时间不为负数的花费最小值 17\tvar dfs func(i, t int) int 18\tdfs = func(i, t int) int { 19\tif t \u0026gt; i { 20\treturn 0 21\t} 22\tif i \u0026lt; 0 { 23\treturn math.MaxInt / 2 24\t} 25\tif mMap[i][t] \u0026gt; 0 { 26\treturn mMap[i][t] 27\t} 28\t// 为当前免费和当前不免费的最小值 29\tres := min(dfs(i-1, t-1), dfs(i-1, t+time[i])+cost[i]) 30\tmMap[i][t] = res 31\treturn res 32\t} 33\treturn dfs(n-1, 0) 34} 思路2 递推 # 分析 # $$ f_i(t) = min{f_{i-1}(t-1), f_{i-1}(t+time[i])+cost[i]} $$\n递推公式如上，第i（从0开始）面墙的t的最小值为后面的全部都免费即i+1-n，t最大值只需要取到t超过前面的墙数i+1即可，大于或等于的一定是0 初始值i=-1，没有墙的时候，[-n,0)设置很大的花费，[0,n]都是0 整体偏移n，那么t的最小值为i+1，最大值为i+1+n，初始值中[0,n)为很大的值，[n,2n]为0 每轮遍历n，遍历n轮，时间复杂度为 $O(n^2)$ ，空间复杂度为 $O(n)$ 代码 # 1func paintWalls1(cost []int, time []int) int { 2\tn := len(cost) 3\t// 偏移n 4\tf := make([]int, 2*n+1) 5\t// 偏移前可以认为是[-n,0)都是超级大 6\tfor i := 0; i \u0026lt; n; i++ { 7\tf[i] = math.MaxInt / 2 8\t} 9 10\tf1 := make([]int, 2*n+1) 11\tfor i := 0; i \u0026lt; n; i++ { 12\tf1, f = f, f1 13\tfor t := i + 1; t \u0026lt; n+i+1; t++ { 14\tf[t] = min(f1[t-1], f1[min(t+time[i], 2*n)]+cost[i]) 15\t} 16\t} 17\treturn f[n] 18} 思路3 再次简化 # 分析 # 思路就是把上面的j := i+1变成j := 0 转成代码后去推思想有点难搞，想不通，建议不要这样写，虽然看起来简单点，但是注释都不好写也就不好维护 代码 # 1func paintWalls2(cost []int, time []int) int { 2\tn := len(cost) 3\t// 偏移n 4\tf := make([]int, 2*n+1) 5\t// 偏移前可以认为是[-n,0)都是超级大 6\tfor i := 0; i \u0026lt; n; i++ { 7\tf[i] = math.MaxInt / 2 8\t} 9 10\tf1 := make([]int, 2*n+1) 11\tfor i := 0; i \u0026lt; n; i++ { 12\tf1, f = f, f1 13\tfLen := 2*n + 1 - i - 1 14\tf = f[:fLen] 15\tfor j := range f[:n] { 16\tf[j] = min(f1[j], f1[min(j+1+time[i], fLen-1)]+cost[i]) 17\t} 18\t} 19\treturn f[0] 20} "},{"id":176,"href":"/docs/leetcode/simple/leetcode2859/","title":"2859. Sum of Values at Indices With K Set Bits","section":"简单","content":" 题目 # You are given a 0-indexed integer array nums and an integer k.\nReturn an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.\nThe set bits in an integer are the 1\u0026rsquo;s present when it is written in binary.\nFor example, the binary representation of 21 is 10101, which has 3 set bits. Example 1:\nInput: nums = [5,10,1,5,2], k = 1 Output: 13 Explanation: The binary representation of the indices are: 0 = 0002 1 = 0012 2 = 0102 3 = 0112 4 = 1002 Indices 1, 2, and 4 have k = 1 set bits in their binary representation. Hence, the answer is nums[1] + nums[2] + nums[4] = 13. Example 2:\nInput: nums = [4,3,2,1], k = 2 Output: 1 Explanation: The binary representation of the indices are: 0 = 002 1 = 012 2 = 102 3 = 112 Only index 3 has k = 2 set bits in its binary representation. Hence, the answer is nums[3] = 1. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 $1 \u0026lt;= nums[i] \u0026lt;= 10^5$ 0 \u0026lt;= k \u0026lt;= 10 思路1 找下标的1数量即可 # 分析 # 一个一个找，找到就加一起，使用官方库 代码 # 1func sumIndicesWithKSetBits(nums []int, k int) int { 2\tres := 0 3\tfor i, x := range nums { 4\tif bits.OnesCount(uint(i)) == k { 5\tres += x 6\t} 7\t} 8\treturn res 9} "},{"id":177,"href":"/docs/leetcode/simple/leetcode2860/","title":"2860. Happy Students","section":"简单","content":" 题目 # You are given a 0-indexed integer array nums of length n where n is the total number of students in the class. The class teacher tries to select a group of students so that all the students remain happy.\nThe ith student will become happy if one of these two conditions is met:\nThe student is selected and the total number of selected students is strictly greater than nums[i]. The student is not selected and the total number of selected students is strictly less than nums[i]. Return the number of ways to select a group of students so that everyone remains happy.\nExample 1:\nInput: nums = [1,1] Output: 2 Explanation: The two possible ways are: The class teacher selects no student. The class teacher selects both students to form the group. If the class teacher selects just one student to form a group then the both students will not be happy. Therefore, there are only two possible ways. Example 2:\nInput: nums = [6,0,3,3,6,7,2,7] Output: 3 Explanation: The three possible ways are: The class teacher selects the student with index = 1 to form the group. The class teacher selects the students with index = 1, 2, 3, 6 to form the group. The class teacher selects all the students to form the group. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ 0 \u0026lt;= nums[i] \u0026lt; nums.length 思路1 排序遍历找点 # 分析 # 选一个下标，大于小于此下标所有的数，小于大于此下标的所有数，那不就是要求数组递增去找 先排序，再遍历 代码 # 1func countWays(nums []int) int { 2\tsort.Ints(nums) 3\tres := 0 4\tn := len(nums) 5\tif nums[0] \u0026gt; 0 { 6\tres++ 7\t} 8\tfor i, x := range nums[:n-1] { 9\t// 前i+1个学生被选中 10\tif i+1 \u0026gt; x \u0026amp;\u0026amp; i+1 \u0026lt; nums[i+1] { 11\tres++ 12\t} 13\t} 14\treturn res + 1 15} "},{"id":178,"href":"/docs/leetcode/competition-20230611/zs-4/","title":"6473. Maximum Sum Queries","section":"LeetCode刷题思路总结","content":" 题目 # You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi].\nFor the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 \u0026lt;= j \u0026lt; n), where nums1[j] \u0026gt;= xi and nums2[j] \u0026gt;= yi, or -1 if there is no j satisfying the constraints.\nReturn an array answer where answer[i] is the answer to the ith query.\nExample 1:\nInput: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]] Output: [6,10,7] Explanation: For the 1st query xi = 4 and yi = 1, we can select index j = 0 since nums1[j] \u0026gt;= 4 and nums2[j] \u0026gt;= 1. The sum nums1[j] + nums2[j] is 6, and we can show that 6 is the maximum we can obtain. For the 2nd query xi = 1 and yi = 3, we can select index j = 2 since nums1[j] \u0026gt;= 1 and nums2[j] \u0026gt;= 3. The sum nums1[j] + nums2[j] is 10, and we can show that 10 is the maximum we can obtain. For the 3rd query xi = 2 and yi = 5, we can select index j = 3 since nums1[j] \u0026gt;= 2 and nums2[j] \u0026gt;= 5. The sum nums1[j] + nums2[j] is 7, and we can show that 7 is the maximum we can obtain. Therefore, we return [6,10,7]. Example 2:\nInput: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]] Output: [9,9,9] Explanation: For this example, we can use index j = 2 for all the queries since it satisfies the constraints for each query. Example 3:\nInput: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]] Output: [-1] Explanation: There is one query in this example with xi = 3 and yi = 3. For every index, j, either nums1[j] \u0026lt; xi or nums2[j] \u0026lt; yi. Hence, there is no solution. Constraints:\nnums1.length == nums2.length n == nums1.length $1 \u0026lt;= n \u0026lt;= 10^5$ $1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10^9$ $1 \u0026lt;= queries.length \u0026lt;= 10^5$ queries[i].length == 2 xi == queries[i][1] yi == queries[i][2] $1 \u0026lt;= xi, yi \u0026lt;= 10^9$ 思路1 降维+分类讨论+单调栈 # 分析 # 三个数要比较，降维为两个数，先对x排序，查询的x也同样排序 那么对于某个query，一定有一组数据x满足条件，就只需要考虑y和sum了 维护一个列表，对于要入列表的元素 如果y比列表所有的都大，sum大于等于某个元素，这个元素不需要了，因为x肯定满足的情况下，y更大且sum较大，肯定更加能满足query 如果y比列表所有的都大，sum小，放后面，先看sum较大的满不满足 如果y在列表的中间范围，那么一定有一个x大于等于它，y也大于等于它，sum肯定大于等于它，这个就没必要判断了 如果y比列表中所有的都小，同上 所以只需要插入y比列表所有都大的就行了，并且sum较小还放后面，sum较大就只剩一个，最终列表就是sum从大到小，y从小到大 查找时直接二分找y就好了 看起来这个列表就是单调栈（栈底sum最大，栈顶y最大），只需要对比栈顶元素即可 代码 # 1func maximumSumQueries(nums1 []int, nums2 []int, queries [][]int) []int { 2\tn := len(nums1) 3\ttype pair struct{ x, y int } 4\tpairs := make([]pair, n) 5\tfor i := range nums1 { 6\tpairs[i] = pair{ 7\tx: nums1[i], 8\ty: nums2[i], 9\t} 10\t} 11\tsort.Slice(pairs, func(i, j int) bool { 12\treturn pairs[i].x \u0026gt; pairs[j].x 13\t}) 14 15\t// 把索引放到第三位，这样动了queries不影响答案的结果 16\tfor i := range queries { 17\tqueries[i] = append(queries[i], i) 18\t} 19\tsort.Slice(queries, func(i, j int) bool { 20\treturn queries[i][0] \u0026gt; queries[j][0] 21\t}) 22 23\tvar st []pair 24\tres := make([]int, len(queries)) 25\ti := 0 // pairs的索引 26\tfor _, v := range queries { 27\tx, y, index := v[0], v[1], v[2] 28\tfor ; i \u0026lt; n \u0026amp;\u0026amp; pairs[i].x \u0026gt;= x; i++ { 29\tp := pairs[i] 30\tif len(st) == 0 { 31\tst = []pair{p} 32\tcontinue 33\t} 34\t// 比最大的y大，才可以入栈 35\tif p.y \u0026lt;= st[len(st)-1].y { 36\tcontinue 37\t} 38\t// 从栈顶向栈底遍历，sum小于等于y的都不要了 39\tfor i := len(st) - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; p.x+p.y \u0026gt;= st[i].x+st[i].y; i-- { 40\tst = st[:i] 41\t} 42\tst = append(st, p) 43\t} 44 45\t// 二分在栈内找第一个y大于等于query的即可 46\ti := sort.Search(len(st), func(i int) bool { 47\treturn st[i].y \u0026gt;= y 48\t}) 49\tif i == len(st) { 50\tres[index] = -1 51\t} else { 52\tres[index] = st[i].x + st[i].y 53\t} 54\t} 55\treturn res 56} 思路2 降维+区间最值（线段树） # 分析 # 降维是肯定的，这次只排序nums，对x从大到小排序 然后遍历一边对y进行处理，当y小于等于前面最大的y，那么肯定有一个x比它大，y也比它大，sum更比它大，这个就没有价值，不要了 然后就得到一个x从大到小，y从小到大的数组 下面对query的查询，就能查到一个区间[a, b]，问题转化成区间最大值，区间最大值使用线段树实现 "},{"id":179,"href":"/docs/leetcode/competition-20230702/zs-1/","title":"6909. Longest Even Odd Subarray With Threshold","section":"LeetCode刷题思路总结","content":" 题目 # You are given a 0-indexed integer array nums and an integer threshold.\nFind the length of the longest subarray of nums starting at index l and ending at index r (0 \u0026lt;= l \u0026lt;= r \u0026lt; nums.length) that satisfies the following conditions:\nnums[l] % 2 == 0 For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2 For all indices i in the range [l, r], nums[i] \u0026lt;= threshold Return an integer denoting the length of the longest such subarray.\nNote: A subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [3,2,5,4], threshold = 5 Output: 3 Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 3 =\u0026gt; [2,5,4]. This subarray satisfies the conditions. Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length. Example 2:\nInput: nums = [1,2], threshold = 2 Output: 1 Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 1 =\u0026gt; [2]. It satisfies all the conditions and we can show that 1 is the maximum possible achievable length. Example 3:\nInput: nums = [2,3,4,5], threshold = 4 Output: 3 Explanation: In this example, we can select the subarray that starts at l = 0 and ends at r = 2 =\u0026gt; [2,3,4]. It satisfies all the conditions. Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100 1 \u0026lt;= threshold \u0026lt;= 100 思路1 枚举左端点 # 分析 # 不难想出，每个从偶数开始的奇偶交替的子数组之间是不相邻的 那么遍历左端点，是偶数就开始找符合条件的最长子数组。找到末尾后，下一个左端点直接从此子数组后一位开始即可 代码 # 1func longestAlternatingSubarray(nums []int, threshold int) int { 2\tn := len(nums) 3\tres := 0 4\t// 枚举左端点 5\tfor l := 0; l \u0026lt; n \u0026amp;\u0026amp; n-l \u0026gt; res; l++ { 6\tif nums[l]%2 != 0 || nums[l] \u0026gt; threshold { 7\tcontinue 8\t} 9 10\tr := l + 1 11\tfor t := 1; r \u0026lt; n \u0026amp;\u0026amp; nums[r] \u0026lt;= threshold \u0026amp;\u0026amp; nums[r]%2 == t; r, t = r+1, t^1 { 12\t} 13\tif r-l \u0026gt; res { 14\tres = r - l 15\t} 16\tl = r - 1 17\t} 18\treturn res 19} "},{"id":180,"href":"/docs/leetcode/competition-20230702/zs-3/","title":"6911. Continuous Subarrays","section":"LeetCode刷题思路总结","content":" 题目 # You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:\nLet i, i + 1, \u0026hellip;, j be the indices in the subarray. Then, for each pair of indices i \u0026lt;= i1, i2 \u0026lt;= j, 0 \u0026lt;= |nums[i1] - nums[i2]| \u0026lt;= 2. Return the total number of continuous subarrays.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [5,4,2,4] Output: 8 Explanation: Continuous subarray of size 1: [5], [4], [2], [4]. Continuous subarray of size 2: [5,4], [4,2], [2,4]. Continuous subarray of size 3: [4,2,4]. Thereare no subarrys of size 4. Total continuous subarrays = 4 + 3 + 1 = 8. It can be shown that there are no more continuous subarrays. Example 2:\nInput: nums = [1,2,3] Output: 6 Explanation: Continuous subarray of size 1: [1], [2], [3]. Continuous subarray of size 2: [1,2], [2,3]. Continuous subarray of size 3: [1,2,3]. Total continuous subarrays = 3 + 2 + 1 = 6. Constraints:\n$1 \u0026lt;= nums.length \u0026lt;= 10^5$ $1 \u0026lt;= nums[i] \u0026lt;= 10^9$ 思路1 枚举左端点 # 分析 # 直接枚举左端点，找到最长的一个符合条件的子数组，然后以此点为起点的所有子数组都满足 然后考虑此左端点后一位，以其为左端点的当前已经满足的都满足，只需要从右端点继续找，就很像一个滑动窗口 每次窗口滑动完，加上窗口长度即可 窗口内使用一个map记录所有的数字出现的次数，窗口左端点右移时，将此数从map中移除，每轮循环重新找窗口内的最大值和最小值，窗口右端点的移动只要满足最大和最小差值小于等于2即可 代码 # 1func continuousSubarrays(nums []int) int64 { 2\t// 枚举左端点，找到不间断的子数组 3\tn := len(nums) 4\tvar res int64 5\tintMap := make(map[int]int) 6\tr := 0 7\tfor l, x := range nums { 8\tmin, max := x, x 9\tfor k := range intMap { 10\tif k \u0026lt; min { 11\tmin = k 12\t} 13\tif k \u0026gt; max { 14\tmax = k 15\t} 16\t} 17 18\t// 找窗口右端点，从上一个右端点向右遍历 19\tfor ; r \u0026lt; n; r++ { 20\tv := nums[r] 21\tif v \u0026lt; min { 22\tmin = v 23\t} 24\tif v \u0026gt; max { 25\tmax = v 26\t} 27\tif max-min \u0026gt; 2 { 28\tbreak 29\t} 30\tintMap[v]++ 31\t} 32\tres += int64(r - l) 33\tif intMap[x]--; intMap[x] == 0 { 34\tdelete(intMap, x) 35\t} 36\t} 37\treturn res 38} "},{"id":181,"href":"/docs/leetcode/competition-20230702/zs-2/","title":"6916. Prime Pairs With Target Sum","section":"LeetCode刷题思路总结","content":" 题目 # You are given an integer n. We say that two integers x and y form a prime number pair if:\n1 \u0026lt;= x \u0026lt;= y \u0026lt;= n x + y == n x and y are prime numbers Return the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.\nNote: A prime number is a natural number greater than 1 with only two factors, itself and 1.\nExample 1:\nInput: n = 10 Output: [[3,7],[5,5]] Explanation: In this example, there are two prime pairs that satisfy the criteria. These pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement. Example 2:\nInput: n = 2 Output: [] Explanation: We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. Constraints:\n$1 \u0026lt;= n \u0026lt;= 10^6$ 思路1 预处理所有质数 # 分析 # 预处理找到所有的质数，然后直接从第一个质数到小于n/2+1的最大的质数一个一个试即可 代码 # 1func oulerPrimes(mx int, primes *[]int) { 2\tflag := make([]bool, mx+1) // 标记数有没有被筛掉，false就是没有 3\tfor i := 2; i \u0026lt; mx+1; i++ { 4\tif !flag[i] { 5\t// 数没有被比自己小的数筛掉，就代表是质数 6\t*primes = append(*primes, i) 7\t} 8\tfor _, v := range *primes { 9\tif i*v \u0026gt; mx { 10\tbreak 11\t} 12\t// 每一个数都作为因子乘以比自己小的素数筛掉后面的数 13\tflag[i*v] = true 14\tif i%v == 0 { 15\t// 减少时间复杂度的关键算法 16\t// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除 17\t// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv 18\t// 那么存在一个数 i \u0026lt; km \u0026lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度 19\tbreak 20\t} 21\t} 22\t} 23} 24 25var allPrimes []int 26 27func init() { 28\tallPrimes = make([]int, 0, 78498) 29\toulerPrimes(1e6, \u0026amp;allPrimes) 30} 31 32func findPrimePairs(n int) [][]int { 33\tup := sort.Search(len(allPrimes), func(i int) bool { 34\treturn allPrimes[i] \u0026gt;= n 35\t}) 36\tvar res [][]int 37\tfor i := 0; i \u0026lt; up \u0026amp;\u0026amp; allPrimes[i] \u0026lt; n/2+1; i++ { 38\tx := allPrimes[i] 39\ty := n - x 40\tj := sort.Search(up, func(i int) bool { 41\treturn allPrimes[i] \u0026gt;= y 42\t}) 43\tif j \u0026lt; up \u0026amp;\u0026amp; allPrimes[j] == y { 44\tres = append(res, []int{x, y}) 45\t} 46\t} 47\treturn res 48} "},{"id":182,"href":"/posts/goisforlovers/","title":"(Hu)go Template Primer","section":"Blog","content":"Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.\nThis document is a brief primer on using Go templates. The Go docs provide more details.\nIntroduction to Go Templates # Go templates provide an extremely simple template language. It adheres to the belief that only the most basic of logic belongs in the template or view layer. One consequence of this simplicity is that Go templates parse very quickly.\nA unique characteristic of Go templates is they are content aware. Variables and content will be sanitized depending on the context of where they are used. More details can be found in the Go docs.\nBasic Syntax # Golang templates are HTML files with the addition of variables and functions.\nGo variables and functions are accessible within {{ }}\nAccessing a predefined variable \u0026ldquo;foo\u0026rdquo;:\n{{ foo }} Parameters are separated using spaces\nCalling the add function with input of 1, 2:\n{{ add 1 2 }} Methods and fields are accessed via dot notation\nAccessing the Page Parameter \u0026ldquo;bar\u0026rdquo;\n{{ .Params.bar }} Parentheses can be used to group items together\n{{ if or (isset .Params \u0026quot;alt\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;) }} Caption {{ end }} Variables # Each Go template has a struct (object) made available to it. In hugo each template is passed either a page or a node struct depending on which type of page you are rendering. More details are available on the variables page.\nA variable is accessed by referencing the variable name.\n\u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; Variables can also be defined and referenced.\n{{ $address := \u0026quot;123 Main St.\u0026quot;}} {{ $address }} Functions # Go template ship with a few functions which provide basic functionality. The Go template system also provides a mechanism for applications to extend the available functions with their own. Hugo template functions provide some additional functionality we believe are useful for building websites. Functions are called by using their name followed by the required parameters separated by spaces. Template functions cannot be added without recompiling hugo.\nExample:\n{{ add 1 2 }} Includes # When including another template you will pass to it the data it will be able to access. To pass along the current context please remember to include a trailing dot. The templates location will always be starting at the /layout/ directory within Hugo.\nExample:\n{{ template \u0026quot;chrome/header.html\u0026quot; . }} Logic # Go templates provide the most basic iteration and conditional logic.\nIteration # Just like in Go, the Go templates make heavy use of range to iterate over a map, array or slice. The following are different examples of how to use range.\nExample 1: Using Context\n{{ range array }} {{ . }} {{ end }} Example 2: Declaring value variable name\n{{range $element := array}} {{ $element }} {{ end }} Example 2: Declaring key and value variable name\n{{range $index, $element := array}} {{ $index }} {{ $element }} {{ end }} Conditionals # If, else, with, or, \u0026amp; and provide the framework for handling conditional logic in Go Templates. Like range, each statement is closed with end.\nGo Templates treat the following values as false:\nfalse 0 any array, slice, map, or string of length zero Example 1: If\n{{ if isset .Params \u0026quot;title\u0026quot; }}\u0026lt;h4\u0026gt;{{ index .Params \u0026quot;title\u0026quot; }}\u0026lt;/h4\u0026gt;{{ end }} Example 2: If -\u0026gt; Else\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{else}} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }} Example 3: And \u0026amp; Or\n{{ if and (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Example 4: With\nAn alternative way of writing \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent.\nThe first example above could be simplified as:\n{{ with .Params.title }}\u0026lt;h4\u0026gt;{{ . }}\u0026lt;/h4\u0026gt;{{ end }} Example 5: If -\u0026gt; Else If\n{{ if isset .Params \u0026quot;alt\u0026quot; }} {{ index .Params \u0026quot;alt\u0026quot; }} {{ else if isset .Params \u0026quot;caption\u0026quot; }} {{ index .Params \u0026quot;caption\u0026quot; }} {{ end }} Pipes # One of the most powerful components of Go templates is the ability to stack actions one after another. This is done by using pipes. Borrowed from unix pipes, the concept is simple, each pipeline\u0026rsquo;s output becomes the input of the following pipe.\nBecause of the very simple syntax of Go templates, the pipe is essential to being able to chain together function calls. One limitation of the pipes is that they only can work with a single value and that value becomes the last parameter of the next pipeline.\nA few simple examples should help convey how to use the pipe.\nExample 1 :\n{{ if eq 1 1 }} Same {{ end }} is the same as\n{{ eq 1 1 | if }} Same {{ end }} It does look odd to place the if at the end, but it does provide a good illustration of how to use the pipes.\nExample 2 :\n{{ index .Params \u0026quot;disqus_url\u0026quot; | html }} Access the page parameter called \u0026ldquo;disqus_url\u0026rdquo; and escape the HTML.\nExample 3 :\n{{ if or (or (isset .Params \u0026quot;title\u0026quot;) (isset .Params \u0026quot;caption\u0026quot;)) (isset .Params \u0026quot;attr\u0026quot;)}} Stuff Here {{ end }} Could be rewritten as\n{{ isset .Params \u0026quot;caption\u0026quot; | or isset .Params \u0026quot;title\u0026quot; | or isset .Params \u0026quot;attr\u0026quot; | if }} Stuff Here {{ end }} Context (aka. the dot) # The most easily overlooked concept to understand about Go templates is that {{ . }} always refers to the current context. In the top level of your template this will be the data set made available to it. Inside of a iteration it will have the value of the current item. When inside of a loop the context has changed. . will no longer refer to the data available to the entire page. If you need to access this from within the loop you will likely want to set it to a variable instead of depending on the context.\nExample:\n{{ $title := .Site.Title }} {{ range .Params.tags }} \u0026lt;li\u0026gt; \u0026lt;a href=\u0026quot;{{ $baseurl }}/tags/{{ . | urlize }}\u0026quot;\u0026gt;{{ . }}\u0026lt;/a\u0026gt; - {{ $title }} \u0026lt;/li\u0026gt; {{ end }} Notice how once we have entered the loop the value of {{ . }} has changed. We have defined a variable outside of the loop so we have access to it from within the loop.\nHugo Parameters # Hugo provides the option of passing values to the template language through the site configuration (for sitewide values), or through the meta data of each specific piece of content. You can define any values of any type (supported by your front matter/config format) and use them however you want to inside of your templates.\nUsing Content (page) Parameters # In each piece of content you can provide variables to be used by the templates. This happens in the front matter.\nAn example of this is used in this documentation site. Most of the pages benefit from having the table of contents provided. Sometimes the TOC just doesn\u0026rsquo;t make a lot of sense. We\u0026rsquo;ve defined a variable in our front matter of some pages to turn off the TOC from being displayed.\nHere is the example front matter:\n--- title: \u0026#34;Permalinks\u0026#34; date: \u0026#34;2013-11-18\u0026#34; aliases: - \u0026#34;/doc/permalinks/\u0026#34; groups: [\u0026#34;extras\u0026#34;] groups_weight: 30 notoc: true --- Here is the corresponding code inside of the template:\n{{ if not .Params.notoc }} \u0026lt;div id=\u0026quot;toc\u0026quot; class=\u0026quot;well col-md-4 col-sm-6\u0026quot;\u0026gt; {{ .TableOfContents }} \u0026lt;/div\u0026gt; {{ end }} Using Site (config) Parameters # In your top-level configuration file (eg, config.yaml) you can define site parameters, which are values which will be available to you in chrome.\nFor instance, you might declare:\n1params: 2 CopyrightHTML: \u0026#34;Copyright \u0026amp;#xA9; 2013 John Doe. All Rights Reserved.\u0026#34; 3 TwitterUser: \u0026#34;spf13\u0026#34; 4 SidebarRecentLimit: 5 Within a footer layout, you might then declare a \u0026lt;footer\u0026gt; which is only provided if the CopyrightHTML parameter is provided, and if it is given, you would declare it to be HTML-safe, so that the HTML entity is not escaped again. This would let you easily update just your top-level config file each January 1st, instead of hunting through your templates.\n{{if .Site.Params.CopyrightHTML}}\u0026lt;footer\u0026gt; \u0026lt;div class=\u0026#34;text-center\u0026#34;\u0026gt;{{.Site.Params.CopyrightHTML | safeHtml}}\u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt;{{end}} An alternative way of writing the \u0026ldquo;if\u0026rdquo; and then referencing the same value is to use \u0026ldquo;with\u0026rdquo; instead. With rebinds the context . within its scope, and skips the block if the variable is absent:\n{{with .Site.Params.TwitterUser}}\u0026lt;span class=\u0026#34;twitter\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://twitter.com/{{.}}\u0026#34; rel=\u0026#34;author\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/twitter.png\u0026#34; width=\u0026#34;48\u0026#34; height=\u0026#34;48\u0026#34; title=\u0026#34;Twitter: {{.}}\u0026#34; alt=\u0026#34;Twitter\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/span\u0026gt;{{end}} Finally, if you want to pull \u0026ldquo;magic constants\u0026rdquo; out of your layouts, you can do so, such as in this example:\n\u0026lt;nav class=\u0026#34;recent\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Recent Posts\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{.RelPermalink}}\u0026#34;\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{end}}\u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; "},{"id":183,"href":"/posts/hugoisforlovers/","title":"Getting Started with Hugo","section":"Blog","content":" Step 1. Install Hugo # Go to Hugo releases and download the appropriate version for your OS and architecture.\nSave it somewhere specific as we will be using it in the next step.\nMore complete instructions are available at Install Hugo\nStep 2. Build the Docs # Hugo has its own example site which happens to also be the documentation site you are reading right now.\nFollow the following steps:\nClone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313 Corresponding pseudo commands:\ngit clone https://github.com/spf13/hugo cd hugo /path/to/where/you/installed/hugo server --source=./docs \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Press ctrl+c to stop Once you\u0026rsquo;ve gotten here, follow along the rest of this page on your local build.\nStep 3. Change the docs site # Stop the Hugo process by hitting Ctrl+C.\nNow we are going to run hugo again, but this time with hugo in watch mode.\n/path/to/hugo/from/step/1/hugo server --source=./docs --watch \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 27 ms \u0026gt; Web Server is available at http://localhost:1313 \u0026gt; Watching for changes in /Users/spf13/Code/hugo/docs/content \u0026gt; Press ctrl+c to stop Open your favorite editor and change one of the source content pages. How about changing this very file to fix the typo. How about changing this very file to fix the typo.\nContent files are found in docs/content/. Unless otherwise specified, files are located at the same relative location as the url, in our case docs/content/overview/quickstart.md.\nChange and save this file.. Notice what happened in your terminal.\n\u0026gt; Change detected, rebuilding site \u0026gt; 29 pages created \u0026gt; 0 tags index created \u0026gt; in 26 ms Refresh the browser and observe that the typo is now fixed.\nNotice how quick that was. Try to refresh the site before it\u0026rsquo;s finished building. I double dare you. Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.\nStep 4. Have fun # The best way to learn something is to play with it.\n"},{"id":184,"href":"/docs/leetcode/hidden/","title":"Hidden","section":"LeetCode刷题思路总结","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":185,"href":"/docs/linux/linux-kernel/drivers/net/igb/","title":"Igb","section":"net/ 网卡驱动部分","content":" 一、igb操作结构体 # 1// drivers/net/ethernet/intel/igb/igb_main.c 2static const struct net_device_ops igb_netdev_ops = { 3\t.ndo_open\t= igb_open, 4\t.ndo_stop\t= igb_close, 5\t.ndo_start_xmit\t= igb_xmit_frame, 6\t.ndo_get_stats64\t= igb_get_stats64, 7\t.ndo_set_rx_mode\t= igb_set_rx_mode, 8\t.ndo_set_mac_address\t= igb_set_mac, 9\t.ndo_change_mtu\t= igb_change_mtu, 10\t.ndo_eth_ioctl\t= igb_ioctl, 11\t.ndo_tx_timeout\t= igb_tx_timeout, 12\t.ndo_validate_addr\t= eth_validate_addr, 13\t.ndo_vlan_rx_add_vid\t= igb_vlan_rx_add_vid, 14\t.ndo_vlan_rx_kill_vid\t= igb_vlan_rx_kill_vid, 15\t.ndo_set_vf_mac\t= igb_ndo_set_vf_mac, 16\t.ndo_set_vf_vlan\t= igb_ndo_set_vf_vlan, 17\t.ndo_set_vf_rate\t= igb_ndo_set_vf_bw, 18\t.ndo_set_vf_spoofchk\t= igb_ndo_set_vf_spoofchk, 19\t.ndo_set_vf_trust\t= igb_ndo_set_vf_trust, 20\t.ndo_get_vf_config\t= igb_ndo_get_vf_config, 21\t.ndo_fix_features\t= igb_fix_features, 22\t.ndo_set_features\t= igb_set_features, 23\t.ndo_fdb_add\t= igb_ndo_fdb_add, 24\t.ndo_features_check\t= igb_features_check, 25\t.ndo_setup_tc\t= igb_setup_tc, 26\t.ndo_bpf\t= igb_xdp, 27\t.ndo_xdp_xmit\t= igb_xdp_xmit, 28}; 二、启动过程 # 1. .ndo_open = igb_open # 1// drivers/net/ethernet/intel/igb/igb_main.c 2int igb_open(struct net_device *netdev) 3{ 4\treturn __igb_open(netdev, false); 5} open里面最重要的就是这个注册硬中断 1// drivers/net/ethernet/intel/igb/igb_main.c 2/** 3 * __igb_open - Called when a network interface is made active 4 * @netdev: network interface device structure 5 * @resuming: indicates whether we are in a resume call 6 * 7 * Returns 0 on success, negative value on failure 8 * 9 * The open entry point is called when a network interface is made 10 * active by the system (IFF_UP). At this point all resources needed 11 * for transmit and receive operations are allocated, the interrupt 12 * handler is registered with the OS, the watchdog timer is started, 13 * and the stack is notified that the interface is ready. 14 **/ 15static int __igb_open(struct net_device *netdev, bool resuming) 16{ 17 ... 18 // 注册中断 19\terr = igb_request_irq(adapter); 20\tif (err) 21\tgoto err_req_irq; 22 ... 23} 调用igb_request_msix注册中断 1// drivers/net/ethernet/intel/igb/igb_main.c 2/** 3 * igb_request_irq - initialize interrupts 4 * @adapter: board private structure to initialize 5 * 6 * Attempts to configure interrupts using the best available 7 * capabilities of the hardware and kernel. 8 **/ 9static int igb_request_irq(struct igb_adapter *adapter) 10{ 11 ... 12 if (adapter-\u0026gt;flags \u0026amp; IGB_FLAG_HAS_MSIX) { 13\terr = igb_request_msix(adapter); 14 ... 15 } 16 ... 17} 注册igb_msix_ring处理函数 1// drivers/net/ethernet/intel/igb/igb_main.c 2/** 3 * igb_request_msix - Initialize MSI-X interrupts 4 * @adapter: board private structure to initialize 5 * 6 * igb_request_msix allocates MSI-X vectors and requests interrupts from the 7 * kernel. 8 **/ 9static int igb_request_msix(struct igb_adapter *adapter) 10{ 11 ... 12\tfor (i = 0; i \u0026lt; num_q_vectors; i++) { 13 ... 14\terr = request_irq(adapter-\u0026gt;msix_entries[vector].vector, 15\tigb_msix_ring, 0, q_vector-\u0026gt;name, 16\tq_vector); 17\tif (err) 18\tgoto err_free; 19\t} 20 ... 21} 在igb_msix_ring中就是设置软中断NET_RX_SOFTIRQ 1// drivers/net/ethernet/intel/igb/igb_main.c 2static irqreturn_t igb_msix_ring(int irq, void *data) 3{ 4\tstruct igb_q_vector *q_vector = data; 5 6\t/* Write the ITR value calculated from the previous interrupt. */ 7\tigb_write_itr(q_vector); 8 9\tnapi_schedule(\u0026amp;q_vector-\u0026gt;napi); 10 11\treturn IRQ_HANDLED; 12} 13 14// include/linux/netdevice.h 15/** 16 *\tnapi_schedule - schedule NAPI poll 17 *\t@n: NAPI context 18 * 19 * Schedule NAPI poll routine to be called if it is not already 20 * running. 21 */ 22static inline void napi_schedule(struct napi_struct *n) 23{ 24\tif (napi_schedule_prep(n)) 25\t__napi_schedule(n); 26} 27 28// net/core/dev.c 29/** 30 * __napi_schedule - schedule for receive 31 * @n: entry to schedule 32 * 33 * The entry\u0026#39;s receive function will be scheduled to run. 34 * Consider using __napi_schedule_irqoff() if hard irqs are masked. 35 */ 36void __napi_schedule(struct napi_struct *n) 37{ 38\tunsigned long flags; 39 40\tlocal_irq_save(flags); 41\t____napi_schedule(this_cpu_ptr(\u0026amp;softnet_data), n); 42\tlocal_irq_restore(flags); 43} 44EXPORT_SYMBOL(__napi_schedule); 45 46// net/core/dev.c 47/* Called with irq disabled */ 48static inline void ____napi_schedule(struct softnet_data *sd, 49\tstruct napi_struct *napi) 50{ 51\tstruct task_struct *thread; 52 53\tlockdep_assert_irqs_disabled(); 54 55\tif (test_bit(NAPI_STATE_THREADED, \u0026amp;napi-\u0026gt;state)) { 56\t/* Paired with smp_mb__before_atomic() in 57\t* napi_enable()/dev_set_threaded(). 58\t* Use READ_ONCE() to guarantee a complete 59\t* read on napi-\u0026gt;thread. Only call 60\t* wake_up_process() when it\u0026#39;s not NULL. 61\t*/ 62\tthread = READ_ONCE(napi-\u0026gt;thread); 63\tif (thread) { 64\t/* Avoid doing set_bit() if the thread is in 65\t* INTERRUPTIBLE state, cause napi_thread_wait() 66\t* makes sure to proceed with napi polling 67\t* if the thread is explicitly woken from here. 68\t*/ 69\tif (READ_ONCE(thread-\u0026gt;__state) != TASK_INTERRUPTIBLE) 70\tset_bit(NAPI_STATE_SCHED_THREADED, \u0026amp;napi-\u0026gt;state); 71\twake_up_process(thread); 72\treturn; 73\t} 74\t} 75 76\tlist_add_tail(\u0026amp;napi-\u0026gt;poll_list, \u0026amp;sd-\u0026gt;poll_list); 77 // 这里设置软中断NET_RX_SOFTIRQ 78\t__raise_softirq_irqoff(NET_RX_SOFTIRQ); 79} 2. 注册poll到napi # 1/** 2 * igb_alloc_q_vector - Allocate memory for a single interrupt vector 3 * @adapter: board private structure to initialize 4 * @v_count: q_vectors allocated on adapter, used for ring interleaving 5 * @v_idx: index of vector in adapter struct 6 * @txr_count: total number of Tx rings to allocate 7 * @txr_idx: index of first Tx ring to allocate 8 * @rxr_count: total number of Rx rings to allocate 9 * @rxr_idx: index of first Rx ring to allocate 10 * 11 * We allocate one q_vector. If allocation fails we return -ENOMEM. 12 **/ 13static int igb_alloc_q_vector(struct igb_adapter *adapter, 14\tint v_count, int v_idx, 15\tint txr_count, int txr_idx, 16\tint rxr_count, int rxr_idx) 17{ 18\t... 19\t/* initialize NAPI */ 20\tnetif_napi_add(adapter-\u0026gt;netdev, \u0026amp;q_vector-\u0026gt;napi, 21\tigb_poll, 64); 22\t... 23} 三、收包处理 # 内核软中断处理收包后会调用注册的poll函数，也就是这里的igb_poll 1// drivers/net/ethernet/intel/igb/igb_main.c 2/** 3 * igb_poll - NAPI Rx polling callback 4 * @napi: napi polling structure 5 * @budget: count of how many packets we should handle 6 **/ 7static int igb_poll(struct napi_struct *napi, int budget) 8{ 9\tstruct igb_q_vector *q_vector = container_of(napi, 10\tstruct igb_q_vector, 11\tnapi); 12\tbool clean_complete = true; 13\tint work_done = 0; 14 15#ifdef CONFIG_IGB_DCA 16\tif (q_vector-\u0026gt;adapter-\u0026gt;flags \u0026amp; IGB_FLAG_DCA_ENABLED) 17\tigb_update_dca(q_vector); 18#endif 19\tif (q_vector-\u0026gt;tx.ring) 20\tclean_complete = igb_clean_tx_irq(q_vector, budget); 21 22\tif (q_vector-\u0026gt;rx.ring) { 23\tint cleaned = igb_clean_rx_irq(q_vector, budget); 24 25\twork_done += cleaned; 26\tif (cleaned \u0026gt;= budget) 27\tclean_complete = false; 28\t} 29 30\t/* If all work not completed, return budget and keep polling */ 31\tif (!clean_complete) 32\treturn budget; 33 34\t/* Exit the polling mode, but don\u0026#39;t re-enable interrupts if stack might 35\t* poll us due to busy-polling 36\t*/ 37\tif (likely(napi_complete_done(napi, work_done))) 38\tigb_ring_irq_enable(q_vector); 39 40\treturn work_done; 41} 在igb_clean_rx_irq函数里面调用到napi_gro_receive 1// drivers/net/ethernet/intel/igb/igb_main.c 2static int igb_clean_rx_irq(struct igb_q_vector *q_vector, const int budget) 3{ 4\tstruct igb_adapter *adapter = q_vector-\u0026gt;adapter; 5\tstruct igb_ring *rx_ring = q_vector-\u0026gt;rx.ring; 6\tstruct sk_buff *skb = rx_ring-\u0026gt;skb; 7\tunsigned int total_bytes = 0, total_packets = 0; 8\tu16 cleaned_count = igb_desc_unused(rx_ring); 9\tunsigned int xdp_xmit = 0; 10\tstruct xdp_buff xdp; 11\tu32 frame_sz = 0; 12\tint rx_buf_pgcnt; 13 14\t/* Frame size depend on rx_ring setup when PAGE_SIZE=4K */ 15#if (PAGE_SIZE \u0026lt; 8192) 16\tframe_sz = igb_rx_frame_truesize(rx_ring, 0); 17#endif 18\txdp_init_buff(\u0026amp;xdp, frame_sz, \u0026amp;rx_ring-\u0026gt;xdp_rxq); 19 20\twhile (likely(total_packets \u0026lt; budget)) { 21\t... 22\tnapi_gro_receive(\u0026amp;q_vector-\u0026gt;napi, skb); 23 24\t/* reset skb pointer */ 25\tskb = NULL; 26 27\t/* update budget accounting */ 28\ttotal_packets++; 29\t} 30\t... 31} "},{"id":186,"href":"/docs/linux/linux-kernel/fs/inotify/","title":"Inotify","section":"/fs/ 文件部分","content":" 一、介绍 # 1. 提供的系统调用 # 1SYSCALL_DEFINE1(inotify_init1, int, flags) 2SYSCALL_DEFINE0(inotify_init) 3SYSCALL_DEFINE3(inotify_add_watch, int, fd, const char __user *, pathname, u32, mask) 4SYSCALL_DEFINE2(inotify_rm_watch, int, fd, __s32, wd) 2. 示例用法 # 1class FileMonitor final { 2public: 3 explicit FileMonitor(std::string path) : m_filePath(std::move(path)) {} 4 5 ~FileMonitor() { stop(); } 6 7 void start() { 8 stop(); 9 std::promise\u0026lt;void\u0026gt; p; 10 m_monitorFuture = std::make_shared\u0026lt;std::future\u0026lt;void\u0026gt;\u0026gt;(std::async(std::launch::async, [\u0026amp;p, this]() { 11 p.set_value(); 12 std::string tag = \u0026#34;file(\u0026#34; + m_filePath + \u0026#34;) monitor loop\u0026#34;; 13 LOGI(WHAT(\u0026#34;{} begin\u0026#34;, tag)); 14 15 { 16 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 17 // 设置为非阻塞方式 18 m_monitorFD = inotify_init1(IN_NONBLOCK); 19 if (m_monitorFD \u0026lt; 0) { 20 LOGE(WHAT(\u0026#34;{} failed\u0026#34;, tag), 21 REASON(\u0026#34;inotify_init failed, ec: {}\u0026#34;, 22 std::to_string(std::error_code(errno, std::system_category()))), 23 WILL(\u0026#34;exit thread and won\u0026#39;t watch file\u0026#34;)); 24 return; 25 } 26 } 27 28 // 添加文件监听的函数，返回false说明总的文件描述符被关闭 29 if (!addFileWatch()) { 30 LOGI(WHAT(\u0026#34;{}, stop monitor\u0026#34;, tag)); 31 return; 32 } 33 34 // 开始监听文件 35 while (true) { 36 char buf[sizeof(struct inotify_event) + m_filePath.size() + 1] = {0}; 37 ssize_t len; 38 { 39 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 40 if (m_monitorFD \u0026lt; 0 || m_watchFD \u0026lt; 0) { 41 // 这里说明外部关闭了监听fd，也就是析构了，退出就好 42 break; 43 } 44 // 非阻塞读取event事件 45 len = read(m_monitorFD, buf, sizeof(buf)); 46 } 47 if (len \u0026lt; 0) { 48 auto err = errno; 49 // 非阻塞的读不到事件返回EAGAIN，直接continue，其他的报错continue 50 if (err != EAGAIN) { 51 LOGW(WHAT(\u0026#34;{}, read get err\u0026#34;, tag), 52 REASON(\u0026#34;get error {}\u0026#34;, std::to_string(std::error_code(err, std::system_category()))), 53 WILL(\u0026#34;retry after 10 ms\u0026#34;)); 54 } 55 std::this_thread::sleep_for(std::chrono::milliseconds(10)); 56 continue; 57 } 58 59 if (len \u0026lt; sizeof(struct inotify_event)) { 60 LOGW(WHAT(\u0026#34;{}, read len error\u0026#34;, tag), REASON(\u0026#34;len {}, need {}\u0026#34;, len, sizeof(struct inotify_event)), 61 WILL(\u0026#34;retry after 10 ms\u0026#34;)); 62 std::this_thread::sleep_for(std::chrono::milliseconds(10)); 63 continue; 64 } 65 66 int index = 0; 67 bool isChanged = false; 68 // 这里怕读到多个事件，使用while处理 69 do { 70 auto event = reinterpret_cast\u0026lt;struct inotify_event *\u0026gt;(buf + index); 71 // index向后移动evnet和name的长度 72 index += sizeof(struct inotify_event) + event-\u0026gt;len; 73 LOGD(WHAT(\u0026#34;event wd {}, mask {}, cookie {}, len {}, name {}\u0026#34;, event-\u0026gt;wd, event-\u0026gt;mask, event-\u0026gt;cookie, 74 event-\u0026gt;len, event-\u0026gt;name)); 75 { 76 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 77 if (event-\u0026gt;wd != m_watchFD) { 78 continue; 79 } 80 } 81 // 老的句柄被移除后，这里read会有一次ignore 82 if (event-\u0026gt;mask \u0026amp; (IN_IGNORED)) { 83 continue; 84 } 85 86 // 到这里说明文件存在改动 87 isChanged = true; 88 89 // 这个文件被删除或重命名，需要重新进行添加 90 if (event-\u0026gt;mask \u0026amp; (IN_DELETE_SELF | IN_MOVE_SELF)) { 91 LOGI(WHAT(\u0026#34;{}, file {} was renamed or deleted, retry open\u0026#34;, tag, m_filePath)); 92 if (!addFileWatch()) { 93 LOGI(WHAT(\u0026#34;{}, stop monitor\u0026#34;, tag)); 94 return; 95 } 96 } 97 98 } while (index \u0026lt; len); 99 100 if (isChanged) { 101 // 文件发生变化 102 LOGI(WHAT(\u0026#34;{}, file change\u0026#34;, tag)); 103 notifyChangeCallback(); 104 } 105 } 106 107 LOGI(WHAT(\u0026#34;{} end\u0026#34;, tag)); 108 { 109 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 110 if (m_monitorFD \u0026gt;= 0) { 111 if (m_watchFD \u0026gt;= 0) { 112 inotify_rm_watch(m_monitorFD, m_watchFD); 113 m_watchFD = -1; 114 } 115 close(m_monitorFD); 116 m_monitorFD = -1; 117 } 118 } 119 })); 120 p.get_future().wait(); 121 } 122 123 void stop() { 124 if (m_monitorFuture == nullptr || !m_monitorFuture-\u0026gt;valid()) { 125 return; 126 } 127 do { 128 // 这里将总的fd关闭，将线程从read阻塞释放出来，然后将watch移除 129 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 130 if (m_monitorFD \u0026gt;= 0) { 131 if (m_watchFD \u0026gt;= 0) { 132 inotify_rm_watch(m_monitorFD, m_watchFD); 133 m_watchFD = -1; 134 } 135 close(m_monitorFD); 136 m_monitorFD = -1; 137 } 138 // 可能还没打开就关闭了，这里确保一下future是正常的，防止死锁 139 } while (m_monitorFuture-\u0026gt;wait_for(std::chrono::milliseconds(1)) != std::future_status::ready); 140 m_monitorFuture = nullptr; 141 } 142 143 /** 144 * @brief 是否正在监控 145 * @return 146 */ 147 bool isRunning() { return m_monitorFuture != nullptr; } 148 149 /** 150 * @brief 添加文件变化回调 151 * @param callback 152 */ 153 void registerChangeCallback(const std::function\u0026lt;void()\u0026gt; \u0026amp;callback) { 154 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_callbackMutex); 155 m_callbacks.emplace_back(callback); 156 } 157 158 /** 159 * @brief 移除文件变化回调 160 * @param callback 161 */ 162 void unregisterChangeCallback(std::function\u0026lt;void()\u0026gt; callback) { 163 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_callbackMutex); 164 for (auto it = m_callbacks.begin(); it != m_callbacks.end(); ++it) { 165 if (it-\u0026gt;target\u0026lt;void *\u0026gt;() == callback.target\u0026lt;void *\u0026gt;()) { 166 m_callbacks.erase(it); 167 break; 168 } 169 } 170 } 171 172private: 173 std::string m_filePath; 174 std::shared_ptr\u0026lt;std::future\u0026lt;void\u0026gt;\u0026gt; m_monitorFuture; 175 std::mutex m_fdMutex; 176 int m_monitorFD = -1; // inotify的句柄 177 int m_watchFD = -1; // 被添加的文件句柄 178 std::mutex m_callbackMutex; // 对回调函数加锁 179 std::vector\u0026lt;std::function\u0026lt;void()\u0026gt;\u0026gt; m_callbacks; // 回调函数 180 181 /** 182 * @brief 通知变更的观察者，此文件变更 183 */ 184 void notifyChangeCallback() { 185 std::vector\u0026lt;std::function\u0026lt;void()\u0026gt;\u0026gt; callbacks; 186 { 187 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_callbackMutex); 188 callbacks = m_callbacks; 189 } 190 for (auto \u0026amp;callback : callbacks) { 191 callback(); 192 } 193 } 194 195 /** 196 * @brief 添加一个文件到列表中 197 * 198 * @return 添加成功还是失败 199 */ 200 bool addFileWatch() { 201 std::string tag = \u0026#34;add file(\u0026#34; + m_filePath + \u0026#34;) to watch\u0026#34;; 202 { 203 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 204 if (m_monitorFD \u0026lt; 0) { 205 return false; 206 } 207 // 关闭上一次的句柄 208 if (m_watchFD \u0026gt;= 0) { 209 LOGI(WHAT(\u0026#34;{}, remove watch fd {}\u0026#34;, tag, m_watchFD)); 210 inotify_rm_watch(m_monitorFD, m_watchFD); 211 m_watchFD = -1; 212 } 213 } 214 uint32_t failedCount = 0; 215 // 最大重试32位最大值的次数 216 while (++failedCount) { 217 // 重新加锁判断是否monitor已经被关了 218 { 219 std::lock_guard\u0026lt;std::mutex\u0026gt; lock(m_fdMutex); 220 if (m_monitorFD \u0026lt; 0) { 221 // 这里说明外部关闭了监听fd，也就是析构了，退出就好 222 return false; 223 } 224 // 监听所有事件，除了访问，打开和关闭，主要监听修改删除，添加成功直接返回 225 m_watchFD = inotify_add_watch(m_monitorFD, m_filePath.c_str(), 226 IN_ALL_EVENTS ^ (IN_ACCESS | IN_OPEN | IN_CLOSE)); 227 if (m_watchFD \u0026gt; 0) { 228 LOGI(WHAT(\u0026#34;{}, add watch success, fd {}\u0026#34;, tag, m_watchFD)); 229 return true; 230 } 231 } 232 if ((failedCount % 100) == 1) { 233 LOGW(WHAT(\u0026#34;{}, inotify_add_watch failed\u0026#34;, tag), 234 REASON(\u0026#34;failed {} times, ec: {}\u0026#34;, failedCount, 235 std::to_string(std::error_code(errno, std::system_category()))), 236 WILL(\u0026#34;retry\u0026#34;)); 237 } 238 std::this_thread::sleep_for(std::chrono::milliseconds(10)); 239 } 240 LOGE(WHAT(\u0026#34;{} failed\u0026#34;, tag), 241 REASON(\u0026#34;reach max failed count {}, ec: {}\u0026#34;, failedCount - 1, m_filePath, 242 std::to_string(std::error_code(errno, std::system_category()))), 243 WILL(\u0026#34;stop watch file\u0026#34;)); 244 return false; 245 } 246}; 二、源码分析 # 1. inotify_init # 都是调用do_inotify_init 1// fs/notify/inotify/inotify_user.c 2SYSCALL_DEFINE1(inotify_init1, int, flags) 3{ 4 return do_inotify_init(flags); 5} 6 7SYSCALL_DEFINE0(inotify_init) 8{ 9 return do_inotify_init(0); 10} do_inotify_init就是创建了一个fd，提供了一系列操作inotify_fops 1// fs/notify/inotify/inotify_user.c 2/* inotify syscalls */ 3static int do_inotify_init(int flags) 4{ 5 struct fsnotify_group *group; 6 int ret; 7 8 /* Check the IN_* constants for consistency. */ 9 BUILD_BUG_ON(IN_CLOEXEC != O_CLOEXEC); 10 BUILD_BUG_ON(IN_NONBLOCK != O_NONBLOCK); 11 12 if (flags \u0026amp; ~(IN_CLOEXEC | IN_NONBLOCK)) 13 return -EINVAL; 14 15 /* fsnotify_obtain_group took a reference to group, we put this when we kill the file in the end */ 16 group = inotify_new_group(inotify_max_queued_events); 17 if (IS_ERR(group)) 18 return PTR_ERR(group); 19 20 ret = anon_inode_getfd(\u0026#34;inotify\u0026#34;, \u0026amp;inotify_fops, group, 21 O_RDONLY | flags); 22 if (ret \u0026lt; 0) 23 fsnotify_destroy_group(group); 24 25 return ret; 26} inotify_ops中重点关注read方法 1static const struct file_operations inotify_fops = { 2 .show_fdinfo = inotify_show_fdinfo, 3 .poll = inotify_poll, 4 .read = inotify_read, 5 .fasync = fsnotify_fasync, 6 .release = inotify_release, 7 .unlocked_ioctl = inotify_ioctl, 8 .compat_ioctl = inotify_ioctl, 9 .llseek = noop_llseek, 10}; 2. read调用发生了什么 # read出来是inotify_event结构体，最后的name不确定长度 1/* 2 * struct inotify_event - structure read from the inotify device for each event 3 * 4 * When you are watching a directory, you will receive the filename for events 5 * such as IN_CREATE, IN_DELETE, IN_OPEN, IN_CLOSE, ..., relative to the wd. 6 */ 7struct inotify_event { 8\t__s32\twd;\t/* watch descriptor */ 9\t__u32\tmask;\t/* watch mask */ 10\t__u32\tcookie;\t/* cookie to synchronize two events */ 11\t__u32\tlen;\t/* length (including nulls) of name */ 12\tchar\tname[0];\t/* stub for possible name */ 13}; inotify_read的处理就是外面调用read时调用的函数 1static ssize_t inotify_read(struct file *file, char __user *buf, 2\tsize_t count, loff_t *pos) 3{ 4\tstruct fsnotify_group *group; 5\tstruct fsnotify_event *kevent; 6\tchar __user *start; 7\tint ret; 8\tDEFINE_WAIT_FUNC(wait, woken_wake_function); 9 10\tstart = buf; 11\tgroup = file-\u0026gt;private_data; 12 13\tadd_wait_queue(\u0026amp;group-\u0026gt;notification_waitq, \u0026amp;wait); 14\twhile (1) { 15\tspin_lock(\u0026amp;group-\u0026gt;notification_lock); 16 // 从group中取一个event，count代表size 17\tkevent = get_one_event(group, count); 18\tspin_unlock(\u0026amp;group-\u0026gt;notification_lock); 19 20\tpr_debug(\u0026#34;%s: group=%p kevent=%p\\n\u0026#34;, __func__, group, kevent); 21 22 // 存在event，拷贝到用户态内存中，然后销毁内核态event，count-=size 23\tif (kevent) { 24\tret = PTR_ERR(kevent); 25\tif (IS_ERR(kevent)) 26\tbreak; 27\tret = copy_event_to_user(group, kevent, buf); 28\tfsnotify_destroy_event(group, kevent); 29\tif (ret \u0026lt; 0) 30\tbreak; 31\tbuf += ret; 32\tcount -= ret; 33\tcontinue; 34\t} 35 36\tret = -EAGAIN; 37\tif (file-\u0026gt;f_flags \u0026amp; O_NONBLOCK) 38\tbreak; 39\tret = -ERESTARTSYS; 40\tif (signal_pending(current)) 41\tbreak; 42 43\tif (start != buf) 44\tbreak; 45 46\twait_woken(\u0026amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT); 47\t} 48\tremove_wait_queue(\u0026amp;group-\u0026gt;notification_waitq, \u0026amp;wait); 49 50\tif (start != buf \u0026amp;\u0026amp; ret != -EFAULT) 51\tret = buf - start; 52\treturn ret; 53} get_one_event可以看到整体size包含inotify_event的size和name的长度 如果count满足整体size，就删除队列第一个并返回 1/* 2 * Get an inotify_kernel_event if one exists and is small 3 * enough to fit in \u0026#34;count\u0026#34;. Return an error pointer if 4 * not large enough. 5 * 6 * Called with the group-\u0026gt;notification_lock held. 7 */ 8static struct fsnotify_event *get_one_event(struct fsnotify_group *group, 9\tsize_t count) 10{ 11\tsize_t event_size = sizeof(struct inotify_event); 12\tstruct fsnotify_event *event; 13 14 // 从group中取一个event，不删除list中的数据 15\tevent = fsnotify_peek_first_event(group); 16\tif (!event) 17\treturn NULL; 18 19\tpr_debug(\u0026#34;%s: group=%p event=%p\\n\u0026#34;, __func__, group, event); 20 21\tevent_size += round_event_name_len(event); 22\tif (event_size \u0026gt; count) 23\treturn ERR_PTR(-EINVAL); 24 25\t/* held the notification_lock the whole time, so this is the 26\t* same event we peeked above */ 27\tfsnotify_remove_first_event(group); 28 29\treturn event; 30} fsnotify_peek_first_event，group中存有通知的链表，这里取第一个 1/* 2 * Return the first event on the notification list without removing it. 3 * Returns NULL if the list is empty. 4 */ 5struct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group) 6{ 7\tassert_spin_locked(\u0026amp;group-\u0026gt;notification_lock); 8 9\tif (fsnotify_notify_queue_is_empty(group)) 10\treturn NULL; 11 12\treturn list_first_entry(\u0026amp;group-\u0026gt;notification_list, 13\tstruct fsnotify_event, list); 14} "},{"id":187,"href":"/docs/linux/linux-kernel/net/unix/unix/","title":"Unix","section":"unix/ unix的处理部分","content":" 一、socket创建 # 定义unix的操作集，当socket调用pf-\u0026gt;create会调用到unix_create 1// net/unix/af_unix.c 2static const struct net_proto_family unix_family_ops = { 3\t.family = PF_UNIX, 4\t.create = unix_create, 5\t.owner\t= THIS_MODULE, 6}; 7 8// net/unix/af_unix.c 9static int unix_create(struct net *net, struct socket *sock, int protocol, 10\tint kern) 11{ 12\tstruct sock *sk; 13 14\tif (protocol \u0026amp;\u0026amp; protocol != PF_UNIX) 15\treturn -EPROTONOSUPPORT; 16 17\tsock-\u0026gt;state = SS_UNCONNECTED; 18 19\tswitch (sock-\u0026gt;type) { 20\tcase SOCK_STREAM: 21\tsock-\u0026gt;ops = \u0026amp;unix_stream_ops; 22\tbreak; 23\t/* 24\t*\tBelieve it or not BSD has AF_UNIX, SOCK_RAW though 25\t*\tnothing uses it. 26\t*/ 27\tcase SOCK_RAW: 28\tsock-\u0026gt;type = SOCK_DGRAM; 29\tfallthrough; 30\tcase SOCK_DGRAM: 31\tsock-\u0026gt;ops = \u0026amp;unix_dgram_ops; 32\tbreak; 33\tcase SOCK_SEQPACKET: 34\tsock-\u0026gt;ops = \u0026amp;unix_seqpacket_ops; 35\tbreak; 36\tdefault: 37\treturn -ESOCKTNOSUPPORT; 38\t} 39 40\tsk = unix_create1(net, sock, kern, sock-\u0026gt;type); 41\tif (IS_ERR(sk)) 42\treturn PTR_ERR(sk); 43 44\treturn 0; 45} "},{"id":188,"href":"/docs/linux/debug/proc/diskstats/","title":"/proc/diskstats 磁盘信息","section":"proc目录内容详解","content":" 一、示例 # 1=\u0026gt; lsblk 2NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT 3loop0 7:0 0 1G 0 loop /app/chroot/webconsole-promoted/shared 4vda 252:0 0 110G 0 disk 5├─vda1 252:1 0 1G 0 part /boot 6└─vda2 252:2 0 109G 0 part 7 ├─cl-root 253:0 0 10G 0 lvm / 8 ├─cl-swap 253:1 0 4G 0 lvm [SWAP] 9 ├─cl-home 253:2 0 6G 0 lvm 10 │ └─home 253:12 0 6G 0 crypt /home 11 ├─cl-app 253:3 0 15G 0 lvm 12 │ └─app 253:10 0 15G 0 crypt /app 13 ├─cl-package 253:4 0 8G 0 lvm 14 │ └─package 253:11 0 8G 0 crypt /package 15 ├─cl-data 253:5 0 20G 0 lvm /data 16 ├─cl-hislog 253:6 0 10G 0 lvm /hislog 17 ├─cl-cache 253:7 0 2G 0 lvm /cache 18 ├─cl-dap 253:8 0 89G 0 lvm /hislog/dap 19 └─cl-backup 253:9 0 25G 0 lvm 20 └─backup 253:13 0 25G 0 crypt /backup 21vdb 252:16 0 80G 0 disk 22└─vdb1 252:17 0 80G 0 part 23 ├─cl-data 253:5 0 20G 0 lvm /data 24 └─cl-dap 253:8 0 89G 0 lvm /hislog/dap 25=\u0026gt; cat /proc/diskstats 26 252 0 vda 159493845 2056576 5617078371 1552152184 65347508 13783484 1128522539 2070129280 0 886384887 3215786500 0 0 0 0 27 252 1 vda1 25353 2 4622370 323480 486 951 48720 50547 0 229456 371417 0 0 0 0 28 252 2 vda2 159468215 2056574 5612447569 1551825664 53970188 13782533 1128473819 1996831053 0 913941147 3332714673 0 0 0 0 29 252 16 vdb 3123909 59138 127128355 46849021 12110593 15158359 241115137 254789137 0 52500297 203906263 0 0 0 0 30 252 17 vdb1 3123367 59138 127104741 46841127 3897483 15027157 240056553 195792831 0 66678589 235705174 0 0 0 0 31 253 0 dm-0 81966850 0 2541179469 718368091 4835864 0 63945263 181587156 0 543304821 900869292 0 0 0 0 32 253 1 dm-1 39491681 0 315937056 354020275 31737102 0 253896816 2458965561 0 200331242 2823539969 0 0 0 0 33 253 2 dm-2 20568 0 1370523 286000 9033 0 116327 616974 0 686801 903014 0 0 0 0 34 253 3 dm-3 27092223 0 1347467400 330732281 1135223 0 23297583 56219835 0 204377309 387211171 0 0 0 0 35 253 4 dm-4 6419 0 68948 90293 19105 0 120956 717639 0 667774 807949 0 0 0 0 36 253 5 dm-5 2779789 0 507214559 36366385 25248746 0 464602835 704195339 0 347508715 740899295 0 0 0 0 37 253 6 dm-6 5251510 0 523996485 71587841 7380194 0 106399514 194806376 0 118078310 266540312 0 0 0 0 38 253 7 dm-7 1772 0 41329 34931 12184 0 218874 1010468 0 818229 1045418 0 0 0 0 39 253 8 dm-8 6203721 0 221744397 82963780 23626490 0 375040396 2117003466 0 80501448 2203736434 0 0 0 0 40 253 9 dm-9 1913762 0 280471928 27737018 3503920 0 160325095 124124824 0 81257167 151876112 0 0 0 0 41 253 10 dm-10 27091739 0 1347462526 415492329 1135223 0 26608603 87048745 0 238219337 502736856 0 0 0 0 42 253 11 dm-11 5942 0 64130 100222 19105 0 134204 811752 0 727465 912004 0 0 0 0 43 253 12 dm-12 20112 0 1365873 336612 9033 0 131175 739788 0 769232 1076503 0 0 0 0 44 253 13 dm-13 1913304 0 280467138 35087780 3503914 0 162938029 175455182 0 91516697 210566101 0 0 0 0 45 7 0 loop0 1470 0 103611 18992 248 0 5763 32870 0 18410 31578 0 0 0 0 二、数据解释 # 将数据格式化一下\nmajor minor name rio rmerge rsect rtime spent(ms) wio wmerge wsect wtime spent(ms) running time spent doing I/O(ms) weighted time spent doing I/Os (ms) 252 0 vda 159493845 2056576 5617078371 1552152184 65347508 13783484 1128522539 2070129280 0 886384887 3215786500 252 1 vda1 25353 2 4622370 323480 486 951 48720 50547 0 229456 371417 252 2 vda2 159468215 2056574 5612447569 1551825664 53970188 13782533 1128473819 1996831053 0 913941147 3332714673 252 16 vdb 3123909 59138 127128355 46849021 12110593 15158359 241115137 254789137 0 52500297 203906263 252 17 vdb1 3123367 59138 127104741 46841127 3897483 15027157 240056553 195792831 0 66678589 235705174 253 0 dm-0 81966850 0 2541179469 718368091 4835864 0 63945263 181587156 0 543304821 900869292 253 1 dm-1 39491681 0 315937056 354020275 31737102 0 253896816 2458965561 0 200331242 2823539969 253 2 dm-2 20568 0 1370523 286000 9033 0 116327 616974 0 686801 903014 253 3 dm-3 27092223 0 1347467400 330732281 1135223 0 23297583 56219835 0 204377309 387211171 253 4 dm-4 6419 0 68948 90293 19105 0 120956 717639 0 667774 807949 253 5 dm-5 2779789 0 507214559 36366385 25248746 0 464602835 704195339 0 347508715 740899295 253 6 dm-6 5251510 0 523996485 71587841 7380194 0 106399514 194806376 0 118078310 266540312 253 7 dm-7 1772 0 41329 34931 12184 0 218874 1010468 0 818229 1045418 253 8 dm-8 6203721 0 221744397 82963780 23626490 0 375040396 2117003466 0 80501448 2203736434 253 9 dm-9 1913762 0 280471928 27737018 3503920 0 160325095 124124824 0 81257167 151876112 253 10 dm-10 27091739 0 1347462526 415492329 1135223 0 26608603 87048745 0 238219337 502736856 253 11 dm-11 5942 0 64130 100222 19105 0 134204 811752 0 727465 912004 253 12 dm-12 20112 0 1365873 336612 9033 0 131175 739788 0 769232 1076503 253 13 dm-13 1913304 0 280467138 35087780 3503914 0 162938029 175455182 0 91516697 210566101 7 0 loop0 1470 0 103611 18992 248 0 5763 32870 0 18410 31578 取第一行详细解释\nmajor number (主设备号) - 252：这是设备的主设备号。 minor mumber (次设备号) - 0：这是设备的次设备号。 device name (设备名称) - vda：这是设备的名称，通常是虚拟磁盘。 reads completed successfully (成功完成的读取次数) - 159493845：这是设备成功完成的读取次数。 reads merged (合并的读取次数) - 2056576：这是合并的读取操作的次数，即相邻的读取请求被合并的次数。 sectors read (读取的扇区数) - 5617078371：这是成功读取的扇区总数。 time spent reading (ms) (读取花费的时间，单位为毫秒) - 1552152184：这是读取操作花费的总时间，单位为毫秒。 writes completed (成功完成的写入次数) - 65347508：这是设备成功完成的写入次数。 writes merged (合并的写入次数) - 13783484：这是合并的写入操作的次数。 sectors written (写入的扇区数) - 1128522539：这是成功写入的扇区总数。 time spent writing (ms) (写入花费的时间，单位为毫秒) - 2070129280：这是写入操作花费的总时间，单位为毫秒。 I/Os currently in progress (当前正在进行的I/O操作数) - 0：这是当前正在进行的输入/输出操作的数量。 time spent doing I/Os (ms) (进行I/O操作花费的时间，单位为毫秒) - 886384887：这是设备进行I/O操作花费的总时间，单位为毫秒。 weighted time spent doing I/Os (ms) (进行I/O操作的加权时间，单位为毫秒) - 3215786500：这是进行I/O操作的加权时间，考虑了I/O操作的队列长度。 后面4个0作为保留字段，通常未使用\n"},{"id":189,"href":"/docs/linux/kernel-troubleshooting/crash/01-netfilter-driver-crash/","title":"1. netfilter驱动使用sk错误引发宕机","section":"宕机vmcore分析","content":" 一、堆栈信息 # [28772.702878] BUG: unable to handle kernel paging request at 0000000400080040 [28772.703475] PGD 0 P4D 0 [28772.703614] Oops: 0000 [#1] SMP PTI [28772.703806] CPU: 6 PID: 96951 Comm: sdptun Kdump: loaded Tainted: G W OE 4.19.181 #6 [28772.704255] Hardware name: Bochs Bochs, BIOS 1.13.0-20201211_142035 04/01/2014 [28772.704635] RIP: 0010:tcp_md5_do_lookup+0x15/0x130 [28772.704881] Code: 04 00 00 0f a3 c2 73 01 c3 e9 37 ff ff ff 0f 1f 80 00 00 00 00 66 66 66 66 90 48 8b 87 40 08 00 00 48 85 c0 0f 84 e4 00 00 00 \u0026lt;48\u0026gt; 8b 38 31 c0 48 85 ff 74 62 41 bb 40 00 00 00 49 c7 c2 ff ff ff [28772.705826] RSP: 0018:ffff957075d83d20 EFLAGS: 00010202 [28772.706093] RAX: 0000000400080040 RBX: ffff956fdfa56118 RCX: 0000000000000001 [28772.706454] RDX: 0000000000000002 RSI: ffff956fdfa56118 RDI: ffff956fbcf3aa80 [28772.706866] RBP: ffff956fdfa5610c R08: 0000000000000001 R09: 000000000000ebb5 [28772.707244] R10: 000000000100007f R11: 000000000000c352 R12: ffff956fbcf3aa80 [28772.707604] R13: ffff956f600ce000 R14: ffff956fdfa56120 R15: ffff956fdfa5610c [28772.707985] FS: 00007f32b003d740(0000) GS:ffff957075d80000(0000) knlGS:0000000000000000 [28772.708395] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [28772.708740] CR2: 0000000400080040 CR3: 00000002263ca006 CR4: 00000000000206e0 [28772.709112] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [28772.709473] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [28772.709834] Call Trace: [28772.709979] \u0026lt;IRQ\u0026gt; [28772.710090] tcp_v4_inbound_md5_hash+0x5c/0x160 [28772.710336] tcp_v4_rcv+0x565/0xc00 [28772.710521] ip_local_deliver_finish+0x61/0x1e0 [28772.710766] ip_local_deliver+0xe0/0xf0 [28772.711016] ? ip_sublist_rcv_finish+0x80/0x80 [28772.711301] ip_rcv+0xbc/0xd0 [28772.711458] ? ip_rcv_finish_core.isra.18+0x360/0x360 [28772.711719] __netif_receive_skb_one_core+0x5a/0x80 [28772.711982] process_backlog+0xaa/0x160 [28772.712182] net_rx_action+0x149/0x3b0 [28772.712379] ? sched_clock+0x5/0x10 [28772.712577] __do_softirq+0xe3/0x2eb [28772.712766] do_softirq_own_stack+0x2a/0x40 [28772.712982] \u0026lt;/IRQ\u0026gt; [28772.713106] do_softirq.part.15+0x4f/0x60 [28772.713326] __local_bh_enable_ip+0x60/0x70 [28772.713595] ip_finish_output2+0x1a7/0x430 [28772.713811] ? ip_finish_output+0x13a/0x280 [28772.714033] ip_output+0x6c/0xe0 [28772.714208] ? ip_fragment.constprop.50+0x80/0x80 [28772.714450] __ip_queue_xmit+0x15d/0x410 [28772.714665] __tcp_transmit_skb+0x528/0xaf0 [28772.714882] tcp_rcv_state_process+0xbc2/0xda0 [28772.715122] tcp_v4_do_rcv+0xb4/0x1e0 [28772.715314] __release_sock+0x7c/0xd0 [28772.715516] release_sock+0x2b/0x90 [28772.715700] inet_stream_connect+0x41/0x50 [28772.715983] __sys_connect+0xd0/0x100 [28772.716177] ? syscall_trace_enter+0x1d3/0x2b0 [28772.716406] __x64_sys_connect+0x16/0x20 [28772.716610] do_syscall_64+0x5f/0x1e0 [28772.716801] ? async_page_fault+0x8/0x30 [28772.717006] entry_SYSCALL_64_after_hwframe+0x44/0xa9 [28772.717265] RIP: 0033:0x7f32afa0fcd5 [28772.717452] Code: 64 89 02 b8 ff ff ff ff eb ba 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 8b 05 76 d7 20 00 85 c0 75 12 b8 2a 00 00 00 0f 05 \u0026lt;48\u0026gt; 3d 00 f0 ff ff 77 53 c3 66 90 41 54 41 89 d4 55 48 89 f5 53 89 [28772.718398] RSP: 002b:00007ffef365ce88 EFLAGS: 00000246 ORIG_RAX: 000000000000002a [28772.718781] RAX: ffffffffffffffda RBX: 00007f329838ef80 RCX: 00007f32afa0fcd5 [28772.719155] RDX: 0000000000000010 RSI: 000055af9e8e26a0 RDI: 000000000000017f [28772.719570] RBP: 00007f3299512df8 R08: 0000000000000004 R09: 0000000000000070 [28772.719930] R10: 00007ffef365ce5c R11: 0000000000000246 R12: 000000000000017f [28772.720292] R13: 00007f32990ecd30 R14: 00007f32992fcd30 R15: 0000000000000001 [28772.720682] Modules linked in: sdp_toa(OE) nfnetlink_queue tun xt_addrtype br_netfilter overlay bridge stp llc xt_TEE nf_dup_ipv6 nf_dup_ipv4 xt_TPROXY nf_tproxy_ipv6 nf_tproxy_ipv4 veth tcp_diag udp_diag inet_diag ipt_MASQUERADE xt_nat xt_multiport xt_socket nf_socket_ipv4 nf_socket_ipv6 nf_conntrack_netlink xt_HL xt_hl xt_set xt_comment xt_owner xt_connmark xt_mark ip6t_REJECT nf_reject_ipv6 ipt_REJECT nf_reject_ipv4 xt_conntrack nft_counter nft_chain_nat_ipv6 nf_nat_ipv6 nft_chain_route_ipv6 nft_chain_nat_ipv4 nf_nat_ipv4 nf_nat nft_chain_route_ipv4 ip_set_hash_netport ip_set_hash_net rfkill ip6_tables nft_compat ip_set nf_tables(E) nfnetlink igb i2c_algo_bit dca tcp_bbr sch_fq ip_vs nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 loop ext4 mbcache jbd2 joydev pcspkr i2c_piix4 ip_tables xfs libcrc32c [28772.725085] dm_crypt xts ata_generic crc32c_intel serio_raw virtio_net ata_piix net_failover virtio_console virtio_blk failover libata dm_mirror dm_region_hash dm_log dm_mod fuse [last unloaded: sdp_toa] [28772.726001] CR2: 0000000400080040 二、分析堆栈信息 # 1. 首先正面分析堆栈 # 1[28772.702878] BUG: unable to handle kernel paging request at 0000000400080040 1// arch/x86/mm/fault.c 2static void 3show_fault_oops(struct pt_regs *regs, unsigned long error_code, 4\tunsigned long address) 5{ 6 ... 7\tpr_alert(\u0026#34;BUG: unable to handle kernel %s at %px\\n\u0026#34;, 8\taddress \u0026lt; PAGE_SIZE ? \u0026#34;NULL pointer dereference\u0026#34; : \u0026#34;paging request\u0026#34;, 9\t(void *)address); 10 11\tdump_pagetable(address); 12} 这个在网上查原因是地址非法，看起来地址和正常的地址确实不太一样，像sk的地址为0xffff956fbcf3aa80 使用crash命令调试vmcore 1=\u0026gt; crash vmlinux /hislog/crash/kdump/127.0.0.1-2023-12-30-00\\:40\\:52/vmcore 2... 3 KERNEL: vmlinux 4 DUMPFILE: /hislog/crash/kdump/127.0.0.1-2023-12-30-00:40:52/vmcore [PARTIAL DUMP] 5 CPUS: 8 6 DATE: Sat Dec 30 00:40:46 2023 7 UPTIME: 07:59:32 8LOAD AVERAGE: 1.30, 1.30, 1.44 9 TASKS: 1624 10 NODENAME: aTrust 11 RELEASE: 4.19.181 12 VERSION: #6 SMP Thu Jun 16 04:03:14 CST 2022 13 MACHINE: x86_64 (2194 Mhz) 14 MEMORY: 8 GB 15 PANIC: \u0026#34;BUG: unable to handle kernel paging request at 0000000400080040\u0026#34; 16 PID: 96951 17 COMMAND: \u0026#34;sdptun\u0026#34; 18 TASK: ffff956fe2e65800 [THREAD_INFO: ffff956fe2e65800] 19 CPU: 6 20 STATE: TASK_RUNNING (PANIC) 21 22crash\u0026gt; bt 23PID: 96951 TASK: ffff956fe2e65800 CPU: 6 COMMAND: \u0026#34;sdptun\u0026#34; 24 #0 [ffff957075d83a20] machine_kexec at ffffffff8e24baae 25 #1 [ffff957075d83a78] __crash_kexec at ffffffff8e33eccd 26 #2 [ffff957075d83b40] crash_kexec at ffffffff8e33fbad 27 #3 [ffff957075d83b58] oops_end at ffffffff8e21fedd 28 #4 [ffff957075d83b78] no_context at ffffffff8e25974c 29 #5 [ffff957075d83bd0] __do_page_fault at ffffffff8e259e5e 30 #6 [ffff957075d83c40] do_page_fault at ffffffff8e25a2f2 31 #7 [ffff957075d83c70] async_page_fault at ffffffff8ec0119e 32 [exception RIP: tcp_md5_do_lookup+21] 33 RIP: ffffffff8e9ad3f5 RSP: ffff957075d83d20 RFLAGS: 00010202 34 RAX: 0000000400080040 RBX: ffff956fdfa56118 RCX: 0000000000000001 35 RDX: 0000000000000002 RSI: ffff956fdfa56118 RDI: ffff956fbcf3aa80 36 RBP: ffff956fdfa5610c R8: 0000000000000001 R9: 000000000000ebb5 37 R10: 000000000100007f R11: 000000000000c352 R12: ffff956fbcf3aa80 38 R13: ffff956f600ce000 R14: ffff956fdfa56120 R15: ffff956fdfa5610c 39 ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018 40 #8 [ffff957075d83d20] tcp_v4_inbound_md5_hash at ffffffff8e9adecc 41 #9 [ffff957075d83d78] tcp_v4_rcv at ffffffff8e9af9a5 42#10 [ffff957075d83de8] ip_local_deliver_finish at ffffffff8e985f61 43#11 [ffff957075d83e08] ip_local_deliver at ffffffff8e986800 44#12 [ffff957075d83e58] ip_rcv at ffffffff8e9868cc 45#13 [ffff957075d83eb0] __netif_receive_skb_one_core at ffffffff8e92523a 46#14 [ffff957075d83ed8] process_backlog at ffffffff8e92642a 47#15 [ffff957075d83f10] net_rx_action at ffffffff8e9257c9 48#16 [ffff957075d83f90] __softirqentry_text_start at ffffffff8ee000e3 49#17 [ffff957075d83ff0] do_softirq_own_stack at ffffffff8ec00e9a 50--- \u0026lt;IRQ stack\u0026gt; --- 51#18 [ffffac70016cbbb0] do_softirq_own_stack at ffffffff8ec00e9a 52 [exception RIP: unknown or invalid address] 53 RIP: ffff956ff7c98000 RSP: ffff956fb117c240 RFLAGS: ffff956ff7c98348 54 RAX: ffffffff8f5e0080 RBX: ffffac70016cbc50 RCX: 0000000000000000 55 RDX: 0100007ff7c98348 RSI: e214a24fbc22aa00 RDI: ffffffff8e98b1ca 56 RBP: ffff956f600ce000 R8: ffffffff8e989a87 R9: ffffffff8e2a7850 57 R10: ffff957018d7c400 R11: ffffffff8e2a77df R12: ffff957018d7c400 58 R13: ffff956ff7c98000 R14: e214a24fbc22aa00 R15: 0000000000000000 59 ORIG_RAX: ffff956f600ce000 CS: 0000 SS: ffffffff8f5e0080 60bt: WARNING: possibly bogus exception frame 61#19 [ffffac70016cbc58] ip_output at ffffffff8e98bd4c 62#20 [ffffac70016cbcb0] __ip_queue_xmit at ffffffff8e98b7ad 63#21 [ffffac70016cbd08] __tcp_transmit_skb at ffffffff8e9a5e48 64#22 [ffffac70016cbd78] tcp_rcv_state_process at ffffffff8e9a3c12 65#23 [ffffac70016cbde8] tcp_v4_do_rcv at ffffffff8e9ae494 66#24 [ffffac70016cbe08] __release_sock at ffffffff8e907c8c 67#25 [ffffac70016cbe30] release_sock at ffffffff8e907d0b 68#26 [ffffac70016cbe48] inet_stream_connect at ffffffff8e9c6bd1 69#27 [ffffac70016cbe70] __sys_connect at ffffffff8e902cd0 70#28 [ffffac70016cbf28] __x64_sys_connect at ffffffff8e902d16 71#29 [ffffac70016cbf30] do_syscall_64 at ffffffff8e203eef 72#30 [ffffac70016cbf50] entry_SYSCALL_64_after_hwframe at ffffffff8ec00088 73 RIP: 00007f32afa0fcd5 RSP: 00007ffef365ce88 RFLAGS: 00000246 74 RAX: ffffffffffffffda RBX: 00007f329838ef80 RCX: 00007f32afa0fcd5 75 RDX: 0000000000000010 RSI: 000055af9e8e26a0 RDI: 000000000000017f 76 RBP: 00007f3299512df8 R8: 0000000000000004 R9: 0000000000000070 77 R10: 00007ffef365ce5c R11: 0000000000000246 R12: 000000000000017f 78 R13: 00007f32990ecd30 R14: 00007f32992fcd30 R15: 0000000000000001 79 ORIG_RAX: 000000000000002a CS: 0033 SS: 002b 堆栈位置 crash\u0026gt; dis -l tcp_md5_do_lookup+21 5 /root/hdc/hardware/linux_kernel_4.19.181/linux-4.19.181/./include/linux/compiler.h: 207 0xffffffff8e9ad3f5 \u0026lt;tcp_md5_do_lookup+21\u0026gt;: mov (%rax),%rdi /root/hdc/hardware/linux_kernel_4.19.181/linux-4.19.181/net/ipv4/tcp_ipv4.c: 994 0xffffffff8e9ad3f8 \u0026lt;tcp_md5_do_lookup+24\u0026gt;: xor %eax,%eax 0xffffffff8e9ad3fa \u0026lt;tcp_md5_do_lookup+26\u0026gt;: test %rdi,%rdi 0xffffffff8e9ad3fd \u0026lt;tcp_md5_do_lookup+29\u0026gt;: je 0xffffffff8e9ad461 \u0026lt;tcp_md5_do_lookup+129\u0026gt; 0xffffffff8e9ad3ff \u0026lt;tcp_md5_do_lookup+31\u0026gt;: mov $0x40,%r11d 1// net/ipv4/tcp_ipv4.c 2/* Find the Key structure for an address. */ 3struct tcp_md5sig_key *tcp_md5_do_lookup(const struct sock *sk, 4\tconst union tcp_md5_addr *addr, 5\tint family) 6{ 7\tconst struct tcp_sock *tp = tcp_sk(sk); 8\tstruct tcp_md5sig_key *key; 9\tconst struct tcp_md5sig_info *md5sig; 10\t__be32 mask; 11\tstruct tcp_md5sig_key *best_match = NULL; 12\tbool match; 13 14\t/* caller either holds rcu_read_lock() or socket lock */ 15\tmd5sig = rcu_dereference_check(tp-\u0026gt;md5sig_info, 16\tlockdep_sock_is_held(sk)); 17\tif (!md5sig) 18\treturn NULL; 19 20\thlist_for_each_entry_rcu(key, \u0026amp;md5sig-\u0026gt;head, node) { 21 ... 22\t} 23\treturn best_match; 24} 25EXPORT_SYMBOL(tcp_md5_do_lookup); 26 27// include/linux/compiler.h 28#define __READ_ONCE_SIZE\t\\ 29({\t\\ 30\tswitch (size) {\t\\ 31\tcase 1: *(__u8 *)res = *(volatile __u8 *)p; break;\t\\ 32\tcase 2: *(__u16 *)res = *(volatile __u16 *)p; break;\t\\ 33\tcase 4: *(__u32 *)res = *(volatile __u32 *)p; break;\t\\ 34\tcase 8: *(__u64 *)res = *(volatile __u64 *)p; break;\t\\ 35\tdefault:\t\\ 36\tbarrier();\t\\ 37\t__builtin_memcpy((void *)res, (const void *)p, size);\t\\ 38\tbarrier();\t\\ 39\t}\t\\ 40}) 41 42static __always_inline 43void __read_once_size(const volatile void *p, void *res, int size) 44{ 45\t__READ_ONCE_SIZE; 46} 从堆栈分析和代码上看，应该是tp-\u0026gt;md5sig_info存在问题 堆栈看是收包到协议栈的tcp处理时 这个变量我们没有动，驱动里面最多修改skb但是也是发出去的，和收包应该没关系 修改的sk结构体的sk_user_data和skc_flags，上面的md5sig_info是tcp_sock中的，和前面两个结构体应该没关系 怀疑点\n踩内存 跑一下kasan的分析 收包时复用了sk，sk的标记不对导致修改错了包而出现问题 优化代码，判断一下sk的状态，跑一下能否复现 2. 验证结果 # kasan确实发现踩内存了，踩内存代码在这里 1 // 只处理tcp协议包 2 if (!sk || sk-\u0026gt;sk_protocol != IPPROTO_TCP) { 3 return NF_ACCEPT; 4 } 堆栈是在发送syn/ack时，要不是之前理过内核代码，都没想到这个时候的sock结构体是request_sock request_sock结构体比sock结构体少了好多东西，所以这里的sk_protocol其实已经越界了，具体是不是IPPROTO_TCP就不一定了 而request_sock结构体中的sk_flags是使用的skc_listener指针，指针的第30位是否为1也是不确定的 写了代码验证确实可能在request_sock中进入到设置toa的逻辑，而request_sock也没有sk_user_data，sk_flags也是指针地址，驱动中正好改了这两个，sk_user_data清零，sk_flags的第30位置0 那么，一个是越界，一个是指针地址不对了，要么改了其他内存，要么free了其他内存且内存泄漏，完美的崩溃 三、结论 # netfilter的hook中，sock结构体指针指向的可能不是我们认为的struct sock，也可能是struct request_sock或struct ，源码分析见 minisock 缩减版本的socket 写netfilter驱动时，需要先对sock结构体指针做判断 1 // 这里需要判断sock是否是完整的，只有完整的sock中flag才是真的flag 2 // 非完整的request_sock中flag是skc_listener 3 // 非完整的inet_timewait_sock中flag是skc_tw_dr 4 // 只处理ipv4 5 if (!sk || !sk_fullsock(sk) || sk-\u0026gt;sk_family != PF_INET) { 6 return NF_ACCEPT; 7 } "},{"id":190,"href":"/docs/linux/kernel-troubleshooting/crash/02-hung-task-crash/","title":"2. Kernel panic - not syncing: hung_task: blocked tasks","section":"宕机vmcore分析","content":" 一、堆栈信息 # [930452.890969] INFO: task idsd:31761 blocked for more than 480 seconds. [930452.891127] oom_reaper: reaped process 15265 ((irewalld)), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB [930452.891476] Tainted: G E 4.19.181 #6 [930452.892678] \u0026#34;echo 0 \u0026gt; /proc/sys/kernel/hung_task_timeout_secs\u0026#34; disables this message. [930452.893296] idsd D 0 31761 1 0x00000080 [930452.893721] Call Trace: [930452.893934] __schedule+0x254/0x840 [930452.894217] schedule+0x28/0x80 [930452.894463] rwsem_down_read_failed+0x111/0x180 [930452.894981] ? xfs_file_buffered_aio_read+0x3c/0xe0 [xfs] [930452.895398] call_rwsem_down_read_failed+0x14/0x30 [930452.895798] down_read+0x1c/0x30 [930452.896102] xfs_ilock+0x82/0x100 [xfs] [930452.896435] xfs_file_buffered_aio_read+0x3c/0xe0 [xfs] [930452.896901] xfs_file_read_iter+0x6e/0xd0 [xfs] [930452.897372] __vfs_read+0x133/0x190 [930452.897651] vfs_read+0x91/0x140 [930452.897937] ksys_read+0x57/0xd0 [930452.898194] do_syscall_64+0x5f/0x1e0 [930452.898454] ? prepare_exit_to_usermode+0x90/0xc0 [930452.898840] entry_SYSCALL_64_after_hwframe+0x44/0xa9 [930452.899229] RIP: 0033:0x7f3846598d75 [930452.899517] Code: Bad RIP value. [930452.899808] RSP: 002b:00007ffe2d885d68 EFLAGS: 00000246 ORIG_RAX: 0000000000000000 [930452.900328] RAX: ffffffffffffffda RBX: 000055d2443adf70 RCX: 00007f3846598d75 [930452.900697] RDX: 0000000000010000 RSI: 00007ffe2d885f60 RDI: 000000000000000d [930452.901094] RBP: 00007f3846866280 R08: 0000000000000000 R09: 00007f3846869d40 [930452.901514] R10: 000055d244381010 R11: 0000000000000246 R12: 0000000000010000 [930452.902067] R13: 00007ffe2d885f60 R14: 0000000000000d68 R15: 00007f3846865740 [930452.902721] NMI backtrace for cpu 3 [930452.902927] CPU: 3 PID: 55 Comm: khungtaskd Kdump: loaded Tainted: G E 4.19.181 #6 [930452.903422] Hardware name: Bochs Bochs, BIOS 1.13.0-20201211_142035 04/01/2014 [930452.903886] Call Trace: [930452.904038] dump_stack+0x66/0x81 [930452.904246] nmi_cpu_backtrace.cold.5+0x13/0x4e [930452.904540] ? lapic_can_unplug_cpu+0x80/0x80 [930452.904788] nmi_trigger_cpumask_backtrace+0xde/0xe0 [930452.905048] watchdog+0x24e/0x320 [930452.905226] ? hungtask_pm_notify+0x40/0x40 [930452.905459] kthread+0x112/0x130 [930452.905632] ? kthread_bind+0x30/0x30 [930452.905829] ret_from_fork+0x35/0x40 [930452.906104] Sending NMI from CPU 3 to CPUs 0-2,4-7: [930452.906503] NMI backtrace for cpu 2 skipped: idling at native_safe_halt+0xe/0x10 [930452.906511] NMI backtrace for cpu 6 skipped: idling at native_safe_halt+0xe/0x10 [930452.906518] NMI backtrace for cpu 1 [930452.906519] CPU: 1 PID: 73259 Comm: in:imjournal Kdump: loaded Tainted: G E 4.19.181 #6 [930452.906519] Hardware name: Bochs Bochs, BIOS 1.13.0-20201211_142035 04/01/2014 [930452.906520] RIP: 0010:syscall_return_via_sysret+0x6c/0x83 [930452.906521] Code: 73 0f 65 48 0f b3 3c 25 d6 17 02 00 48 89 c7 eb 08 48 89 c7 48 0f ba ef 3f 48 81 cf 00 08 00 00 48 81 cf 00 10 00 00 0f 22 df \u0026lt;58\u0026gt; 5f 5c 0f 01 f8 48 0f 07 0f 1f 40 00 66 2e 0f 1f 84 00 00 00 00 [930452.906522] RSP: 0018:fffffe000002efe8 EFLAGS: 00000086 [930452.906523] RAX: 0000000187c50003 RBX: 00007ff248000bd0 RCX: 00007ff2604e7b51 [930452.906524] RDX: 0000000000000241 RSI: 00007ff256881b30 RDI: 8000000187c51803 [930452.906524] RBP: 0000000000000004 R08: 0000000000000000 R09: 0000000000000001 [930452.906525] R10: 00000000000001b6 R11: 0000000000000293 R12: 00007ff25e6f6c87 [930452.906526] R13: 00007ff25e6f6c86 R14: 0000000000000001 R15: 00007ff2544be138 [930452.906526] FS: 00007ff256883700(0000) GS:ffff95f22dc40000(0000) knlGS:0000000000000000 [930452.906527] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [930452.906527] CR2: 00007ff2544b0000 CR3: 0000000187c50003 CR4: 00000000000206e0 [930452.906528] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [930452.906528] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [930452.906529] Call Trace: [930452.906529] \u0026lt;ENTRY_TRAMPOLINE\u0026gt; [930452.906529] \u0026lt;/ENTRY_TRAMPOLINE\u0026gt; [930452.906533] NMI backtrace for cpu 0 skipped: idling at native_safe_halt+0xe/0x10 [930452.906544] NMI backtrace for cpu 5 [930452.906545] CPU: 5 PID: 126827 Comm: systemd-journal Kdump: loaded Tainted: G E 4.19.181 #6 [930452.906546] Hardware name: Bochs Bochs, BIOS 1.13.0-20201211_142035 04/01/2014 [930452.906546] RIP: 0010:0xffffffffc01e4902 [930452.906547] Code: cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc \u0026lt;55\u0026gt; 48 89 e5 48 81 ec 00 00 00 00 53 41 55 41 56 41 57 31 c0 45 31 [930452.906548] RSP: 0018:ffffb0d6871dbd88 EFLAGS: 00000286 [930452.906549] RAX: ffffffffc01e4902 RBX: ffff95ef8414cea0 RCX: 000000007fff0000 [930452.906549] RDX: 000000007fff0000 RSI: ffffb0d6819a5038 RDI: ffffb0d6871dbec0 [930452.906549] RBP: 000000007fff0000 R08: 0000000000000000 R09: 0000000000000000 [930452.906550] R10: 0000000000000000 R11: 0000000000000000 R12: ffffb0d6871dbec0 [930452.906550] R13: ffffb0d6871dbe08 R14: 0000000000000000 R15: 0000000000000000 [930452.906551] FS: 00007f3929d18600(0000) GS:ffff95f22dd40000(0000) knlGS:0000000000000000 [930452.906551] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 [930452.906551] CR2: 00007f3924613000 CR3: 000000013b03a001 CR4: 00000000000206e0 [930452.906552] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 [930452.906552] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 [930452.906552] Call Trace: [930452.906553] ? seccomp_run_filters+0x5c/0xb0 [930452.906553] ? do_filp_open+0xa7/0x100 [930452.906553] ? __seccomp_filter+0x44/0x4a0 [930452.906554] ? audit_filter_rules.constprop.14+0x438/0x1100 [930452.906554] ? __check_object_size+0x162/0x180 [930452.906554] ? syscall_trace_enter+0x192/0x2b0 [930452.906555] ? do_syscall_64+0x14d/0x1e0 [930452.906555] ? async_page_fault+0x8/0x30 [930452.906555] ? entry_SYSCALL_64_after_hwframe+0x44/0xa9 [930452.906582] NMI backtrace for cpu 7 skipped: idling at native_safe_halt+0xe/0x10 [930452.906636] NMI backtrace for cpu 4 skipped: idling at native_safe_halt+0xe/0x10 [930452.907596] Kernel panic - not syncing: hung_task: blocked tasks [930452.915969] last invoked oom-killer: gfp_mask=0x600040(GFP_NOFS), nodemask=(null), order=0, oom_score_adj=-1000 [930452.916497] CPU: 3 PID: 55 Comm: khungtaskd Kdump: loaded Tainted: G E 4.19.181 #6 [930452.916748] last cpuset=/ mems_allowed=0 [930452.917390] Hardware name: Bochs Bochs, BIOS 1.13.0-20201211_142035 04/01/2014 [930452.917391] Call Trace: [930452.917403] dump_stack+0x66/0x81 [930452.917409] panic+0xe7/0x24a [930452.933168] watchdog+0x25a/0x320 [930452.933390] ? hungtask_pm_notify+0x40/0x40 [930452.933649] kthread+0x112/0x130 [930452.933877] ? kthread_bind+0x30/0x30 [930452.934136] ret_from_fork+0x35/0x40 [930452.934372] CPU: 5 PID: 12473 Comm: last Kdump: loaded Tainted: G E 4.19.181 #6 二、分析堆栈信息 # 1. 首先正面分析堆栈 # 1[267625.696626] Kernel panic - not syncing: hung_task: blocked tasks 这个在网上查原因是由于某个进程卡死超过一定时间，内核有个配置进行宕机处理 网上说明的出现问题的都是xfs调用导致，都是由于磁盘问题或代码bug造成死锁而出现 本堆栈环境是云平台的虚拟机 "},{"id":191,"href":"/docs/linux/linux-kernel/data-structures/atomic/","title":"atomic 原子变量","section":"数据结构","content":" 一、实例用法 # 1. atomic_t的用法 # 1 2atomic_t g_running_hooks = ATOMIC_INIT(0); 3 4int main() { 5 int count; 6 7 atomic_inc(\u0026amp;g_running_hooks); // 加一 8 atomic_dec(\u0026amp;g_running_hooks); // 减一 9 atomic_set_release(\u0026amp;g_running_hooks, 1); // 设置为1 10 atomic_set_release(\u0026amp;g_running_hooks, 0); // 设置为0 11 count = atomic_read_acquire(\u0026amp;g_running_hooks); // 读取值 12} "},{"id":192,"href":"/docs/linux/linux-kernel/kernel/locking/bit_spinlock/","title":"bit_spinlock","section":"/kernel/lockng/ 锁相关","content":" 一、前言 # bit_spinlock是内核里面比较原始的一种自旋锁的实现，只有0和1两种状态。使用原子操作TAS（test and set）来抢锁，线程之间无序抢锁，并不公平。\n二、使用实例 # 1void test_hash(void) { 2 unsigned long lock = 0; 3 printk(\u0026#34;lock: %lu, lock ptr: %pK\\n\u0026#34;, lock, \u0026amp;lock); // lock: 0, lock ptr: 0xffffaaabbb 4 5 // 使用变量第一位作为锁，锁了之后lock的值的第一位被设置为1 6 bit_spin_lock(0, \u0026amp;lock); 7 // 尝试申请锁，不阻塞，申请到返回true，否则返回false 8 t = bit_spin_trylock(0, \u0026amp;lock); 9 printk(\u0026#34;entry: %lu, %pK, try %d\\n\u0026#34;, lock, \u0026amp;lock, t); // lock: 1, lock ptr: 0xffffaaabbb, 0 10 11 // 解锁 12 bit_spin_unlock(0, \u0026amp;lock); 13 t = bit_spin_trylock(0, \u0026amp;lock); 14 printk(\u0026#34;entry: %lu, %pK, try %d\\n\u0026#34;, lock, \u0026amp;lock, t); // lock: 1, lock ptr: 0xffffaaabbb, 0 15 16 return; 17} 三、具体实现 # 1. bit_spin_lock # 就是最简单的test_and_set，将addr作为原子变量的指针操作\n1// include/linux/bit_spinlock.h 2/* 3 * bit-based spin_lock() 4 * 5 * Don\u0026#39;t use this unless you really need to: spin_lock() and spin_unlock() 6 * are significantly faster. 7 */ 8static inline void bit_spin_lock(int bitnum, unsigned long *addr) 9{ 10\t/* 11\t* Assuming the lock is uncontended, this never enters 12\t* the body of the outer loop. If it is contended, then 13\t* within the inner loop a non-atomic test is used to 14\t* busywait with less bus contention for a good time to 15\t* attempt to acquire the lock bit. 16\t*/ 17\tpreempt_disable(); 18#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK) 19\twhile (unlikely(test_and_set_bit_lock(bitnum, addr))) { 20\tpreempt_enable(); 21\tdo { 22\tcpu_relax(); 23\t} while (test_bit(bitnum, addr)); 24\tpreempt_disable(); 25\t} 26#endif 27\t__acquire(bitlock); 28} 29 30// include/asm-generic/bitops/lock.h 31/** 32 * test_and_set_bit_lock - Set a bit and return its old value, for lock 33 * @nr: Bit to set 34 * @addr: Address to count from 35 * 36 * This operation is atomic and provides acquire barrier semantics if 37 * the returned value is 0. 38 * It can be used to implement bit locks. 39 */ 40static inline int test_and_set_bit_lock(unsigned int nr, 41\tvolatile unsigned long *p) 42{ 43\tlong old; 44\tunsigned long mask = BIT_MASK(nr); 45 46\tp += BIT_WORD(nr); 47\tif (READ_ONCE(*p) \u0026amp; mask) 48\treturn 1; 49 50\told = atomic_long_fetch_or_acquire(mask, (atomic_long_t *)p); 51\treturn !!(old \u0026amp; mask); 52} 2. bit_spin_trylock # 1// include/linux/bit_spinlock.h 2/* 3 * Return true if it was acquired 4 */ 5static inline int bit_spin_trylock(int bitnum, unsigned long *addr) 6{ 7\tpreempt_disable(); 8#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK) 9\tif (unlikely(test_and_set_bit_lock(bitnum, addr))) { 10\tpreempt_enable(); 11\treturn 0; 12\t} 13#endif 14\t__acquire(bitlock); 15\treturn 1; 16} 3. bit_spin_unlock # 1// include/linux/bit_spinlock.h 2/* 3 * bit-based spin_unlock() 4 */ 5static inline void bit_spin_unlock(int bitnum, unsigned long *addr) 6{ 7#ifdef CONFIG_DEBUG_SPINLOCK 8\tBUG_ON(!test_bit(bitnum, addr)); 9#endif 10#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK) 11\tclear_bit_unlock(bitnum, addr); 12#endif 13\tpreempt_enable(); 14\t__release(bitlock); 15} 4. bit_spin_is_locked # 1// include/linux/bit_spinlock.h 2/* 3 * Return true if the lock is held. 4 */ 5static inline int bit_spin_is_locked(int bitnum, unsigned long *addr) 6{ 7#if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK) 8\treturn test_bit(bitnum, addr); 9#elif defined CONFIG_PREEMPT_COUNT 10\treturn preempt_count(); 11#else 12\treturn 1; 13#endif 14} "},{"id":193,"href":"/docs/openssl/ssl/certificate/","title":"Certificate","section":"ssl ssl协议相关","content":" 一、构造请求 # 1. 构造服务端证书 # 2. 构造客户端证书 # 1/* 到这一步的堆栈信息 2libssl.so.3!tls_construct_client_certificate(SSL * s, WPACKET * pkt) (/ssl/statem/statem_clnt.c:3504) 3libssl.so.3!write_state_machine(SSL * s) (/ssl/statem/statem.c:855) 4libssl.so.3!state_machine(SSL * s, int server) (/ssl/statem/statem.c:451) 5libssl.so.3!ossl_statem_connect(SSL * s) (/ssl/statem/statem.c:265) 6libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (/ssl/record/rec_layer_s3.c:398) 7libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (/ssl/s3_lib.c:4449) 8libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (/ssl/ssl_lib.c:2062) 9libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (/ssl/ssl_lib.c:2140) 10s_client_main(int argc, char ** argv) (/apps/s_client.c:2841) 11do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (/apps/openssl.c:418) 12main(int argc, char ** argv) (/apps/openssl.c:298) 13 */ 14// ssl/statem/statem_clnt.c 15int tls_construct_client_certificate(SSL *s, WPACKET *pkt) 16{ 17 if (SSL_IS_TLS13(s)) { 18 if (s-\u0026gt;pha_context == NULL) { 19 /* no context available, add 0-length context */ 20 if (!WPACKET_put_bytes_u8(pkt, 0)) { 21 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 22 return 0; 23 } 24 } else if (!WPACKET_sub_memcpy_u8(pkt, s-\u0026gt;pha_context, s-\u0026gt;pha_context_len)) { 25 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 26 return 0; 27 } 28 } 29 if (!ssl3_output_cert_chain(s, pkt, 30 (s-\u0026gt;s3.tmp.cert_req == 2) ? NULL 31 : s-\u0026gt;cert-\u0026gt;key)) { 32 /* SSLfatal() already called */ 33 return 0; 34 } 35 36 if (SSL_IS_TLS13(s) 37 \u0026amp;\u0026amp; SSL_IS_FIRST_HANDSHAKE(s) 38 \u0026amp;\u0026amp; (!s-\u0026gt;method-\u0026gt;ssl3_enc-\u0026gt;change_cipher_state(s, 39 SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) { 40 /* 41 * This is a fatal error, which leaves enc_write_ctx in an inconsistent 42 * state and thus ssl3_send_alert may crash. 43 */ 44 SSLfatal(s, SSL_AD_NO_ALERT, SSL_R_CANNOT_CHANGE_CIPHER); 45 return 0; 46 } 47 48 return 1; 49} 二、处理请求 # 1. 客户端收到服务端的Certificate # 1.1. 证书完整性校验 # 1/* 2libcrypto.so.3!internal_verify(X509_STORE_CTX * ctx) (crypto/x509/x509_vfy.c:1823) 3libcrypto.so.3!verify_chain(X509_STORE_CTX * ctx) (crypto/x509/x509_vfy.c:229) 4libcrypto.so.3!X509_verify_cert(X509_STORE_CTX * ctx) (crypto/x509/x509_vfy.c:295) 5libssl.so.3!ssl_verify_cert_chain(SSL * s, struct stack_st_X509 * sk) (ssl/ssl_cert.c:446) 6libssl.so.3!tls_post_process_server_certificate(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:1870) 7libssl.so.3!ossl_statem_client_post_process_message(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:1085) 8libssl.so.3!read_state_machine(SSL * s) (ssl/statem/statem.c:675) 9libssl.so.3!state_machine(SSL * s, int server) (ssl/statem/statem.c:442) 10libssl.so.3!ossl_statem_connect(SSL * s) (ssl/statem/statem.c:265) 11libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (ssl/record/rec_layer_s3.c:398) 12libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (ssl/s3_lib.c:4449) 13libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (ssl/ssl_lib.c:2062) 14libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (ssl/ssl_lib.c:2140) 15s_client_main(int argc, char ** argv) (apps/s_client.c:2841) 16do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (apps/openssl.c:418) 17main(int argc, char ** argv) (apps/openssl.c:298) 18 */ 19/* 20 * Verify the issuer signatures and cert times of ctx-\u0026gt;chain. 21 * Sadly, returns 0 also on internal error. 22 */ 23static int internal_verify(X509_STORE_CTX *ctx) 24{ 25 int n = sk_X509_num(ctx-\u0026gt;chain) - 1; 26 X509 *xi = sk_X509_value(ctx-\u0026gt;chain, n); 27 X509 *xs = xi; 28 29 ctx-\u0026gt;error_depth = n; 30 if (ctx-\u0026gt;bare_ta_signed) { 31 /* 32 * With DANE-verified bare public key TA signatures, 33 * on the top certificate we check only the timestamps. 34 * We report the issuer as NULL because all we have is a bare key. 35 */ 36 xi = NULL; 37 } else if (ossl_x509_likely_issued(xi, xi) != X509_V_OK 38 /* exceptional case: last cert in the chain is not self-issued */ 39 \u0026amp;\u0026amp; ((ctx-\u0026gt;param-\u0026gt;flags \u0026amp; X509_V_FLAG_PARTIAL_CHAIN) == 0)) { 40 if (n \u0026gt; 0) { 41 n--; 42 ctx-\u0026gt;error_depth = n; 43 xs = sk_X509_value(ctx-\u0026gt;chain, n); 44 } else { 45 CB_FAIL_IF(1, ctx, xi, 0, 46 X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE); 47 } 48 /* 49 * The below code will certainly not do a 50 * self-signature check on xi because it is not self-issued. 51 */ 52 } 53 54 /* 55 * Do not clear error (by ctx-\u0026gt;error = X509_V_OK), it must be \u0026#34;sticky\u0026#34;, 56 * only the user\u0026#39;s callback is allowed to reset errors (at its own peril). 57 */ 58 while (n \u0026gt;= 0) { 59 /*- 60 * For each iteration of this loop: 61 * n is the subject depth 62 * xs is the subject cert, for which the signature is to be checked 63 * xi is NULL for DANE-verified bare public key TA signatures 64 * else the supposed issuer cert containing the public key to use 65 * Initially xs == xi if the last cert in the chain is self-issued. 66 */ 67 /* 68 * Do signature check for self-signed certificates only if explicitly 69 * asked for because it does not add any security and just wastes time. 70 */ 71 if (xi != NULL 72 \u0026amp;\u0026amp; (xs != xi 73 || ((ctx-\u0026gt;param-\u0026gt;flags \u0026amp; X509_V_FLAG_CHECK_SS_SIGNATURE) != 0 74 \u0026amp;\u0026amp; (xi-\u0026gt;ex_flags \u0026amp; EXFLAG_SS) != 0))) { 75 EVP_PKEY *pkey; 76 /* 77 * If the issuer\u0026#39;s public key is not available or its key usage 78 * does not support issuing the subject cert, report the issuer 79 * cert and its depth (rather than n, the depth of the subject). 80 */ 81 int issuer_depth = n + (xs == xi ? 0 : 1); 82 /* 83 * According to https://tools.ietf.org/html/rfc5280#section-6.1.4 84 * step (n) we must check any given key usage extension in a CA cert 85 * when preparing the verification of a certificate issued by it. 86 * According to https://tools.ietf.org/html/rfc5280#section-4.2.1.3 87 * we must not verify a certificate signature if the key usage of 88 * the CA certificate that issued the certificate prohibits signing. 89 * In case the \u0026#39;issuing\u0026#39; certificate is the last in the chain and is 90 * not a CA certificate but a \u0026#39;self-issued\u0026#39; end-entity cert (i.e., 91 * xs == xi \u0026amp;\u0026amp; !(xi-\u0026gt;ex_flags \u0026amp; EXFLAG_CA)) RFC 5280 does not apply 92 * (see https://tools.ietf.org/html/rfc6818#section-2) and thus 93 * we are free to ignore any key usage restrictions on such certs. 94 */ 95 int ret = xs == xi \u0026amp;\u0026amp; (xi-\u0026gt;ex_flags \u0026amp; EXFLAG_CA) == 0 96 ? X509_V_OK : ossl_x509_signing_allowed(xi, xs); 97 98 CB_FAIL_IF(ret != X509_V_OK, ctx, xi, issuer_depth, ret); 99 // 获取公钥 100 if ((pkey = X509_get0_pubkey(xi)) == NULL) { 101 CB_FAIL_IF(1, ctx, xi, issuer_depth, 102 X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY); 103 } else { 104 // 对证书的签名信息使用公钥做完整性校验 105 CB_FAIL_IF(X509_verify(xs, pkey) \u0026lt;= 0, 106 ctx, xs, n, X509_V_ERR_CERT_SIGNATURE_FAILURE); 107 } 108 } 109 110 /* In addition to RFC 5280 requirements do also for trust anchor cert */ 111 /* Calls verify callback as needed */ 112 if (!ossl_x509_check_cert_time(ctx, xs, n)) 113 return 0; 114 115 /* 116 * Signal success at this depth. However, the previous error (if any) 117 * is retained. 118 */ 119 ctx-\u0026gt;current_issuer = xi; 120 ctx-\u0026gt;current_cert = xs; 121 ctx-\u0026gt;error_depth = n; 122 if (!ctx-\u0026gt;verify_cb(1, ctx)) 123 return 0; 124 125 if (--n \u0026gt;= 0) { 126 xi = xs; 127 xs = sk_X509_value(ctx-\u0026gt;chain, n); 128 } 129 } 130 return 1; 131} "},{"id":194,"href":"/docs/openssl/ssl/certificateVerify/","title":"Certificate Verify","section":"ssl ssl协议相关","content":" 一、构造请求 # 1// ssl/statem/statem_lib.c 2int tls_construct_cert_verify(SSL *s, WPACKET *pkt) 3{ 4 EVP_PKEY *pkey = NULL; 5 const EVP_MD *md = NULL; 6 EVP_MD_CTX *mctx = NULL; 7 EVP_PKEY_CTX *pctx = NULL; 8 size_t hdatalen = 0, siglen = 0; 9 void *hdata; 10 unsigned char *sig = NULL; 11 unsigned char tls13tbs[TLS13_TBS_PREAMBLE_SIZE + EVP_MAX_MD_SIZE]; 12 const SIGALG_LOOKUP *lu = s-\u0026gt;s3.tmp.sigalg; 13 14 if (lu == NULL || s-\u0026gt;s3.tmp.cert == NULL) { 15 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 16 goto err; 17 } 18 // 从证书中取私钥用于签名 19 pkey = s-\u0026gt;s3.tmp.cert-\u0026gt;privatekey; 20 21 if (pkey == NULL || !tls1_lookup_md(s-\u0026gt;ctx, lu, \u0026amp;md)) { 22 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 23 goto err; 24 } 25 26 mctx = EVP_MD_CTX_new(); 27 if (mctx == NULL) { 28 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE); 29 goto err; 30 } 31 32 /* Get the data to be signed */ 33 // 获取要用于签名的数据 34 if (!get_cert_verify_tbs_data(s, tls13tbs, \u0026amp;hdata, \u0026amp;hdatalen)) { 35 /* SSLfatal() already called */ 36 goto err; 37 } 38 39 if (SSL_USE_SIGALGS(s) \u0026amp;\u0026amp; !WPACKET_put_bytes_u16(pkt, lu-\u0026gt;sigalg)) { 40 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 41 goto err; 42 } 43 44 // 做签名的准备 45 if (EVP_DigestSignInit_ex(mctx, \u0026amp;pctx, 46 md == NULL ? NULL : EVP_MD_get0_name(md), 47 s-\u0026gt;ctx-\u0026gt;libctx, s-\u0026gt;ctx-\u0026gt;propq, pkey, 48 NULL) \u0026lt;= 0) { 49 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 50 goto err; 51 } 52 53 if (lu-\u0026gt;sig == EVP_PKEY_RSA_PSS) { 54 if (EVP_PKEY_CTX_set_rsa_padding(pctx, RSA_PKCS1_PSS_PADDING) \u0026lt;= 0 55 || EVP_PKEY_CTX_set_rsa_pss_saltlen(pctx, 56 RSA_PSS_SALTLEN_DIGEST) \u0026lt;= 0) { 57 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 58 goto err; 59 } 60 } 61 62 // 根据版本做不同的签名信息 63 if (s-\u0026gt;version == SSL3_VERSION) { 64 /* 65 * Here we use EVP_DigestSignUpdate followed by EVP_DigestSignFinal 66 * in order to add the EVP_CTRL_SSL3_MASTER_SECRET call between them. 67 */ 68 if (EVP_DigestSignUpdate(mctx, hdata, hdatalen) \u0026lt;= 0 69 || EVP_MD_CTX_ctrl(mctx, EVP_CTRL_SSL3_MASTER_SECRET, 70 (int)s-\u0026gt;session-\u0026gt;master_key_length, 71 s-\u0026gt;session-\u0026gt;master_key) \u0026lt;= 0 72 || EVP_DigestSignFinal(mctx, NULL, \u0026amp;siglen) \u0026lt;= 0) { 73 74 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 75 goto err; 76 } 77 sig = OPENSSL_malloc(siglen); 78 if (sig == NULL 79 || EVP_DigestSignFinal(mctx, sig, \u0026amp;siglen) \u0026lt;= 0) { 80 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 81 goto err; 82 } 83 } else { 84 /* 85 * Here we *must* use EVP_DigestSign() because Ed25519/Ed448 does not 86 * support streaming via EVP_DigestSignUpdate/EVP_DigestSignFinal 87 */ 88 if (EVP_DigestSign(mctx, NULL, \u0026amp;siglen, hdata, hdatalen) \u0026lt;= 0) { 89 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 90 goto err; 91 } 92 sig = OPENSSL_malloc(siglen); 93 if (sig == NULL 94 || EVP_DigestSign(mctx, sig, \u0026amp;siglen, hdata, hdatalen) \u0026lt;= 0) { 95 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_EVP_LIB); 96 goto err; 97 } 98 } 99 100#ifndef OPENSSL_NO_GOST 101 { 102 int pktype = lu-\u0026gt;sig; 103 104 if (pktype == NID_id_GostR3410_2001 105 || pktype == NID_id_GostR3410_2012_256 106 || pktype == NID_id_GostR3410_2012_512) 107 BUF_reverse(sig, NULL, siglen); 108 } 109#endif 110 111 // 把签名信息放到包里面 112 if (!WPACKET_sub_memcpy_u16(pkt, sig, siglen)) { 113 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 114 goto err; 115 } 116 117 /* Digest cached records and discard handshake buffer */ 118 if (!ssl3_digest_cached_records(s, 0)) { 119 /* SSLfatal() already called */ 120 goto err; 121 } 122 123 OPENSSL_free(sig); 124 EVP_MD_CTX_free(mctx); 125 return 1; 126 err: 127 OPENSSL_free(sig); 128 EVP_MD_CTX_free(mctx); 129 return 0; 130} 获取certificate verify的用于签名的数据 1// ssl/statem/statem_lib.c 2/* 3 * Size of the to-be-signed TLS13 data, without the hash size itself: 4 * 64 bytes of value 32, 33 context bytes, 1 byte separator 5 */ 6#define TLS13_TBS_START_SIZE 64 7#define TLS13_TBS_PREAMBLE_SIZE (TLS13_TBS_START_SIZE + 33 + 1) 8 9static int get_cert_verify_tbs_data(SSL *s, unsigned char *tls13tbs, 10 void **hdata, size_t *hdatalen) 11{ 12 /* ASCII: \u0026#34;TLS 1.3, server CertificateVerify\u0026#34;, in hex for EBCDIC compatibility */ 13 static const char servercontext[] = \u0026#34;\\x54\\x4c\\x53\\x20\\x31\\x2e\\x33\\x2c\\x20\\x73\\x65\\x72\u0026#34; 14 \u0026#34;\\x76\\x65\\x72\\x20\\x43\\x65\\x72\\x74\\x69\\x66\\x69\\x63\\x61\\x74\\x65\\x56\\x65\\x72\\x69\\x66\\x79\u0026#34;; 15 /* ASCII: \u0026#34;TLS 1.3, client CertificateVerify\u0026#34;, in hex for EBCDIC compatibility */ 16 static const char clientcontext[] = \u0026#34;\\x54\\x4c\\x53\\x20\\x31\\x2e\\x33\\x2c\\x20\\x63\\x6c\\x69\u0026#34; 17 \u0026#34;\\x65\\x6e\\x74\\x20\\x43\\x65\\x72\\x74\\x69\\x66\\x69\\x63\\x61\\x74\\x65\\x56\\x65\\x72\\x69\\x66\\x79\u0026#34;; 18 19 if (SSL_IS_TLS13(s)) { 20 size_t hashlen; 21 22 /* Set the first 64 bytes of to-be-signed data to octet 32 */ 23 memset(tls13tbs, 32, TLS13_TBS_START_SIZE); 24 /* This copies the 33 bytes of context plus the 0 separator byte */ 25 if (s-\u0026gt;statem.hand_state == TLS_ST_CR_CERT_VRFY 26 || s-\u0026gt;statem.hand_state == TLS_ST_SW_CERT_VRFY) 27 strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, servercontext); 28 else 29 strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, clientcontext); 30 31 /* 32 * If we\u0026#39;re currently reading then we need to use the saved handshake 33 * hash value. We can\u0026#39;t use the current handshake hash state because 34 * that includes the CertVerify itself. 35 */ 36 if (s-\u0026gt;statem.hand_state == TLS_ST_CR_CERT_VRFY 37 || s-\u0026gt;statem.hand_state == TLS_ST_SR_CERT_VRFY) { 38 memcpy(tls13tbs + TLS13_TBS_PREAMBLE_SIZE, s-\u0026gt;cert_verify_hash, 39 s-\u0026gt;cert_verify_hash_len); 40 hashlen = s-\u0026gt;cert_verify_hash_len; 41 } else if (!ssl_handshake_hash(s, tls13tbs + TLS13_TBS_PREAMBLE_SIZE, 42 EVP_MAX_MD_SIZE, \u0026amp;hashlen)) { 43 /* SSLfatal() already called */ 44 return 0; 45 } 46 47 *hdata = tls13tbs; 48 *hdatalen = TLS13_TBS_PREAMBLE_SIZE + hashlen; 49 } else { 50 size_t retlen; 51 long retlen_l; 52 53 // tls1.3之前使用握手缓冲区的数据作为要用于签名的数据 54 retlen = retlen_l = BIO_get_mem_data(s-\u0026gt;s3.handshake_buffer, hdata); 55 if (retlen_l \u0026lt;= 0) { 56 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 57 return 0; 58 } 59 *hdatalen = retlen; 60 } 61 62 return 1; 63} "},{"id":195,"href":"/docs/ai/nlp/dga_domain_detect/","title":"dga域名识别","section":"AI相关","content":" https://xz.aliyun.com/t/10522?time__1311=mq%2BxBDyGDQe4nDBkP1mckDmhllGOQeD https://www.cnblogs.com/LHWorldBlog/p/9195623.html https://zhuanlan.zhihu.com/p/562983875 https://blog.csdn.net/weixin_43298886/article/details/109523109 https://www.fx361.com/page/2022/0712/14907807.shtml https://www.zhihu.com/tardis/zm/art/268886634?source_id=1005 https://zhuanlan.zhihu.com/p/645227922 https://www.modb.pro/db/99980 https://zhuanlan.zhihu.com/p/59483058 https://zhuanlan.zhihu.com/p/392406205\n"},{"id":196,"href":"/docs/glibc/nss/hosts/dns/","title":"dns 根据/etc/resolv.conf发包处理","section":"hosts dns解析服务","content":" gethostbyname # dns的一些系统行为 # 具体代码看 发送udp包给一个dns服务器 1. 什么情况下使用下一个dns服务器，当前结果直接丢弃 # 当前dns服务器接收失败（网络错误，收包错误等） dns服务器返回serverfail、notimplement、refused dns服务器返回正常的情况下，下面条件都满足就尝试下一个 answer为空 当前dns服务器不是authoritive answer 当前dns服务器不能递归查询 resource为空 2. 什么情况下使用tcp进行发送dns # 返回响应中有tc字段为1 源码 # 从_nss_dns_gethostbyname3_r开始 1// resolv/nss_dns/dns-host.c 2enum nss_status 3_nss_dns_gethostbyname3_r (const char *name, int af, struct hostent *result, 4\tchar *buffer, size_t buflen, int *errnop, 5\tint *h_errnop, int32_t *ttlp, char **canonp) 6{ 7 struct resolv_context *ctx = __resolv_context_get (); 8 if (ctx == NULL) 9 { 10 *errnop = errno; 11 *h_errnop = NETDB_INTERNAL; 12 return NSS_STATUS_UNAVAIL; 13 } 14 enum nss_status status = gethostbyname3_context 15 (ctx, name, af, result, buffer, buflen, errnop, h_errnop, ttlp, canonp); 16 __resolv_context_put (ctx); 17 return status; 18} 19libc_hidden_def (_nss_dns_gethostbyname3_r) 1. 如何读取/etc/resolv.conf # 获取struct resolv_context *ctx 1// resolv/resolv_context.c 2struct resolv_context * 3__resolv_context_get (void) 4{ 5 return context_get (false); 6} 7libc_hidden_def (__resolv_context_get) 8 9// resolv/resolv_context.c 10/* Backing function for the __resolv_context_get family of 11 functions. */ 12static struct resolv_context * 13context_get (bool preinit) 14{ 15 if (current != NULL) 16 return context_reuse (); 17 18\t// 这里的_res是一个全局线程安全的变量 19 struct resolv_context *ctx = context_alloc (\u0026amp;_res); 20 if (ctx == NULL) 21 return NULL; 22 if (!maybe_init (ctx, preinit)) 23 { 24 context_free (ctx); 25 return NULL; 26 } 27 return ctx; 28} 29 30// resolv/resolv_context.c 31/* Initialize *RESP if RES_INIT is not yet set in RESP-\u0026gt;options, or if 32 res_init in some other thread requested re-initializing. */ 33static __attribute__ ((warn_unused_result)) bool 34maybe_init (struct resolv_context *ctx, bool preinit) 35{ 36 struct __res_state *resp = ctx-\u0026gt;resp; 37 if (resp-\u0026gt;options \u0026amp; RES_INIT) 38 { 39 if (resp-\u0026gt;options \u0026amp; RES_NORELOAD) 40 /* Configuration reloading was explicitly disabled. */ 41 return true; 42 43 /* If there is no associated resolv_conf object despite the 44 initialization, something modified *ctx-\u0026gt;resp. Do not 45 override those changes. */ 46 if (ctx-\u0026gt;conf != NULL \u0026amp;\u0026amp; replicated_configuration_matches (ctx)) 47 { 48 struct resolv_conf *current = __resolv_conf_get_current (); 49 if (current == NULL) 50 return false; 51 52 /* Check if the configuration changed. */ 53 if (current != ctx-\u0026gt;conf) 54 { 55 /* This call will detach the extended resolver state. */ 56 if (resp-\u0026gt;nscount \u0026gt; 0) 57 __res_iclose (resp, true); 58 /* Reattach the current configuration. */ 59 if (__resolv_conf_attach (ctx-\u0026gt;resp, current)) 60 { 61 __resolv_conf_put (ctx-\u0026gt;conf); 62 /* ctx takes ownership, so we do not release current. */ 63 ctx-\u0026gt;conf = current; 64 } 65 } 66 else 67 /* No change. Drop the reference count for current. */ 68 __resolv_conf_put (current); 69 } 70 return true; 71 } 72 73 assert (ctx-\u0026gt;conf == NULL); 74 if (preinit) 75 { 76 if (!resp-\u0026gt;retrans) 77 resp-\u0026gt;retrans = RES_TIMEOUT; 78 if (!resp-\u0026gt;retry) 79 resp-\u0026gt;retry = RES_DFLRETRY; 80 resp-\u0026gt;options = RES_DEFAULT; 81 if (!resp-\u0026gt;id) 82 resp-\u0026gt;id = res_randomid (); 83 } 84 85 if (__res_vinit (resp, preinit) \u0026lt; 0) 86 return false; 87 ctx-\u0026gt;conf = __resolv_conf_get (ctx-\u0026gt;resp); 88 return true; 89} 调用__resolv_conf_get_current，里面会检测/etc/resolv.conf是否改变，改变则重新加载 1struct resolv_conf * 2__resolv_conf_get_current (void) 3{ 4 struct file_change_detection initial; 5 // 检测一下/etc/resolv.conf是否更改，结果存到initial中，返回的只是函数调用的成功或失败 6 if (!__file_change_detection_for_path (\u0026amp;initial, _PATH_RESCONF)) 7 return NULL; 8 9 struct resolv_conf_global *global_copy = get_locked_global (); 10 if (global_copy == NULL) 11 return NULL; 12 struct resolv_conf *conf; 13 if (global_copy-\u0026gt;conf_current != NULL 14 \u0026amp;\u0026amp; __file_is_unchanged (\u0026amp;initial, \u0026amp;global_copy-\u0026gt;file_resolve_conf)) 15 /* We can reuse the cached configuration object. */ 16 conf = global_copy-\u0026gt;conf_current; 17 else 18 { 19 /* Parse configuration while holding the lock. This avoids 20 duplicate work. */ 21 struct file_change_detection after_load; 22 conf = __resolv_conf_load (NULL, \u0026amp;after_load); 23 if (conf != NULL) 24 { 25 if (global_copy-\u0026gt;conf_current != NULL) 26 conf_decrement (global_copy-\u0026gt;conf_current); 27 global_copy-\u0026gt;conf_current = conf; /* Takes ownership. */ 28 29 /* Update file change detection data, but only if it matches 30 the initial measurement. This avoids an ABA race in case 31 /etc/resolv.conf is temporarily replaced while the file 32 is read (after the initial measurement), and restored to 33 the initial version later. */ 34 if (__file_is_unchanged (\u0026amp;initial, \u0026amp;after_load)) 35 global_copy-\u0026gt;file_resolve_conf = after_load; 36 else 37 /* If there is a discrepancy, trigger a reload during the 38 next use. */ 39 global_copy-\u0026gt;file_resolve_conf.size = -1; 40 } 41 } 42 43 if (conf != NULL) 44 { 45 /* Return an additional reference. */ 46 assert (conf-\u0026gt;__refcount \u0026gt; 0); 47 ++conf-\u0026gt;__refcount; 48 assert (conf-\u0026gt;__refcount \u0026gt; 0); 49 } 50 put_locked_global (global_copy); 51 return conf; 52} 重新加载会调用__resolv_conf_load加载配置打开/etc/resolv.conf 1// resolv/resolv.h 2#ifndef _PATH_RESCONF 3#define _PATH_RESCONF \u0026#34;/etc/resolv.conf\u0026#34; 4#endif 5 6// resolv/res_init.c 7struct resolv_conf * 8__resolv_conf_load (struct __res_state *preinit, 9 struct file_change_detection *change) 10{ 11 /* Ensure that /etc/hosts.conf has been loaded (once). */ 12 _res_hconf_init (); 13 14 FILE *fp = fopen (_PATH_RESCONF, \u0026#34;rce\u0026#34;); 15 if (fp == NULL) 16 switch (errno) 17 { 18 case EACCES: 19 case EISDIR: 20 case ELOOP: 21 case ENOENT: 22 case ENOTDIR: 23 case EPERM: 24 /* Ignore these errors. They are persistent errors caused 25 by file system contents. */ 26 break; 27 default: 28 /* Other errors refer to resource allocation problems and 29 need to be handled by the application. */ 30 return NULL; 31 } 32 33 struct resolv_conf_parser parser; 34 resolv_conf_parser_init (\u0026amp;parser, preinit); 35 36 struct resolv_conf *conf = NULL; 37 bool ok = res_vinit_1 (fp, \u0026amp;parser); 38 if (ok \u0026amp;\u0026amp; change != NULL) 39 /* Update the file change information if the configuration was 40 loaded successfully. */ 41 ok = __file_change_detection_for_fp (change, fp); 42 43 if (ok) 44 { 45 parser.template.nameserver_list 46 = nameserver_list_begin (\u0026amp;parser.nameserver_list); 47 parser.template.nameserver_list_size 48 = nameserver_list_size (\u0026amp;parser.nameserver_list); 49 parser.template.search_list = search_list_begin (\u0026amp;parser.search_list); 50 parser.template.search_list_size 51 = search_list_size (\u0026amp;parser.search_list); 52 parser.template.sort_list = sort_list_begin (\u0026amp;parser.sort_list); 53 parser.template.sort_list_size = sort_list_size (\u0026amp;parser.sort_list); 54 conf = __resolv_conf_allocate (\u0026amp;parser.template); 55 } 56 resolv_conf_parser_free (\u0026amp;parser); 57 58 if (fp != NULL) 59 { 60 int saved_errno = errno; 61 fclose (fp); 62 __set_errno (saved_errno); 63 } 64 65 return conf; 66} 处理/etc/resolv.conf # 格式化一下看 1// resolv/res_init.c 2/* Internal helper function for __res_vinit, to aid with resource 3 deallocation and error handling. Return true on success, false on 4 failure. */ 5static bool res_vinit_1(FILE *fp, struct resolv_conf_parser *parser) { 6 char *cp; 7 size_t buffer_size = 0; 8 bool haveenv = false; 9 10 /* Allow user to override the local domain definition. */ 11 if ((cp = getenv(\u0026#34;LOCALDOMAIN\u0026#34;)) != NULL) { 12 /* The code below splits the string in place. */ 13 cp = __strdup(cp); 14 if (cp == NULL) return false; 15 free(parser-\u0026gt;search_list_store); 16 parser-\u0026gt;search_list_store = cp; 17 haveenv = true; 18 19 /* The string will be truncated as needed below. */ 20 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 21 22 /* Set search list to be blank-separated strings from rest of 23 env value. Permits users of LOCALDOMAIN to still have a 24 search list, and anyone to set the one that they want to use 25 as an individual (even more important now that the rfc1535 26 stuff restricts searches). */ 27 for (bool in_name = true; *cp != \u0026#39;\\0\u0026#39;; cp++) { 28 if (*cp == \u0026#39;\\n\u0026#39;) { 29 *cp = \u0026#39;\\0\u0026#39;; 30 break; 31 } else if (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) { 32 *cp = \u0026#39;\\0\u0026#39;; 33 in_name = false; 34 } else if (!in_name) { 35 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 36 in_name = true; 37 } 38 } 39 } 40 41#define MATCH(line, name) \\ 42 (!strncmp((line), name, sizeof(name) - 1) \u0026amp;\u0026amp; ((line)[sizeof(name) - 1] == \u0026#39; \u0026#39; || (line)[sizeof(name) - 1] == \u0026#39;\\t\u0026#39;)) 43 44 if (fp != NULL) { 45 /* No threads use this stream. */ 46 __fsetlocking(fp, FSETLOCKING_BYCALLER); 47 /* Read the config file. */ 48 while (true) { 49 { 50 ssize_t ret = __getline(\u0026amp;parser-\u0026gt;buffer, \u0026amp;buffer_size, fp); 51 if (ret \u0026lt;= 0) { 52 if (_IO_ferror_unlocked(fp)) 53 return false; 54 else 55 break; 56 } 57 } 58 59 /* Skip comments. */ 60 if (*parser-\u0026gt;buffer == \u0026#39;;\u0026#39; || *parser-\u0026gt;buffer == \u0026#39;#\u0026#39;) continue; 61 /* Read default domain name. */ 62 if (MATCH(parser-\u0026gt;buffer, \u0026#34;domain\u0026#34;)) { 63 if (haveenv) /* LOCALDOMAIN overrides the configuration file. */ 64 continue; 65 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;domain\u0026#34;) - 1; 66 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 67 if ((*cp == \u0026#39;\\0\u0026#39;) || (*cp == \u0026#39;\\n\u0026#39;)) continue; 68 69 cp = __strdup(cp); 70 if (cp == NULL) return false; 71 free(parser-\u0026gt;search_list_store); 72 parser-\u0026gt;search_list_store = cp; 73 search_list_clear(\u0026amp;parser-\u0026gt;search_list); 74 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 75 /* Replace trailing whitespace. */ 76 if ((cp = strpbrk(cp, \u0026#34; \\t\\n\u0026#34;)) != NULL) *cp = \u0026#39;\\0\u0026#39;; 77 continue; 78 } 79 /* Set search list. */ 80 if (MATCH(parser-\u0026gt;buffer, \u0026#34;search\u0026#34;)) { 81 if (haveenv) /* LOCALDOMAIN overrides the configuration file. */ 82 continue; 83 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;search\u0026#34;) - 1; 84 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 85 if ((*cp == \u0026#39;\\0\u0026#39;) || (*cp == \u0026#39;\\n\u0026#39;)) continue; 86 87 { 88 char *p = strchr(cp, \u0026#39;\\n\u0026#39;); 89 if (p != NULL) *p = \u0026#39;\\0\u0026#39;; 90 } 91 cp = __strdup(cp); 92 if (cp == NULL) return false; 93 free(parser-\u0026gt;search_list_store); 94 parser-\u0026gt;search_list_store = cp; 95 96 /* The string is truncated below. */ 97 search_list_clear(\u0026amp;parser-\u0026gt;search_list); 98 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 99 100 /* Set search list to be blank-separated strings on rest 101 of line. */ 102 for (bool in_name = true; *cp != \u0026#39;\\0\u0026#39;; cp++) { 103 if (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) { 104 *cp = \u0026#39;\\0\u0026#39;; 105 in_name = false; 106 } else if (!in_name) { 107 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 108 in_name = true; 109 } 110 } 111 continue; 112 } 113 /* Read nameservers to query. */ 114 if (MATCH(parser-\u0026gt;buffer, \u0026#34;nameserver\u0026#34;)) { 115 struct in_addr a; 116 117 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;nameserver\u0026#34;) - 1; 118 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 119 120 /* Ignore trailing contents on the name server line. */ 121 { 122 char *el; 123 if ((el = strpbrk(cp, \u0026#34; \\t\\n\u0026#34;)) != NULL) *el = \u0026#39;\\0\u0026#39;; 124 } 125 126 struct sockaddr *sa; 127 if ((*cp != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (*cp != \u0026#39;\\n\u0026#39;) \u0026amp;\u0026amp; __inet_aton_exact(cp, \u0026amp;a)) { 128 sa = allocate_address_v4(a, NAMESERVER_PORT); 129 if (sa == NULL) return false; 130 } else { 131 struct in6_addr a6; 132 char *el; 133 if ((el = strchr(cp, SCOPE_DELIMITER)) != NULL) *el = \u0026#39;\\0\u0026#39;; 134 if ((*cp != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (__inet_pton(AF_INET6, cp, \u0026amp;a6) \u0026gt; 0)) { 135 struct sockaddr_in6 *sa6; 136 137 sa6 = malloc(sizeof(*sa6)); 138 if (sa6 == NULL) return false; 139 140 sa6-\u0026gt;sin6_family = AF_INET6; 141 sa6-\u0026gt;sin6_port = htons(NAMESERVER_PORT); 142 sa6-\u0026gt;sin6_flowinfo = 0; 143 sa6-\u0026gt;sin6_addr = a6; 144 145 sa6-\u0026gt;sin6_scope_id = 0; 146 if (__glibc_likely(el != NULL)) 147 /* Ignore errors, for backwards 148 compatibility. */ 149 __inet6_scopeid_pton(\u0026amp;a6, el + 1, \u0026amp;sa6-\u0026gt;sin6_scope_id); 150 sa = (struct sockaddr *)sa6; 151 } else 152 /* IPv6 address parse failure. */ 153 sa = NULL; 154 } 155 if (sa != NULL) { 156 const struct sockaddr **p = nameserver_list_emplace(\u0026amp;parser-\u0026gt;nameserver_list); 157 if (p != NULL) 158 *p = sa; 159 else { 160 free(sa); 161 return false; 162 } 163 } 164 continue; 165 } 166 if (MATCH(parser-\u0026gt;buffer, \u0026#34;sortlist\u0026#34;)) { 167 struct in_addr a; 168 169 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;sortlist\u0026#34;) - 1; 170 while (true) { 171 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 172 if (*cp == \u0026#39;\\0\u0026#39; || *cp == \u0026#39;\\n\u0026#39; || *cp == \u0026#39;;\u0026#39;) break; 173 char *net = cp; 174 while (*cp \u0026amp;\u0026amp; !is_sort_mask(*cp) \u0026amp;\u0026amp; *cp != \u0026#39;;\u0026#39; \u0026amp;\u0026amp; isascii(*cp) \u0026amp;\u0026amp; !isspace(*cp)) cp++; 175 char separator = *cp; 176 *cp = 0; 177 struct resolv_sortlist_entry e; 178 if (__inet_aton_exact(net, \u0026amp;a)) { 179 e.addr = a; 180 if (is_sort_mask(separator)) { 181 *cp++ = separator; 182 net = cp; 183 while (*cp \u0026amp;\u0026amp; *cp != \u0026#39;;\u0026#39; \u0026amp;\u0026amp; isascii(*cp) \u0026amp;\u0026amp; !isspace(*cp)) cp++; 184 separator = *cp; 185 *cp = 0; 186 if (__inet_aton_exact(net, \u0026amp;a)) 187 e.mask = a.s_addr; 188 else 189 e.mask = net_mask(e.addr); 190 } else 191 e.mask = net_mask(e.addr); 192 sort_list_add(\u0026amp;parser-\u0026gt;sort_list, e); 193 } 194 *cp = separator; 195 } 196 continue; 197 } 198 if (MATCH(parser-\u0026gt;buffer, \u0026#34;options\u0026#34;)) { 199 res_setoptions(parser, parser-\u0026gt;buffer + sizeof(\u0026#34;options\u0026#34;) - 1); 200 continue; 201 } 202 } 203 } 204 if (__glibc_unlikely(nameserver_list_size(\u0026amp;parser-\u0026gt;nameserver_list) == 0)) { 205 const struct sockaddr **p = nameserver_list_emplace(\u0026amp;parser-\u0026gt;nameserver_list); 206 if (p == NULL) return false; 207 *p = allocate_address_v4(__inet_makeaddr(IN_LOOPBACKNET, 1), NAMESERVER_PORT); 208 if (*p == NULL) return false; 209 } 210 211 if (search_list_size(\u0026amp;parser-\u0026gt;search_list) == 0) { 212 char *domain; 213 if (!domain_from_hostname(\u0026amp;domain)) return false; 214 if (domain != NULL) { 215 free(parser-\u0026gt;search_list_store); 216 parser-\u0026gt;search_list_store = domain; 217 search_list_add(\u0026amp;parser-\u0026gt;search_list, domain); 218 } 219 } 220 221 if ((cp = getenv(\u0026#34;RES_OPTIONS\u0026#34;)) != NULL) res_setoptions(parser, cp); 222 223 if (nameserver_list_has_failed(\u0026amp;parser-\u0026gt;nameserver_list) || search_list_has_failed(\u0026amp;parser-\u0026gt;search_list) || 224 sort_list_has_failed(\u0026amp;parser-\u0026gt;sort_list)) { 225 __set_errno(ENOMEM); 226 return false; 227 } 228 229 return true; 230} 2. 如何发包 # 调用gethostbyname3_context，格式化了一下，之前的缩进太难看懂 1// resolv/nss_dns/dns-host.c 2static enum nss_status gethostbyname3_context(struct resolv_context *ctx, const char *name, int af, 3 struct hostent *result, char *buffer, size_t buflen, int *errnop, 4 int *h_errnop, int32_t *ttlp, char **canonp) { 5 union { 6 querybuf *buf; 7 u_char *ptr; 8 } host_buffer; 9 querybuf *orig_host_buffer; 10 char tmp[NS_MAXDNAME]; 11 int size, type, n; 12 const char *cp; 13 int map = 0; 14 int olderr = errno; 15 enum nss_status status; 16 17 switch (af) { 18 case AF_INET: 19 size = INADDRSZ; 20 type = T_A; 21 break; 22 case AF_INET6: 23 size = IN6ADDRSZ; 24 type = T_AAAA; 25 break; 26 default: 27 *h_errnop = NO_DATA; 28 *errnop = EAFNOSUPPORT; 29 return NSS_STATUS_UNAVAIL; 30 } 31 32 result-\u0026gt;h_addrtype = af; 33 result-\u0026gt;h_length = size; 34 35 /* 36 * if there aren\u0026#39;t any dots, it could be a user-level alias. 37 * this is also done in res_query() since we are not the only 38 * function that looks up host names. 39 */ 40 if (strchr(name, \u0026#39;.\u0026#39;) == NULL \u0026amp;\u0026amp; (cp = __res_context_hostalias(ctx, name, tmp, sizeof(tmp))) != NULL) name = cp; 41 42 host_buffer.buf = orig_host_buffer = (querybuf *)alloca(1024); 43 44 // 这里发起dns请求 45 n = __res_context_search(ctx, name, C_IN, type, host_buffer.buf-\u0026gt;buf, 1024, \u0026amp;host_buffer.ptr, NULL, NULL, NULL, 46 NULL); 47 if (n \u0026lt; 0) { 48 switch (errno) { 49 case ESRCH: 50 status = NSS_STATUS_TRYAGAIN; 51 h_errno = TRY_AGAIN; 52 break; 53 /* System has run out of file descriptors. */ 54 case EMFILE: 55 case ENFILE: 56 h_errno = NETDB_INTERNAL; 57 /* Fall through. */ 58 case ECONNREFUSED: 59 case ETIMEDOUT: 60 status = NSS_STATUS_UNAVAIL; 61 break; 62 default: 63 status = NSS_STATUS_NOTFOUND; 64 break; 65 } 66 *h_errnop = h_errno; 67 if (h_errno == TRY_AGAIN) 68 *errnop = EAGAIN; 69 else 70 __set_errno(olderr); 71 72 /* If we are looking for an IPv6 address and mapping is enabled 73 by having the RES_USE_INET6 bit in _res.options set, we try 74 another lookup. */ 75 if (af == AF_INET6 \u0026amp;\u0026amp; res_use_inet6()) 76 n = __res_context_search(ctx, name, C_IN, T_A, host_buffer.buf-\u0026gt;buf, 77 host_buffer.buf != orig_host_buffer ? MAXPACKET : 1024, \u0026amp;host_buffer.ptr, NULL, 78 NULL, NULL, NULL); 79 80 if (n \u0026lt; 0) { 81 if (host_buffer.buf != orig_host_buffer) free(host_buffer.buf); 82 return status; 83 } 84 85 map = 1; 86 87 result-\u0026gt;h_addrtype = AF_INET; 88 result-\u0026gt;h_length = INADDRSZ; 89 } 90 91 // 处理一下dns响应结果 92 status = 93 getanswer_r(ctx, host_buffer.buf, n, name, type, result, buffer, buflen, errnop, h_errnop, map, ttlp, canonp); 94 if (host_buffer.buf != orig_host_buffer) free(host_buffer.buf); 95 return status; 96} 到__res_context_search进行处理发送dns请求 1// resolv/res_query.c 2/* Formulate a normal query, send, and retrieve answer in supplied 3 buffer. Return the size of the response on success, -1 on error. 4 If enabled, implement search rules until answer or unrecoverable 5 failure is detected. Error code, if any, is left in h_errno. */ 6int 7__res_context_search (struct resolv_context *ctx, 8\tconst char *name, int class, int type, 9\tunsigned char *answer, int anslen, 10\tunsigned char **answerp, unsigned char **answerp2, 11\tint *nanswerp2, int *resplen2, int *answerp2_malloced) 12{ 13\tstruct __res_state *statp = ctx-\u0026gt;resp; 14\tconst char *cp; 15\tUHEADER *hp = (UHEADER *) answer; 16\tchar tmp[NS_MAXDNAME]; 17\tu_int dots; 18\tint trailing_dot, ret, saved_herrno; 19\tint got_nodata = 0, got_servfail = 0, root_on_list = 0; 20\tint tried_as_is = 0; 21\tint searched = 0; 22 23\t__set_errno (0); 24\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND); /* True if we never query. */ 25 26\tdots = 0; 27\tfor (cp = name; *cp != \u0026#39;\\0\u0026#39;; cp++) 28\tdots += (*cp == \u0026#39;.\u0026#39;); 29\ttrailing_dot = 0; 30\tif (cp \u0026gt; name \u0026amp;\u0026amp; *--cp == \u0026#39;.\u0026#39;) 31\ttrailing_dot++; 32 33\t/* If there aren\u0026#39;t any dots, it could be a user-level alias. */ 34\tif (!dots \u0026amp;\u0026amp; (cp = __res_context_hostalias 35\t(ctx, name, tmp, sizeof tmp))!= NULL) 36\treturn __res_context_query (ctx, cp, class, type, answer, 37\tanslen, answerp, answerp2, 38\tnanswerp2, resplen2, answerp2_malloced); 39 40\t/* 41\t* If there are enough dots in the name, let\u0026#39;s just give it a 42\t* try \u0026#39;as is\u0026#39;. The threshold can be set with the \u0026#34;ndots\u0026#34; option. 43\t* Also, query \u0026#39;as is\u0026#39;, if there is a trailing dot in the name. 44\t*/ 45\tsaved_herrno = -1; 46\tif (dots \u0026gt;= statp-\u0026gt;ndots || trailing_dot) { 47\tret = __res_context_querydomain (ctx, name, NULL, class, type, 48\tanswer, anslen, answerp, 49\tanswerp2, nanswerp2, resplen2, 50\tanswerp2_malloced); 51\tif (ret \u0026gt; 0 || trailing_dot 52\t/* If the second response is valid then we use that. */ 53\t|| (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL \u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 54\treturn (ret); 55\tsaved_herrno = h_errno; 56\ttried_as_is++; 57\tif (answerp \u0026amp;\u0026amp; *answerp != answer) { 58\tanswer = *answerp; 59\tanslen = MAXPACKET; 60\t} 61\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 62\t{ 63\tfree (*answerp2); 64\t*answerp2 = NULL; 65\t*nanswerp2 = 0; 66\t*answerp2_malloced = 0; 67\t} 68\t} 69 70\t/* 71\t* We do at least one level of search if 72\t*\t- there is no dot and RES_DEFNAME is set, or 73\t*\t- there is at least one dot, there is no trailing dot, 74\t*\tand RES_DNSRCH is set. 75\t*/ 76\tif ((!dots \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_DEFNAMES) != 0) || 77\t(dots \u0026amp;\u0026amp; !trailing_dot \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_DNSRCH) != 0)) { 78\tint done = 0; 79 80\tfor (size_t domain_index = 0; !done; ++domain_index) { 81\tconst char *dname = __resolv_context_search_list 82\t(ctx, domain_index); 83\tif (dname == NULL) 84\tbreak; 85\tsearched = 1; 86 87\t/* __res_context_querydoman concatenates name 88\twith dname with a \u0026#34;.\u0026#34; in between. If we 89\tpass it in dname the \u0026#34;.\u0026#34; we got from the 90\tconfigured default search path, we\u0026#39;ll end 91\tup with \u0026#34;name..\u0026#34;, which won\u0026#39;t resolve. 92\tOTOH, passing it \u0026#34;\u0026#34; will result in \u0026#34;name.\u0026#34;, 93\twhich has the intended effect for both 94\tpossible representations of the root 95\tdomain. */ 96\tif (dname[0] == \u0026#39;.\u0026#39;) 97\tdname++; 98\tif (dname[0] == \u0026#39;\\0\u0026#39;) 99\troot_on_list++; 100 101\tret = __res_context_querydomain 102\t(ctx, name, dname, class, type, 103\tanswer, anslen, answerp, answerp2, nanswerp2, 104\tresplen2, answerp2_malloced); 105\tif (ret \u0026gt; 0 || (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL 106\t\u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 107\treturn (ret); 108 109\tif (answerp \u0026amp;\u0026amp; *answerp != answer) { 110\tanswer = *answerp; 111\tanslen = MAXPACKET; 112\t} 113\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 114\t{ 115\tfree (*answerp2); 116\t*answerp2 = NULL; 117\t*nanswerp2 = 0; 118\t*answerp2_malloced = 0; 119\t} 120 121\t/* 122\t* If no server present, give up. 123\t* If name isn\u0026#39;t found in this domain, 124\t* keep trying higher domains in the search list 125\t* (if that\u0026#39;s enabled). 126\t* On a NO_DATA error, keep trying, otherwise 127\t* a wildcard entry of another type could keep us 128\t* from finding this entry higher in the domain. 129\t* If we get some other error (negative answer or 130\t* server failure), then stop searching up, 131\t* but try the input name below in case it\u0026#39;s 132\t* fully-qualified. 133\t*/ 134\tif (errno == ECONNREFUSED) { 135\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 136\treturn (-1); 137\t} 138 139\tswitch (statp-\u0026gt;res_h_errno) { 140\tcase NO_DATA: 141\tgot_nodata++; 142\t/* FALLTHROUGH */ 143\tcase HOST_NOT_FOUND: 144\t/* keep trying */ 145\tbreak; 146\tcase TRY_AGAIN: 147\tif (hp-\u0026gt;rcode == SERVFAIL) { 148\t/* try next search element, if any */ 149\tgot_servfail++; 150\tbreak; 151\t} 152\t/* FALLTHROUGH */ 153\tdefault: 154\t/* anything else implies that we\u0026#39;re done */ 155\tdone++; 156\t} 157 158\t/* if we got here for some reason other than DNSRCH, 159\t* we only wanted one iteration of the loop, so stop. 160\t*/ 161\tif ((statp-\u0026gt;options \u0026amp; RES_DNSRCH) == 0) 162\tdone++; 163\t} 164\t} 165 166\t/* 167\t* If the query has not already been tried as is then try it 168\t* unless RES_NOTLDQUERY is set and there were no dots. 169\t*/ 170\tif ((dots || !searched || (statp-\u0026gt;options \u0026amp; RES_NOTLDQUERY) == 0) 171\t\u0026amp;\u0026amp; !(tried_as_is || root_on_list)) { 172\tret = __res_context_querydomain 173\t(ctx, name, NULL, class, type, 174\tanswer, anslen, answerp, answerp2, nanswerp2, 175\tresplen2, answerp2_malloced); 176\tif (ret \u0026gt; 0 || (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL 177\t\u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 178\treturn (ret); 179\t} 180 181\t/* if we got here, we didn\u0026#39;t satisfy the search. 182\t* if we did an initial full query, return that query\u0026#39;s H_ERRNO 183\t* (note that we wouldn\u0026#39;t be here if that query had succeeded). 184\t* else if we ever got a nodata, send that back as the reason. 185\t* else send back meaningless H_ERRNO, that being the one from 186\t* the last DNSRCH we did. 187\t*/ 188\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 189\t{ 190\tfree (*answerp2); 191\t*answerp2 = NULL; 192\t*nanswerp2 = 0; 193\t*answerp2_malloced = 0; 194\t} 195\tif (saved_herrno != -1) 196\tRES_SET_H_ERRNO(statp, saved_herrno); 197\telse if (got_nodata) 198\tRES_SET_H_ERRNO(statp, NO_DATA); 199\telse if (got_servfail) 200\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 201\treturn (-1); 202} 203libc_hidden_def (__res_context_search) 从__res_context_querydomain也会调用到__res_context_query 里面就是判断了一下最大域名大小不超过1025 1// resolv/arpa/nameser_compat.h 2#define MAXDNAME\tNS_MAXDNAME 3 4// resolv/arpa/nameser.h 5#define NS_MAXDNAME\t1025\t/*%\u0026lt; maximum domain name */ 6 7// resolv/res_query.c 8/* Perform a call on res_query on the concatenation of name and 9 domain. */ 10static int 11__res_context_querydomain (struct resolv_context *ctx, 12\tconst char *name, const char *domain, 13\tint class, int type, 14\tunsigned char *answer, int anslen, 15\tunsigned char **answerp, unsigned char **answerp2, 16\tint *nanswerp2, int *resplen2, 17\tint *answerp2_malloced) 18{ 19\tstruct __res_state *statp = ctx-\u0026gt;resp; 20\tchar nbuf[MAXDNAME]; 21\tconst char *longname = nbuf; 22\tsize_t n, d; 23 24\tif (domain == NULL) { 25\tn = strlen(name); 26 27\t/* Decrement N prior to checking it against MAXDNAME 28\tso that we detect a wrap to SIZE_MAX and return 29\ta reasonable error. */ 30\tn--; 31\tif (n \u0026gt;= MAXDNAME - 1) { 32\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 33\treturn (-1); 34\t} 35\tlongname = name; 36\t} else { 37\tn = strlen(name); 38\td = strlen(domain); 39 // 判断一下是否超过最长域名大小 40\tif (n + d + 1 \u0026gt;= MAXDNAME) { 41\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 42\treturn (-1); 43\t} 44\tchar *p = __stpcpy (nbuf, name); 45\t*p++ = \u0026#39;.\u0026#39;; 46\tstrcpy (p, domain); 47\t} 48\treturn __res_context_query (ctx, longname, class, type, answer, 49\tanslen, answerp, answerp2, nanswerp2, 50\tresplen2, answerp2_malloced); 51} __res_context_query发起dns请求 1// resolv/res_query.c 2/* Formulate a normal query, send, and await answer. Returned answer 3 is placed in supplied buffer ANSWER. Perform preliminary check of 4 answer, returning success only if no error is indicated and the 5 answer count is nonzero. Return the size of the response on 6 success, -1 on error. Error number is left in h_errno. 7 8 Caller must parse answer and determine whether it answers the 9 question. */ 10int 11__res_context_query (struct resolv_context *ctx, const char *name, 12\tint class, int type, 13\tunsigned char *answer, int anslen, 14\tunsigned char **answerp, unsigned char **answerp2, 15\tint *nanswerp2, int *resplen2, int *answerp2_malloced) 16{ 17\tstruct __res_state *statp = ctx-\u0026gt;resp; 18\tUHEADER *hp = (UHEADER *) answer; 19\tUHEADER *hp2; 20\tint n, use_malloc = 0; 21 22\tsize_t bufsize = (type == T_QUERY_A_AND_AAAA ? 2 : 1) * QUERYSIZE; 23\tu_char *buf = alloca (bufsize); 24\tu_char *query1 = buf; 25\tint nquery1 = -1; 26\tu_char *query2 = NULL;\t// 存储AAAA请求 27\tint nquery2 = 0;\t// query2的长度 28 29 again: 30 // 构造dns请求包 31\thp-\u0026gt;rcode = NOERROR;\t/* default */ 32 33\tif (type == T_QUERY_A_AND_AAAA) 34\t{ 35\t// 要请求A和AAAA，构造A记录存到query1中，AAAA存到query2中 36\t// 构造A存到query1中 37\tn = __res_context_mkquery (ctx, QUERY, name, class, T_A, NULL, 38\tquery1, bufsize); 39\tif (n \u0026gt; 0) 40\t{ 41\tif ((statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 42\t{ 43\t/* Use RESOLV_EDNS_BUFFER_SIZE because the receive 44\tbuffer can be reallocated. */ 45\tn = __res_nopt (ctx, n, query1, bufsize, 46\tRESOLV_EDNS_BUFFER_SIZE); 47\tif (n \u0026lt; 0) 48\tgoto unspec_nomem; 49\t} 50 51\tnquery1 = n; 52\t/* Align the buffer. */ 53\tint npad = ((nquery1 + __alignof__ (HEADER) - 1) 54\t\u0026amp; ~(__alignof__ (HEADER) - 1)) - nquery1; 55\tif (n \u0026gt; bufsize - npad) 56\t{ 57\tn = -1; 58\tgoto unspec_nomem; 59\t} 60\tint nused = n + npad; 61\tquery2 = buf + nused; 62\t// 构造AAAA到query2 63\tn = __res_context_mkquery (ctx, QUERY, name, class, T_AAAA, 64\tNULL, query2, bufsize - nused); 65\tif (n \u0026gt; 0 66\t\u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 67\t/* Use RESOLV_EDNS_BUFFER_SIZE because the receive 68\tbuffer can be reallocated. */ 69\tn = __res_nopt (ctx, n, query2, bufsize, 70\tRESOLV_EDNS_BUFFER_SIZE); 71\tnquery2 = n; 72\t} 73 74\tunspec_nomem:; 75\t} 76\telse 77\t{ 78\t// 不是A和AAAA都需要，就只构造query就行了 79\tn = __res_context_mkquery (ctx, QUERY, name, class, type, NULL, 80\tquery1, bufsize); 81 82\tif (n \u0026gt; 0 83\t\u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 84\t{ 85\t/* Use RESOLV_EDNS_BUFFER_SIZE if the receive buffer 86\tcan be reallocated. */ 87\tsize_t advertise; 88\tif (answerp == NULL) 89\tadvertise = anslen; 90\telse 91\tadvertise = RESOLV_EDNS_BUFFER_SIZE; 92\tn = __res_nopt (ctx, n, query1, bufsize, advertise); 93\t} 94 95\tnquery1 = n; 96\t} 97 98\tif (__glibc_unlikely (n \u0026lt;= 0) \u0026amp;\u0026amp; !use_malloc) { 99\t/* Retry just in case res_nmkquery failed because of too 100\tshort buffer. Shouldn\u0026#39;t happen. */ 101\tbufsize = (type == T_QUERY_A_AND_AAAA ? 2 : 1) * MAXPACKET; 102\tbuf = malloc (bufsize); 103\tif (buf != NULL) { 104\tquery1 = buf; 105\tuse_malloc = 1; 106\tgoto again; 107\t} 108\t} 109\tif (__glibc_unlikely (n \u0026lt;= 0)) { 110\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 111\tif (use_malloc) 112\tfree (buf); 113\treturn (n); 114\t} 115 116\t/* Suppress AAAA lookups if required. __res_handle_no_aaaa 117\tchecks RES_NOAAAA first, so avoids parsing the 118\tjust-generated query packet in most cases. nss_dns avoids 119\tusing T_QUERY_A_AND_AAAA in RES_NOAAAA mode, so there is no 120\tneed to handle it here. */ 121\tif (type == T_AAAA \u0026amp;\u0026amp; __res_handle_no_aaaa (ctx, query1, nquery1, 122\tanswer, anslen, \u0026amp;n)) 123\t/* There must be no second query for AAAA queries. The code 124\tbelow is still needed to translate NODATA responses. */ 125\tassert (query2 == NULL); 126\telse 127\t{ 128\tassert (answerp == NULL || (void *) *answerp == (void *) answer); 129 // 发送dns请求 130\tn = __res_context_send (ctx, query1, nquery1, query2, nquery2, 131\tanswer, anslen, 132\tanswerp, answerp2, nanswerp2, resplen2, 133\tanswerp2_malloced); 134\t} 135 136 // 处理dns响应 137\tif (use_malloc) 138\tfree (buf); 139\tif (n \u0026lt; 0) { 140\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 141\treturn (n); 142\t} 143 144\tif (answerp != NULL) 145\t/* __res_context_send might have reallocated the buffer. */ 146\thp = (UHEADER *) *answerp; 147 148\t/* We simplify the following tests by assigning HP to HP2 or 149\tvice versa. It is easy to verify that this is the same as 150\tignoring all tests of HP or HP2. */ 151\tif (answerp2 == NULL || *resplen2 \u0026lt; (int) sizeof (HEADER)) 152\t{ 153\thp2 = hp; 154\t} 155\telse 156\t{ 157\thp2 = (UHEADER *) *answerp2; 158\tif (n \u0026lt; (int) sizeof (HEADER)) 159\t{ 160\thp = hp2; 161\t} 162\t} 163 164\t/* Make sure both hp and hp2 are defined */ 165\tassert((hp != NULL) \u0026amp;\u0026amp; (hp2 != NULL)); 166 167\tif ((hp-\u0026gt;rcode != NOERROR || ntohs(hp-\u0026gt;ancount) == 0) 168\t\u0026amp;\u0026amp; (hp2-\u0026gt;rcode != NOERROR || ntohs(hp2-\u0026gt;ancount) == 0)) { 169\tswitch (hp-\u0026gt;rcode == NOERROR ? hp2-\u0026gt;rcode : hp-\u0026gt;rcode) { 170\tcase NXDOMAIN: 171\tif ((hp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; ntohs (hp-\u0026gt;ancount) != 0) 172\t|| (hp2-\u0026gt;rcode == NOERROR 173\t\u0026amp;\u0026amp; ntohs (hp2-\u0026gt;ancount) != 0)) 174\tgoto success; 175\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND); 176\tbreak; 177\tcase SERVFAIL: 178\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 179\tbreak; 180\tcase NOERROR: 181\tif (ntohs (hp-\u0026gt;ancount) != 0 182\t|| ntohs (hp2-\u0026gt;ancount) != 0) 183\tgoto success; 184\tRES_SET_H_ERRNO(statp, NO_DATA); 185\tbreak; 186\tcase FORMERR: 187\tcase NOTIMP: 188\t/* Servers must not reply to AAAA queries with 189\tNOTIMP etc but some of them do. */ 190\tif ((hp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; ntohs (hp-\u0026gt;ancount) != 0) 191\t|| (hp2-\u0026gt;rcode == NOERROR 192\t\u0026amp;\u0026amp; ntohs (hp2-\u0026gt;ancount) != 0)) 193\tgoto success; 194\t/* FALLTHROUGH */ 195\tcase REFUSED: 196\tdefault: 197\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 198\tbreak; 199\t} 200\treturn (-1); 201\t} 202 success: 203\treturn (n); 204} 205libc_hidden_def (__res_context_query) __res_context_send发送dns请求包 1// resolv/res_send.c 2int 3__res_context_send (struct resolv_context *ctx, 4\tconst unsigned char *buf, int buflen, 5\tconst unsigned char *buf2, int buflen2, 6\tunsigned char *ans, int anssiz, 7\tunsigned char **ansp, unsigned char **ansp2, 8\tint *nansp2, int *resplen2, int *ansp2_malloced) 9{ 10\tstruct __res_state *statp = ctx-\u0026gt;resp; 11\tint gotsomewhere, terrno, try, v_circuit, resplen; 12\t/* On some architectures send_vc is inlined and the compiler might emit 13\ta warning indicating \u0026#39;resplen\u0026#39; may be used uninitialized. Note that 14\tthe warning belongs to resplen in send_vc which is used as return 15\tvalue! There the maybe-uninitialized warning is already ignored as 16\tit is a false-positive - see comment in send_vc. 17\tHere the variable n is set to the return value of send_vc. 18\tSee below. */ 19\tDIAG_PUSH_NEEDS_COMMENT; 20\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 21\tint n; 22\tDIAG_POP_NEEDS_COMMENT; 23 24\tif (statp-\u0026gt;nscount == 0) { 25\t__set_errno (ESRCH); 26\treturn (-1); 27\t} 28 29\tif (anssiz \u0026lt; (buf2 == NULL ? 1 : 2) * HFIXEDSZ) { 30\t__set_errno (EINVAL); 31\treturn (-1); 32\t} 33 34\tv_circuit = ((statp-\u0026gt;options \u0026amp; RES_USEVC) 35\t|| buflen \u0026gt; PACKETSZ 36\t|| buflen2 \u0026gt; PACKETSZ); 37\tgotsomewhere = 0; 38\tterrno = ETIMEDOUT; 39 40\t/* 41\t* If the ns_addr_list in the resolver context has changed, then 42\t* invalidate our cached copy and the associated timing data. 43\t*/ 44\tif (EXT(statp).nscount != 0) { 45\tint needclose = 0; 46 47\tif (EXT(statp).nscount != statp-\u0026gt;nscount) 48\tneedclose++; 49\telse 50\tfor (unsigned int ns = 0; ns \u0026lt; statp-\u0026gt;nscount; ns++) { 51\tif (statp-\u0026gt;nsaddr_list[ns].sin_family != 0 52\t\u0026amp;\u0026amp; !sock_eq((struct sockaddr_in6 *) 53\t\u0026amp;statp-\u0026gt;nsaddr_list[ns], 54\tEXT(statp).nsaddrs[ns])) 55\t{ 56\tneedclose++; 57\tbreak; 58\t} 59\t} 60\tif (needclose) { 61\t__res_iclose(statp, false); 62\tEXT(statp).nscount = 0; 63\t} 64\t} 65 66\t/* 67\t* Maybe initialize our private copy of the ns_addr_list. 68\t*/ 69\tif (EXT(statp).nscount == 0) { 70\tfor (unsigned int ns = 0; ns \u0026lt; statp-\u0026gt;nscount; ns++) { 71\tEXT(statp).nssocks[ns] = -1; 72\tif (statp-\u0026gt;nsaddr_list[ns].sin_family == 0) 73\tcontinue; 74\tif (EXT(statp).nsaddrs[ns] == NULL) 75\tEXT(statp).nsaddrs[ns] = 76\tmalloc(sizeof (struct sockaddr_in6)); 77\tif (EXT(statp).nsaddrs[ns] != NULL) 78\tmemset (mempcpy(EXT(statp).nsaddrs[ns], 79\t\u0026amp;statp-\u0026gt;nsaddr_list[ns], 80\tsizeof (struct sockaddr_in)), 81\t\u0026#39;\\0\u0026#39;, 82\tsizeof (struct sockaddr_in6) 83\t- sizeof (struct sockaddr_in)); 84\telse 85\treturn -1; 86\t} 87\tEXT(statp).nscount = statp-\u0026gt;nscount; 88\t} 89 90\t/* Name server index offset. Used to implement 91\tRES_ROTATE. */ 92\tunsigned int ns_offset = nameserver_offset (statp); 93 94\t/* 95\t* Send request, RETRY times, or until successful. 96\t*/ 97 // 发送请求，重试到成功或超出重试次数为止 98 // 根据ns为索引，一个一个尝试，超时就尝试下一个 99\tfor (try = 0; try \u0026lt; statp-\u0026gt;retry; try++) { 100\tfor (unsigned ns_shift = 0; ns_shift \u0026lt; statp-\u0026gt;nscount; ns_shift++) 101\t{ 102\t/* The actual name server index. This implements 103\tRES_ROTATE. */ 104\tunsigned int ns = ns_shift + ns_offset; 105\tif (ns \u0026gt;= statp-\u0026gt;nscount) 106\tns -= statp-\u0026gt;nscount; 107 108\tsame_ns: 109\tif (__glibc_unlikely (v_circuit)) { 110 // tcpdns，内部会创建socket放到statp-\u0026gt;_vcsock中 111\t/* Use VC; at most one attempt per server. */ 112\ttry = statp-\u0026gt;retry; 113\tn = send_vc(statp, buf, buflen, buf2, buflen2, 114\t\u0026amp;ans, \u0026amp;anssiz, \u0026amp;terrno, 115\tns, ansp, ansp2, nansp2, resplen2, 116\tansp2_malloced); 117\tif (n \u0026lt; 0) 118\treturn (-1); 119\t/* See comment at the declaration of n. */ 120\tDIAG_PUSH_NEEDS_COMMENT; 121\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 122\tif (n == 0 \u0026amp;\u0026amp; (buf2 == NULL || *resplen2 == 0)) 123\tgoto next_ns; 124\tDIAG_POP_NEEDS_COMMENT; 125\t} else { 126 // udpdns，内部会创建socket放到EXT(statp).nssocks中 127\t/* Use datagrams. */ 128\tn = send_dg(statp, buf, buflen, buf2, buflen2, 129\t\u0026amp;ans, \u0026amp;anssiz, \u0026amp;terrno, 130\tns, \u0026amp;v_circuit, \u0026amp;gotsomewhere, ansp, 131\tansp2, nansp2, resplen2, ansp2_malloced); 132\tif (n \u0026lt; 0) 133\treturn (-1); 134\t// n为0且不需要buf2或resplen2为0，尝试下一个 135\tif (n == 0 \u0026amp;\u0026amp; (buf2 == NULL || *resplen2 == 0)) 136\tgoto next_ns; 137\t// v_circuit就使用同一个ns继续发，也就是tcp重新发一次 138\tif (v_circuit) 139\t// XXX Check whether both requests failed or 140\t// XXX whether one has been answered successfully 141\tgoto same_ns; 142\t} 143 144\tresplen = n; 145 146\t/* See comment at the declaration of n. Note: resplen = n; */ 147\tDIAG_PUSH_NEEDS_COMMENT; 148\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 149\t/* Mask the AD bit in both responses unless it is 150\tmarked trusted. */ 151\tif (resplen \u0026gt; HFIXEDSZ) 152\t{ 153\tif (ansp != NULL) 154\tmask_ad_bit (ctx, *ansp); 155\telse 156\tmask_ad_bit (ctx, ans); 157\t} 158\tDIAG_POP_NEEDS_COMMENT; 159\tif (resplen2 != NULL \u0026amp;\u0026amp; *resplen2 \u0026gt; HFIXEDSZ) 160\tmask_ad_bit (ctx, *ansp2); 161 162\t/* 163\t* If we have temporarily opened a virtual circuit, 164\t* or if we haven\u0026#39;t been asked to keep a socket open, 165\t* close the socket. 166\t*/ 167\tif ((v_circuit \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_USEVC) == 0) || 168\t(statp-\u0026gt;options \u0026amp; RES_STAYOPEN) == 0) { 169\t__res_iclose(statp, false); 170\t} 171\treturn (resplen); 172 next_ns: ; 173\t} /*foreach ns*/ 174\t} /*foreach retry*/ 175\t__res_iclose(statp, false); 176\tif (!v_circuit) { 177\tif (!gotsomewhere) 178\t__set_errno (ECONNREFUSED);\t/* no nameservers found */ 179\telse 180\t__set_errno (ETIMEDOUT);\t/* no answer obtained */ 181\t} else 182\t__set_errno (terrno); 183\treturn (-1); 184} 185libc_hidden_def (__res_context_send) 2.1. 发送udp包给一个dns服务器 # 调用send_dg 从这里可以看到什么情况下使用下一个dns服务器，什么情况下使用tcp重新发送 1// /resolv/res_send.c 2/* The send_dg function is responsible for sending a DNS query over UDP 3 to the nameserver numbered NS from the res_state STATP i.e. 4 EXT(statp).nssocks[ns]. The function supports IPv4 and IPv6 queries 5 along with the ability to send the query in parallel for both stacks 6 (default) or serially (RES_SINGLKUP). It also supports serial lookup 7 with a close and reopen of the socket used to talk to the server 8 (RES_SNGLKUPREOP) to work around broken name servers. 9 10 The query stored in BUF of BUFLEN length is sent first followed by 11 the query stored in BUF2 of BUFLEN2 length. Queries are sent 12 in parallel (default) or serially (RES_SINGLKUP or RES_SNGLKUPREOP). 13 14 Answers to the query are stored firstly in *ANSP up to a max of 15 *ANSSIZP bytes. If more than *ANSSIZP bytes are needed and ANSCP 16 is non-NULL (to indicate that modifying the answer buffer is allowed) 17 then malloc is used to allocate a new response buffer and ANSCP and 18 ANSP will both point to the new buffer. If more than *ANSSIZP bytes 19 are needed but ANSCP is NULL, then as much of the response as 20 possible is read into the buffer, but the results will be truncated. 21 When truncation happens because of a small answer buffer the DNS 22 packets header field TC will bet set to 1, indicating a truncated 23 message, while the rest of the UDP packet is discarded. 24 25 Answers to the query are stored secondly in *ANSP2 up to a max of 26 *ANSSIZP2 bytes, with the actual response length stored in 27 *RESPLEN2. If more than *ANSSIZP bytes are needed and ANSP2 28 is non-NULL (required for a second query) then malloc is used to 29 allocate a new response buffer, *ANSSIZP2 is set to the new buffer 30 size and *ANSP2_MALLOCED is set to 1. 31 32 The ANSP2_MALLOCED argument will eventually be removed as the 33 change in buffer pointer can be used to detect the buffer has 34 changed and that the caller should use free on the new buffer. 35 36 Note that the answers may arrive in any order from the server and 37 therefore the first and second answer buffers may not correspond to 38 the first and second queries. 39 40 It is not supported to call this function with a non-NULL ANSP2 41 but a NULL ANSCP. Put another way, you can call send_vc with a 42 single unmodifiable buffer or two modifiable buffers, but no other 43 combination is supported. 44 45 It is the caller\u0026#39;s responsibility to free the malloc allocated 46 buffers by detecting that the pointers have changed from their 47 original values i.e. *ANSCP or *ANSP2 has changed. 48 49 If an answer is truncated because of UDP datagram DNS limits then 50 *V_CIRCUIT is set to 1 and the return value non-zero to indicate to 51 the caller to retry with TCP. The value *GOTSOMEWHERE is set to 1 52 if any progress was made reading a response from the nameserver and 53 is used by the caller to distinguish between ECONNREFUSED and 54 ETIMEDOUT (the latter if *GOTSOMEWHERE is 1). 55 56 If errors are encountered then *TERRNO is set to an appropriate 57 errno value and a zero result is returned for a recoverable error, 58 and a less-than zero result is returned for a non-recoverable error. 59 60 If no errors are encountered then *TERRNO is left unmodified and 61 a the length of the first response in bytes is returned. */ 62/** 63 * @brief 发送udp包给某个dns服务器 64 * 65 * @param statp dns配置上下文，dns服务器的socket存在EXT(statp).nssocks[ns]中 66 * @param buf 要发送的数据包1，A和AAAA都需要时存放A记录，否则要啥就存啥 67 * @param buflen 68 * @param buf2 要发送的数据包2，A和AAAA都需要时存放AAAA记录，否则为空 69 * @param buflen2 70 * @param ansp 71 * @param anssizp 72 * @param terrno 当有错误时，errno存到这里返回 73 * @param ns dns服务器的索引号 74 * @param v_circuit 75 * @param gotsomewhere 76 * @param anscp 77 * @param ansp2 78 * @param anssizp2 79 * @param resplen2 80 * @param ansp2_malloced 81 * @return int 如果返回1，要使用tcp重新发包 82\t如果返回0，当buf2为空或resplen2为0则尝试下一个dns服务器 83\t如果返回大于0的其他数，有结果返回 84\t如果返回小于0，不可恢复错误 85 */ 86static int send_dg(res_state statp, const u_char *buf, int buflen, const u_char *buf2, int buflen2, u_char **ansp, 87 int *anssizp, int *terrno, int ns, int *v_circuit, int *gotsomewhere, u_char **anscp, u_char **ansp2, 88 int *anssizp2, int *resplen2, int *ansp2_malloced) { 89 const UHEADER *hp = (UHEADER *)buf; 90 const UHEADER *hp2 = (UHEADER *)buf2; 91 struct timespec now, timeout, finish; 92 struct pollfd pfd[1]; 93 int ptimeout; 94 struct sockaddr_in6 from; 95 int resplen = 0; 96 int n; 97 98 /* 99 * Compute time for the total operation. 100 */ 101 // 计算超时时间，retrans默认为5，可以配置resolv.conf \u0026#34;options timeout:10\u0026#34;来修改 102 int seconds = (statp-\u0026gt;retrans \u0026lt;\u0026lt; ns); 103 // nscount为配置的dns服务器数量，一般一个网卡一个到两个 104 // 当ns为0时，seconds为5 105 // 当ns为1时，当nscount为2时，seconds为5；当nscount为3时，seconds为3；当nscount为4时，seconds为2 106 // 当ns为2时，当nscount为2时，seconds为10；当nscount为3时，seconds为6；当nscount为4时，seconds为5 107 if (ns \u0026gt; 0) seconds /= statp-\u0026gt;nscount; 108 if (seconds \u0026lt;= 0) seconds = 1; 109 bool single_request_reopen = (statp-\u0026gt;options \u0026amp; RES_SNGLKUPREOP) != 0; 110 bool single_request = (((statp-\u0026gt;options \u0026amp; RES_SNGLKUP) != 0) | single_request_reopen); 111 int save_gotsomewhere = *gotsomewhere; 112 113 int retval; 114retry_reopen: 115 // 重新建立socket 116 retval = reopen(statp, terrno, ns); 117 if (retval \u0026lt;= 0) { 118 if (resplen2 != NULL) *resplen2 = 0; 119 return retval; 120 } 121retry: 122 // 根据上面的seconds计算超时，存到finish中 123 evNowTime(\u0026amp;now); 124 evConsTime(\u0026amp;timeout, seconds, 0); 125 evAddTime(\u0026amp;finish, \u0026amp;now, \u0026amp;timeout); 126 int need_recompute = 0; // 代表是否需要计算超时时间 127 int nwritten = 0; 128 int recvresp1 = 0; // buf是否已经收到了响应 129 /* Skip the second response if there is no second query. 130 To do that we mark the second response as received. */ 131 int recvresp2 = buf2 == NULL; // buf2是否已经收到了响应，如果没有buf2，默认为1 132 pfd[0].fd = EXT(statp).nssocks[ns]; 133 pfd[0].events = POLLOUT; 134wait: 135 if (need_recompute) { 136 // 需要计算超时，算一下 137 recompute_resend: 138 evNowTime(\u0026amp;now); 139 if (evCmpTime(finish, now) \u0026lt;= 0) { 140 poll_err_out: 141 // 超时了，返回0，resplen2置0，尝试下一个dns服务器 142 return close_and_return_error(statp, resplen2); 143 } 144 evSubTime(\u0026amp;timeout, \u0026amp;finish, \u0026amp;now); 145 need_recompute = 0; 146 } 147 /* Convert struct timespec in milliseconds. */ 148 ptimeout = timeout.tv_sec * 1000 + timeout.tv_nsec / 1000000; 149 150\t// 使用poll进行收包 151 n = 0; 152 if (nwritten == 0) n = __poll(pfd, 1, 0); 153 if (__glibc_unlikely(n == 0)) { 154 n = __poll(pfd, 1, ptimeout); 155 need_recompute = 1; 156 } 157 if (n == 0) { 158 if (resplen \u0026gt; 1 \u0026amp;\u0026amp; (recvresp1 || (buf2 != NULL \u0026amp;\u0026amp; recvresp2))) { 159 /* There are quite a few broken name servers out 160 there which don\u0026#39;t handle two outstanding 161 requests from the same source. There are also 162 broken firewall settings. If we time out after 163 having received one answer switch to the mode 164 where we send the second request only once we 165 have received the first answer. */ 166 if (!single_request) { 167 statp-\u0026gt;options |= RES_SNGLKUP; 168 single_request = true; 169 *gotsomewhere = save_gotsomewhere; 170 goto retry; 171 } else if (!single_request_reopen) { 172 statp-\u0026gt;options |= RES_SNGLKUPREOP; 173 single_request_reopen = true; 174 *gotsomewhere = save_gotsomewhere; 175 __res_iclose(statp, false); 176 goto retry_reopen; 177 } 178 179 *resplen2 = 1; 180 return resplen; 181 } 182 183 *gotsomewhere = 1; 184 if (resplen2 != NULL) *resplen2 = 0; 185 return 0; 186 } 187 if (n \u0026lt; 0) { 188 if (errno == EINTR) goto recompute_resend; 189 190 goto poll_err_out; 191 } 192 __set_errno(0); 193 if (pfd[0].revents \u0026amp; POLLOUT) { 194 // POLLOUT代表可以发包了，下面是发送数据包的逻辑，调用sendmsg 195#ifndef __ASSUME_SENDMMSG 196 static int have_sendmmsg; 197#else 198#define have_sendmmsg 1 199#endif 200 if (have_sendmmsg \u0026gt;= 0 \u0026amp;\u0026amp; nwritten == 0 \u0026amp;\u0026amp; buf2 != NULL \u0026amp;\u0026amp; !single_request) { 201 struct iovec iov = {.iov_base = (void *)buf, .iov_len = buflen}; 202 struct iovec iov2 = {.iov_base = (void *)buf2, .iov_len = buflen2}; 203 struct mmsghdr reqs[2] = { 204 { 205 .msg_hdr = 206 { 207 .msg_iov = \u0026amp;iov, 208 .msg_iovlen = 1, 209 }, 210 }, 211 {.msg_hdr = 212 { 213 .msg_iov = \u0026amp;iov2, 214 .msg_iovlen = 1, 215 }}, 216 }; 217 218 int ndg = __sendmmsg(pfd[0].fd, reqs, 2, MSG_NOSIGNAL); 219 if (__glibc_likely(ndg == 2)) { 220 if (reqs[0].msg_len != buflen || reqs[1].msg_len != buflen2) goto fail_sendmmsg; 221 222 pfd[0].events = POLLIN; 223 nwritten += 2; 224 } else if (ndg == 1 \u0026amp;\u0026amp; reqs[0].msg_len == buflen) 225 goto just_one; 226 else if (ndg \u0026lt; 0 \u0026amp;\u0026amp; (errno == EINTR || errno == EAGAIN)) 227 goto recompute_resend; 228 else { 229#ifndef __ASSUME_SENDMMSG 230 if (__glibc_unlikely(have_sendmmsg == 0)) { 231 if (ndg \u0026lt; 0 \u0026amp;\u0026amp; errno == ENOSYS) { 232 have_sendmmsg = -1; 233 goto try_send; 234 } 235 have_sendmmsg = 1; 236 } 237#endif 238 239 fail_sendmmsg: 240 return close_and_return_error(statp, resplen2); 241 } 242 } else { 243 ssize_t sr; 244#ifndef __ASSUME_SENDMMSG 245 try_send: 246#endif 247 if (nwritten != 0) 248 sr = __send(pfd[0].fd, buf2, buflen2, MSG_NOSIGNAL); 249 else 250 sr = __send(pfd[0].fd, buf, buflen, MSG_NOSIGNAL); 251 252 if (sr != (nwritten != 0 ? buflen2 : buflen)) { 253 if (errno == EINTR || errno == EAGAIN) goto recompute_resend; 254 return close_and_return_error(statp, resplen2); 255 } 256 just_one: 257 if (nwritten != 0 || buf2 == NULL || single_request) 258 pfd[0].events = POLLIN; 259 else 260 pfd[0].events = POLLIN | POLLOUT; 261 ++nwritten; 262 } 263 goto wait; 264 } else if (pfd[0].revents \u0026amp; POLLIN) { 265 // pollin代表有包收到了，这里是收包逻辑 266 int *thisanssizp; 267 u_char **thisansp; 268 int *thisresplenp; // 当前收包长度 269 270 // 都没收到响应或buf2为空，当前收到包的长度放到resplen 271 // 有一个收到响应，且buf2不为空，当前收包长度放到resp2len 272 if ((recvresp1 | recvresp2) == 0 || buf2 == NULL) { 273 /* We have not received any responses 274 yet or we only have one response to 275 receive. */ 276 thisanssizp = anssizp; 277 thisansp = anscp ?: ansp; 278 assert(anscp != NULL || ansp2 == NULL); 279 thisresplenp = \u0026amp;resplen; 280 } else { 281 thisanssizp = anssizp2; 282 thisansp = ansp2; 283 thisresplenp = resplen2; 284 } 285 286 if (*thisanssizp \u0026lt; MAXPACKET 287 /* If the current buffer is not the the static 288 user-supplied buffer then we can reallocate 289 it. */ 290 \u0026amp;\u0026amp; (thisansp != NULL \u0026amp;\u0026amp; thisansp != ansp) 291#ifdef FIONREAD 292 /* Is the size too small? */ 293 \u0026amp;\u0026amp; (__ioctl(pfd[0].fd, FIONREAD, thisresplenp) \u0026lt; 0 || *thisanssizp \u0026lt; *thisresplenp) 294#endif 295 ) { 296 /* Always allocate MAXPACKET, callers expect 297 this specific size. */ 298 u_char *newp = malloc(MAXPACKET); 299 if (newp != NULL) { 300 *thisanssizp = MAXPACKET; 301 *thisansp = newp; 302 if (thisansp == ansp2) *ansp2_malloced = 1; 303 } 304 } 305 /* We could end up with truncation if anscp was NULL 306 (not allowed to change caller\u0026#39;s buffer) and the 307 response buffer size is too small. This isn\u0026#39;t a 308 reliable way to detect truncation because the ioctl 309 may be an inaccurate report of the UDP message size. 310 Therefore we use this only to issue debug output. 311 To do truncation accurately with UDP we need 312 MSG_TRUNC which is only available on Linux. We 313 can abstract out the Linux-specific feature in the 314 future to detect truncation. */ 315 UHEADER *anhp = (UHEADER *)*thisansp; // anhp为收到的数据包 316 socklen_t fromlen = sizeof(struct sockaddr_in6); 317 assert(sizeof(from) \u0026lt;= fromlen); 318 *thisresplenp = __recvfrom(pfd[0].fd, (char *)*thisansp, *thisanssizp, 0, (struct sockaddr *)\u0026amp;from, \u0026amp;fromlen); 319 if (__glibc_unlikely(*thisresplenp \u0026lt;= 0)) { 320 if (errno == EINTR || errno == EAGAIN) { 321 // errno为intr或eagin，重新收包，回到wait判断一下超时时间是否到达 322 need_recompute = 1; 323 goto wait; 324 } 325 // 否则收包失败后，返回0，resplen2置0，尝试下一个dns服务器 326 return close_and_return_error(statp, resplen2); 327 } 328 *gotsomewhere = 1; 329 if (__glibc_unlikely(*thisresplenp \u0026lt; HFIXEDSZ)) { 330 // 包长度小于dns固定头部长度12，返回0，resplen2置0，尝试下一个dns服务器 331 /* 332 * Undersized message. 333 */ 334 *terrno = EMSGSIZE; 335 return close_and_return_error(statp, resplen2); 336 } 337 338 /* Check for the correct header layout and a matching 339 question. */ 340 int matching_query = 0; /* Default to no matching query. */ 341 // 对比queryid是否匹配，请求的两个id都匹配一下是否对应 342 // 这里说明A记录和AAAA记录的id不能一样 343 if (!recvresp1 \u0026amp;\u0026amp; anhp-\u0026gt;id == hp-\u0026gt;id \u0026amp;\u0026amp; 344 __libc_res_queriesmatch(buf, buf + buflen, *thisansp, *thisansp + *thisanssizp)) 345 matching_query = 1; 346 if (!recvresp2 \u0026amp;\u0026amp; anhp-\u0026gt;id == hp2-\u0026gt;id \u0026amp;\u0026amp; 347 __libc_res_queriesmatch(buf2, buf2 + buflen2, *thisansp, *thisansp + *thisanssizp)) 348 matching_query = 2; 349 if (matching_query == 0) 350 /* Spurious UDP packet. Drop it and continue 351 waiting. */ 352 { 353 // 没匹配到，丢包继续等，顺便算一下超时时间 354 need_recompute = 1; 355 goto wait; 356 } 357 358 if (anhp-\u0026gt;rcode == SERVFAIL || anhp-\u0026gt;rcode == NOTIMP || anhp-\u0026gt;rcode == REFUSED) { 359 // 上面三个响应错误要使用下一个dns服务器继续尝试 360 next_ns: 361 // 使用下一个dns服务器继续试的处理 362 if (recvresp1 || (buf2 != NULL \u0026amp;\u0026amp; recvresp2)) { 363 // buf已经收到了响应或者buf2已经收到了响应（非这一次） 364 // resplen2置0，返回第一次响应长度 365\t// 第一次也是需要下一个dns服务器的错误，则返回0，使用下一个dns服务器继续请求 366\t// 第一次不需要下一个dns服务器，就是第一次的长度，不会尝试下一个dns服务器 367 *resplen2 = 0; 368 return resplen; 369 } 370 if (buf2 != NULL) { 371 // 这里就是首次收到响应就有错误且有buf2，等一下两个结果都返回 372 // 把第一次的长度置0，哪个响应哪个为1，然后继续等 373 /* No data from the first reply. */ 374 resplen = 0; 375 /* We are waiting for a possible second reply. */ 376 if (matching_query == 1) 377 recvresp1 = 1; 378 else 379 recvresp2 = 1; 380 381 goto wait; 382 } 383 384 /* don\u0026#39;t retry if called from dig */ 385 // dig会设置pfcode的值，这里判断为0则代表不是dig 386 // 正常解析就直接关闭socket然后返回0 387 if (!statp-\u0026gt;pfcode) return close_and_return_error(statp, resplen2); 388 __res_iclose(statp, false); 389 } 390 if (anhp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; anhp-\u0026gt;ancount == 0 \u0026amp;\u0026amp; anhp-\u0026gt;aa == 0 \u0026amp;\u0026amp; anhp-\u0026gt;ra == 0 \u0026amp;\u0026amp; anhp-\u0026gt;arcount == 0) { 391 // 没错误，但是不是递归查询且结果为空，尝试下一个dns服务器 392 goto next_ns; 393 } 394 if (!(statp-\u0026gt;options \u0026amp; RES_IGNTC) \u0026amp;\u0026amp; anhp-\u0026gt;tc) { 395 // 非忽略tc的配置下，当响应中有tc字段，设置v_circuit为1，返回长度1 396 // 虽成功但需要使用tcp重新发包，并且只给resplen，resplen2设置为0 397 /* 398 * To get the rest of answer, 399 * use TCP with same server. 400 */ 401 *v_circuit = 1; 402 __res_iclose(statp, false); 403 // XXX if we have received one reply we could 404 // XXX use it and not repeat it over TCP... 405 if (resplen2 != NULL) *resplen2 = 0; 406 return (1); 407 } 408 /* Mark which reply we received. */ 409 if (matching_query == 1) 410 recvresp1 = 1; 411 else 412 recvresp2 = 1; 413 /* Repeat waiting if we have a second answer to arrive. */ 414 if ((recvresp1 \u0026amp; recvresp2) == 0) { 415 // 还有一个还没收到响应，继续等 416 if (single_request) { 417 pfd[0].events = POLLOUT; 418 if (single_request_reopen) { 419 __res_iclose(statp, false); 420 retval = reopen(statp, terrno, ns); 421 if (retval \u0026lt;= 0) { 422 if (resplen2 != NULL) *resplen2 = 0; 423 return retval; 424 } 425 pfd[0].fd = EXT(statp).nssocks[ns]; 426 } 427 } 428 goto wait; 429 } 430 /* All is well. We have received both responses (if 431 two responses were requested). */ 432 return (resplen); 433 } else if (pfd[0].revents \u0026amp; (POLLERR | POLLHUP | POLLNVAL)) 434 /* Something went wrong. We can stop trying. */ 435 return close_and_return_error(statp, resplen2); 436 else { 437 /* poll should not have returned \u0026gt; 0 in this case. */ 438 abort(); 439 } 440} "},{"id":197,"href":"/docs/systemd/dns/","title":"dns 根据/etc/resolv.conf发包处理","section":"systemd源码分析记录","content":" gethostbyname # dns的一些系统行为 # 具体代码看 发送udp包给一个dns服务器 1. 什么情况下使用下一个dns服务器，当前结果直接丢弃 # 当前dns服务器接收失败（网络错误，收包错误等） dns服务器返回serverfail、notimplement、refused dns服务器返回正常的情况下，下面条件都满足就尝试下一个 answer为空 当前dns服务器不是authoritive answer 当前dns服务器不能递归查询 resource为空 2. 什么情况下使用tcp进行发送dns # 返回响应中有tc字段为1 源码 # 从_nss_dns_gethostbyname3_r开始 1// resolv/nss_dns/dns-host.c 2enum nss_status 3_nss_dns_gethostbyname3_r (const char *name, int af, struct hostent *result, 4\tchar *buffer, size_t buflen, int *errnop, 5\tint *h_errnop, int32_t *ttlp, char **canonp) 6{ 7 struct resolv_context *ctx = __resolv_context_get (); 8 if (ctx == NULL) 9 { 10 *errnop = errno; 11 *h_errnop = NETDB_INTERNAL; 12 return NSS_STATUS_UNAVAIL; 13 } 14 enum nss_status status = gethostbyname3_context 15 (ctx, name, af, result, buffer, buflen, errnop, h_errnop, ttlp, canonp); 16 __resolv_context_put (ctx); 17 return status; 18} 19libc_hidden_def (_nss_dns_gethostbyname3_r) 1. 如何读取/etc/resolv.conf # 获取struct resolv_context *ctx 1// resolv/resolv_context.c 2struct resolv_context * 3__resolv_context_get (void) 4{ 5 return context_get (false); 6} 7libc_hidden_def (__resolv_context_get) 8 9// resolv/resolv_context.c 10/* Backing function for the __resolv_context_get family of 11 functions. */ 12static struct resolv_context * 13context_get (bool preinit) 14{ 15 if (current != NULL) 16 return context_reuse (); 17 18 struct resolv_context *ctx = context_alloc (\u0026amp;_res); 19 if (ctx == NULL) 20 return NULL; 21 if (!maybe_init (ctx, preinit)) 22 { 23 context_free (ctx); 24 return NULL; 25 } 26 return ctx; 27} 28 29// resolv/resolv_context.c 30/* Initialize *RESP if RES_INIT is not yet set in RESP-\u0026gt;options, or if 31 res_init in some other thread requested re-initializing. */ 32static __attribute__ ((warn_unused_result)) bool 33maybe_init (struct resolv_context *ctx, bool preinit) 34{ 35 struct __res_state *resp = ctx-\u0026gt;resp; 36 if (resp-\u0026gt;options \u0026amp; RES_INIT) 37 { 38 if (resp-\u0026gt;options \u0026amp; RES_NORELOAD) 39 /* Configuration reloading was explicitly disabled. */ 40 return true; 41 42 /* If there is no associated resolv_conf object despite the 43 initialization, something modified *ctx-\u0026gt;resp. Do not 44 override those changes. */ 45 if (ctx-\u0026gt;conf != NULL \u0026amp;\u0026amp; replicated_configuration_matches (ctx)) 46 { 47 struct resolv_conf *current = __resolv_conf_get_current (); 48 if (current == NULL) 49 return false; 50 51 /* Check if the configuration changed. */ 52 if (current != ctx-\u0026gt;conf) 53 { 54 /* This call will detach the extended resolver state. */ 55 if (resp-\u0026gt;nscount \u0026gt; 0) 56 __res_iclose (resp, true); 57 /* Reattach the current configuration. */ 58 if (__resolv_conf_attach (ctx-\u0026gt;resp, current)) 59 { 60 __resolv_conf_put (ctx-\u0026gt;conf); 61 /* ctx takes ownership, so we do not release current. */ 62 ctx-\u0026gt;conf = current; 63 } 64 } 65 else 66 /* No change. Drop the reference count for current. */ 67 __resolv_conf_put (current); 68 } 69 return true; 70 } 71 72 assert (ctx-\u0026gt;conf == NULL); 73 if (preinit) 74 { 75 if (!resp-\u0026gt;retrans) 76 resp-\u0026gt;retrans = RES_TIMEOUT; 77 if (!resp-\u0026gt;retry) 78 resp-\u0026gt;retry = RES_DFLRETRY; 79 resp-\u0026gt;options = RES_DEFAULT; 80 if (!resp-\u0026gt;id) 81 resp-\u0026gt;id = res_randomid (); 82 } 83 84 if (__res_vinit (resp, preinit) \u0026lt; 0) 85 return false; 86 ctx-\u0026gt;conf = __resolv_conf_get (ctx-\u0026gt;resp); 87 return true; 88} 调用__resolv_conf_get_current，里面会检测/etc/resolv.conf是否改变，改变则重新加载 1struct resolv_conf * 2__resolv_conf_get_current (void) 3{ 4 struct file_change_detection initial; 5 // 检测一下/etc/resolv.conf是否更改，结果存到initial中，返回的只是函数调用的成功或失败 6 if (!__file_change_detection_for_path (\u0026amp;initial, _PATH_RESCONF)) 7 return NULL; 8 9 struct resolv_conf_global *global_copy = get_locked_global (); 10 if (global_copy == NULL) 11 return NULL; 12 struct resolv_conf *conf; 13 if (global_copy-\u0026gt;conf_current != NULL 14 \u0026amp;\u0026amp; __file_is_unchanged (\u0026amp;initial, \u0026amp;global_copy-\u0026gt;file_resolve_conf)) 15 /* We can reuse the cached configuration object. */ 16 conf = global_copy-\u0026gt;conf_current; 17 else 18 { 19 /* Parse configuration while holding the lock. This avoids 20 duplicate work. */ 21 struct file_change_detection after_load; 22 conf = __resolv_conf_load (NULL, \u0026amp;after_load); 23 if (conf != NULL) 24 { 25 if (global_copy-\u0026gt;conf_current != NULL) 26 conf_decrement (global_copy-\u0026gt;conf_current); 27 global_copy-\u0026gt;conf_current = conf; /* Takes ownership. */ 28 29 /* Update file change detection data, but only if it matches 30 the initial measurement. This avoids an ABA race in case 31 /etc/resolv.conf is temporarily replaced while the file 32 is read (after the initial measurement), and restored to 33 the initial version later. */ 34 if (__file_is_unchanged (\u0026amp;initial, \u0026amp;after_load)) 35 global_copy-\u0026gt;file_resolve_conf = after_load; 36 else 37 /* If there is a discrepancy, trigger a reload during the 38 next use. */ 39 global_copy-\u0026gt;file_resolve_conf.size = -1; 40 } 41 } 42 43 if (conf != NULL) 44 { 45 /* Return an additional reference. */ 46 assert (conf-\u0026gt;__refcount \u0026gt; 0); 47 ++conf-\u0026gt;__refcount; 48 assert (conf-\u0026gt;__refcount \u0026gt; 0); 49 } 50 put_locked_global (global_copy); 51 return conf; 52} 重新加载会调用__resolv_conf_load加载配置打开/etc/resolv.conf 1// resolv/resolv.h 2#ifndef _PATH_RESCONF 3#define _PATH_RESCONF \u0026#34;/etc/resolv.conf\u0026#34; 4#endif 5 6// resolv/res_init.c 7struct resolv_conf * 8__resolv_conf_load (struct __res_state *preinit, 9 struct file_change_detection *change) 10{ 11 /* Ensure that /etc/hosts.conf has been loaded (once). */ 12 _res_hconf_init (); 13 14 FILE *fp = fopen (_PATH_RESCONF, \u0026#34;rce\u0026#34;); 15 if (fp == NULL) 16 switch (errno) 17 { 18 case EACCES: 19 case EISDIR: 20 case ELOOP: 21 case ENOENT: 22 case ENOTDIR: 23 case EPERM: 24 /* Ignore these errors. They are persistent errors caused 25 by file system contents. */ 26 break; 27 default: 28 /* Other errors refer to resource allocation problems and 29 need to be handled by the application. */ 30 return NULL; 31 } 32 33 struct resolv_conf_parser parser; 34 resolv_conf_parser_init (\u0026amp;parser, preinit); 35 36 struct resolv_conf *conf = NULL; 37 bool ok = res_vinit_1 (fp, \u0026amp;parser); 38 if (ok \u0026amp;\u0026amp; change != NULL) 39 /* Update the file change information if the configuration was 40 loaded successfully. */ 41 ok = __file_change_detection_for_fp (change, fp); 42 43 if (ok) 44 { 45 parser.template.nameserver_list 46 = nameserver_list_begin (\u0026amp;parser.nameserver_list); 47 parser.template.nameserver_list_size 48 = nameserver_list_size (\u0026amp;parser.nameserver_list); 49 parser.template.search_list = search_list_begin (\u0026amp;parser.search_list); 50 parser.template.search_list_size 51 = search_list_size (\u0026amp;parser.search_list); 52 parser.template.sort_list = sort_list_begin (\u0026amp;parser.sort_list); 53 parser.template.sort_list_size = sort_list_size (\u0026amp;parser.sort_list); 54 conf = __resolv_conf_allocate (\u0026amp;parser.template); 55 } 56 resolv_conf_parser_free (\u0026amp;parser); 57 58 if (fp != NULL) 59 { 60 int saved_errno = errno; 61 fclose (fp); 62 __set_errno (saved_errno); 63 } 64 65 return conf; 66} 处理/etc/resolv.conf # 格式化一下看 1// resolv/res_init.c 2/* Internal helper function for __res_vinit, to aid with resource 3 deallocation and error handling. Return true on success, false on 4 failure. */ 5static bool res_vinit_1(FILE *fp, struct resolv_conf_parser *parser) { 6 char *cp; 7 size_t buffer_size = 0; 8 bool haveenv = false; 9 10 /* Allow user to override the local domain definition. */ 11 if ((cp = getenv(\u0026#34;LOCALDOMAIN\u0026#34;)) != NULL) { 12 /* The code below splits the string in place. */ 13 cp = __strdup(cp); 14 if (cp == NULL) return false; 15 free(parser-\u0026gt;search_list_store); 16 parser-\u0026gt;search_list_store = cp; 17 haveenv = true; 18 19 /* The string will be truncated as needed below. */ 20 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 21 22 /* Set search list to be blank-separated strings from rest of 23 env value. Permits users of LOCALDOMAIN to still have a 24 search list, and anyone to set the one that they want to use 25 as an individual (even more important now that the rfc1535 26 stuff restricts searches). */ 27 for (bool in_name = true; *cp != \u0026#39;\\0\u0026#39;; cp++) { 28 if (*cp == \u0026#39;\\n\u0026#39;) { 29 *cp = \u0026#39;\\0\u0026#39;; 30 break; 31 } else if (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) { 32 *cp = \u0026#39;\\0\u0026#39;; 33 in_name = false; 34 } else if (!in_name) { 35 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 36 in_name = true; 37 } 38 } 39 } 40 41#define MATCH(line, name) \\ 42 (!strncmp((line), name, sizeof(name) - 1) \u0026amp;\u0026amp; ((line)[sizeof(name) - 1] == \u0026#39; \u0026#39; || (line)[sizeof(name) - 1] == \u0026#39;\\t\u0026#39;)) 43 44 if (fp != NULL) { 45 /* No threads use this stream. */ 46 __fsetlocking(fp, FSETLOCKING_BYCALLER); 47 /* Read the config file. */ 48 while (true) { 49 { 50 ssize_t ret = __getline(\u0026amp;parser-\u0026gt;buffer, \u0026amp;buffer_size, fp); 51 if (ret \u0026lt;= 0) { 52 if (_IO_ferror_unlocked(fp)) 53 return false; 54 else 55 break; 56 } 57 } 58 59 /* Skip comments. */ 60 if (*parser-\u0026gt;buffer == \u0026#39;;\u0026#39; || *parser-\u0026gt;buffer == \u0026#39;#\u0026#39;) continue; 61 /* Read default domain name. */ 62 if (MATCH(parser-\u0026gt;buffer, \u0026#34;domain\u0026#34;)) { 63 if (haveenv) /* LOCALDOMAIN overrides the configuration file. */ 64 continue; 65 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;domain\u0026#34;) - 1; 66 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 67 if ((*cp == \u0026#39;\\0\u0026#39;) || (*cp == \u0026#39;\\n\u0026#39;)) continue; 68 69 cp = __strdup(cp); 70 if (cp == NULL) return false; 71 free(parser-\u0026gt;search_list_store); 72 parser-\u0026gt;search_list_store = cp; 73 search_list_clear(\u0026amp;parser-\u0026gt;search_list); 74 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 75 /* Replace trailing whitespace. */ 76 if ((cp = strpbrk(cp, \u0026#34; \\t\\n\u0026#34;)) != NULL) *cp = \u0026#39;\\0\u0026#39;; 77 continue; 78 } 79 /* Set search list. */ 80 if (MATCH(parser-\u0026gt;buffer, \u0026#34;search\u0026#34;)) { 81 if (haveenv) /* LOCALDOMAIN overrides the configuration file. */ 82 continue; 83 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;search\u0026#34;) - 1; 84 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 85 if ((*cp == \u0026#39;\\0\u0026#39;) || (*cp == \u0026#39;\\n\u0026#39;)) continue; 86 87 { 88 char *p = strchr(cp, \u0026#39;\\n\u0026#39;); 89 if (p != NULL) *p = \u0026#39;\\0\u0026#39;; 90 } 91 cp = __strdup(cp); 92 if (cp == NULL) return false; 93 free(parser-\u0026gt;search_list_store); 94 parser-\u0026gt;search_list_store = cp; 95 96 /* The string is truncated below. */ 97 search_list_clear(\u0026amp;parser-\u0026gt;search_list); 98 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 99 100 /* Set search list to be blank-separated strings on rest 101 of line. */ 102 for (bool in_name = true; *cp != \u0026#39;\\0\u0026#39;; cp++) { 103 if (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) { 104 *cp = \u0026#39;\\0\u0026#39;; 105 in_name = false; 106 } else if (!in_name) { 107 search_list_add(\u0026amp;parser-\u0026gt;search_list, cp); 108 in_name = true; 109 } 110 } 111 continue; 112 } 113 /* Read nameservers to query. */ 114 if (MATCH(parser-\u0026gt;buffer, \u0026#34;nameserver\u0026#34;)) { 115 struct in_addr a; 116 117 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;nameserver\u0026#34;) - 1; 118 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 119 120 /* Ignore trailing contents on the name server line. */ 121 { 122 char *el; 123 if ((el = strpbrk(cp, \u0026#34; \\t\\n\u0026#34;)) != NULL) *el = \u0026#39;\\0\u0026#39;; 124 } 125 126 struct sockaddr *sa; 127 if ((*cp != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (*cp != \u0026#39;\\n\u0026#39;) \u0026amp;\u0026amp; __inet_aton_exact(cp, \u0026amp;a)) { 128 sa = allocate_address_v4(a, NAMESERVER_PORT); 129 if (sa == NULL) return false; 130 } else { 131 struct in6_addr a6; 132 char *el; 133 if ((el = strchr(cp, SCOPE_DELIMITER)) != NULL) *el = \u0026#39;\\0\u0026#39;; 134 if ((*cp != \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (__inet_pton(AF_INET6, cp, \u0026amp;a6) \u0026gt; 0)) { 135 struct sockaddr_in6 *sa6; 136 137 sa6 = malloc(sizeof(*sa6)); 138 if (sa6 == NULL) return false; 139 140 sa6-\u0026gt;sin6_family = AF_INET6; 141 sa6-\u0026gt;sin6_port = htons(NAMESERVER_PORT); 142 sa6-\u0026gt;sin6_flowinfo = 0; 143 sa6-\u0026gt;sin6_addr = a6; 144 145 sa6-\u0026gt;sin6_scope_id = 0; 146 if (__glibc_likely(el != NULL)) 147 /* Ignore errors, for backwards 148 compatibility. */ 149 __inet6_scopeid_pton(\u0026amp;a6, el + 1, \u0026amp;sa6-\u0026gt;sin6_scope_id); 150 sa = (struct sockaddr *)sa6; 151 } else 152 /* IPv6 address parse failure. */ 153 sa = NULL; 154 } 155 if (sa != NULL) { 156 const struct sockaddr **p = nameserver_list_emplace(\u0026amp;parser-\u0026gt;nameserver_list); 157 if (p != NULL) 158 *p = sa; 159 else { 160 free(sa); 161 return false; 162 } 163 } 164 continue; 165 } 166 if (MATCH(parser-\u0026gt;buffer, \u0026#34;sortlist\u0026#34;)) { 167 struct in_addr a; 168 169 cp = parser-\u0026gt;buffer + sizeof(\u0026#34;sortlist\u0026#34;) - 1; 170 while (true) { 171 while (*cp == \u0026#39; \u0026#39; || *cp == \u0026#39;\\t\u0026#39;) cp++; 172 if (*cp == \u0026#39;\\0\u0026#39; || *cp == \u0026#39;\\n\u0026#39; || *cp == \u0026#39;;\u0026#39;) break; 173 char *net = cp; 174 while (*cp \u0026amp;\u0026amp; !is_sort_mask(*cp) \u0026amp;\u0026amp; *cp != \u0026#39;;\u0026#39; \u0026amp;\u0026amp; isascii(*cp) \u0026amp;\u0026amp; !isspace(*cp)) cp++; 175 char separator = *cp; 176 *cp = 0; 177 struct resolv_sortlist_entry e; 178 if (__inet_aton_exact(net, \u0026amp;a)) { 179 e.addr = a; 180 if (is_sort_mask(separator)) { 181 *cp++ = separator; 182 net = cp; 183 while (*cp \u0026amp;\u0026amp; *cp != \u0026#39;;\u0026#39; \u0026amp;\u0026amp; isascii(*cp) \u0026amp;\u0026amp; !isspace(*cp)) cp++; 184 separator = *cp; 185 *cp = 0; 186 if (__inet_aton_exact(net, \u0026amp;a)) 187 e.mask = a.s_addr; 188 else 189 e.mask = net_mask(e.addr); 190 } else 191 e.mask = net_mask(e.addr); 192 sort_list_add(\u0026amp;parser-\u0026gt;sort_list, e); 193 } 194 *cp = separator; 195 } 196 continue; 197 } 198 if (MATCH(parser-\u0026gt;buffer, \u0026#34;options\u0026#34;)) { 199 res_setoptions(parser, parser-\u0026gt;buffer + sizeof(\u0026#34;options\u0026#34;) - 1); 200 continue; 201 } 202 } 203 } 204 if (__glibc_unlikely(nameserver_list_size(\u0026amp;parser-\u0026gt;nameserver_list) == 0)) { 205 const struct sockaddr **p = nameserver_list_emplace(\u0026amp;parser-\u0026gt;nameserver_list); 206 if (p == NULL) return false; 207 *p = allocate_address_v4(__inet_makeaddr(IN_LOOPBACKNET, 1), NAMESERVER_PORT); 208 if (*p == NULL) return false; 209 } 210 211 if (search_list_size(\u0026amp;parser-\u0026gt;search_list) == 0) { 212 char *domain; 213 if (!domain_from_hostname(\u0026amp;domain)) return false; 214 if (domain != NULL) { 215 free(parser-\u0026gt;search_list_store); 216 parser-\u0026gt;search_list_store = domain; 217 search_list_add(\u0026amp;parser-\u0026gt;search_list, domain); 218 } 219 } 220 221 if ((cp = getenv(\u0026#34;RES_OPTIONS\u0026#34;)) != NULL) res_setoptions(parser, cp); 222 223 if (nameserver_list_has_failed(\u0026amp;parser-\u0026gt;nameserver_list) || search_list_has_failed(\u0026amp;parser-\u0026gt;search_list) || 224 sort_list_has_failed(\u0026amp;parser-\u0026gt;sort_list)) { 225 __set_errno(ENOMEM); 226 return false; 227 } 228 229 return true; 230} 2. 如何发包 # 调用gethostbyname3_context，格式化了一下，之前的缩进太难看懂 1// resolv/nss_dns/dns-host.c 2static enum nss_status gethostbyname3_context(struct resolv_context *ctx, const char *name, int af, 3 struct hostent *result, char *buffer, size_t buflen, int *errnop, 4 int *h_errnop, int32_t *ttlp, char **canonp) { 5 union { 6 querybuf *buf; 7 u_char *ptr; 8 } host_buffer; 9 querybuf *orig_host_buffer; 10 char tmp[NS_MAXDNAME]; 11 int size, type, n; 12 const char *cp; 13 int map = 0; 14 int olderr = errno; 15 enum nss_status status; 16 17 switch (af) { 18 case AF_INET: 19 size = INADDRSZ; 20 type = T_A; 21 break; 22 case AF_INET6: 23 size = IN6ADDRSZ; 24 type = T_AAAA; 25 break; 26 default: 27 *h_errnop = NO_DATA; 28 *errnop = EAFNOSUPPORT; 29 return NSS_STATUS_UNAVAIL; 30 } 31 32 result-\u0026gt;h_addrtype = af; 33 result-\u0026gt;h_length = size; 34 35 /* 36 * if there aren\u0026#39;t any dots, it could be a user-level alias. 37 * this is also done in res_query() since we are not the only 38 * function that looks up host names. 39 */ 40 if (strchr(name, \u0026#39;.\u0026#39;) == NULL \u0026amp;\u0026amp; (cp = __res_context_hostalias(ctx, name, tmp, sizeof(tmp))) != NULL) name = cp; 41 42 host_buffer.buf = orig_host_buffer = (querybuf *)alloca(1024); 43 44 // 这里发起dns请求 45 n = __res_context_search(ctx, name, C_IN, type, host_buffer.buf-\u0026gt;buf, 1024, \u0026amp;host_buffer.ptr, NULL, NULL, NULL, 46 NULL); 47 if (n \u0026lt; 0) { 48 switch (errno) { 49 case ESRCH: 50 status = NSS_STATUS_TRYAGAIN; 51 h_errno = TRY_AGAIN; 52 break; 53 /* System has run out of file descriptors. */ 54 case EMFILE: 55 case ENFILE: 56 h_errno = NETDB_INTERNAL; 57 /* Fall through. */ 58 case ECONNREFUSED: 59 case ETIMEDOUT: 60 status = NSS_STATUS_UNAVAIL; 61 break; 62 default: 63 status = NSS_STATUS_NOTFOUND; 64 break; 65 } 66 *h_errnop = h_errno; 67 if (h_errno == TRY_AGAIN) 68 *errnop = EAGAIN; 69 else 70 __set_errno(olderr); 71 72 /* If we are looking for an IPv6 address and mapping is enabled 73 by having the RES_USE_INET6 bit in _res.options set, we try 74 another lookup. */ 75 if (af == AF_INET6 \u0026amp;\u0026amp; res_use_inet6()) 76 n = __res_context_search(ctx, name, C_IN, T_A, host_buffer.buf-\u0026gt;buf, 77 host_buffer.buf != orig_host_buffer ? MAXPACKET : 1024, \u0026amp;host_buffer.ptr, NULL, 78 NULL, NULL, NULL); 79 80 if (n \u0026lt; 0) { 81 if (host_buffer.buf != orig_host_buffer) free(host_buffer.buf); 82 return status; 83 } 84 85 map = 1; 86 87 result-\u0026gt;h_addrtype = AF_INET; 88 result-\u0026gt;h_length = INADDRSZ; 89 } 90 91 // 处理一下dns响应结果 92 status = 93 getanswer_r(ctx, host_buffer.buf, n, name, type, result, buffer, buflen, errnop, h_errnop, map, ttlp, canonp); 94 if (host_buffer.buf != orig_host_buffer) free(host_buffer.buf); 95 return status; 96} 到__res_context_search进行处理发送dns请求 1// resolv/res_query.c 2/* Formulate a normal query, send, and retrieve answer in supplied 3 buffer. Return the size of the response on success, -1 on error. 4 If enabled, implement search rules until answer or unrecoverable 5 failure is detected. Error code, if any, is left in h_errno. */ 6int 7__res_context_search (struct resolv_context *ctx, 8\tconst char *name, int class, int type, 9\tunsigned char *answer, int anslen, 10\tunsigned char **answerp, unsigned char **answerp2, 11\tint *nanswerp2, int *resplen2, int *answerp2_malloced) 12{ 13\tstruct __res_state *statp = ctx-\u0026gt;resp; 14\tconst char *cp; 15\tUHEADER *hp = (UHEADER *) answer; 16\tchar tmp[NS_MAXDNAME]; 17\tu_int dots; 18\tint trailing_dot, ret, saved_herrno; 19\tint got_nodata = 0, got_servfail = 0, root_on_list = 0; 20\tint tried_as_is = 0; 21\tint searched = 0; 22 23\t__set_errno (0); 24\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND); /* True if we never query. */ 25 26\tdots = 0; 27\tfor (cp = name; *cp != \u0026#39;\\0\u0026#39;; cp++) 28\tdots += (*cp == \u0026#39;.\u0026#39;); 29\ttrailing_dot = 0; 30\tif (cp \u0026gt; name \u0026amp;\u0026amp; *--cp == \u0026#39;.\u0026#39;) 31\ttrailing_dot++; 32 33\t/* If there aren\u0026#39;t any dots, it could be a user-level alias. */ 34\tif (!dots \u0026amp;\u0026amp; (cp = __res_context_hostalias 35\t(ctx, name, tmp, sizeof tmp))!= NULL) 36\treturn __res_context_query (ctx, cp, class, type, answer, 37\tanslen, answerp, answerp2, 38\tnanswerp2, resplen2, answerp2_malloced); 39 40\t/* 41\t* If there are enough dots in the name, let\u0026#39;s just give it a 42\t* try \u0026#39;as is\u0026#39;. The threshold can be set with the \u0026#34;ndots\u0026#34; option. 43\t* Also, query \u0026#39;as is\u0026#39;, if there is a trailing dot in the name. 44\t*/ 45\tsaved_herrno = -1; 46\tif (dots \u0026gt;= statp-\u0026gt;ndots || trailing_dot) { 47\tret = __res_context_querydomain (ctx, name, NULL, class, type, 48\tanswer, anslen, answerp, 49\tanswerp2, nanswerp2, resplen2, 50\tanswerp2_malloced); 51\tif (ret \u0026gt; 0 || trailing_dot 52\t/* If the second response is valid then we use that. */ 53\t|| (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL \u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 54\treturn (ret); 55\tsaved_herrno = h_errno; 56\ttried_as_is++; 57\tif (answerp \u0026amp;\u0026amp; *answerp != answer) { 58\tanswer = *answerp; 59\tanslen = MAXPACKET; 60\t} 61\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 62\t{ 63\tfree (*answerp2); 64\t*answerp2 = NULL; 65\t*nanswerp2 = 0; 66\t*answerp2_malloced = 0; 67\t} 68\t} 69 70\t/* 71\t* We do at least one level of search if 72\t*\t- there is no dot and RES_DEFNAME is set, or 73\t*\t- there is at least one dot, there is no trailing dot, 74\t*\tand RES_DNSRCH is set. 75\t*/ 76\tif ((!dots \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_DEFNAMES) != 0) || 77\t(dots \u0026amp;\u0026amp; !trailing_dot \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_DNSRCH) != 0)) { 78\tint done = 0; 79 80\tfor (size_t domain_index = 0; !done; ++domain_index) { 81\tconst char *dname = __resolv_context_search_list 82\t(ctx, domain_index); 83\tif (dname == NULL) 84\tbreak; 85\tsearched = 1; 86 87\t/* __res_context_querydoman concatenates name 88\twith dname with a \u0026#34;.\u0026#34; in between. If we 89\tpass it in dname the \u0026#34;.\u0026#34; we got from the 90\tconfigured default search path, we\u0026#39;ll end 91\tup with \u0026#34;name..\u0026#34;, which won\u0026#39;t resolve. 92\tOTOH, passing it \u0026#34;\u0026#34; will result in \u0026#34;name.\u0026#34;, 93\twhich has the intended effect for both 94\tpossible representations of the root 95\tdomain. */ 96\tif (dname[0] == \u0026#39;.\u0026#39;) 97\tdname++; 98\tif (dname[0] == \u0026#39;\\0\u0026#39;) 99\troot_on_list++; 100 101\tret = __res_context_querydomain 102\t(ctx, name, dname, class, type, 103\tanswer, anslen, answerp, answerp2, nanswerp2, 104\tresplen2, answerp2_malloced); 105\tif (ret \u0026gt; 0 || (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL 106\t\u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 107\treturn (ret); 108 109\tif (answerp \u0026amp;\u0026amp; *answerp != answer) { 110\tanswer = *answerp; 111\tanslen = MAXPACKET; 112\t} 113\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 114\t{ 115\tfree (*answerp2); 116\t*answerp2 = NULL; 117\t*nanswerp2 = 0; 118\t*answerp2_malloced = 0; 119\t} 120 121\t/* 122\t* If no server present, give up. 123\t* If name isn\u0026#39;t found in this domain, 124\t* keep trying higher domains in the search list 125\t* (if that\u0026#39;s enabled). 126\t* On a NO_DATA error, keep trying, otherwise 127\t* a wildcard entry of another type could keep us 128\t* from finding this entry higher in the domain. 129\t* If we get some other error (negative answer or 130\t* server failure), then stop searching up, 131\t* but try the input name below in case it\u0026#39;s 132\t* fully-qualified. 133\t*/ 134\tif (errno == ECONNREFUSED) { 135\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 136\treturn (-1); 137\t} 138 139\tswitch (statp-\u0026gt;res_h_errno) { 140\tcase NO_DATA: 141\tgot_nodata++; 142\t/* FALLTHROUGH */ 143\tcase HOST_NOT_FOUND: 144\t/* keep trying */ 145\tbreak; 146\tcase TRY_AGAIN: 147\tif (hp-\u0026gt;rcode == SERVFAIL) { 148\t/* try next search element, if any */ 149\tgot_servfail++; 150\tbreak; 151\t} 152\t/* FALLTHROUGH */ 153\tdefault: 154\t/* anything else implies that we\u0026#39;re done */ 155\tdone++; 156\t} 157 158\t/* if we got here for some reason other than DNSRCH, 159\t* we only wanted one iteration of the loop, so stop. 160\t*/ 161\tif ((statp-\u0026gt;options \u0026amp; RES_DNSRCH) == 0) 162\tdone++; 163\t} 164\t} 165 166\t/* 167\t* If the query has not already been tried as is then try it 168\t* unless RES_NOTLDQUERY is set and there were no dots. 169\t*/ 170\tif ((dots || !searched || (statp-\u0026gt;options \u0026amp; RES_NOTLDQUERY) == 0) 171\t\u0026amp;\u0026amp; !(tried_as_is || root_on_list)) { 172\tret = __res_context_querydomain 173\t(ctx, name, NULL, class, type, 174\tanswer, anslen, answerp, answerp2, nanswerp2, 175\tresplen2, answerp2_malloced); 176\tif (ret \u0026gt; 0 || (ret == 0 \u0026amp;\u0026amp; resplen2 != NULL 177\t\u0026amp;\u0026amp; *resplen2 \u0026gt; 0)) 178\treturn (ret); 179\t} 180 181\t/* if we got here, we didn\u0026#39;t satisfy the search. 182\t* if we did an initial full query, return that query\u0026#39;s H_ERRNO 183\t* (note that we wouldn\u0026#39;t be here if that query had succeeded). 184\t* else if we ever got a nodata, send that back as the reason. 185\t* else send back meaningless H_ERRNO, that being the one from 186\t* the last DNSRCH we did. 187\t*/ 188\tif (answerp2 \u0026amp;\u0026amp; *answerp2_malloced) 189\t{ 190\tfree (*answerp2); 191\t*answerp2 = NULL; 192\t*nanswerp2 = 0; 193\t*answerp2_malloced = 0; 194\t} 195\tif (saved_herrno != -1) 196\tRES_SET_H_ERRNO(statp, saved_herrno); 197\telse if (got_nodata) 198\tRES_SET_H_ERRNO(statp, NO_DATA); 199\telse if (got_servfail) 200\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 201\treturn (-1); 202} 203libc_hidden_def (__res_context_search) 从__res_context_querydomain也会调用到__res_context_query 里面就是判断了一下最大域名大小不超过1025 1// resolv/arpa/nameser_compat.h 2#define MAXDNAME\tNS_MAXDNAME 3 4// resolv/arpa/nameser.h 5#define NS_MAXDNAME\t1025\t/*%\u0026lt; maximum domain name */ 6 7// resolv/res_query.c 8/* Perform a call on res_query on the concatenation of name and 9 domain. */ 10static int 11__res_context_querydomain (struct resolv_context *ctx, 12\tconst char *name, const char *domain, 13\tint class, int type, 14\tunsigned char *answer, int anslen, 15\tunsigned char **answerp, unsigned char **answerp2, 16\tint *nanswerp2, int *resplen2, 17\tint *answerp2_malloced) 18{ 19\tstruct __res_state *statp = ctx-\u0026gt;resp; 20\tchar nbuf[MAXDNAME]; 21\tconst char *longname = nbuf; 22\tsize_t n, d; 23 24\tif (domain == NULL) { 25\tn = strlen(name); 26 27\t/* Decrement N prior to checking it against MAXDNAME 28\tso that we detect a wrap to SIZE_MAX and return 29\ta reasonable error. */ 30\tn--; 31\tif (n \u0026gt;= MAXDNAME - 1) { 32\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 33\treturn (-1); 34\t} 35\tlongname = name; 36\t} else { 37\tn = strlen(name); 38\td = strlen(domain); 39 // 判断一下是否超过最长域名大小 40\tif (n + d + 1 \u0026gt;= MAXDNAME) { 41\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 42\treturn (-1); 43\t} 44\tchar *p = __stpcpy (nbuf, name); 45\t*p++ = \u0026#39;.\u0026#39;; 46\tstrcpy (p, domain); 47\t} 48\treturn __res_context_query (ctx, longname, class, type, answer, 49\tanslen, answerp, answerp2, nanswerp2, 50\tresplen2, answerp2_malloced); 51} __res_context_query发起dns请求 1// resolv/res_query.c 2/* Formulate a normal query, send, and await answer. Returned answer 3 is placed in supplied buffer ANSWER. Perform preliminary check of 4 answer, returning success only if no error is indicated and the 5 answer count is nonzero. Return the size of the response on 6 success, -1 on error. Error number is left in h_errno. 7 8 Caller must parse answer and determine whether it answers the 9 question. */ 10int 11__res_context_query (struct resolv_context *ctx, const char *name, 12\tint class, int type, 13\tunsigned char *answer, int anslen, 14\tunsigned char **answerp, unsigned char **answerp2, 15\tint *nanswerp2, int *resplen2, int *answerp2_malloced) 16{ 17\tstruct __res_state *statp = ctx-\u0026gt;resp; 18\tUHEADER *hp = (UHEADER *) answer; 19\tUHEADER *hp2; 20\tint n, use_malloc = 0; 21 22\tsize_t bufsize = (type == T_QUERY_A_AND_AAAA ? 2 : 1) * QUERYSIZE; 23\tu_char *buf = alloca (bufsize); 24\tu_char *query1 = buf; 25\tint nquery1 = -1; 26\tu_char *query2 = NULL;\t// 存储AAAA请求 27\tint nquery2 = 0;\t// query2的长度 28 29 again: 30 // 构造dns请求包 31\thp-\u0026gt;rcode = NOERROR;\t/* default */ 32 33\tif (type == T_QUERY_A_AND_AAAA) 34\t{ 35\t// 要请求A和AAAA，构造A记录存到query1中，AAAA存到query2中 36\t// 构造A存到query1中 37\tn = __res_context_mkquery (ctx, QUERY, name, class, T_A, NULL, 38\tquery1, bufsize); 39\tif (n \u0026gt; 0) 40\t{ 41\tif ((statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 42\t{ 43\t/* Use RESOLV_EDNS_BUFFER_SIZE because the receive 44\tbuffer can be reallocated. */ 45\tn = __res_nopt (ctx, n, query1, bufsize, 46\tRESOLV_EDNS_BUFFER_SIZE); 47\tif (n \u0026lt; 0) 48\tgoto unspec_nomem; 49\t} 50 51\tnquery1 = n; 52\t/* Align the buffer. */ 53\tint npad = ((nquery1 + __alignof__ (HEADER) - 1) 54\t\u0026amp; ~(__alignof__ (HEADER) - 1)) - nquery1; 55\tif (n \u0026gt; bufsize - npad) 56\t{ 57\tn = -1; 58\tgoto unspec_nomem; 59\t} 60\tint nused = n + npad; 61\tquery2 = buf + nused; 62\t// 构造AAAA到query2 63\tn = __res_context_mkquery (ctx, QUERY, name, class, T_AAAA, 64\tNULL, query2, bufsize - nused); 65\tif (n \u0026gt; 0 66\t\u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 67\t/* Use RESOLV_EDNS_BUFFER_SIZE because the receive 68\tbuffer can be reallocated. */ 69\tn = __res_nopt (ctx, n, query2, bufsize, 70\tRESOLV_EDNS_BUFFER_SIZE); 71\tnquery2 = n; 72\t} 73 74\tunspec_nomem:; 75\t} 76\telse 77\t{ 78\t// 不是A和AAAA都需要，就只构造query就行了 79\tn = __res_context_mkquery (ctx, QUERY, name, class, type, NULL, 80\tquery1, bufsize); 81 82\tif (n \u0026gt; 0 83\t\u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0) 84\t{ 85\t/* Use RESOLV_EDNS_BUFFER_SIZE if the receive buffer 86\tcan be reallocated. */ 87\tsize_t advertise; 88\tif (answerp == NULL) 89\tadvertise = anslen; 90\telse 91\tadvertise = RESOLV_EDNS_BUFFER_SIZE; 92\tn = __res_nopt (ctx, n, query1, bufsize, advertise); 93\t} 94 95\tnquery1 = n; 96\t} 97 98\tif (__glibc_unlikely (n \u0026lt;= 0) \u0026amp;\u0026amp; !use_malloc) { 99\t/* Retry just in case res_nmkquery failed because of too 100\tshort buffer. Shouldn\u0026#39;t happen. */ 101\tbufsize = (type == T_QUERY_A_AND_AAAA ? 2 : 1) * MAXPACKET; 102\tbuf = malloc (bufsize); 103\tif (buf != NULL) { 104\tquery1 = buf; 105\tuse_malloc = 1; 106\tgoto again; 107\t} 108\t} 109\tif (__glibc_unlikely (n \u0026lt;= 0)) { 110\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 111\tif (use_malloc) 112\tfree (buf); 113\treturn (n); 114\t} 115 116\t/* Suppress AAAA lookups if required. __res_handle_no_aaaa 117\tchecks RES_NOAAAA first, so avoids parsing the 118\tjust-generated query packet in most cases. nss_dns avoids 119\tusing T_QUERY_A_AND_AAAA in RES_NOAAAA mode, so there is no 120\tneed to handle it here. */ 121\tif (type == T_AAAA \u0026amp;\u0026amp; __res_handle_no_aaaa (ctx, query1, nquery1, 122\tanswer, anslen, \u0026amp;n)) 123\t/* There must be no second query for AAAA queries. The code 124\tbelow is still needed to translate NODATA responses. */ 125\tassert (query2 == NULL); 126\telse 127\t{ 128\tassert (answerp == NULL || (void *) *answerp == (void *) answer); 129 // 发送dns请求 130\tn = __res_context_send (ctx, query1, nquery1, query2, nquery2, 131\tanswer, anslen, 132\tanswerp, answerp2, nanswerp2, resplen2, 133\tanswerp2_malloced); 134\t} 135 136 // 处理dns响应 137\tif (use_malloc) 138\tfree (buf); 139\tif (n \u0026lt; 0) { 140\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 141\treturn (n); 142\t} 143 144\tif (answerp != NULL) 145\t/* __res_context_send might have reallocated the buffer. */ 146\thp = (UHEADER *) *answerp; 147 148\t/* We simplify the following tests by assigning HP to HP2 or 149\tvice versa. It is easy to verify that this is the same as 150\tignoring all tests of HP or HP2. */ 151\tif (answerp2 == NULL || *resplen2 \u0026lt; (int) sizeof (HEADER)) 152\t{ 153\thp2 = hp; 154\t} 155\telse 156\t{ 157\thp2 = (UHEADER *) *answerp2; 158\tif (n \u0026lt; (int) sizeof (HEADER)) 159\t{ 160\thp = hp2; 161\t} 162\t} 163 164\t/* Make sure both hp and hp2 are defined */ 165\tassert((hp != NULL) \u0026amp;\u0026amp; (hp2 != NULL)); 166 167\tif ((hp-\u0026gt;rcode != NOERROR || ntohs(hp-\u0026gt;ancount) == 0) 168\t\u0026amp;\u0026amp; (hp2-\u0026gt;rcode != NOERROR || ntohs(hp2-\u0026gt;ancount) == 0)) { 169\tswitch (hp-\u0026gt;rcode == NOERROR ? hp2-\u0026gt;rcode : hp-\u0026gt;rcode) { 170\tcase NXDOMAIN: 171\tif ((hp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; ntohs (hp-\u0026gt;ancount) != 0) 172\t|| (hp2-\u0026gt;rcode == NOERROR 173\t\u0026amp;\u0026amp; ntohs (hp2-\u0026gt;ancount) != 0)) 174\tgoto success; 175\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND); 176\tbreak; 177\tcase SERVFAIL: 178\tRES_SET_H_ERRNO(statp, TRY_AGAIN); 179\tbreak; 180\tcase NOERROR: 181\tif (ntohs (hp-\u0026gt;ancount) != 0 182\t|| ntohs (hp2-\u0026gt;ancount) != 0) 183\tgoto success; 184\tRES_SET_H_ERRNO(statp, NO_DATA); 185\tbreak; 186\tcase FORMERR: 187\tcase NOTIMP: 188\t/* Servers must not reply to AAAA queries with 189\tNOTIMP etc but some of them do. */ 190\tif ((hp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; ntohs (hp-\u0026gt;ancount) != 0) 191\t|| (hp2-\u0026gt;rcode == NOERROR 192\t\u0026amp;\u0026amp; ntohs (hp2-\u0026gt;ancount) != 0)) 193\tgoto success; 194\t/* FALLTHROUGH */ 195\tcase REFUSED: 196\tdefault: 197\tRES_SET_H_ERRNO(statp, NO_RECOVERY); 198\tbreak; 199\t} 200\treturn (-1); 201\t} 202 success: 203\treturn (n); 204} 205libc_hidden_def (__res_context_query) __res_context_send发送dns请求包 1// resolv/res_send.c 2int 3__res_context_send (struct resolv_context *ctx, 4\tconst unsigned char *buf, int buflen, 5\tconst unsigned char *buf2, int buflen2, 6\tunsigned char *ans, int anssiz, 7\tunsigned char **ansp, unsigned char **ansp2, 8\tint *nansp2, int *resplen2, int *ansp2_malloced) 9{ 10\tstruct __res_state *statp = ctx-\u0026gt;resp; 11\tint gotsomewhere, terrno, try, v_circuit, resplen; 12\t/* On some architectures send_vc is inlined and the compiler might emit 13\ta warning indicating \u0026#39;resplen\u0026#39; may be used uninitialized. Note that 14\tthe warning belongs to resplen in send_vc which is used as return 15\tvalue! There the maybe-uninitialized warning is already ignored as 16\tit is a false-positive - see comment in send_vc. 17\tHere the variable n is set to the return value of send_vc. 18\tSee below. */ 19\tDIAG_PUSH_NEEDS_COMMENT; 20\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 21\tint n; 22\tDIAG_POP_NEEDS_COMMENT; 23 24\tif (statp-\u0026gt;nscount == 0) { 25\t__set_errno (ESRCH); 26\treturn (-1); 27\t} 28 29\tif (anssiz \u0026lt; (buf2 == NULL ? 1 : 2) * HFIXEDSZ) { 30\t__set_errno (EINVAL); 31\treturn (-1); 32\t} 33 34\tv_circuit = ((statp-\u0026gt;options \u0026amp; RES_USEVC) 35\t|| buflen \u0026gt; PACKETSZ 36\t|| buflen2 \u0026gt; PACKETSZ); 37\tgotsomewhere = 0; 38\tterrno = ETIMEDOUT; 39 40\t/* 41\t* If the ns_addr_list in the resolver context has changed, then 42\t* invalidate our cached copy and the associated timing data. 43\t*/ 44\tif (EXT(statp).nscount != 0) { 45\tint needclose = 0; 46 47\tif (EXT(statp).nscount != statp-\u0026gt;nscount) 48\tneedclose++; 49\telse 50\tfor (unsigned int ns = 0; ns \u0026lt; statp-\u0026gt;nscount; ns++) { 51\tif (statp-\u0026gt;nsaddr_list[ns].sin_family != 0 52\t\u0026amp;\u0026amp; !sock_eq((struct sockaddr_in6 *) 53\t\u0026amp;statp-\u0026gt;nsaddr_list[ns], 54\tEXT(statp).nsaddrs[ns])) 55\t{ 56\tneedclose++; 57\tbreak; 58\t} 59\t} 60\tif (needclose) { 61\t__res_iclose(statp, false); 62\tEXT(statp).nscount = 0; 63\t} 64\t} 65 66\t/* 67\t* Maybe initialize our private copy of the ns_addr_list. 68\t*/ 69\tif (EXT(statp).nscount == 0) { 70\tfor (unsigned int ns = 0; ns \u0026lt; statp-\u0026gt;nscount; ns++) { 71\tEXT(statp).nssocks[ns] = -1; 72\tif (statp-\u0026gt;nsaddr_list[ns].sin_family == 0) 73\tcontinue; 74\tif (EXT(statp).nsaddrs[ns] == NULL) 75\tEXT(statp).nsaddrs[ns] = 76\tmalloc(sizeof (struct sockaddr_in6)); 77\tif (EXT(statp).nsaddrs[ns] != NULL) 78\tmemset (mempcpy(EXT(statp).nsaddrs[ns], 79\t\u0026amp;statp-\u0026gt;nsaddr_list[ns], 80\tsizeof (struct sockaddr_in)), 81\t\u0026#39;\\0\u0026#39;, 82\tsizeof (struct sockaddr_in6) 83\t- sizeof (struct sockaddr_in)); 84\telse 85\treturn -1; 86\t} 87\tEXT(statp).nscount = statp-\u0026gt;nscount; 88\t} 89 90\t/* Name server index offset. Used to implement 91\tRES_ROTATE. */ 92\tunsigned int ns_offset = nameserver_offset (statp); 93 94\t/* 95\t* Send request, RETRY times, or until successful. 96\t*/ 97 // 发送请求，重试到成功或超出重试次数为止 98 // 根据ns为索引，一个一个尝试，超时就尝试下一个 99\tfor (try = 0; try \u0026lt; statp-\u0026gt;retry; try++) { 100\tfor (unsigned ns_shift = 0; ns_shift \u0026lt; statp-\u0026gt;nscount; ns_shift++) 101\t{ 102\t/* The actual name server index. This implements 103\tRES_ROTATE. */ 104\tunsigned int ns = ns_shift + ns_offset; 105\tif (ns \u0026gt;= statp-\u0026gt;nscount) 106\tns -= statp-\u0026gt;nscount; 107 108\tsame_ns: 109\tif (__glibc_unlikely (v_circuit)) { 110 // tcpdns，内部会创建socket放到statp-\u0026gt;_vcsock中 111\t/* Use VC; at most one attempt per server. */ 112\ttry = statp-\u0026gt;retry; 113\tn = send_vc(statp, buf, buflen, buf2, buflen2, 114\t\u0026amp;ans, \u0026amp;anssiz, \u0026amp;terrno, 115\tns, ansp, ansp2, nansp2, resplen2, 116\tansp2_malloced); 117\tif (n \u0026lt; 0) 118\treturn (-1); 119\t/* See comment at the declaration of n. */ 120\tDIAG_PUSH_NEEDS_COMMENT; 121\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 122\tif (n == 0 \u0026amp;\u0026amp; (buf2 == NULL || *resplen2 == 0)) 123\tgoto next_ns; 124\tDIAG_POP_NEEDS_COMMENT; 125\t} else { 126 // udpdns，内部会创建socket放到EXT(statp).nssocks中 127\t/* Use datagrams. */ 128\tn = send_dg(statp, buf, buflen, buf2, buflen2, 129\t\u0026amp;ans, \u0026amp;anssiz, \u0026amp;terrno, 130\tns, \u0026amp;v_circuit, \u0026amp;gotsomewhere, ansp, 131\tansp2, nansp2, resplen2, ansp2_malloced); 132\tif (n \u0026lt; 0) 133\treturn (-1); 134\t// n为0且不需要buf2或resplen2为0，尝试下一个 135\tif (n == 0 \u0026amp;\u0026amp; (buf2 == NULL || *resplen2 == 0)) 136\tgoto next_ns; 137\t// v_circuit就使用同一个ns继续发，也就是tcp重新发一次 138\tif (v_circuit) 139\t// XXX Check whether both requests failed or 140\t// XXX whether one has been answered successfully 141\tgoto same_ns; 142\t} 143 144\tresplen = n; 145 146\t/* See comment at the declaration of n. Note: resplen = n; */ 147\tDIAG_PUSH_NEEDS_COMMENT; 148\tDIAG_IGNORE_NEEDS_COMMENT (9, \u0026#34;-Wmaybe-uninitialized\u0026#34;); 149\t/* Mask the AD bit in both responses unless it is 150\tmarked trusted. */ 151\tif (resplen \u0026gt; HFIXEDSZ) 152\t{ 153\tif (ansp != NULL) 154\tmask_ad_bit (ctx, *ansp); 155\telse 156\tmask_ad_bit (ctx, ans); 157\t} 158\tDIAG_POP_NEEDS_COMMENT; 159\tif (resplen2 != NULL \u0026amp;\u0026amp; *resplen2 \u0026gt; HFIXEDSZ) 160\tmask_ad_bit (ctx, *ansp2); 161 162\t/* 163\t* If we have temporarily opened a virtual circuit, 164\t* or if we haven\u0026#39;t been asked to keep a socket open, 165\t* close the socket. 166\t*/ 167\tif ((v_circuit \u0026amp;\u0026amp; (statp-\u0026gt;options \u0026amp; RES_USEVC) == 0) || 168\t(statp-\u0026gt;options \u0026amp; RES_STAYOPEN) == 0) { 169\t__res_iclose(statp, false); 170\t} 171\treturn (resplen); 172 next_ns: ; 173\t} /*foreach ns*/ 174\t} /*foreach retry*/ 175\t__res_iclose(statp, false); 176\tif (!v_circuit) { 177\tif (!gotsomewhere) 178\t__set_errno (ECONNREFUSED);\t/* no nameservers found */ 179\telse 180\t__set_errno (ETIMEDOUT);\t/* no answer obtained */ 181\t} else 182\t__set_errno (terrno); 183\treturn (-1); 184} 185libc_hidden_def (__res_context_send) 2.1. 发送udp包给一个dns服务器 # 调用send_dg 从这里可以看到什么情况下使用下一个dns服务器，什么情况下使用tcp重新发送 1// /resolv/res_send.c 2/* The send_dg function is responsible for sending a DNS query over UDP 3 to the nameserver numbered NS from the res_state STATP i.e. 4 EXT(statp).nssocks[ns]. The function supports IPv4 and IPv6 queries 5 along with the ability to send the query in parallel for both stacks 6 (default) or serially (RES_SINGLKUP). It also supports serial lookup 7 with a close and reopen of the socket used to talk to the server 8 (RES_SNGLKUPREOP) to work around broken name servers. 9 10 The query stored in BUF of BUFLEN length is sent first followed by 11 the query stored in BUF2 of BUFLEN2 length. Queries are sent 12 in parallel (default) or serially (RES_SINGLKUP or RES_SNGLKUPREOP). 13 14 Answers to the query are stored firstly in *ANSP up to a max of 15 *ANSSIZP bytes. If more than *ANSSIZP bytes are needed and ANSCP 16 is non-NULL (to indicate that modifying the answer buffer is allowed) 17 then malloc is used to allocate a new response buffer and ANSCP and 18 ANSP will both point to the new buffer. If more than *ANSSIZP bytes 19 are needed but ANSCP is NULL, then as much of the response as 20 possible is read into the buffer, but the results will be truncated. 21 When truncation happens because of a small answer buffer the DNS 22 packets header field TC will bet set to 1, indicating a truncated 23 message, while the rest of the UDP packet is discarded. 24 25 Answers to the query are stored secondly in *ANSP2 up to a max of 26 *ANSSIZP2 bytes, with the actual response length stored in 27 *RESPLEN2. If more than *ANSSIZP bytes are needed and ANSP2 28 is non-NULL (required for a second query) then malloc is used to 29 allocate a new response buffer, *ANSSIZP2 is set to the new buffer 30 size and *ANSP2_MALLOCED is set to 1. 31 32 The ANSP2_MALLOCED argument will eventually be removed as the 33 change in buffer pointer can be used to detect the buffer has 34 changed and that the caller should use free on the new buffer. 35 36 Note that the answers may arrive in any order from the server and 37 therefore the first and second answer buffers may not correspond to 38 the first and second queries. 39 40 It is not supported to call this function with a non-NULL ANSP2 41 but a NULL ANSCP. Put another way, you can call send_vc with a 42 single unmodifiable buffer or two modifiable buffers, but no other 43 combination is supported. 44 45 It is the caller\u0026#39;s responsibility to free the malloc allocated 46 buffers by detecting that the pointers have changed from their 47 original values i.e. *ANSCP or *ANSP2 has changed. 48 49 If an answer is truncated because of UDP datagram DNS limits then 50 *V_CIRCUIT is set to 1 and the return value non-zero to indicate to 51 the caller to retry with TCP. The value *GOTSOMEWHERE is set to 1 52 if any progress was made reading a response from the nameserver and 53 is used by the caller to distinguish between ECONNREFUSED and 54 ETIMEDOUT (the latter if *GOTSOMEWHERE is 1). 55 56 If errors are encountered then *TERRNO is set to an appropriate 57 errno value and a zero result is returned for a recoverable error, 58 and a less-than zero result is returned for a non-recoverable error. 59 60 If no errors are encountered then *TERRNO is left unmodified and 61 a the length of the first response in bytes is returned. */ 62/** 63 * @brief 发送udp包给某个dns服务器 64 * 65 * @param statp dns配置上下文，dns服务器的socket存在EXT(statp).nssocks[ns]中 66 * @param buf 要发送的数据包1，A和AAAA都需要时存放A记录，否则要啥就存啥 67 * @param buflen 68 * @param buf2 要发送的数据包2，A和AAAA都需要时存放AAAA记录，否则为空 69 * @param buflen2 70 * @param ansp 71 * @param anssizp 72 * @param terrno 当有错误时，errno存到这里返回 73 * @param ns dns服务器的索引号 74 * @param v_circuit 75 * @param gotsomewhere 76 * @param anscp 77 * @param ansp2 78 * @param anssizp2 79 * @param resplen2 80 * @param ansp2_malloced 81 * @return int 如果返回1，要使用tcp重新发包 82\t如果返回0，当buf2为空或resplen2为0则尝试下一个dns服务器 83\t如果返回大于0的其他数，有结果返回 84\t如果返回小于0，不可恢复错误 85 */ 86static int send_dg(res_state statp, const u_char *buf, int buflen, const u_char *buf2, int buflen2, u_char **ansp, 87 int *anssizp, int *terrno, int ns, int *v_circuit, int *gotsomewhere, u_char **anscp, u_char **ansp2, 88 int *anssizp2, int *resplen2, int *ansp2_malloced) { 89 const UHEADER *hp = (UHEADER *)buf; 90 const UHEADER *hp2 = (UHEADER *)buf2; 91 struct timespec now, timeout, finish; 92 struct pollfd pfd[1]; 93 int ptimeout; 94 struct sockaddr_in6 from; 95 int resplen = 0; 96 int n; 97 98 /* 99 * Compute time for the total operation. 100 */ 101 // 计算超时时间，retrans默认为5，可以配置resolv.conf \u0026#34;options timeout:10\u0026#34;来修改 102 int seconds = (statp-\u0026gt;retrans \u0026lt;\u0026lt; ns); 103 // nscount为配置的dns服务器数量，一般一个网卡一个到两个 104 // 当ns为0时，seconds为5 105 // 当ns为1时，当nscount为2时，seconds为5；当nscount为3时，seconds为3；当nscount为4时，seconds为2 106 // 当ns为2时，当nscount为2时，seconds为10；当nscount为3时，seconds为6；当nscount为4时，seconds为5 107 if (ns \u0026gt; 0) seconds /= statp-\u0026gt;nscount; 108 if (seconds \u0026lt;= 0) seconds = 1; 109 bool single_request_reopen = (statp-\u0026gt;options \u0026amp; RES_SNGLKUPREOP) != 0; 110 bool single_request = (((statp-\u0026gt;options \u0026amp; RES_SNGLKUP) != 0) | single_request_reopen); 111 int save_gotsomewhere = *gotsomewhere; 112 113 int retval; 114retry_reopen: 115 // 重新建立socket 116 retval = reopen(statp, terrno, ns); 117 if (retval \u0026lt;= 0) { 118 if (resplen2 != NULL) *resplen2 = 0; 119 return retval; 120 } 121retry: 122 // 根据上面的seconds计算超时，存到finish中 123 evNowTime(\u0026amp;now); 124 evConsTime(\u0026amp;timeout, seconds, 0); 125 evAddTime(\u0026amp;finish, \u0026amp;now, \u0026amp;timeout); 126 int need_recompute = 0; // 代表是否需要计算超时时间 127 int nwritten = 0; 128 int recvresp1 = 0; // buf是否已经收到了响应 129 /* Skip the second response if there is no second query. 130 To do that we mark the second response as received. */ 131 int recvresp2 = buf2 == NULL; // buf2是否已经收到了响应，如果没有buf2，默认为1 132 pfd[0].fd = EXT(statp).nssocks[ns]; 133 pfd[0].events = POLLOUT; 134wait: 135 if (need_recompute) { 136 // 需要计算超时，算一下 137 recompute_resend: 138 evNowTime(\u0026amp;now); 139 if (evCmpTime(finish, now) \u0026lt;= 0) { 140 poll_err_out: 141 // 超时了，返回0，resplen2置0，尝试下一个dns服务器 142 return close_and_return_error(statp, resplen2); 143 } 144 evSubTime(\u0026amp;timeout, \u0026amp;finish, \u0026amp;now); 145 need_recompute = 0; 146 } 147 /* Convert struct timespec in milliseconds. */ 148 ptimeout = timeout.tv_sec * 1000 + timeout.tv_nsec / 1000000; 149 150\t// 使用poll进行收包 151 n = 0; 152 if (nwritten == 0) n = __poll(pfd, 1, 0); 153 if (__glibc_unlikely(n == 0)) { 154 n = __poll(pfd, 1, ptimeout); 155 need_recompute = 1; 156 } 157 if (n == 0) { 158 if (resplen \u0026gt; 1 \u0026amp;\u0026amp; (recvresp1 || (buf2 != NULL \u0026amp;\u0026amp; recvresp2))) { 159 /* There are quite a few broken name servers out 160 there which don\u0026#39;t handle two outstanding 161 requests from the same source. There are also 162 broken firewall settings. If we time out after 163 having received one answer switch to the mode 164 where we send the second request only once we 165 have received the first answer. */ 166 if (!single_request) { 167 statp-\u0026gt;options |= RES_SNGLKUP; 168 single_request = true; 169 *gotsomewhere = save_gotsomewhere; 170 goto retry; 171 } else if (!single_request_reopen) { 172 statp-\u0026gt;options |= RES_SNGLKUPREOP; 173 single_request_reopen = true; 174 *gotsomewhere = save_gotsomewhere; 175 __res_iclose(statp, false); 176 goto retry_reopen; 177 } 178 179 *resplen2 = 1; 180 return resplen; 181 } 182 183 *gotsomewhere = 1; 184 if (resplen2 != NULL) *resplen2 = 0; 185 return 0; 186 } 187 if (n \u0026lt; 0) { 188 if (errno == EINTR) goto recompute_resend; 189 190 goto poll_err_out; 191 } 192 __set_errno(0); 193 if (pfd[0].revents \u0026amp; POLLOUT) { 194 // POLLOUT代表可以发包了，下面是发送数据包的逻辑，调用sendmsg 195#ifndef __ASSUME_SENDMMSG 196 static int have_sendmmsg; 197#else 198#define have_sendmmsg 1 199#endif 200 if (have_sendmmsg \u0026gt;= 0 \u0026amp;\u0026amp; nwritten == 0 \u0026amp;\u0026amp; buf2 != NULL \u0026amp;\u0026amp; !single_request) { 201 struct iovec iov = {.iov_base = (void *)buf, .iov_len = buflen}; 202 struct iovec iov2 = {.iov_base = (void *)buf2, .iov_len = buflen2}; 203 struct mmsghdr reqs[2] = { 204 { 205 .msg_hdr = 206 { 207 .msg_iov = \u0026amp;iov, 208 .msg_iovlen = 1, 209 }, 210 }, 211 {.msg_hdr = 212 { 213 .msg_iov = \u0026amp;iov2, 214 .msg_iovlen = 1, 215 }}, 216 }; 217 218 int ndg = __sendmmsg(pfd[0].fd, reqs, 2, MSG_NOSIGNAL); 219 if (__glibc_likely(ndg == 2)) { 220 if (reqs[0].msg_len != buflen || reqs[1].msg_len != buflen2) goto fail_sendmmsg; 221 222 pfd[0].events = POLLIN; 223 nwritten += 2; 224 } else if (ndg == 1 \u0026amp;\u0026amp; reqs[0].msg_len == buflen) 225 goto just_one; 226 else if (ndg \u0026lt; 0 \u0026amp;\u0026amp; (errno == EINTR || errno == EAGAIN)) 227 goto recompute_resend; 228 else { 229#ifndef __ASSUME_SENDMMSG 230 if (__glibc_unlikely(have_sendmmsg == 0)) { 231 if (ndg \u0026lt; 0 \u0026amp;\u0026amp; errno == ENOSYS) { 232 have_sendmmsg = -1; 233 goto try_send; 234 } 235 have_sendmmsg = 1; 236 } 237#endif 238 239 fail_sendmmsg: 240 return close_and_return_error(statp, resplen2); 241 } 242 } else { 243 ssize_t sr; 244#ifndef __ASSUME_SENDMMSG 245 try_send: 246#endif 247 if (nwritten != 0) 248 sr = __send(pfd[0].fd, buf2, buflen2, MSG_NOSIGNAL); 249 else 250 sr = __send(pfd[0].fd, buf, buflen, MSG_NOSIGNAL); 251 252 if (sr != (nwritten != 0 ? buflen2 : buflen)) { 253 if (errno == EINTR || errno == EAGAIN) goto recompute_resend; 254 return close_and_return_error(statp, resplen2); 255 } 256 just_one: 257 if (nwritten != 0 || buf2 == NULL || single_request) 258 pfd[0].events = POLLIN; 259 else 260 pfd[0].events = POLLIN | POLLOUT; 261 ++nwritten; 262 } 263 goto wait; 264 } else if (pfd[0].revents \u0026amp; POLLIN) { 265 // pollin代表有包收到了，这里是收包逻辑 266 int *thisanssizp; 267 u_char **thisansp; 268 int *thisresplenp; // 当前收包长度 269 270 // 都没收到响应或buf2为空，当前收到包的长度放到resplen 271 // 有一个收到响应，且buf2不为空，当前收包长度放到resp2len 272 if ((recvresp1 | recvresp2) == 0 || buf2 == NULL) { 273 /* We have not received any responses 274 yet or we only have one response to 275 receive. */ 276 thisanssizp = anssizp; 277 thisansp = anscp ?: ansp; 278 assert(anscp != NULL || ansp2 == NULL); 279 thisresplenp = \u0026amp;resplen; 280 } else { 281 thisanssizp = anssizp2; 282 thisansp = ansp2; 283 thisresplenp = resplen2; 284 } 285 286 if (*thisanssizp \u0026lt; MAXPACKET 287 /* If the current buffer is not the the static 288 user-supplied buffer then we can reallocate 289 it. */ 290 \u0026amp;\u0026amp; (thisansp != NULL \u0026amp;\u0026amp; thisansp != ansp) 291#ifdef FIONREAD 292 /* Is the size too small? */ 293 \u0026amp;\u0026amp; (__ioctl(pfd[0].fd, FIONREAD, thisresplenp) \u0026lt; 0 || *thisanssizp \u0026lt; *thisresplenp) 294#endif 295 ) { 296 /* Always allocate MAXPACKET, callers expect 297 this specific size. */ 298 u_char *newp = malloc(MAXPACKET); 299 if (newp != NULL) { 300 *thisanssizp = MAXPACKET; 301 *thisansp = newp; 302 if (thisansp == ansp2) *ansp2_malloced = 1; 303 } 304 } 305 /* We could end up with truncation if anscp was NULL 306 (not allowed to change caller\u0026#39;s buffer) and the 307 response buffer size is too small. This isn\u0026#39;t a 308 reliable way to detect truncation because the ioctl 309 may be an inaccurate report of the UDP message size. 310 Therefore we use this only to issue debug output. 311 To do truncation accurately with UDP we need 312 MSG_TRUNC which is only available on Linux. We 313 can abstract out the Linux-specific feature in the 314 future to detect truncation. */ 315 UHEADER *anhp = (UHEADER *)*thisansp; // anhp为收到的数据包 316 socklen_t fromlen = sizeof(struct sockaddr_in6); 317 assert(sizeof(from) \u0026lt;= fromlen); 318 *thisresplenp = __recvfrom(pfd[0].fd, (char *)*thisansp, *thisanssizp, 0, (struct sockaddr *)\u0026amp;from, \u0026amp;fromlen); 319 if (__glibc_unlikely(*thisresplenp \u0026lt;= 0)) { 320 if (errno == EINTR || errno == EAGAIN) { 321 // errno为intr或eagin，重新收包，回到wait判断一下超时时间是否到达 322 need_recompute = 1; 323 goto wait; 324 } 325 // 否则收包失败后，返回0，resplen2置0，尝试下一个dns服务器 326 return close_and_return_error(statp, resplen2); 327 } 328 *gotsomewhere = 1; 329 if (__glibc_unlikely(*thisresplenp \u0026lt; HFIXEDSZ)) { 330 // 包长度小于dns固定头部长度12，返回0，resplen2置0，尝试下一个dns服务器 331 /* 332 * Undersized message. 333 */ 334 *terrno = EMSGSIZE; 335 return close_and_return_error(statp, resplen2); 336 } 337 338 /* Check for the correct header layout and a matching 339 question. */ 340 int matching_query = 0; /* Default to no matching query. */ 341 // 对比queryid是否匹配，请求的两个id都匹配一下是否对应 342 // 这里说明A记录和AAAA记录的id不能一样 343 if (!recvresp1 \u0026amp;\u0026amp; anhp-\u0026gt;id == hp-\u0026gt;id \u0026amp;\u0026amp; 344 __libc_res_queriesmatch(buf, buf + buflen, *thisansp, *thisansp + *thisanssizp)) 345 matching_query = 1; 346 if (!recvresp2 \u0026amp;\u0026amp; anhp-\u0026gt;id == hp2-\u0026gt;id \u0026amp;\u0026amp; 347 __libc_res_queriesmatch(buf2, buf2 + buflen2, *thisansp, *thisansp + *thisanssizp)) 348 matching_query = 2; 349 if (matching_query == 0) 350 /* Spurious UDP packet. Drop it and continue 351 waiting. */ 352 { 353 // 没匹配到，丢包继续等，顺便算一下超时时间 354 need_recompute = 1; 355 goto wait; 356 } 357 358 if (anhp-\u0026gt;rcode == SERVFAIL || anhp-\u0026gt;rcode == NOTIMP || anhp-\u0026gt;rcode == REFUSED) { 359 // 上面三个响应错误要使用下一个dns服务器继续尝试 360 next_ns: 361 // 使用下一个dns服务器继续试的处理 362 if (recvresp1 || (buf2 != NULL \u0026amp;\u0026amp; recvresp2)) { 363 // buf已经收到了响应或者buf2已经收到了响应（非这一次） 364 // resplen2置0，返回第一次响应长度 365\t// 第一次也是需要下一个dns服务器的错误，则返回0，使用下一个dns服务器继续请求 366\t// 第一次不需要下一个dns服务器，就是第一次的长度，不会尝试下一个dns服务器 367 *resplen2 = 0; 368 return resplen; 369 } 370 if (buf2 != NULL) { 371 // 这里就是首次收到响应就有错误且有buf2，等一下两个结果都返回 372 // 把第一次的长度置0，哪个响应哪个为1，然后继续等 373 /* No data from the first reply. */ 374 resplen = 0; 375 /* We are waiting for a possible second reply. */ 376 if (matching_query == 1) 377 recvresp1 = 1; 378 else 379 recvresp2 = 1; 380 381 goto wait; 382 } 383 384 /* don\u0026#39;t retry if called from dig */ 385 // dig会设置pfcode的值，这里判断为0则代表不是dig 386 // 正常解析就直接关闭socket然后返回0 387 if (!statp-\u0026gt;pfcode) return close_and_return_error(statp, resplen2); 388 __res_iclose(statp, false); 389 } 390 if (anhp-\u0026gt;rcode == NOERROR \u0026amp;\u0026amp; anhp-\u0026gt;ancount == 0 \u0026amp;\u0026amp; anhp-\u0026gt;aa == 0 \u0026amp;\u0026amp; anhp-\u0026gt;ra == 0 \u0026amp;\u0026amp; anhp-\u0026gt;arcount == 0) { 391 // 没错误，但是不是递归查询且结果为空，尝试下一个dns服务器 392 goto next_ns; 393 } 394 if (!(statp-\u0026gt;options \u0026amp; RES_IGNTC) \u0026amp;\u0026amp; anhp-\u0026gt;tc) { 395 // 非忽略tc的配置下，当响应中有tc字段，设置v_circuit为1，返回长度1 396 // 虽成功但需要使用tcp重新发包，并且只给resplen，resplen2设置为0 397 /* 398 * To get the rest of answer, 399 * use TCP with same server. 400 */ 401 *v_circuit = 1; 402 __res_iclose(statp, false); 403 // XXX if we have received one reply we could 404 // XXX use it and not repeat it over TCP... 405 if (resplen2 != NULL) *resplen2 = 0; 406 return (1); 407 } 408 /* Mark which reply we received. */ 409 if (matching_query == 1) 410 recvresp1 = 1; 411 else 412 recvresp2 = 1; 413 /* Repeat waiting if we have a second answer to arrive. */ 414 if ((recvresp1 \u0026amp; recvresp2) == 0) { 415 // 还有一个还没收到响应，继续等 416 if (single_request) { 417 pfd[0].events = POLLOUT; 418 if (single_request_reopen) { 419 __res_iclose(statp, false); 420 retval = reopen(statp, terrno, ns); 421 if (retval \u0026lt;= 0) { 422 if (resplen2 != NULL) *resplen2 = 0; 423 return retval; 424 } 425 pfd[0].fd = EXT(statp).nssocks[ns]; 426 } 427 } 428 goto wait; 429 } 430 /* All is well. We have received both responses (if 431 two responses were requested). */ 432 return (resplen); 433 } else if (pfd[0].revents \u0026amp; (POLLERR | POLLHUP | POLLNVAL)) 434 /* Something went wrong. We can stop trying. */ 435 return close_and_return_error(statp, resplen2); 436 else { 437 /* poll should not have returned \u0026gt; 0 in this case. */ 438 abort(); 439 } 440} "},{"id":198,"href":"/docs/glibc/nss/hosts/files/","title":"files 读取/etc/hosts文件","section":"hosts dns解析服务","content":" gethostbyname # 源码 # 从_nss_files_gethostbyname3_r开始 1// nss/nss_files/files-hosts.c 2enum nss_status 3_nss_files_gethostbyname3_r (const char *name, int af, struct hostent *result, 4\tchar *buffer, size_t buflen, int *errnop, 5\tint *herrnop, int32_t *ttlp, char **canonp) 6{ 7 FILE *stream = NULL; 8 uintptr_t pad = -(uintptr_t) buffer % __alignof__ (struct hostent_data); 9 buffer += pad; 10 buflen = buflen \u0026gt; pad ? buflen - pad : 0; 11 12 /* Open file. */ 13 enum nss_status status = internal_setent (\u0026amp;stream); 14 15 if (status == NSS_STATUS_SUCCESS) 16 { 17 while ((status = internal_getent (stream, result, buffer, buflen, errnop, 18\therrnop, af)) 19\t== NSS_STATUS_SUCCESS) 20\t{ 21\tLOOKUP_NAME_CASE (h_name, h_aliases) 22\t} 23 24 if (status == NSS_STATUS_SUCCESS 25\t\u0026amp;\u0026amp; _res_hconf.flags \u0026amp; HCONF_FLAG_MULTI) 26\tstatus = gethostbyname3_multi 27\t(stream, name, af, result, buffer, buflen, errnop, herrnop); 28 29 fclose (stream); 30 } 31 32 if (canonp \u0026amp;\u0026amp; status == NSS_STATUS_SUCCESS) 33 *canonp = result-\u0026gt;h_name; 34 35 return status; 36} 37libc_hidden_def (_nss_files_gethostbyname3_r) inernal_setent打开文件/etc/hosts 1// nss/nss_files/files-XXX.c 2#define DATAFILE\t\u0026#34;/etc/\u0026#34; DATABASE 3 4// nss/nss_files/files-hosts.c 5#define DATABASE\t\u0026#34;hosts\u0026#34; 6 7// nss/nss_files/files-XXX.c 8/* Maintenance of the stream open on the database file. For getXXent 9 operations the stream needs to be held open across calls, the other 10 getXXbyYY operations all use their own stream. */ 11 12/* Open database file if not already opened. */ 13static enum nss_status 14internal_setent (FILE **stream) 15{ 16 enum nss_status status = NSS_STATUS_SUCCESS; 17 18 if (*stream == NULL) 19 { 20 *stream = __nss_files_fopen (DATAFILE); 21 22 if (*stream == NULL) 23\tstatus = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL; 24 } 25 else 26 rewind (*stream); 27 28 return status; 29} 所以files就是处理/etc/hosts文件 "},{"id":199,"href":"/docs/linux/debug/ftrace/","title":"ftrace","section":"调试技术","content":" 一、使用 # https://www.kernel.org/doc/html/v4.19/trace/ftrace-uses.html\n1. ftrace hook内核函数 # 1.1. 前置判断 # 想要hook某个函数，需要内核开启编译选项进行支持 正常默认编译选项中可以hook非内联的所有函数（包括静态函数） 查看函数是否可以hook可以通过下面命令进行搜索 hook如果要调用自己函数（调用instruction_pointer_set），在arm64上只有5.5以上支持，x86上是3.x之后就支持了 1=\u0026gt; grep \u0026#34;tcp_options_write\u0026#34; /proc/kallsyms 2ffffffffafa03a90 t __pfx_tcp_options_write 3ffffffffafa03aa0 t tcp_options_write 1.2. 基础实现 # Makefile 1NAME := sdp_toa 2 3obj-m := $(NAME).o 4 5ifeq ($(KERNDIR), ) 6KDIR := /lib/modules/$(shell uname -r)/build 7else 8KDIR := $(KERNDIR) 9endif 10PWD := $(shell pwd) 11COMPILE_DATE=$(shell date \u0026#34;+%Y%m%d\u0026#34;) 12COMPILE_TIME=$(shell date -d $(COMPILE_DATE) \u0026#34;+%s\u0026#34;) 13$(info COMPILE_TIME=$(COMPILE_TIME)) 14 15$(NAME)-objs += main.o \\ 16\tftrace_hook.o 17 18# $(NAME)-y += 19# $(NAME)-n += 20 21ccflags-y += -DHIDS_FILTER_COMPILE_TIME=$(COMPILE_TIME) 22ifeq ($(DEBUG), 1) 23ccflags-y += -g -O0 -DDEBUG 24endif 25 26all: 27\t$(MAKE) -C $(KDIR) M=$(PWD) modules 28 29clean : 30\t$(MAKE) -C $(KDIR) M=$(PWD) modules clean 源文件 1// ftrace_hook_utils.h 2#ifndef _FTRACE_HOOK_UTILS_H_ 3#define _FTRACE_HOOK_UTILS_H_ 4 5#define __SC_DECL(t, a) t a 6#define __FTRACE_HOOK_DEFINE_VAR0(m, ...) 7#define __FTRACE_HOOK_DEFINE_VAR1(m, t, a, ...) m(t, a) 8#define __FTRACE_HOOK_DEFINE_VAR2(m, t, a, ...) m(t, a), __FTRACE_HOOK_DEFINE_VAR1(m, __VA_ARGS__) 9#define __FTRACE_HOOK_DEFINE_VAR3(m, t, a, ...) m(t, a), __FTRACE_HOOK_DEFINE_VAR2(m, __VA_ARGS__) 10#define __FTRACE_HOOK_DEFINE_VAR4(m, t, a, ...) m(t, a), __FTRACE_HOOK_DEFINE_VAR3(m, __VA_ARGS__) 11#define __FTRACE_HOOK_DEFINE_VAR5(m, t, a, ...) m(t, a), __FTRACE_HOOK_DEFINE_VAR4(m, __VA_ARGS__) 12#define __FTRACE_HOOK_DEFINE_VAR6(m, t, a, ...) m(t, a), __FTRACE_HOOK_DEFINE_VAR5(m, __VA_ARGS__) 13#define FTRACE_HOOK_DEFINE_VAR(n, ...) __FTRACE_HOOK_DEFINE_VAR##n(__VA_ARGS__) 14 15#endif // _FTRACE_HOOK_UTILS_H_ 1// ftrace_hook.h 2#ifndef _FTRACE_H_ 3#define _FTRACE_H_ 4 5#include \u0026lt;linux/atomic.h\u0026gt; 6#include \u0026lt;linux/ftrace.h\u0026gt; 7 8#include \u0026#34;ftrace_hook_utils.h\u0026#34; 9 10// 自定义log方式就定义hook_log，代码内部会使用hook_log_info等函数进行调用 11#ifndef TAG 12#define TAG \u0026#34;ftrace_hook\u0026#34; 13#endif 14 15#ifndef HOOK_LOG_INFO 16#ifdef DEBUG 17#define HOOK_LOG_INFO(fmt, ...) pr_info(\u0026#34;[%s] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, ##__VA_ARGS__) 18#else 19#define HOOK_LOG_INFO(fmt, ...) pr_info(\u0026#34;[%s][I][%s:%d] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, __FUNCTION__, __LINE__, ##__VA_ARGS__) 20#endif 21#endif 22 23#ifndef HOOK_LOG_WARN 24#ifdef DEBUG 25#define HOOK_LOG_WARN(fmt, ...) pr_warn(\u0026#34;[%s] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, ##__VA_ARGS__) 26#else 27#define HOOK_LOG_WARN(fmt, ...) pr_info(\u0026#34;[%s][W][%s:%d] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, __FUNCTION__, __LINE__, ##__VA_ARGS__) 28#endif 29#endif 30 31#ifndef HOOK_LOG_ERR 32#ifdef DEBUG 33#define HOOK_LOG_ERR(fmt, ...) pr_err(\u0026#34;[%s] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, ##__VA_ARGS__) 34#else 35#define HOOK_LOG_ERR(fmt, ...) pr_info(\u0026#34;[%s][E][%s:%d] \u0026#34; fmt \u0026#34;\\n\u0026#34;, TAG, __FUNCTION__, __LINE__, ##__VA_ARGS__) 36#endif 37#endif 38 39/** 40 * @brief Hook项 41 * 42 */ 43struct ftrace_hook { 44 /** 函数符号名 */ 45 const char *name; 46 47 /** 替换函数地址 */ 48 void *replacement; 49 50 /** 原始函数地址 */ 51 void **original; 52 53 /** 符号的原始地址 */ 54 unsigned long _address; 55 56 /** ftrace 相关结构体 */ 57 struct ftrace_ops ops; 58}; 59 60/** 61 * @brief 正在运行的钩子数，如果大于 0 建议不要卸载，等待其变为 0 62 */ 63extern atomic_t g_running_hooks; 64 65/** 66 * @brief 钩子进入时调用 67 * 68 * @param name 函数符号名 69 */ 70static inline void ftrace_hook_func_enter(const char *name) { 71 // 增加引用计数，避免模块被释放 72 atomic_inc(\u0026amp;g_running_hooks); 73} 74 75/** 76 * @brief 钩子结束时调用，由宏完成，不必手动调用 77 * 78 * @param name 函数符号名 79 */ 80static inline void ftrace_hook_func_exit(const char *name) { 81 // 减少引用计数 82 atomic_dec(\u0026amp;g_running_hooks); 83} 84 85/** 86 * @brief hook多个函数 87 * 88 * @param hooks 89 * @param count 90 * @return int 0 表示全部成功，否则返回 -errno 91 */ 92int ftrace_hook_multi_register(struct ftrace_hook hooks[], size_t count); 93/** 94 * @brief unhook多个函数，按照反方向unhook 95 * 96 * @param hooks 97 * @param count 98 */ 99void ftrace_hook_multi_unregister(struct ftrace_hook hooks[], size_t count); 100 101/** 102 * @brief 启用ftrace的hook功能 103 * 104 */ 105void enable_ftrace_hook(void); 106/** 107 * @brief 禁用ftrace的hook功能 108 * 109 */ 110void disable_ftrace_hook(void); 111/** 112 * @brief 返回当前是否启用ftrace的hook功能 113 * 114 * @return true 115 * @return false 116 */ 117bool is_ftrace_hook_enabled(void); 118 119// 替换的函数名 120#define FTRACE_HOOK_REPLACE_NAME(name) __ftrace_hook_replace_##name 121// 原始函数名 122#define FTRACE_HOOK_ORIG_NAME(name) __ftrace_hook_orig_##name 123// 定义结构体 124#define FTRACE_HOOK_STRUCT(name) \\ 125 { \\ 126 #name, FTRACE_HOOK_REPLACE_NAME(name), (void **)\u0026amp;FTRACE_HOOK_ORIG_NAME(name), 0, {} \\ 127 } 128 129/** 130 * @brief 定义要替换的函数 131 * @param n 函数参数个数 132 * @param name 函数名 133 * @param return_type 函数返回类型 134 * @param ... 函数参数按照type, var的方式传入 135 * 136 */ 137#define FTRACE_HOOK_FUNC_REPLACE(n, name, return_type, ...) \\ 138 static return_type (*FTRACE_HOOK_ORIG_NAME(name))(FTRACE_HOOK_DEFINE_VAR(n, __SC_DECL, __VA_ARGS__)); \\ 139 static return_type FTRACE_HOOK_REPLACE_NAME(name)(FTRACE_HOOK_DEFINE_VAR(n, __SC_DECL, __VA_ARGS__)) { \\ 140 static const char *__name = #name; \\ 141 ftrace_hook_func_enter(#name); 142 143// 结束符 144#define FTRACE_HOOK_FUNC_END } 145 146// 调用原始函数 147#define FTRACE_HOOK_FUNC_ORIG(name, ...) FTRACE_HOOK_ORIG_NAME(name)(__VA_ARGS__) 148 149/** 150 * @brief 钩子返回，减少引用计数 151 * @note 所有钩子中必须使用这个宏返回数据 152 * 153 */ 154#define FTRACE_HOOK_RETURN(x) \\ 155 do { \\ 156 ftrace_hook_func_exit(__name); \\ 157 return x; \\ 158 } while (0) 159 160#define FTRACE_HOOK_RETURN_VOID() \\ 161 do { \\ 162 ftrace_hook_func_exit(__name); \\ 163 return; \\ 164 } while (0) 165 166#endif // _FTRACE_H_ 1// ftrace_hook.c 2#include \u0026#34;ftrace_hook.h\u0026#34; 3 4// 记录当前是否启用hook功能，0表示未启用，1表示启用 5atomic_t g_hook_enable = ATOMIC_INIT(0); 6 7void enable_ftrace_hook(void) { atomic_set_release(\u0026amp;g_hook_enable, 1); } 8 9void disable_ftrace_hook(void) { atomic_set_release(\u0026amp;g_hook_enable, 0); } 10 11bool is_ftrace_hook_enabled(void) { return atomic_read_acquire(\u0026amp;g_hook_enable) == 1; } 12 13atomic_t g_running_hooks = ATOMIC_INIT(0); 14 15/** 16 * @brief 中转函数，在每次调用hook函数前调用，如果regs-\u0026gt;ip被修改，则调用修改后的函数，否则调用原始函数 17 * 18 */ 19static void notrace ftrace_hook_trampoline(unsigned long ip, unsigned long parent_ip, struct ftrace_ops *ops, 20 struct pt_regs *regs) { 21 struct ftrace_hook *hook = container_of(ops, struct ftrace_hook, ops); 22 ftrace_hook_func_enter(\u0026#34;ftrace_hook_trampoline\u0026#34;); 23 24 if (hook-\u0026gt;replacement) { 25 // 修改调用自己的函数 26 instruction_pointer_set(regs, (unsigned long)hook-\u0026gt;replacement); 27 } 28 29 ftrace_hook_func_exit(\u0026#34;ftrace_hook_trampoline\u0026#34;); 30} 31 32static int hook_by_ftrace(struct ftrace_hook *hook) { 33 int ret; 34 35 // 查找符号 36 hook-\u0026gt;_address = kallsyms_lookup_name(hook-\u0026gt;name); 37 if (!hook-\u0026gt;_address) { 38 HOOK_LOG_WARN(\u0026#34;Failed to resolve %s address\u0026#34;, hook-\u0026gt;name); 39 return -ENOENT; 40 } 41 42 // 跳过开头的 ftrace entry 指令，避免再次进入 43 if (hook-\u0026gt;original) { 44 *(hook-\u0026gt;original) = (void *)(hook-\u0026gt;_address + MCOUNT_INSN_SIZE); 45 } 46 47 hook-\u0026gt;ops.func = ftrace_hook_trampoline; 48 // FTRACE_OPS_FL_SAVE_REGS: 需要访问参数 49 // FTRACE_OPS_FL_RECURSION_SAFE: 我们自己处理重入，减少性能损失 50 // FTRACE_OPS_FL_IPMODIFY: 我们需要修改 IP 寄存器 51 hook-\u0026gt;ops.flags = FTRACE_OPS_FL_SAVE_REGS | FTRACE_OPS_FL_RECURSION_SAFE | FTRACE_OPS_FL_IPMODIFY; 52 53 // 此函数支持符号名唯一的hook，如果存在多个函数同一个符号则需要使用ftrace_set_filter_ip来进行处理 54 ret = ftrace_set_filter(\u0026amp;hook-\u0026gt;ops, (unsigned char *)hook-\u0026gt;name, strlen(hook-\u0026gt;name), 0); 55 if (ret \u0026lt; 0) { 56 HOOK_LOG_WARN(\u0026#34;Failed to set ftrace ip filter(%s, 0x%p): %d\u0026#34;, hook-\u0026gt;name, (void *)hook-\u0026gt;_address, ret); 57 return ret; 58 } 59 60 ret = register_ftrace_function(\u0026amp;hook-\u0026gt;ops); 61 if (ret \u0026lt; 0) { 62 // 清理 63 ftrace_set_notrace(\u0026amp;hook-\u0026gt;ops, (unsigned char *)hook-\u0026gt;name, strlen(hook-\u0026gt;name), 0); 64 HOOK_LOG_WARN(\u0026#34;Failed to register ftrace function(%s): %d\u0026#34;, hook-\u0026gt;name, ret); 65 return ret; 66 } 67 68 return 0; 69} 70 71static void unhook_by_ftrace(struct ftrace_hook *hook) { 72 int ret; 73 ret = unregister_ftrace_function(\u0026amp;hook-\u0026gt;ops); 74 if (ret \u0026lt; 0) { 75 HOOK_LOG_WARN(\u0026#34;Failed to unregister ftrace function(%s): %d\u0026#34;, hook-\u0026gt;name, ret); 76 } 77 78 ret = ftrace_set_notrace(\u0026amp;hook-\u0026gt;ops, (unsigned char *)hook-\u0026gt;name, strlen(hook-\u0026gt;name), 0); 79 if (ret \u0026lt; 0) { 80 HOOK_LOG_WARN(\u0026#34;Failed to remove ftrace ip filter(%s, 0x%p): %d\u0026#34;, hook-\u0026gt;name, (void *)hook-\u0026gt;_address, ret); 81 } 82} 83 84static int ftrace_hook_register(struct ftrace_hook *hook) { 85 if (!hook || !hook-\u0026gt;name || !hook-\u0026gt;name[0] || !hook-\u0026gt;replacement) { 86 return -EINVAL; 87 } 88 89 return hook_by_ftrace(hook); 90} 91 92static void ftrace_hook_unregister(struct ftrace_hook *hook) { 93 if (!hook || !hook-\u0026gt;name || !hook-\u0026gt;name[0]) { 94 return; 95 } 96 97 unhook_by_ftrace(hook); 98} 99 100/** 101 * @brief 注册多个 102 * 103 * @param hooks 104 * @param count 105 * @return int 0 表示全部成功，否则返回 -errno 106 */ 107int ftrace_hook_multi_register(struct ftrace_hook hooks[], size_t count) { 108 int ret = 0; 109 int i = 0; 110 111 if (unlikely(hooks == NULL)) { 112 return -EINVAL; 113 } 114 115 for (; i \u0026lt; count; ++i) { 116 ret = ftrace_hook_register(hooks + i); 117 if (ret \u0026lt; 0) { 118 HOOK_LOG_WARN(\u0026#34;Failed to register hook(%s): %d\u0026#34;, hooks[i].name, ret); 119 goto failed; 120 } 121 } 122 123 return 0; 124 125failed: 126 for (--i; i \u0026gt;= 0; --i) { 127 ftrace_hook_unregister(hooks + i); 128 } 129 return ret; 130} 131 132/** 133 * @brief 注销多个 134 * 135 * @param hooks 136 * @param count 137 */ 138void ftrace_hook_multi_unregister(struct ftrace_hook hooks[], size_t count) { 139 int i = (int)count; 140 if (unlikely(hooks == NULL)) { 141 return; 142 } 143 for (--i; i \u0026gt;= 0; --i) { 144 ftrace_hook_unregister(hooks + i); 145 } 146} 1.3. 使用示例 # 1// main.c 2#include \u0026#34;ftrace_hook.h\u0026#34; 3 4// hook tcp_established_options 5// 下面的宏定义了需要赋值的原函数指针并声明了替换的函数，在函数开头会添加引用计数 6FTRACE_HOOK_FUNC_REPLACE(4, tcp_established_options, unsigned int, struct sock *, sk, struct sk_buff *, skb, 7 struct tcp_out_options *, opts, struct tcp_md5sig_key **, md5) { 8 unsigned int size = 0; 9 // 调用原函数 10 size = FTRACE_HOOK_FUNC_ORIG(tcp_established_options, sk, skb, opts, md5); 11 // do something 12 FTRACE_HOOK_RETURN(size); // 使用宏进行返回，会将引用计数减一 13} 14FTRACE_HOOK_FUNC_END 15 16static struct ftrace_hook toa_hooks[] = { 17 FTRACE_HOOK_STRUCT(tcp_established_options), 18}; 19 20int toa_init(void) { 21 int ret; 22 ret = ftrace_hook_multi_register(toa_hooks, ARRAY_SIZE(toa_hooks)); 23 24 if (ret) { 25 // do something 26 goto hook_err; 27 } 28 29 // 上面只是注册，需要下面的调用来启动hook函数调用 30 enable_ftrace_hook(); 31 return 0; 32hook_err: 33 return ret; 34} 35 36void toa_exit(void) { 37 int running_hooks; 38 39 disable_ftrace_hook(); // 非必要，不调也可以卸载 40 ftrace_hook_multi_unregister(toa_hooks, ARRAY_SIZE(toa_hooks)); 41 42 // 下面的处理防止驱动退出后，已经调用到hook函数内部的函数返回到非法内存地址 43 // 这里等待引用计数减到0后再退出释放内存 44 while ((running_hooks = atomic_read_acquire(\u0026amp;g_running_hooks))) { 45 SDP_LOG_INFO(\u0026#34;waiting for running hooks %d\u0026#34;, running_hooks); 46 msleep(1); 47 } 48} 49 50MODULE_LICENSE(\u0026#34;GPL\u0026#34;); 51MODULE_DESCRIPTION(\u0026#34;ftrace test\u0026#34;); 52MODULE_AUTHOR(\u0026#34;xxx\u0026#34;); 53module_init(toa_init); 54module_exit(toa_exit); "},{"id":200,"href":"/docs/linux/linux-kernel/data-structures/hashtable/","title":"hashtable 哈希表","section":"数据结构","content":" 一、前言 # 内核里面实现哈希表很简单粗暴，使用一个数组作为hash查找，每一个元素里面就是一个链表。\n二、示例 # 1. 内核标准实现 # 1#include \u0026lt;linux/hashtable.h\u0026gt; 2#include \u0026lt;linux/printk.h\u0026gt; 3 4// 定义2^3的hash表，也就是8个桶 5DEFINE_HASHTABLE(test_hash_table, 3); 6 7typedef struct test_hash_node { 8 struct hlist_node list; 9 int key; 10 int value; 11} test_hash_node_t; 12 13void test_hash(void) { 14 test_hash_node_t item[10]; 15 test_hash_node_t *entry; 16 size_t i; 17 int key; 18 19 // DEFINE_HASHTABLE定义的不用初始化 20 // DECLARE_HASHTABLE定义的一定要初始化，默认的table中的first可能没有清零，导致后面遍历崩掉 21 // hash_init(test_hash_table); 22 23 for (i = 0; i \u0026lt; 10; i++) { 24 entry = \u0026amp;item[i]; 25 // 初始化node，也就是将两个指针清零 26 INIT_HLIST_NODE(\u0026amp;entry-\u0026gt;list); 27 28 entry-\u0026gt;key = i; 29 entry-\u0026gt;value = i; 30 // 插入hash表 31 hash_add(test_hash_table, \u0026amp;entry-\u0026gt;list, entry-\u0026gt;key); 32 } 33 34 // 查询 35 key = 5; 36 hash_for_each_possible(test_hash_table, entry, list, key) { 37 if (entry-\u0026gt;key == key) { 38 printk(\u0026#34;key: %d, value: %d\\n\u0026#34;, entry-\u0026gt;key, entry-\u0026gt;value); 39 } 40 } 41 42 // 遍历所有的key 43 hash_for_each(test_hash_table, i, entry, list) { 44 printk(\u0026#34;hash idx %ld, key: %d, value: %d\\n\u0026#34;, i, entry-\u0026gt;key, entry-\u0026gt;value); 45 } 46} 2. 使用hlist自定义实现 # 自定义实现可以自定义hash表长度、添加锁等操作，默认的hash表不能处理锁 1#include \u0026lt;linux/list.h\u0026gt; 2#include \u0026lt;linux/printk.h\u0026gt; 3 4#define TEST_HASH_SIZE 5 5 6typedef struct test_hash_node { 7 struct hlist_node list; 8 int key; 9 int value; 10} test_hash_node_t; 11 12typedef struct test_hashinfo { 13 struct hlist_head hash[TEST_HASH_SIZE]; 14} test_hashinfo_t; 15 16static inline int test_hash_fun(unsigned int key) { 17 return key % TEST_HASH_SIZE; 18} 19 20void test_hash(void) { 21 test_hashinfo_t table; 22 test_hash_node_t item[10]; 23 test_hash_node_t *entry; 24 struct hlist_head *head; 25 size_t i; 26 int key; 27 28 // 一定要初始化，默认的table中的first可能没有清零，导致后面遍历崩掉 29 for (i = 0; i \u0026lt; ARRAY_SIZE(table.hash); i++) { 30 INIT_HLIST_HEAD(\u0026amp;table.hash[i]); 31 } 32 33 for (i = 0; i \u0026lt; 10; i++) { 34 entry = \u0026amp;item[i]; 35 // 初始化node，也就是将两个指针清零 36 INIT_HLIST_NODE(entry); 37 38 entry-\u0026gt;key = i; 39 entry-\u0026gt;value = i; 40 // 插入hash表，找到hash对应的桶 41 head = \u0026amp;table.hash[test_hash_fun(item[i]-\u0026gt;key)]; 42 // 添加到hash桶的头部 43 hlist_add_head(entry-\u0026gt;list, head); 44 } 45 46 // 查询 47 key = 5; 48 // 先找到桶 49 head = \u0026amp;table.hash[test_hash_fun(key)]; 50 // 遍历链表找到元素 51 hlist_for_each_entry(entry, head, list) { 52 if (entry-\u0026gt;key == key) { 53 printk(\u0026#34;find key %d, value %d\\n\u0026#34;, entry-\u0026gt;key, entry-\u0026gt;value); 54 break; 55 } 56 } 57} 3. 使用hlist_bl自定义实现，每个桶一个自旋锁 # 1#include \u0026lt;linux/hashtable.h\u0026gt; 2#include \u0026lt;linux/list_bl.h\u0026gt; 3#include \u0026lt;linux/printk.h\u0026gt; 4 5/********** 这一部分可以写到hashtable_bl.h中 start **********/ 6#define DEFINE_HASHTABLE_BL(name, bits) \\ 7 struct hlist_bl_head name[1 \u0026lt;\u0026lt; (bits)] = {[0 ...((1 \u0026lt;\u0026lt; (bits)) - 1)] = HLIST_HEAD_INIT} 8 9#define DEFINE_READ_MOSTLY_HASHTABLE_BL(name, bits) \\ 10 struct hlist_bl_head name[1 \u0026lt;\u0026lt; (bits)] __read_mostly = {[0 ...((1 \u0026lt;\u0026lt; (bits)) - 1)] = HLIST_HEAD_INIT} 11 12#define DECLARE_HASHTABLE_BL(name, bits) struct hlist_bl_head name[1 \u0026lt;\u0026lt; (bits)] 13 14static inline void __hash_init_bl(struct hlist_bl_head *ht, unsigned int sz) { 15 unsigned int i; 16 17 for (i = 0; i \u0026lt; sz; i++) INIT_HLIST_HEAD(\u0026amp;ht[i]); 18} 19 20#define hash_init_bl(hashtable) __hash_init_bl(hashtable, HASH_SIZE(hashtable)) 21 22// 获取key对应的头节点 23#define hash_get_head(hashtable, key) (\u0026amp;hashtable[hash_min(key, HASH_BITS(hashtable))]) 24 25/** 26 * hash_add - add an object to a hashtable 27 * @hashtable: hashtable to add to 28 * @node: the \u0026amp;struct hlist_node of the object to be added 29 * @key: the key of the object to be added 30 */ 31#define hash_add_bl(hashtable, node, key) \\ 32 ({ \\ 33 struct hlist_bl_head *__mptr = hash_get_head(hashtable, key); \\ 34 hlist_bl_lock(__mptr); \\ 35 hlist_bl_add_head(node, __mptr); \\ 36 hlist_bl_unlock(__mptr); \\ 37 }) 38 39/** 40 * hash_for_each_safe - iterate over a hashtable safe against removal of 41 * hash entry 42 * @name: hashtable to iterate 43 * @bkt: integer to use as bucket loop cursor 44 * @tmp: a \u0026amp;struct used for temporary storage 45 * @pos: the \u0026amp;struct hlist_bl_node to use as a loop cursor. 46 * @obj: the type * to use as a loop cursor for each entry 47 * @member: the name of the hlist_node within the struct 48 */ 49#define hash_for_each_safe_bl(name, bkt, tmp, pos, obj, member) \\ 50 for ((bkt) = 0, obj = NULL; (bkt) \u0026lt; HASH_SIZE(name); (bkt)++) \\ 51 hlist_bl_for_each_entry_safe(obj, pos, tmp, \u0026amp;name[bkt], member) 52/********** 这一部分可以写到hashtable_bl.h中 end **********/ 53 54// 定义链表元素节点 55typedef struct test_hash_node { 56 struct hlist_bl_node list; 57 int key; 58 int value; 59} test_hash_node_t; 60 61// 定义hash表 62static DEFINE_HASHTABLE_BL(table, 10); // 这里会自动初始化 63 64void test_hash(void) { 65 test_hash_node_t item[10]; 66 test_hash_node_t *entry; 67 struct hlist_bl_head *head; 68 struct hlist_bl_node *node; 69 size_t i; 70 int key; 71 72 for (i = 0; i \u0026lt; 10; i++) { 73 entry = \u0026amp;item[i]; 74 // 初始化node，也就是将两个指针清零 75 INIT_HLIST_BL_NODE(\u0026amp;entry-\u0026gt;list); 76 77 entry-\u0026gt;key = i; 78 entry-\u0026gt;value = i; 79 // 插入hash表 80 hash_add_bl(table, \u0026amp;entry-\u0026gt;list, entry-\u0026gt;key); 81 } 82 83 // 查询 84 key = 5; 85 head = hash_get_head(table, key); 86 // 遍历链表找到元素 87 hlist_bl_lock(head); 88 hlist_bl_for_each_entry(entry, node, head, list) { 89 if (entry-\u0026gt;key == key) { 90 printk(\u0026#34;find key %d, value %d\\n\u0026#34;, entry-\u0026gt;key, entry-\u0026gt;value); 91 break; 92 } 93 } 94 hlist_bl_unlock(head); 95 96 // 遍历所有table，不加锁清理 97 hash_for_each_safe_bl(toa_ipv6_table, idx, tmp, node, entry, list) { 98 hlist_bl_del(node); 99 } 100} "},{"id":201,"href":"/docs/ctf/knowledge/encoder-decoder/algorithm/","title":"hash和编码算法列表","section":"加解密编码等算法","content":" 一、hash算法对应的场景 # hash均为不可逆加密，一般用于密码的校验 算法名称 位数 用途 hashcat编号 备注 NTLM v2为16位 windows密码 1000 先算hex，再使用unicode编码，再计算md4\n爆破的hash类似a7fcb22a88038f35a8f39d503e7f0062 RAR5 压缩包密码 13000 爆破的hash类似$rar5$16$1e71cb65fbc2e25d134279f2cb5be013$15$f6115d7dee842c1f8901b057e2bc8952$8$1988f3ce18017cdb RAR3-hp 压缩包密码 12500 爆破的hash类似$RAR3$*0*f3e592b768e33df0*f304b7cfd600a36ea3930f7a3c1db19b 二、编码算法对应场景 # 算法名称 位数 用途 备注 base64 数据编码传输 在线加解密https://the-x.cn/encodings/Base64.aspx brainfuck 数据编码 在线编码解码https://www.splitbrain.org/services/ook Ook! 数据编码 在线编码解码https://www.splitbrain.org/services/ook 与佛论禅 数据加密 在线加解密http://www.keyfc.net/bbs/tools/tudoucode.aspx 1. brainfuck # 1.1. 示例 # +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt; ++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ +[-\u0026gt;- ----- \u0026lt;]\u0026gt;-- ----- --.\u0026lt;+ +++[- \u0026gt;---- \u0026lt;]\u0026gt;-- ----- .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ +++++ .\u0026lt;+++ +[-\u0026gt;- ---\u0026lt;] \u0026gt;-.\u0026lt;+ +++++ [-\u0026gt;++ ++++\u0026lt; ]\u0026gt;+++ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;---- -.+++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- ----- .\u0026lt; 1.2. python解密 # 安装python-brainfuck 解密过程 1\u0026gt;\u0026gt;\u0026gt; import brainfuck 2\u0026gt;\u0026gt;\u0026gt; text = brainfuck.to_function(\u0026#34;\u0026#34;\u0026#34; 3... +++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt; 4... ++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ +[-\u0026gt;- ----- \u0026lt;]\u0026gt;-- ----- --.\u0026lt;+ +++[- \u0026gt;---- 5... \u0026lt;]\u0026gt;-- ----- .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ +++++ .\u0026lt;+++ +[-\u0026gt;- ---\u0026lt;] \u0026gt;-.\u0026lt;+ +++++ [-\u0026gt;++ 6... ++++\u0026lt; ]\u0026gt;+++ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;---- -.+++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- ----- .\u0026lt; 7... \u0026#34;\u0026#34;\u0026#34;) 8\u0026gt;\u0026gt;\u0026gt; text() 9\u0026#39;flag{N7F5_AD5\u0026#39; 1.3. php加解密 # https://github.com/splitbrain/ook\n编码 1/** 2 * fuck_text() generates brainfuck code from $text. The resulting code will use the current 3 * register p for looping and the register p+1 for the resulting character. Thus, make sure 4 * these two registers are zero (prepend \u0026#34;[-]\u0026gt;[-]\u0026lt;\u0026lt;\u0026#34; to clear the first two registers). 5 * 6 * I suggest you to use this function in conjunction with wordwrap: 7 * 8 * $bf = wordwrap(fuck_text(\u0026#34;Hello World\u0026#34;), 75, \u0026#34;\\n\u0026#34;, 1)); 9 * 10 * wich will generate nice, formatted output. 11 * 12 * @param string $text 13 */ 14function fuck_text($text) 15{ 16 /* value of current pointer */ 17 $value = 0; 18 $result = \u0026#39;\u0026#39;; 19 20 for ($_t = 0; $_t \u0026lt; strlen($text); ++$_t) { 21 22 /* ordinal difference between current char and the one we want to have */ 23 $diff = ord($text[$_t]) - $value; 24 25 /* it\u0026#39;s easier like this than always computing this value - saves some cpu cycles*/ 26 $value = ord($text[$_t]); 27 28 /* repeat current character */ 29 if ($diff == 0) { 30 $result .= \u0026#34;\u0026gt;.\u0026lt;\u0026#34;; 31 continue; 32 } 33 34 /* is it worth making a loop? 35 No. A bunch of + or - consume less space than the loop. */ 36 if (abs($diff) \u0026lt; 10) { 37 38 /* output a bunch of + or - */ 39 if ($diff \u0026gt; 0) 40 $result .= \u0026#34;\u0026gt;\u0026#34; . str_repeat(\u0026#34;+\u0026#34;, $diff); 41 else if ($diff \u0026lt; 0) 42 $result .= \u0026#34;\u0026gt;\u0026#34; . str_repeat(\u0026#34;-\u0026#34;, abs($diff)); 43 44 } /* Yes, create a loop. This will make the resulting code more compact. */ 45 else { 46 47 /* we strictly use ints, as PHP has some bugs with floating point operations 48 (even if no division is involved) */ 49 $loop = (int)sqrt(abs($diff)); 50 51 /* set loop counter */ 52 $result .= str_repeat(\u0026#34;+\u0026#34;, $loop); 53 54 /* execute loop, then add reminder */ 55 if ($diff \u0026gt; 0) { 56 $result .= \u0026#34;[-\u0026gt;\u0026#34; . str_repeat(\u0026#34;+\u0026#34;, $loop) . \u0026#34;\u0026lt;]\u0026#34;; 57 $result .= \u0026#34;\u0026gt;\u0026#34; . str_repeat(\u0026#34;+\u0026#34;, $diff - pow($loop, 2)); 58 } else if ($diff \u0026lt; 0) { 59 $result .= \u0026#34;[-\u0026gt;\u0026#34; . str_repeat(\u0026#34;-\u0026#34;, $loop) . \u0026#34;\u0026lt;]\u0026#34;; 60 $result .= \u0026#34;\u0026gt;\u0026#34; . str_repeat(\u0026#34;-\u0026#34;, abs($diff) - pow($loop, 2)); 61 } 62 63 } /* end: if loop */ 64 65 $result .= \u0026#34;.\u0026lt;\u0026#34;; 66 67 } /* end: for */ 68 69 /* cleanup */ 70 return str_replace(\u0026#34;\u0026lt;\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, $result); 71} 72 73$output = fuck_text($input); 74$output = preg_replace(\u0026#39;/(.....)/\u0026#39;,\u0026#39;\\\\1 \u0026#39;, $output); 75$output = wordwrap($output,75,\u0026#34;\\n\u0026#34;); 解码 1/** 2 * Debug function displays valuable debug information. 3 * Rewrite this if desired. 4 * 5 * @param string $s Source string 6 * @param int $_s Source string pointer (current position) 7 * @param array $d Data array 8 * @param int $_d Data array pointer 9 * @param string $i Input string 10 * @param int $_i Input pointer 11 * @param string $o Output string 12 */ 13function brainfuck_debug(\u0026amp;$s, \u0026amp;$_s, \u0026amp;$d, \u0026amp;$_d, \u0026amp;$i, \u0026amp;$_i, \u0026amp;$o) 14{ 15 echo \u0026#34;\u0026lt;table\u0026gt;\\n\u0026#34;; 16 echo \u0026#34;\u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;Position\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;Value\u0026lt;/th\u0026gt;\u0026lt;th\u0026gt;ASCII\u0026lt;/th\u0026gt;\u0026lt;/tr\u0026gt;\\n\u0026#34;; 17 18 foreach ($d as $element =\u0026gt; $value) { 19 echo \u0026#34;\u0026lt;tr\u0026gt;\\n\u0026#34;; 20 echo \u0026#39;\u0026lt;td style=\u0026#34;text-align: center\u0026#34;\u0026gt;\u0026#39; . $element . \u0026#34;\u0026lt;/td\u0026gt;\\n\u0026#34;; 21 echo \u0026#39;\u0026lt;td style=\u0026#34;text-align: center\u0026#34;\u0026gt;\u0026#39; . ord($value) . \u0026#34;\u0026lt;/td\u0026gt;\\n\u0026#34;; 22 echo \u0026#39;\u0026lt;td style=\u0026#34;text-align: center\u0026#34;\u0026gt;\u0026#39; . (ord($value) \u0026gt;= 32 ? htmlentities($value) : \u0026#34;\u0026amp;nbsp;\u0026#34;) . \u0026#34;\u0026lt;/td\u0026gt;\\n\u0026#34;; 23 echo \u0026#34;\u0026lt;/tr\u0026gt;\\n\u0026#34;; 24 } 25 26 echo \u0026#34;\u0026lt;/table\u0026gt;\\n\u0026#34;; 27} 28 29/** 30 * The actual interpreter 31 * 32 * @param string $s Source string 33 * @param int $_s Source string pointer (current position) 34 * @param array $d Data array 35 * @param int $_d Data array pointer 36 * @param string $i Input string 37 * @param int $_i Input pointer 38 * @param string $o Output string 39 */ 40function brainfuck_interpret(\u0026amp;$s, \u0026amp;$_s, \u0026amp;$d, \u0026amp;$_d, \u0026amp;$i, \u0026amp;$_i, \u0026amp;$o) 41{ 42 do { 43 switch ($s[$_s]) { 44 /* Execute brainfuck commands. Values are not stored as numbers, but as their 45 representing characters in the ASCII table. This is perfect, as chr(256) is 46 automagically converted to chr(0). */ 47 case \u0026#39;+\u0026#39;: 48 $d[$_d] = chr(ord($d[$_d]) + 1); 49 break; 50 case \u0026#39;-\u0026#39;: 51 $d[$_d] = chr(ord($d[$_d]) - 1); 52 break; 53 case \u0026#39;\u0026gt;\u0026#39;: 54 $_d++; 55 if (!isset($d[$_d])) $d[$_d] = chr(0); 56 break; 57 case \u0026#39;\u0026lt;\u0026#39;: 58 $_d--; 59 break; 60 61 /* Output is stored in a variable. Change this to 62 echo $d[$_d]; flush(); 63 if you would like to have a \u0026#34;live\u0026#34; output (when running long calculations, for example. 64 Or if you are just terribly impatient). */ 65 case \u0026#39;.\u0026#39;: 66 $o .= $d[$_d]; 67 break; 68 69 /* Due to PHP\u0026#39;s non-interactive nature I have the whole input passed over in a string. 70 I successively read characters from this string and pass it over to BF every time a 71 \u0026#39;,\u0026#39; command is executed. */ 72 case \u0026#39;,\u0026#39;: 73 $d[$_d] = $_i == strlen($i) ? chr(0) : $i[$_i++]; 74 break; 75 76 /* Catch loops */ 77 case \u0026#39;[\u0026#39;: 78 /* Skip loop (also nested ones) */ 79 if ((int)ord($d[$_d]) == 0) { 80 $brackets = 1; 81 while ($brackets \u0026amp;\u0026amp; $_s++ \u0026lt; strlen($s)) { 82 if ($s[$_s] == \u0026#39;[\u0026#39;) 83 $brackets++; 84 else if ($s[$_s] == \u0026#39;]\u0026#39;) 85 $brackets--; 86 } 87 } /* Execute loop */ 88 else { 89 $pos = $_s++ - 1; 90 /* The closing ] returns true when the loop has to be executed again. If so, then return 91 to the $pos(ition) where the opening [ is. */ 92 if (brainfuck_interpret($s, $_s, $d, $_d, $i, $_i, $o)) 93 $_s = $pos; 94 } 95 break; 96 /* Return true when loop has to be executed again. It is redundant to the [ checking, but 97 it will save some parsing time (otherwise the interpreter would have to return to [ only 98 to skip all characters again) */ 99 case \u0026#39;]\u0026#39;: 100 return ((int)ord($d[$_d]) != 0); 101 /* Call debug function */ 102 case \u0026#39;#\u0026#39;: 103 brainfuck_debug($s, $_s, $d, $_d, $i, $_i, $o); 104 } 105 } while (++$_s \u0026lt; strlen($s)); 106} 107 108/** 109 * Call this one in order to interpret brainfuck code 110 * 111 * @param string $source source data 112 * @param string $input Simulate stdin 113 * @return string the output 114 */ 115function brainfuck($source, $input = \u0026#39;\u0026#39;) 116{ 117 118 /* Define needed variables: 119 120 $data Brainfuck\u0026#39;s memory 121 $source Source data 122 $input Simulate STDIN 123 $output Save output in here 124 125 Each with according index variables 126 */ 127 128 $data = array(); 129 $data[0] = chr(0); /* It is necessary to set every element explicitly, as 130 PHP treats arrays as hashes */ 131 $data_index = 0; 132 133 $source_index = 0; 134 135 $input_index = 0; 136 137 $output = \u0026#39;\u0026#39;; 138 139 /* Call the actual interpreter */ 140 brainfuck_interpret( 141 $source, 142 $source_index, 143 $data, 144 $data_index, 145 $input, 146 $input_index, 147 $output 148 ); 149 150 return $output; 151} 2. Ook! 格式 # Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. % 2.1. php编码解码 # 编码 1// 基于brain_fuck的编码转成这样 2$output = fuck_text($input); 3$output = strtr($output,array(\u0026#39;\u0026gt;\u0026#39; =\u0026gt; \u0026#39;Ook. Ook? \u0026#39;, 4 \u0026#39;\u0026lt;\u0026#39; =\u0026gt; \u0026#39;Ook? Ook. \u0026#39;, 5 \u0026#39;+\u0026#39; =\u0026gt; \u0026#39;Ook. Ook. \u0026#39;, 6 \u0026#39;-\u0026#39; =\u0026gt; \u0026#39;Ook! Ook! \u0026#39;, 7 \u0026#39;.\u0026#39; =\u0026gt; \u0026#39;Ook! Ook. \u0026#39;, 8 \u0026#39;,\u0026#39; =\u0026gt; \u0026#39;Ook. Ook! \u0026#39;, 9 \u0026#39;[\u0026#39; =\u0026gt; \u0026#39;Ook! Ook? \u0026#39;, 10 \u0026#39;]\u0026#39; =\u0026gt; \u0026#39;Ook? Ook! \u0026#39;, 11 )); 解码 1$lookup = array( 2 \u0026#39;.?\u0026#39; =\u0026gt; \u0026#39;\u0026gt;\u0026#39;, 3 \u0026#39;?.\u0026#39; =\u0026gt; \u0026#39;\u0026lt;\u0026#39;, 4 \u0026#39;..\u0026#39; =\u0026gt; \u0026#39;+\u0026#39;, 5 \u0026#39;!!\u0026#39; =\u0026gt; \u0026#39;-\u0026#39;, 6 \u0026#39;!.\u0026#39; =\u0026gt; \u0026#39;.\u0026#39;, 7 \u0026#39;.!\u0026#39; =\u0026gt; \u0026#39;,\u0026#39;, 8 \u0026#39;!?\u0026#39; =\u0026gt; \u0026#39;[\u0026#39;, 9 \u0026#39;?!\u0026#39; =\u0026gt; \u0026#39;]\u0026#39;, 10 ); 11 12$input = preg_replace(\u0026#39;/[^\\.?!]+/\u0026#39;,\u0026#39;\u0026#39;,$input); 13$len = strlen($input); 14for($i=0;$i\u0026lt;$len;$i+=2){ 15 $output .= $lookup[$input{$i}.$input{$i+1}]; 16} 17$output = brainfuck($output); 3. 与佛论禅 # 类似下面格式\n佛曰：遮等諳勝能礙皤藐哆娑梵迦侄羅哆迦梵者梵楞蘇涅侄室實真缽朋能。奢怛俱道怯都諳怖梵尼怯一罰心缽謹缽薩苦奢夢怯帝梵遠朋陀諳陀穆諳所呐知涅侄以薩怯想夷奢醯數羅怯諸 "},{"id":202,"href":"/docs/linux/linux-kernel/data-structures/kfifo/","title":"kfifo 无锁循环队列","section":"数据结构","content":" 一、提供的接口 # 1. 定义相关 # 声明和初始化 1// include/linux/kfifo.h 2/** 3 * DECLARE_KFIFO - macro to declare a fifo object 4 * @fifo: name of the declared fifo 5 * @type: type of the fifo elements 6 * @size: the number of elements in the fifo, this must be a power of 2 7 */ 8#define DECLARE_KFIFO(fifo, type, size) STRUCT_KFIFO(type, size) fifo 9 10/** 11 * INIT_KFIFO - Initialize a fifo declared by DECLARE_KFIFO 12 * @fifo: name of the declared fifo datatype 13 */ 14#define INIT_KFIFO(fifo) \\ 15(void)({ \\ 16 typeof(\u0026amp;(fifo)) __tmp = \u0026amp;(fifo); \\ 17 struct __kfifo *__kfifo = \u0026amp;__tmp-\u0026gt;kfifo; \\ 18 __kfifo-\u0026gt;in = 0; \\ 19 __kfifo-\u0026gt;out = 0; \\ 20 __kfifo-\u0026gt;mask = __is_kfifo_ptr(__tmp) ? 0 : ARRAY_SIZE(__tmp-\u0026gt;buf) - 1;\\ 21 __kfifo-\u0026gt;esize = sizeof(*__tmp-\u0026gt;buf); \\ 22 __kfifo-\u0026gt;data = __is_kfifo_ptr(__tmp) ? NULL : __tmp-\u0026gt;buf; \\ 23}) 声明和初始化一起可以用DEFINE_KFIFO 1// include/linux/kfifo.h 2/** 3 * DEFINE_KFIFO - macro to define and initialize a fifo 4 * @fifo: name of the declared fifo datatype 5 * @type: type of the fifo elements 6 * @size: the number of elements in the fifo, this must be a power of 2 7 * 8 * Note: the macro can be used for global and local fifo data type variables. 9 */ 10#define DEFINE_KFIFO(fifo, type, size) \\ 11 DECLARE_KFIFO(fifo, type, size) = \\ 12 (typeof(fifo)) { \\ 13 { \\ 14 { \\ 15 .in = 0, \\ 16 .out = 0, \\ 17 .mask = __is_kfifo_ptr(\u0026amp;(fifo)) ? \\ 18 0 : \\ 19 ARRAY_SIZE((fifo).buf) - 1, \\ 20 .esize = sizeof(*(fifo).buf), \\ 21 .data = __is_kfifo_ptr(\u0026amp;(fifo)) ? \\ 22 NULL : \\ 23 (fifo).buf, \\ 24 } \\ 25 } \\ 26 } 2. 操作相关 # 单个元素操作 1// include/linux/kfifo.h 2/** 3 * kfifo_put - put data into the fifo 4 * @fifo: address of the fifo to be used 5 * @val: the data to be added 6 * 7 * This macro copies the given value into the fifo. 8 * It returns 0 if the fifo was full. Otherwise it returns the number 9 * processed elements. 10 * 11 * Note that with only one concurrent reader and one concurrent 12 * writer, you don\u0026#39;t need extra locking to use these macro. 13 */ 14#define kfifo_put(fifo, val) 15... 16 17/** 18 * kfifo_get - get data from the fifo 19 * @fifo: address of the fifo to be used 20 * @val: address where to store the data 21 * 22 * This macro reads the data from the fifo. 23 * It returns 0 if the fifo was empty. Otherwise it returns the number 24 * processed elements. 25 * 26 * Note that with only one concurrent reader and one concurrent 27 * writer, you don\u0026#39;t need extra locking to use these macro. 28 */ 29#define kfifo_get(fifo, val) \\ 30__kfifo_uint_must_check_helper( \\ 31({ \\ 32 typeof((fifo) + 1) __tmp = (fifo); \\ 33 typeof(__tmp-\u0026gt;ptr) __val = (val); \\ 34 unsigned int __ret; \\ 35 const size_t __recsize = sizeof(*__tmp-\u0026gt;rectype); \\ 36 struct __kfifo *__kfifo = \u0026amp;__tmp-\u0026gt;kfifo; \\ 37 if (__recsize) \\ 38 __ret = __kfifo_out_r(__kfifo, __val, sizeof(*__val), \\ 39 __recsize); \\ 40 else { \\ 41 __ret = !kfifo_is_empty(__tmp); \\ 42 if (__ret) { \\ 43 *(typeof(__tmp-\u0026gt;type))__val = \\ 44 (__is_kfifo_ptr(__tmp) ? \\ 45 ((typeof(__tmp-\u0026gt;type))__kfifo-\u0026gt;data) : \\ 46 (__tmp-\u0026gt;buf) \\ 47 )[__kfifo-\u0026gt;out \u0026amp; __tmp-\u0026gt;kfifo.mask]; \\ 48 smp_wmb(); \\ 49 __kfifo-\u0026gt;out++; \\ 50 } \\ 51 } \\ 52 __ret; \\ 53}) \\ 54) 3. 获取属性 # 1// include/linux/kfifo.h 2/** 3 * kfifo_is_empty - returns true if the fifo is empty 4 * @fifo: address of the fifo to be used 5 */ 6#define kfifo_is_empty(fifo) \\ 7({ \\ 8 typeof((fifo) + 1) __tmpq = (fifo); \\ 9 __tmpq-\u0026gt;kfifo.in == __tmpq-\u0026gt;kfifo.out; \\ 10}) 11 12/** 13 * kfifo_is_full - returns true if the fifo is full 14 * @fifo: address of the fifo to be used 15 */ 16#define kfifo_is_full(fifo) 示例用法 # 1/* keybuf.h */ 2#include \u0026lt;linux/kfifo.h\u0026gt; 3#define KEYBUF_KFIFO_SIZE 32 4// 这里将类型单独定义出来 5typedef STRUCT_KFIFO(unsigned char, 32) KeyBufType; 6// 按键结构体 7extern KeyBufType g_keybuf; 8 9/* keybuf.c */ 10#include \u0026lt;linux/kfifo.h\u0026gt; 11KeyBufType g_keybuf = (typeof(g_keybuf)){{{ 12 .in = 0, 13 .out = 0, 14 .mask = __is_kfifo_ptr(\u0026amp;(g_keybuf)) ? 0 : ARRAY_SIZE((g_keybuf).buf) - 1, 15 .esize = sizeof(*(g_keybuf).buf), 16 .data = __is_kfifo_ptr(\u0026amp;(g_keybuf)) ? NULL : (g_keybuf).buf, 17}}}; 18 19void intHandler() { 20 ... 21 // 插入一个数据 22 kfifo_put(\u0026amp;g_keybuf, data); 23} 24 25/* main.c */ 26#include \u0026#34;keybuf.h\u0026#34; 27 28int main() { 29 for (;;) { 30 io_cli(); 31 // 判断是否为空 32 if (kfifo_is_empty(\u0026amp;g_keybuf)) { 33 io_stihlt(); 34 } else { 35 // 取一个数据出来 36 unsigned char i; 37 kfifo_get(\u0026amp;g_keybuf, \u0026amp;i); 38 ... 39 } 40 } 41} 二、源码分析 # 1. 定义 # 主要结构体__kfifo 1// include/linux/kfifo.h 2struct __kfifo { 3 unsigned int in; // 写索引 4 unsigned int out; // 读索引 5 unsigned int mask; // 读写的mask，循环的高效写法的关键 6 unsigned int esize; // 数据的长度 7 void *data; // 数据段起始地址 8}; 联合声明 type、const_type、ptr和ptr_const的值没有实际含义，只是在后续实现的时候可以使用typeof()来找到类型，可以理解成是模板的C语言版本实现 rectype是作为一个占位符存在的，看清楚是一个指针数组，相当于可以指定头部大小，recsize指定即可，默认的是0，也就是按照__kfifo的大小最小占位 1#define __STRUCT_KFIFO_COMMON(datatype, recsize, ptrtype) \\ 2 union { \\ 3 struct __kfifo kfifo; \\ 4 datatype *type; \\ 5 const datatype *const_type; \\ 6 char (*rectype)[recsize]; \\ 7 ptrtype *ptr; \\ 8 ptrtype const *ptr_const; \\ 9 } 2. 操作 # 2.1. kfifo_put # 定义 1// include/linux/kfifo.h 2#define kfifo_put(fifo, val) \\ 3({ \\ 4 typeof((fifo) + 1) __tmp = (fifo); \\ 5 typeof(*__tmp-\u0026gt;const_type) __val = (val); \\ 6 unsigned int __ret; \\ 7 size_t __recsize = sizeof(*__tmp-\u0026gt;rectype); \\ 8 struct __kfifo *__kfifo = \u0026amp;__tmp-\u0026gt;kfifo; \\ 9 if (__recsize) \\ 10 __ret = __kfifo_in_r(__kfifo, \u0026amp;__val, sizeof(__val), \\ 11 __recsize); \\ 12 else { \\ 13 __ret = !kfifo_is_full(__tmp); \\ 14 if (__ret) { \\ 15 (__is_kfifo_ptr(__tmp) ? \\ 16 ((typeof(__tmp-\u0026gt;type))__kfifo-\u0026gt;data) : \\ 17 (__tmp-\u0026gt;buf) \\ 18 )[__kfifo-\u0026gt;in \u0026amp; __tmp-\u0026gt;kfifo.mask] = \\ 19 *(typeof(__tmp-\u0026gt;type))\u0026amp;__val; \\ 20 smp_wmb(); \\ 21 __kfifo-\u0026gt;in++; \\ 22 } \\ 23 } \\ 24 __ret; \\ 25}) 宏展开为 1({ 2 typeof((\u0026amp;fifo) + 1) __tmp = (\u0026amp;fifo); 3 typeof(*__tmp-\u0026gt;const_type) __val = (data); 4 unsigned int __ret; 5 size_t __recsize = sizeof(*__tmp-\u0026gt;rectype); 6 struct __kfifo *__kfifo = \u0026amp;__tmp-\u0026gt;kfifo; 7 if (__recsize) 8 __ret = __kfifo_in_r(__kfifo, \u0026amp;__val, sizeof(__val), __recsize); 9 else { 10 __ret = !kfifo_is_full(__tmp); 11 if (__ret) { 12 (__is_kfifo_ptr(__tmp) ? ((typeof(__tmp-\u0026gt;type))__kfifo-\u0026gt;data) 13 : (__tmp-\u0026gt;buf))[__kfifo-\u0026gt;in \u0026amp; __tmp-\u0026gt;kfifo.mask] = *(typeof(__tmp-\u0026gt;type))\u0026amp;__val; 14 smp_wmb(); 15 __kfifo-\u0026gt;in++; 16 } 17 } 18 __ret; 19}) 上面关键点在于[__kfifo-\u0026gt;in \u0026amp; __tmp-\u0026gt;kfifo.mask]，里面的in可以任意溢出，只保留mask的值 也就是假设size为32，mask为0b11111，in随便加，溢出后被mask与就只剩0-31，也就是从0开始，形成循环 3. 属性 # 3.1. kfifo_is_full # 1// include/linux/kfifo.h 2#define kfifo_is_full(fifo) \\ 3 ({ \\ 4 typeof((fifo) + 1) __tmpq = (fifo); \\ 5 kfifo_len(__tmpq) \u0026gt; __tmpq-\u0026gt;kfifo.mask; \\ 6 }) 宏展开 1({ 2 typeof((\u0026amp;fifo) + 1) __tmpq = (\u0026amp;fifo); 3 ({ 4 typeof((__tmpq) + 1) __tmpl = (__tmpq); 5 __tmpl-\u0026gt;kfifo.in - __tmpl-\u0026gt;kfifo.out; 6 }) \u0026gt; __tmpq-\u0026gt;kfifo.mask; 7}) 直接用in减去out，肯定会想如果in溢出从0开始怎么办，举个例子就知道了。假设in和out都是8位，那么0x00 - 0xff = 0x01，可以看到，溢出不影响计算两个的差值，所以整个kfifo的操作过程中，in和out只管尽情加就好了，不用考虑溢出的问题 两个差值大于mask就说明确实满了，假设容量2个，差值为2，mask为1，大于正好满了 "},{"id":203,"href":"/docs/linux/linux-kernel/mm/kmem_cache/","title":"kmem_cache","section":"/mm/ 内存管理","content":" 一、前言 # kmem_cache是slab管理器，每一个slab都是由kmem_cache进行管理的。struct kmem_cache有三种定义，SLAB、SLUB、SLOB。内核在高版本已经使用SLUB，当前介绍一下SLUB定义的kmem_cache相关原理，另外两个是类似的实现。\nSLAB是基础，SLOB用于嵌入式的小内存管理，SLUB是SLAB的改进版 二、实例 # 1. 使用kmem_cache定义一个hash表，管理用户态设置内存 # 1// 定义kmem_cache的slab 2struct kmem_cache *toa_ipv6_node_slab = NULL; 3// toa的ipv6表 4SDP_DEFINE_HASHTABLE_BL(toa_ipv6_table, TOA_IPV6_HASH_BITS); 5 6#ifdef DEBUG 7#define TOA_IPV6_SLAB_FLAG (SLAB_RED_ZONE | SLAB_POISON | SLAB_STORE_USER | SLAB_CONSISTENCY_CHECKS) 8#else 9#define TOA_IPV6_SLAB_FLAG 0 10#endif 11 12// 初始化kmemcache 13static int init_toa_ipv6_slab(void) { 14 static const char *tag = __FUNCTION__; 15\t// 定义的是使用struct toa_ipv6_node的对应大小，后面malloc就是这个大小 16 toa_ipv6_node_slab = KMEM_CACHE(toa_ipv6_node, TOA_IPV6_SLAB_FLAG); 17 if (toa_ipv6_node_slab == NULL) { 18 LOG_ERR(\u0026#34;%s, create slab failed, maybe out of memory\u0026#34;, tag); 19 return -1; 20 } 21 return 0; 22} 23 24// 仅允许驱动卸载调用，里面会清理hash表，不加锁 25static void uninit_toa_ipv6_slab(void) { 26 static const char *tag = __FUNCTION__; 27 int idx; 28 int count = 0; 29 struct hlist_bl_node *tmp = NULL; 30 struct hlist_bl_node *node = NULL; 31 toa_ipv6_node_t *entry = NULL; 32 33 BUG_ON(!toa_ipv6_node_slab); 34 35\t// kmem_cache在销毁slab前需要将所有的slab回收掉才行 36 hash_for_each_safe_bl(toa_ipv6_table, idx, tmp, node, entry, list) { 37 hlist_bl_del(node); 38 kmem_cache_free(toa_ipv6_node_slab, entry); 39 ++count; 40 } 41 LOG_INFO(\u0026#34;%s, there are %d ipv6 nodes not freed\u0026#34;, tag, count); 42 43 kmem_cache_destroy(toa_ipv6_node_slab); 44 toa_ipv6_node_slab = NULL; 45} 46 47// 使用 48void test(void) { 49\tstruct toa_ipv6_node *node = NULL; 50\tnode = kmem_cache_zalloc(toa_ipv6_node_slab, GFP_KERNEL); 51\t// do something 52} 三、代码原理 # 1. 先解释一下struct kmem_cache # 1// include/linux/slub_def.h 2/* 3 * Slab cache management. 4 */ 5struct kmem_cache { 6\t// 每个cpu的私有数据，用于特定场景的快速申请和释放 7\tstruct kmem_cache_cpu __percpu *cpu_slab; 8 9\t/* Used for retrieving partial slabs, etc. */ 10\t// 记录分配时要设置的flags 11\t// SLAB_CONSISTENCY_CHECKS 用于检查内存分配器（slab 分配器）的内部一致性，启用这个选项可以帮助开发人员检测和诊断内存管理中的错误和不一致问题 12\t// - 内存块完整性 13\t// - 内存池状态 14\t// - 边界检查 15\t// - 双重释放 16\t// SLAB_RED_ZONE 用于在缓存中划分红色区域，以检测内存越界等问题 17\t// SLAB_POISON 用于填充对象以防止使用未初始化的内存或检出内存越界访问 18\t// SLAB_HWCACHE_ALIGN 用于将对象对齐到缓存行，以提高缓存命中率和性能 19\t// SLAB_CACHE_DMA\t对应于使用GFP_DMA 20\t// SLAB_CACHE_DMA32\t对应于使用GFP_DMA32 21\t// SLAB_STORE_USER\t用于存储最后的使用者信息，帮助在调试过程中追踪内存使用 22\t// SLAB_PANIC\t函数调用失败时触发panic，从而中止系统运行，这是为了确保系统不会在内存分配错误后继续运行，导致更严重的问题 23\tslab_flags_t flags; 24 25\t// kmem_cache_shrink进行内存缩减时，要保留的最小的值。由函数set_min_partial(s, ilog2(s-\u0026gt;size)/2)设置 26\tunsigned long min_partial; 27 28\t// object的实际大小，包含对齐 29\tunsigned int size;\t/* The size of an object including metadata */ 30\t// object的payload大小，数据结构实际使用的大小 31\tunsigned int object_size;/* The size of an object without metadata */ 32 33 34\tstruct reciprocal_value reciprocal_size; 35\tunsigned int offset;\t/* Free pointer offset */ 36#ifdef CONFIG_SLUB_CPU_PARTIAL 37\t/* Number of per cpu partial objects to keep around */ 38\tunsigned int cpu_partial; 39\t/* Number of per cpu partial slabs to keep around */ 40\tunsigned int cpu_partial_slabs; 41#endif 42\tstruct kmem_cache_order_objects oo; 43 44\t/* Allocation and freeing of slabs */ 45\tstruct kmem_cache_order_objects min; 46\tgfp_t allocflags;\t/* gfp flags to use on each alloc */ 47\tint refcount;\t/* Refcount for slab cache destroy */ 48\tvoid (*ctor)(void *); 49\tunsigned int inuse;\t/* Offset to metadata */ 50\tunsigned int align;\t/* Alignment */ 51\tunsigned int red_left_pad;\t/* Left redzone padding size */ 52\tconst char *name;\t/* Name (only for display!) */ 53\tstruct list_head list;\t/* List of slab caches */ 54#ifdef CONFIG_SYSFS 55\tstruct kobject kobj;\t/* For sysfs */ 56#endif 57#ifdef CONFIG_SLAB_FREELIST_HARDENED 58\tunsigned long random; 59#endif 60 61#ifdef CONFIG_NUMA 62\t/* 63\t* Defragmentation by allocating from a remote node. 64\t*/ 65\tunsigned int remote_node_defrag_ratio; 66#endif 67 68#ifdef CONFIG_SLAB_FREELIST_RANDOM 69\tunsigned int *random_seq; 70#endif 71 72#ifdef CONFIG_KASAN 73\tstruct kasan_cache kasan_info; 74#endif 75 76\tunsigned int useroffset;\t/* Usercopy region offset */ 77\tunsigned int usersize;\t/* Usercopy region size */ 78 79\tstruct kmem_cache_node *node[MAX_NUMNODES]; 80}; "},{"id":204,"href":"/docs/linux/linux-kernel/data-structures/list/","title":"list 链表","section":"数据结构","content":" 一、前言 # 内核里面链表的实现有很多种\n名称 用途 定义 list_head 双向链表 include/linux/types.h hlist_head \u0026amp; hlist_node 带头节点的双向链表 include/linux/types.h hlist_bl_head \u0026amp; hlist_bl_node 带自旋锁和头节点的双向链表 include/linux/list_bl.h hlist_nulls_head \u0026amp; hlist_nulls_node 使用ptr最后一位代表end的双向链表 include/linux/list_nulls.h 二、使用实例 # 1. 在链表中间插入 # 1void test() { 2\t// 按照到期时间排序插入 3 struct TIMER *node; 4 struct TIMER *prev = NULL; // 记录要插入的节点前一个的节点 5 6 hlist_for_each_entry(node, \u0026amp;s_timer_list, entry) { 7 if (node-\u0026gt;expires \u0026gt; timer-\u0026gt;expires) { 8 break; 9 } 10 prev = node; 11 } 12 if (prev == NULL) { 13 // 没有前一个节点，说明要插入到第一个 14 // 1. 有节点，但是都不满足条件，插入最前面 15 // 2. 没有节点，直接插入最前面 16 hlist_add_head(\u0026amp;timer-\u0026gt;entry, \u0026amp;s_timer_list); 17 } else { 18 // 有前一个节点，插入到前一个节点后面 19 hlist_add_behind(\u0026amp;timer-\u0026gt;entry, \u0026amp;prev-\u0026gt;entry); 20 } 21} 三、代码实现详解 # 3. hlist_bl_head \u0026amp; hlist_bl_node 带自旋锁和头节点的双向链表 # 和hlist实现差不多，定义都一样，但是在hlist_bl_head-\u0026gt;first中取了第一位作为自旋锁。原因自然是因为字节对齐的问题，内核里面最差也是4字节对齐，就算16位也是2字节对齐，指针的最后一位都是0，所以最后一位可以拿来作为自旋锁。下面讲一些和hlist不一样的使用\n定义如下\n1static inline void hlist_bl_lock(struct hlist_bl_head *b) 2{ 3\tbit_spin_lock(0, (unsigned long *)b); 4} 5 6static inline void hlist_bl_unlock(struct hlist_bl_head *b) 7{ 8\t__bit_spin_unlock(0, (unsigned long *)b); 9} 自旋锁使用hlist_bl_head作为地址设置第0位，写的比较隐晦，实际修改的是first，因为struct hlist_bl_head就只有一个元素\n1struct hlist_bl_head { 2\tstruct hlist_bl_node *first; 3}; 由于first最后一位被使用了，所以所有取first的地方都要做特殊处理\n1// 取first真实地址需要将锁的位排除掉 2static inline struct hlist_bl_node *hlist_bl_first(struct hlist_bl_head *h) 3{ 4\treturn (struct hlist_bl_node *) 5\t((unsigned long)h-\u0026gt;first \u0026amp; ~LIST_BL_LOCKMASK); 6} 7 8// 设置first时必须要加锁的状态 9static inline void hlist_bl_set_first(struct hlist_bl_head *h, 10\tstruct hlist_bl_node *n) 11{ 12\tLIST_BL_BUG_ON((unsigned long)n \u0026amp; LIST_BL_LOCKMASK); 13\tLIST_BL_BUG_ON(((unsigned long)h-\u0026gt;first \u0026amp; LIST_BL_LOCKMASK) != 14\tLIST_BL_LOCKMASK); 15\th-\u0026gt;first = (struct hlist_bl_node *)((unsigned long)n | LIST_BL_LOCKMASK); 16} "},{"id":205,"href":"/docs/ai/cv/minst/","title":"minst手写数字识别——神经网络实战笔记","section":"计算机视觉","content":" 一、前言 # 神经网络、深度学习理论一片，基本都可以说道一下，但是真的上手搭建一个神经网络，并将数据处理并进行实践就难到我了。这里记录一下数据处理和神经网络实践。算作学习记录，或者说模板，后续搭建神经网络就参考这个博客，提供学习模板\n这里做的是minst手写数字识别的数据集，数据和代码来源主要来自kaggle\n二、正文 # 1. 数据处理部分 # 先看目录结构有啥\n1import numpy as np # linear algebra 2import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv) 3 4import os 5for dirname, _, filenames in os.walk(\u0026#39;/kaggle/input\u0026#39;): 6 for filename in filenames: 7 print(os.path.join(dirname, filename)) 1/kaggle/input/digit-recognizer/train.csv 2/kaggle/input/digit-recognizer/test.csv 3/kaggle/input/digit-recognizer/sample_submission.csv 读取数据自然是用pandas的read_csv函数\n1train_data = pd.read_csv(\u0026#39;/kaggle/input/digit-recognizer/train.csv\u0026#39;) 2print(train_data) 1 label pixel0 pixel1 pixel2 pixel3 pixel4 pixel5 pixel6 pixel7 \\ 20 1 0 0 0 0 0 0 0 0 31 0 0 0 0 0 0 0 0 0 42 1 0 0 0 0 0 0 0 0 53 4 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 7... ... ... ... ... ... ... ... ... ... 841995 0 0 0 0 0 0 0 0 0 941996 1 0 0 0 0 0 0 0 0 1041997 7 0 0 0 0 0 0 0 0 1141998 6 0 0 0 0 0 0 0 0 1241999 9 0 0 0 0 0 0 0 0 13 14 pixel8 ... pixel774 pixel775 pixel776 pixel777 pixel778 \\ 150 0 ... 0 0 0 0 0 161 0 ... 0 0 0 0 0 172 0 ... 0 0 0 0 0 183 0 ... 0 0 0 0 0 194 0 ... 0 0 0 0 0 20... ... ... ... ... ... ... ... 2141995 0 ... 0 0 0 0 0 2241996 0 ... 0 0 0 0 0 2341997 0 ... 0 0 0 0 0 2441998 0 ... 0 0 0 0 0 2541999 0 ... 0 0 0 0 0 26 27 pixel779 pixel780 pixel781 pixel782 pixel783 280 0 0 0 0 0 291 0 0 0 0 0 302 0 0 0 0 0 313 0 0 0 0 0 324 0 0 0 0 0 33... ... ... ... ... ... 3441995 0 0 0 0 0 3541996 0 0 0 0 0 3641997 0 0 0 0 0 3741998 0 0 0 0 0 3841999 0 0 0 0 0 39 40[42000 rows x 785 columns] 取出label，也就是标记，并做一下统计，用sns的countplot画一下统计图\n1import seaborn as sns 11 4684 27 4401 33 4351 49 4188 52 4177 66 4137 70 4132 84 4072 98 4063 105 3795 11Name: label, dtype: int64 取数据部分，就是把数据裁掉label列\n1X_train = train_data.drop(labels=[\u0026#39;label\u0026#39;], axis=1) 2print(X_train) 1 pixel0 pixel1 pixel2 pixel3 pixel4 pixel5 pixel6 pixel7 pixel8 \\ 20 0 0 0 0 0 0 0 0 0 31 0 0 0 0 0 0 0 0 0 42 0 0 0 0 0 0 0 0 0 53 0 0 0 0 0 0 0 0 0 64 0 0 0 0 0 0 0 0 0 7... ... ... ... ... ... ... ... ... ... 841995 0 0 0 0 0 0 0 0 0 941996 0 0 0 0 0 0 0 0 0 1041997 0 0 0 0 0 0 0 0 0 1141998 0 0 0 0 0 0 0 0 0 1241999 0 0 0 0 0 0 0 0 0 13 14 pixel9 ... pixel774 pixel775 pixel776 pixel777 pixel778 \\ 150 0 ... 0 0 0 0 0 161 0 ... 0 0 0 0 0 172 0 ... 0 0 0 0 0 183 0 ... 0 0 0 0 0 194 0 ... 0 0 0 0 0 20... ... ... ... ... ... ... ... 2141995 0 ... 0 0 0 0 0 2241996 0 ... 0 0 0 0 0 2341997 0 ... 0 0 0 0 0 2441998 0 ... 0 0 0 0 0 2541999 0 ... 0 0 0 0 0 26 27 pixel779 pixel780 pixel781 pixel782 pixel783 280 0 0 0 0 0 291 0 0 0 0 0 302 0 0 0 0 0 313 0 0 0 0 0 324 0 0 0 0 0 33... ... ... ... ... ... 3441995 0 0 0 0 0 3541996 0 0 0 0 0 3641997 0 0 0 0 0 3741998 0 0 0 0 0 3841999 0 0 0 0 0 39 40[42000 rows x 784 columns] 数据取出来了，删除原变量清理空间\n1del train_data 处理label为训练需要的，由于输出为10个数字，所以转成[0, 1, \u0026hellip;, 0]的形式，比较好输出 使用tensorflow的keras中的to_categorical函数进行转化\n1import tensorflow as tf 2print(Y_train) 3Y_train = tf.keras.utils.to_categorical(Y_train, num_classes = 10) 4print(Y_train) 10 1 21 0 32 1 43 4 54 0 6 .. 741995 0 841996 1 941997 7 1041998 6 1141999 9 12Name: label, Length: 42000, dtype: int64 13[[0. 1. 0. ... 0. 0. 0.] 14 [1. 0. 0. ... 0. 0. 0.] 15 [0. 1. 0. ... 0. 0. 0.] 16 ... 17 [0. 0. 0. ... 1. 0. 0.] 18 [0. 0. 0. ... 0. 0. 0.] 19 [0. 0. 0. ... 0. 0. 1.]] 2. 搭建神经网络 # 1.1. 全连接神经网络 # 第一步先用最简单的刚学会的全连接神经网络进行搭建 先初始化tpu\n1# detect and init the TPU 2tpu = tf.distribute.cluster_resolver.TPUClusterResolver() 3tf.config.experimental_connect_to_cluster(tpu) 4tf.tpu.experimental.initialize_tpu_system(tpu) 5 6# instantiate a distribution strategy 7tpu_strategy = tf.distribute.experimental.TPUStrategy(tpu) 全连接神经网络使用tensorflow上层封装的keras很方便的搭建\n由于数据为784像素，搭建一个$784 \\times 300 \\times 10$的三层全连接神经网络 激活函数用sigmoid函数，输出层不使用激活函数 训练算法为随机梯度下降算法SDG 损失函数使用最常见的方差，也就是MSE函数 评估函数，就是每次训练给自己看的正确率，使用accuracy 没有让定学习率，是keras自定义了一个学习率，想改可以更改，仿照下面示例 1lr = tf.keras.get_value(model.optimizer.lr) 2tf.keras.set_value(model.optimizer.lr, lr * 0.1) 搭建神经网络\n1# 用tpu进行编译 2with tpu_strategy.scope(): 3 model = tf.keras.Sequential([ 4 # Adds a densely-connected layer with 784 units to the model: 5 tf.keras.layers.Dense(784, activation=\u0026#39;sigmoid\u0026#39;, input_shape=(784,)), 6 # Add another: 7 tf.keras.layers.Dense(300, activation=\u0026#39;sigmoid\u0026#39;), 8 # Add an output layer with 10 output units: 9 tf.keras.layers.Dense(10)]) 10 11 model.compile(optimizer=\u0026#39;sgd\u0026#39;, 12 loss=\u0026#39;mse\u0026#39;, 13 metrics=[\u0026#39;accuracy\u0026#39;]) 开始训练，训练10轮，不使用batch_size，也就是一个数据训练一次，使用就是多少个数据一起计算损失进行训练 上面的评价函数应该用accuracy，不过我写成了mse，和loss一样了，不过可以看出损失在下降\n1model.fit(X_train, Y_train, epochs=10) 1Train on 42000 samples 2Epoch 1/10 342000/42000 [==============================] - 19s 445us/sample - loss: 0.0662 - mse: 0.0662 4Epoch 2/10 542000/42000 [==============================] - 15s 358us/sample - loss: 0.0450 - mse: 0.0450 6Epoch 3/10 742000/42000 [==============================] - 15s 363us/sample - loss: 0.0389 - mse: 0.0389 8Epoch 4/10 942000/42000 [==============================] - 15s 361us/sample - loss: 0.0352 - mse: 0.0352 10Epoch 5/10 1142000/42000 [==============================] - 15s 368us/sample - loss: 0.0327 - mse: 0.0327 12Epoch 6/10 1342000/42000 [==============================] - 15s 365us/sample - loss: 0.0307 - mse: 0.0307 14Epoch 7/10 1542000/42000 [==============================] - 15s 360us/sample - loss: 0.0290 - mse: 0.0290 16Epoch 8/10 1742000/42000 [==============================] - 15s 361us/sample - loss: 0.0277 - mse: 0.0277 18Epoch 9/10 1942000/42000 [==============================] - 16s 382us/sample - loss: 0.0265 - mse: 0.0265 20Epoch 10/10 2142000/42000 [==============================] - 15s 360us/sample - loss: 0.0255 - mse: 0.0255 预测正确率为91.085%，很开心，初步使用神经网络完成\n几个参数修改对比\n输出层加上sigmoid激活函数，正确率降低到81.285%，猜测限制了发挥 输出层使用relu函数，正确率比sigmoid函数高一点，到达85.014%，应该同样限制了发挥吧 所有层使用relu函数，预测结果直接有问题，relu函数导致结果全部为0，所以无法正常训练 根据网上查到的信息，主要原因是输入没有做归一化，权值初始化有问题，训练过程出现权值过大或者过小，通过relu函数变成0，训练过程权值无法调整到合适的值导致无法正常训练 隐藏层改为100个神经元，预测结果和300差别不大，都是91.000% 神经网络改为$784 \\times 150 \\times 150 \\times 10$，正确率达到86.257%，暂时未测试是否是训练轮数不够导致影响 sigmoid函数作为激活函数，在反向传播算法中，传播越远，梯度下降越难。由于传播使用的前一层的导数乘积，sigmoid函数导数最大为$\\frac{1}{4}$，所以会下降更难，一般全连接神经网络只有三层 1.2. 卷积神经网络 # 1# 用tpu进行编译 2with tpu_strategy.scope(): 3 # Set the CNN model 4 # my CNN architechture is In -\u0026gt; [[Conv2D-\u0026gt;relu]*2 -\u0026gt; MaxPool2D -\u0026gt; Dropout]*2 -\u0026gt; Flatten -\u0026gt; Dense -\u0026gt; Dropout -\u0026gt; Out 5 model = tf.keras.Sequential() 6 model.add(tf.keras.layers.Conv2D(filters = 32, kernel_size = (5,5),padding = \u0026#39;Same\u0026#39;, 7 activation =\u0026#39;relu\u0026#39;, input_shape = (28,28,1))) 8 model.add(tf.keras.layers.Conv2D(filters = 32, kernel_size = (5,5),padding = \u0026#39;Same\u0026#39;, 9 activation =\u0026#39;relu\u0026#39;)) 10 model.add(tf.keras.layers.MaxPool2D(pool_size=(2,2))) 11 model.add(tf.keras.layers.Dropout(0.25)) 12 13 14 model.add(tf.keras.layers.Conv2D(filters = 64, kernel_size = (3,3),padding = \u0026#39;Same\u0026#39;, 15 activation =\u0026#39;relu\u0026#39;)) 16 model.add(tf.keras.layers.Conv2D(filters = 64, kernel_size = (3,3),padding = \u0026#39;Same\u0026#39;, 17 activation =\u0026#39;relu\u0026#39;)) 18 model.add(tf.keras.layers.MaxPool2D(pool_size=(2,2), strides=(2,2))) 19 model.add(tf.keras.layers.Dropout(0.25)) 20 21 22 model.add(tf.keras.layers.Flatten()) 23 model.add(tf.keras.layers.Dense(256, activation = \u0026#34;relu\u0026#34;)) 24 model.add(tf.keras.layers.Dropout(0.5)) 25 model.add(tf.keras.layers.Dense(10)) 26 27 # Define the optimizer 28 optimizer = tf.keras.optimizers.RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0) 29 # Compile the model 30 model.compile(optimizer = optimizer , loss = \u0026#34;mse\u0026#34;, metrics=[\u0026#34;accuracy\u0026#34;]) 31 32 model.fit(X_train, Y_train, epochs=9, batch_size=42) 1Train on 42000 samples 2Epoch 1/9 342000/42000 [==============================] - 9s 225us/sample - loss: 0.6169 - accuracy: 0.8257 4Epoch 2/9 542000/42000 [==============================] - 5s 126us/sample - loss: 0.0145 - accuracy: 0.9686 6Epoch 3/9 742000/42000 [==============================] - 5s 131us/sample - loss: 0.0123 - accuracy: 0.9736 8Epoch 4/9 942000/42000 [==============================] - 5s 126us/sample - loss: 0.0113 - accuracy: 0.9763 10Epoch 5/9 1142000/42000 [==============================] - 5s 125us/sample - loss: 0.0110 - accuracy: 0.9772 12Epoch 6/9 1342000/42000 [==============================] - 6s 132us/sample - loss: 0.0107 - accuracy: 0.9774 14Epoch 7/9 1542000/42000 [==============================] - 6s 135us/sample - loss: 0.0105 - accuracy: 0.9775 16Epoch 8/9 1742000/42000 [==============================] - 6s 132us/sample - loss: 0.0102 - accuracy: 0.9787 18Epoch 9/9 1942000/42000 [==============================] - 5s 125us/sample - loss: 0.0102 - accuracy: 0.9774 3. 结果预测 # 对测试数据进行读取和预测 1X_test = pd.read_csv(\u0026#39;/kaggle/input/digit-recognizer/test.csv\u0026#39;) 2X_test = X_test.values.reshape(-1,28,28,1) 3result = model.predict(X_test) 4print(result) [[-6.0319379e-03 2.2311732e-03 9.7684860e-01 ... -5.4722652e-03 5.9211254e-04 4.1266829e-03] [ 1.0062367e+00 -2.2030249e-03 -5.0238818e-03 ... -3.2700002e-03 -9.3276799e-04 -3.5367012e-03] [ 2.6999190e-03 6.4259917e-03 1.0489762e-02 ... -1.1652485e-03 6.1268814e-02 9.1225845e-01] ... [-5.9012100e-03 -9.0321898e-04 1.8455610e-03 ... 2.4292246e-03 -3.2179952e-03 -1.5886426e-03] [-7.6884702e-03 -5.6109652e-03 -2.5104508e-03 ... -7.8360438e-03 -1.0629505e-02 1.0693249e+00] [-2.6000291e-03 5.1201209e-03 9.4756949e-01 ... -3.5209060e-03 5.4134727e-03 6.2924922e-03]] 这数据肯定不能用，用argmax转成我们需要的结果 1tmp = np.argmax(result, axis=1) 2print(tmp) [2 0 9 ... 3 9 2] 存到csv，提交 1result_data = pd.read_csv(\u0026#39;/kaggle/input/digit-recognizer/sample_submission.csv\u0026#39;) 2result_data[\u0026#39;Label\u0026#39;] = tmp 3result_data.to_csv(\u0026#39;/kaggle/working/sample_submission.csv\u0026#39;, index = 0) "},{"id":206,"href":"/docs/nginx/openresty/stream/socket-tcp/","title":"ngx_stream_lua_socket_tcp.c","section":"https://github.com/openresty/stream-lua-nginx-module","content":" 一、使用 # 二、流程 # "},{"id":207,"href":"/docs/linux/linux-kernel/kernel/locking/qspinlock/","title":"qspinlock","section":"/kernel/lockng/ 锁相关","content":" 一、介绍 # qspinlock是基于MCS lock进行改进的，将整个锁放入32位的空间中\n二、结构体介绍 # 1// include/asm-generic/qspinlock_types.h 2typedef struct qspinlock { 3\tunion { 4\tatomic_t val; 5 6\t/* 7\t* By using the whole 2nd least significant byte for the 8\t* pending bit, we can allow better optimization of the lock 9\t* acquisition for the pending bit holder. 10\t*/ 11#ifdef __LITTLE_ENDIAN 12\tstruct { 13\tu8\tlocked; 14\tu8\tpending; 15\t}; 16\tstruct { 17\tu16\tlocked_pending; 18\tu16\ttail; 19\t}; 20#else 21\tstruct { 22\tu16\ttail; 23\tu16\tlocked_pending; 24\t}; 25\tstruct { 26\tu8\treserved[2]; 27\tu8\tpending; 28\tu8\tlocked; 29\t}; 30#endif 31\t}; 32} arch_spinlock_t; 33 34/* 35 * Initializier 36 */ 37#define\t__ARCH_SPIN_LOCK_UNLOCKED\t{ { .val = ATOMIC_INIT(0) } } 38 39/* 40 * Bitfields in the atomic value: 41 * 42 * When NR_CPUS \u0026lt; 16K 43 * 0- 7: locked byte 44 * 8: pending 45 * 9-15: not used 46 * 16-17: tail index 47 * 18-31: tail cpu (+1) 48 * 49 * When NR_CPUS \u0026gt;= 16K 50 * 0- 7: locked byte 51 * 8: pending 52 * 9-10: tail index 53 * 11-31: tail cpu (+1) 54 */ 55#define\t_Q_SET_MASK(type)\t(((1U \u0026lt;\u0026lt; _Q_ ## type ## _BITS) - 1)\\ 56\t\u0026lt;\u0026lt; _Q_ ## type ## _OFFSET) 57#define _Q_LOCKED_OFFSET\t0 58#define _Q_LOCKED_BITS\t8 59#define _Q_LOCKED_MASK\t_Q_SET_MASK(LOCKED) 60 61#define _Q_PENDING_OFFSET\t(_Q_LOCKED_OFFSET + _Q_LOCKED_BITS) 62#if CONFIG_NR_CPUS \u0026lt; (1U \u0026lt;\u0026lt; 14) 63#define _Q_PENDING_BITS\t8 64#else 65#define _Q_PENDING_BITS\t1 66#endif 67#define _Q_PENDING_MASK\t_Q_SET_MASK(PENDING) 68 69#define _Q_TAIL_IDX_OFFSET\t(_Q_PENDING_OFFSET + _Q_PENDING_BITS) 70#define _Q_TAIL_IDX_BITS\t2 71#define _Q_TAIL_IDX_MASK\t_Q_SET_MASK(TAIL_IDX) 72 73#define _Q_TAIL_CPU_OFFSET\t(_Q_TAIL_IDX_OFFSET + _Q_TAIL_IDX_BITS) 74#define _Q_TAIL_CPU_BITS\t(32 - _Q_TAIL_CPU_OFFSET) 75#define _Q_TAIL_CPU_MASK\t_Q_SET_MASK(TAIL_CPU) 76 77#define _Q_TAIL_OFFSET\t_Q_TAIL_IDX_OFFSET 78#define _Q_TAIL_MASK\t(_Q_TAIL_IDX_MASK | _Q_TAIL_CPU_MASK) 79 80#define _Q_LOCKED_VAL\t(1U \u0026lt;\u0026lt; _Q_LOCKED_OFFSET) 81#define _Q_PENDING_VAL\t(1U \u0026lt;\u0026lt; _Q_PENDING_OFFSET) 内存排布如下，小端序\n大端序\n其中，locked只有1个字节，代表是否上锁，只有0和1两个值 tail中还有 16-17代表tail index，代表一个cpu最多同时获取4个spin lock 18-31代表tail cpu，针对cpu数目小于 $2^{14} = 16384$ 个的情况 三、相关操作及函数 # 1. native_queued_spin_lock_slowpath 上锁 # 1// kernel/locking/qspinlock.c 2#ifdef CONFIG_PARAVIRT_SPINLOCKS 3#define queued_spin_lock_slowpath\tnative_queued_spin_lock_slowpath 4#endif 5... 6/** 7 * queued_fetch_set_pending_acquire - fetch the whole lock value and set pending 8 * @lock : Pointer to queued spinlock structure 9 * Return: The previous lock value 10 * 11 * *,*,* -\u0026gt; *,1,* 12 */ 13#ifndef queued_fetch_set_pending_acquire 14static __always_inline u32 queued_fetch_set_pending_acquire(struct qspinlock *lock) 15{ 16\treturn atomic_fetch_or_acquire(_Q_PENDING_VAL, \u0026amp;lock-\u0026gt;val); 17} 18#endif 19... 20/** 21 * queued_spin_lock_slowpath - acquire the queued spinlock 22 * @lock: Pointer to queued spinlock structure 23 * @val: Current value of the queued spinlock 32-bit word 24 * 25 * (queue tail, pending bit, lock value) 26 * 27 * fast : slow : unlock 28 * : : 29 * uncontended (0,0,0) -:--\u0026gt; (0,0,1) ------------------------------:--\u0026gt; (*,*,0) 30 * : | ^--------.------. / : 31 * : v \\ \\ | : 32 * pending : (0,1,1) +--\u0026gt; (0,1,0) \\ | : 33 * : | ^--\u0026#39; | | : 34 * : v | | : 35 * uncontended : (n,x,y) +--\u0026gt; (n,0,0) --\u0026#39; | : 36 * queue : | ^--\u0026#39; | : 37 * : v | : 38 * contended : (*,x,y) +--\u0026gt; (*,0,0) ---\u0026gt; (*,0,1) -\u0026#39; : 39 * queue : ^--\u0026#39; : 40 */ 41void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val) 42{ 43\tstruct mcs_spinlock *prev, *next, *node; 44\tu32 old, tail; 45\tint idx; 46 47 // 确保cpu数量不超过自旋锁支持最大数量 48\tBUILD_BUG_ON(CONFIG_NR_CPUS \u0026gt;= (1U \u0026lt;\u0026lt; _Q_TAIL_CPU_BITS)); 49 50\tif (pv_enabled()) 51\tgoto pv_queue; 52 53\tif (virt_spin_lock(lock)) 54\treturn; 55 56\t/* 57\t* Wait for in-progress pending-\u0026gt;locked hand-overs with a bounded 58\t* number of spins so that we guarantee forward progress. 59\t* 60\t* 0,1,0 -\u0026gt; 0,0,1 61\t*/ 62\tif (val == _Q_PENDING_VAL) { 63\tint cnt = _Q_PENDING_LOOPS; 64\tval = atomic_cond_read_relaxed(\u0026amp;lock-\u0026gt;val, 65\t(VAL != _Q_PENDING_VAL) || !cnt--); 66\t} 67 68\t/* 69\t* If we observe any contention; queue. 70\t*/ 71 // 这里发现pending或等待队列有值，说明不止我们在等，且第一顺位有cpu在等 72 // 我们属于第二顺位之后的，乖乖到后面排队 73\tif (val \u0026amp; ~_Q_LOCKED_MASK) 74\tgoto queue; 75 76\t/* 77\t* trylock || pending 78\t* 79\t* 0,0,* -\u0026gt; 0,1,* -\u0026gt; 0,0,1 pending, trylock 80\t*/ 81 // 设置pending为1，返回是设置前的值 82\tval = queued_fetch_set_pending_acquire(lock); 83 84\t/* 85\t* If we observe contention, there is a concurrent locker. 86\t* 87\t* Undo and queue; our setting of PENDING might have made the 88\t* n,0,0 -\u0026gt; 0,0,0 transition fail and it will now be waiting 89\t* on @next to become !NULL. 90\t*/ 91 // 这里发现我们设置pending前，pending或等待队列有值，说明在上面那句话执行过程中，有cpu比我们更优先设置了pending 92 // 这里算是二次确认，说明我们比别人慢，不属于第一顺位，乖乖到后面排队 93\tif (unlikely(val \u0026amp; ~_Q_LOCKED_MASK)) { 94 95\t/* Undo PENDING if we set it. */ 96 // 如果设置pending前没有pending，说明pending是我们自己设置的，将pending清空 97 // 我们设置的pending，还走到这个位置，说明第一顺位没人，但是第二顺位有人，我们放开pending，排后面去 98\tif (!(val \u0026amp; _Q_PENDING_MASK)) 99\tclear_pending(lock); 100 101 // 进入到排队状态 102\tgoto queue; 103\t} 104 105\t/* 106\t* We\u0026#39;re pending, wait for the owner to go away. 107\t* 108\t* 0,1,1 -\u0026gt; 0,1,0 109\t* 110\t* this wait loop must be a load-acquire such that we match the 111\t* store-release that clears the locked bit and create lock 112\t* sequentiality; this is because not all 113\t* clear_pending_set_locked() implementations imply full 114\t* barriers. 115\t*/ 116 // 我们设置pending，其他cpu没有申请，说明我们是第一顺位 117 // 只需要等待锁被释放就可以了 118\tif (val \u0026amp; _Q_LOCKED_MASK) 119\tatomic_cond_read_acquire(\u0026amp;lock-\u0026gt;val, !(VAL \u0026amp; _Q_LOCKED_MASK)); 120 121\t/* 122\t* take ownership and clear the pending bit. 123\t* 124\t* 0,1,0 -\u0026gt; 0,0,1 125\t*/ 126 // 设置上锁，清理我们设置的pending 127\tclear_pending_set_locked(lock); 128\tlockevent_inc(lock_pending); 129\treturn; 130 131\t/* 132\t* End of pending bit optimistic spinning and beginning of MCS 133\t* queuing. 134\t*/ 135queue: 136\tlockevent_inc(lock_slowpath); 137pv_queue: 138\tnode = this_cpu_ptr(\u0026amp;qnodes[0].mcs); 139\tidx = node-\u0026gt;count++; 140\ttail = encode_tail(smp_processor_id(), idx); 141 142\ttrace_contention_begin(lock, LCB_F_SPIN); 143 144\t/* 145\t* 4 nodes are allocated based on the assumption that there will 146\t* not be nested NMIs taking spinlocks. That may not be true in 147\t* some architectures even though the chance of needing more than 148\t* 4 nodes will still be extremely unlikely. When that happens, 149\t* we fall back to spinning on the lock directly without using 150\t* any MCS node. This is not the most elegant solution, but is 151\t* simple enough. 152\t*/ 153\tif (unlikely(idx \u0026gt;= MAX_NODES)) { 154\tlockevent_inc(lock_no_node); 155\twhile (!queued_spin_trylock(lock)) 156\tcpu_relax(); 157\tgoto release; 158\t} 159 160\tnode = grab_mcs_node(node, idx); 161 162\t/* 163\t* Keep counts of non-zero index values: 164\t*/ 165\tlockevent_cond_inc(lock_use_node2 + idx - 1, idx); 166 167\t/* 168\t* Ensure that we increment the head node-\u0026gt;count before initialising 169\t* the actual node. If the compiler is kind enough to reorder these 170\t* stores, then an IRQ could overwrite our assignments. 171\t*/ 172\tbarrier(); 173 174\tnode-\u0026gt;locked = 0; 175\tnode-\u0026gt;next = NULL; 176\tpv_init_node(node); 177 178\t/* 179\t* We touched a (possibly) cold cacheline in the per-cpu queue node; 180\t* attempt the trylock once more in the hope someone let go while we 181\t* weren\u0026#39;t watching. 182\t*/ 183\tif (queued_spin_trylock(lock)) 184\tgoto release; 185 186\t/* 187\t* Ensure that the initialisation of @node is complete before we 188\t* publish the updated tail via xchg_tail() and potentially link 189\t* @node into the waitqueue via WRITE_ONCE(prev-\u0026gt;next, node) below. 190\t*/ 191\tsmp_wmb(); 192 193\t/* 194\t* Publish the updated tail. 195\t* We have already touched the queueing cacheline; don\u0026#39;t bother with 196\t* pending stuff. 197\t* 198\t* p,*,* -\u0026gt; n,*,* 199\t*/ 200\told = xchg_tail(lock, tail); 201\tnext = NULL; 202 203\t/* 204\t* if there was a previous node; link it and wait until reaching the 205\t* head of the waitqueue. 206\t*/ 207\tif (old \u0026amp; _Q_TAIL_MASK) { 208\tprev = decode_tail(old); 209 210\t/* Link @node into the waitqueue. */ 211\tWRITE_ONCE(prev-\u0026gt;next, node); 212 213\tpv_wait_node(node, prev); 214\tarch_mcs_spin_lock_contended(\u0026amp;node-\u0026gt;locked); 215 216\t/* 217\t* While waiting for the MCS lock, the next pointer may have 218\t* been set by another lock waiter. We optimistically load 219\t* the next pointer \u0026amp; prefetch the cacheline for writing 220\t* to reduce latency in the upcoming MCS unlock operation. 221\t*/ 222\tnext = READ_ONCE(node-\u0026gt;next); 223\tif (next) 224\tprefetchw(next); 225\t} 226 227\t/* 228\t* we\u0026#39;re at the head of the waitqueue, wait for the owner \u0026amp; pending to 229\t* go away. 230\t* 231\t* *,x,y -\u0026gt; *,0,0 232\t* 233\t* this wait loop must use a load-acquire such that we match the 234\t* store-release that clears the locked bit and create lock 235\t* sequentiality; this is because the set_locked() function below 236\t* does not imply a full barrier. 237\t* 238\t* The PV pv_wait_head_or_lock function, if active, will acquire 239\t* the lock and return a non-zero value. So we have to skip the 240\t* atomic_cond_read_acquire() call. As the next PV queue head hasn\u0026#39;t 241\t* been designated yet, there is no way for the locked value to become 242\t* _Q_SLOW_VAL. So both the set_locked() and the 243\t* atomic_cmpxchg_relaxed() calls will be safe. 244\t* 245\t* If PV isn\u0026#39;t active, 0 will be returned instead. 246\t* 247\t*/ 248\tif ((val = pv_wait_head_or_lock(lock, node))) 249\tgoto locked; 250 251\tval = atomic_cond_read_acquire(\u0026amp;lock-\u0026gt;val, !(VAL \u0026amp; _Q_LOCKED_PENDING_MASK)); 252 253locked: 254\t/* 255\t* claim the lock: 256\t* 257\t* n,0,0 -\u0026gt; 0,0,1 : lock, uncontended 258\t* *,*,0 -\u0026gt; *,*,1 : lock, contended 259\t* 260\t* If the queue head is the only one in the queue (lock value == tail) 261\t* and nobody is pending, clear the tail code and grab the lock. 262\t* Otherwise, we only need to grab the lock. 263\t*/ 264 265\t/* 266\t* In the PV case we might already have _Q_LOCKED_VAL set, because 267\t* of lock stealing; therefore we must also allow: 268\t* 269\t* n,0,1 -\u0026gt; 0,0,1 270\t* 271\t* Note: at this point: (val \u0026amp; _Q_PENDING_MASK) == 0, because of the 272\t* above wait condition, therefore any concurrent setting of 273\t* PENDING will make the uncontended transition fail. 274\t*/ 275\tif ((val \u0026amp; _Q_TAIL_MASK) == tail) { 276\tif (atomic_try_cmpxchg_relaxed(\u0026amp;lock-\u0026gt;val, \u0026amp;val, _Q_LOCKED_VAL)) 277\tgoto release; /* No contention */ 278\t} 279 280\t/* 281\t* Either somebody is queued behind us or _Q_PENDING_VAL got set 282\t* which will then detect the remaining tail and queue behind us 283\t* ensuring we\u0026#39;ll see a @next. 284\t*/ 285\tset_locked(lock); 286 287\t/* 288\t* contended path; wait for next if not observed yet, release. 289\t*/ 290\tif (!next) 291\tnext = smp_cond_load_relaxed(\u0026amp;node-\u0026gt;next, (VAL)); 292 293\tarch_mcs_spin_unlock_contended(\u0026amp;next-\u0026gt;locked); 294\tpv_kick_node(lock, next); 295 296release: 297\ttrace_contention_end(lock, 0); 298 299\t/* 300\t* release the node 301\t*/ 302\t__this_cpu_dec(qnodes[0].mcs.count); 303} 304EXPORT_SYMBOL(queued_spin_lock_slowpath); 分段对此代码进行分析\n1.1. 第一个cpu或第一顺位cpu获取锁的过程 # 1void queued_spin_lock_slowpath(struct qspinlock *lock, u32 val) 2{ 3\tstruct mcs_spinlock *prev, *next, *node; 4\tu32 old, tail; 5\tint idx; 6 ... 7\t/* 8\t* If we observe any contention; queue. 9\t*/ 10 // 这里发现pending或等待队列有值，说明不止我们在等，且第一顺位有cpu在等 11 // 我们属于第二顺位之后的，乖乖到后面排队 12\tif (val \u0026amp; ~_Q_LOCKED_MASK) 13\tgoto queue; 14 15\t/* 16\t* trylock || pending 17\t* 18\t* 0,0,* -\u0026gt; 0,1,* -\u0026gt; 0,0,1 pending, trylock 19\t*/ 20 // 设置pending为1，返回是设置前的值 21\tval = queued_fetch_set_pending_acquire(lock); 22 23\t/* 24\t* If we observe contention, there is a concurrent locker. 25\t* 26\t* Undo and queue; our setting of PENDING might have made the 27\t* n,0,0 -\u0026gt; 0,0,0 transition fail and it will now be waiting 28\t* on @next to become !NULL. 29\t*/ 30 // 这里发现我们设置pending前，pending或等待队列有值，说明在上面那句话执行过程中，有cpu比我们更优先设置了pending 31 // 这里算是二次确认，说明我们比别人慢，不属于第一顺位，乖乖到后面排队 32\tif (unlikely(val \u0026amp; ~_Q_LOCKED_MASK)) { 33 34\t/* Undo PENDING if we set it. */ 35 // 如果设置pending前没有pending，说明pending是我们自己设置的，将pending清空 36 // 我们设置的pending，还走到这个位置，说明第一顺位没人，但是第二顺位有人，我们放开pending，排后面去 37\tif (!(val \u0026amp; _Q_PENDING_MASK)) 38\tclear_pending(lock); 39 40 // 进入到排队状态 41\tgoto queue; 42\t} 43 44\t/* 45\t* We\u0026#39;re pending, wait for the owner to go away. 46\t* 47\t* 0,1,1 -\u0026gt; 0,1,0 48\t* 49\t* this wait loop must be a load-acquire such that we match the 50\t* store-release that clears the locked bit and create lock 51\t* sequentiality; this is because not all 52\t* clear_pending_set_locked() implementations imply full 53\t* barriers. 54\t*/ 55 // 我们设置pending，其他cpu没有申请，说明我们是第一顺位 56 // 只需要等待锁被释放就可以了 57\tif (val \u0026amp; _Q_LOCKED_MASK) 58\tatomic_cond_read_acquire(\u0026amp;lock-\u0026gt;val, !(VAL \u0026amp; _Q_LOCKED_MASK)); 59 60\t/* 61\t* take ownership and clear the pending bit. 62\t* 63\t* 0,1,0 -\u0026gt; 0,0,1 64\t*/ 65 // 设置上锁，清理我们设置的pending 66\tclear_pending_set_locked(lock); 67\tlockevent_inc(lock_pending); 68\treturn; 69 ... 70} 1.2. 第二顺位及以后的cpu获取锁过程 # "},{"id":208,"href":"/docs/linux/linux-kernel/data-structures/rbtree/","title":"rbtree 红黑树","section":"数据结构","content":"1// include/linux/rbtree.h 2struct rb_node { 3\tunsigned long __rb_parent_color; 4\tstruct rb_node *rb_right; 5\tstruct rb_node *rb_left; 6} __attribute__((aligned(sizeof(long)))); 先参考 地址对齐 了解为什么可以使用__rb_parent_color的低两位作为颜色 "},{"id":209,"href":"/docs/linux/linux-kernel/data-structures/rcu/","title":"RCU Read-Copy-Update","section":"数据结构","content":" 一文带你深入解析Linux内核-RCU机制（超详细~） Linux 内核：RCU机制与使用\n一、原理 # 对一块数据要写入时，先拷贝一份，更新数据完成后，再更新到原数据结构 保证要么读取老数据，要么读取新数据，不会出现读取一半的情况 写的时候锁住，等待读，应对写少读多的场景 二、关键思想 # 复制后更新数据 延迟回收内存，当没有老数据结构引用的读者时，才回收内存 "},{"id":210,"href":"/docs/openssl/engines/rsa/","title":"rsa普密ukey","section":"引擎开发","content":" 一、首先先看rsa的证书认证过程 # 1. tls1.2的rsa证书双向认证 Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d) # 1# 服务端命令 2openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt -CAfile cacert.pem -Verify 1 3# 客户端命令 4openssl s_client -connect 127.0.0.1:7777 -cipher RSA -tls1_2 -debug -keylogfile test.log -cert domain.crt -key domain.key @startuml tls title tls1.2的rsa证书双向认证 participant client participant server == tcp建立完成后 == client-\u0026gt;server: Client Hello note over client client hello Content Type: Handshake(22) Version: TLS 1.0 (0x0301) 这个可以忽略，Handshake默认就是tls1.0 Handshake Type: Client Hello(1) Version: TLS 1.2 (0x0303) 客户端支持的最高tls版本 算法套件信息 Cipher Suites 包含密钥交换算法、身份认证算法、对称加密算法、信息摘要算法 随机数 Random 前四个字节为GMT Unix时间，增强随机性 请求的服务名 Extension: server_name(0) 签名哈希算法列表 Extension: signature_algorithms(13) end note server-\u0026gt;client: Server Hello, Certificate, Certificate Request, Server Hello Done note over server Server Hello Content Type: Handshake(22) Handshake Type: Server Hello(2) Version: TLS 1.2 (0x0303) 确定TLS版本为1.2 Random 随机数 前四个字节为GMT Unix时间，增强随机性 Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d) 确定算法套件 end note note over server Certificate Content Type: Handshake(22) Handshake Type: Certificate(11) 下发服务端证书 包含证书信息、证书公钥 end note note over server Certificate Content Type: Handshake(22) Handshake Type: Certificate(11) 下发服务端证书 包含证书信息、证书公钥、证书签名信息 end note note over server Certificate Request Content Type: Handshake(22) Handshake Type: Certificate Request (13) 要求客户端提交证书，一般是nginx配置中开启了对端证书校验 Certificate types (3 types) 允许提交的证书类型 RSA Sign DSS Sign ECDSA Sign Signature Hash Algorithms (23 algorithms) 支持的签名和hash算法 Distinguished Names (135 bytes) CA相关信息，只支持此CA下发的相关证书 end note note over server Server Hello Done Content Type: Handshake(22) Handshake Type: Server Hello Done(14) server hello结束 end note client-\u0026gt;server: Certificate, Client Key Exchange, Certificate Verify, Change Cipher Spec, Encrypted Handshake Message note over client Certificate Content Type: Handshake(22) Handshake Type: Certificate(11) 提交客户端证书 Certificates (2043 bytes) 证书信息集 Certificate: 单个证书信息 signedCertificate 证书的基本信息 subject 主题 subjectPublicKeyInfo 公钥信息 validity 证书有效期 algorithmIdentifier (sha256WithRSAEncryption) encrypted: 证书签名值（每个证书都自带（签发时使用私钥加密摘要信息算出来的），用于防篡改，不是tls过程中算出来的） end note note over client Client Key Exchange Content Type: Handshake(22) Handshake Type: Client Key Exchange(16) 生成预主密钥，使用服务端下发的公钥加密上传到服务端，由于只有服务端自己有私钥这一步保证证书是服务端自己持有的 end note note over client Certificate Verify Content Type: Handshake(22) Handshake Type: Certificate Verify (15) 使用客户端证书的私钥对握手信息进行签名，由服务端进行验签来确定证书是客户端自己持有的 end note note over client Change Chipher Spec Content Type: Change Chipher Spec(20) 告知服务端，下面的数据要加密了 end note note over client Finished Opaque Type: Application Data(23) 下面是解密后的数据 Content Type: Handshake(22) Handshake Type: Finished(20) end note server-\u0026gt;client: New Session Ticket, Change Cipher Spec, Finished note over server New Session Ticket Content Type: Change Chipher Spec(20) Handshake Type: New Session Ticket (4) 给一个session到客户端，用于ssl复用 end note note over server Change Chipher Spec Content Type: Change Chipher Spec(20) 告知客户端，下面的数据要加密了 end note note over server Finished Opaque Type: Application Data(23) 下面是解密后的数据 Content Type: Handshake(22) Handshake Type: Finished(20) end note == 开始ssl数据传输 == @enduml 从上面的过程中，我们知道有几个关键点\n证书主体内容作为Certificate发出去 Client Verify需要使用证书的私钥对握手信息进行签名 二、如何开发一个引擎 # 1. 证书双向认证引擎 # 从上面的流程可以得出，证书认证中需要使用客户端证书的部分只有Certificate和Certificate Verify两个请求 一般使用ukey进行双向认证的话，私钥是无法导出的，所以需要实现一下证书导出和私钥签名函数 1.1. 引擎基础设置 # 1/******************** 这个函数是引擎设置的最基础的函数 ********************/ 2/* Constants used when creating the ENGINE */ 3static const char* engine_id = \u0026#34;skf\u0026#34;; 4static const char* engine_name = \u0026#34;skf hardware engine support\u0026#34;; 5static RSA_METHOD* skf_rsa_method = nullptr; 6/* Prepare the ENGINE structure for registration */ 7static int skf_bind_helper(ENGINE* e) { 8 LOG_DEBUG(\u0026#34;skf_bind_helper\u0026#34;); 9 10 // set skf rsa engine method, use default method and diy some function 11 if ((skf_rsa_method = RSA_meth_dup(RSA_get_default_method())) == NULL || 12 // 私钥加密函数 13 RSA_meth_set_priv_enc(skf_rsa_method, skf_rsa_priv_enc) == 0) { 14 return 0; 15 } 16 17 if (!ENGINE_set_id(e, engine_id) || // 引擎id 18 !ENGINE_set_name(e, engine_name) || // 引擎名字 19 !ENGINE_set_init_function(e, engine_init) || // 初始化函数，握手前调用 20 !ENGINE_set_finish_function(e, engine_finish) || // 结束函数，连接完成不再需要引擎时调用 21 !ENGINE_set_destroy_function(e, engine_destroy) || // 销毁函数，结束时调用，只会被调用一次 22 !ENGINE_set_RSA(e, skf_rsa_method) || // 设置rsa算法结构体 23 // if not set, sdf will load by default if possible 24 !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) || 25 !ENGINE_set_load_ssl_client_cert_function(e, skf_load_ssl_client_cert) // 设置客户端证书加载函数 26 ) { 27 return 0; 28 } 29 30 return 1; 31} 32 33/* This stuff is needed if this ENGINE is being compiled into a self-contained 34 * shared-library. */ 35#include \u0026lt;openssl/engine.h\u0026gt; 36#ifndef OPENSSL_NO_DYNAMIC_ENGINE 37 38extern \u0026#34;C\u0026#34; { 39static int bind_helper(ENGINE* e, const char* id) { 40 if (id \u0026amp;\u0026amp; (strcmp(id, engine_id) != 0)) return 0; 41 42 if (!skf_bind_helper(e)) return 0; 43 44 return 1; 45} 46 47IMPLEMENT_DYNAMIC_CHECK_FN() 48IMPLEMENT_DYNAMIC_BIND_FN(bind_helper) 49} 50#else 51static ENGINE* engine_skf(void) { 52 ENGINE* eng = ENGINE_new(); 53 if (!eng) return NULL; 54 if (!skf_bind_helper(eng)) { 55 ENGINE_free(eng); 56 return NULL; 57 } 58 59 return eng; 60} 61 62void engine_load_skf_int(void) { 63 ENGINE* toadd = engine_skf(); 64 if (!toadd) return; 65 ENGINE_add(toadd); 66 ENGINE_free(toadd); 67 ERR_clear_error(); 68} 69#endif /* OPENSSL_NO_DYNAMIC_ENGINE */ 1.2. 导出证书的函数 # 注册证书的加载函数到openssl 1static int skf_bind_helper(ENGINE* e) { 2 ... 3 if (... 4 !ENGINE_set_load_ssl_client_cert_function(e, skf_load_ssl_client_cert) // 设置客户端证书加载函数 5 ) { 6 return 0; 7 } 8 9 return 1; 10} 函数原型为 1static int skf_load_ssl_client_cert(ENGINE* e, SSL* ssl, STACK_OF(X509_NAME) * ca_dn, X509** pcert, EVP_PKEY** ppkey, 2 STACK_OF(X509) * *pother, UI_METHOD* ui_method, void* callback_data); 1) 一个简单的软件实现代码如下，从文件中读取证书给到引擎 # 1/** 2 * @brief 导出客户端证书函数 3 * 4 * @param[in] e 引擎指针 5 * @param[in] ssl ssl结构体 6 * @param[in] ca_dn ca相关信息，一般是服务端下发的用于匹配证书 7 * @param[out] pcert 证书指针，内部申请空间，外部会进行释放 8 * @param[out] ppkey 算法key结构体，里面其实是只需要公钥的 9 * @param[out] pother 10 * @param[in] ui_method 11 * @param[in] callback_data 12 * @return int 1成功，0失败 13 */ 14static int skf_load_ssl_client_cert(ENGINE* e, SSL* ssl, STACK_OF(X509_NAME) * ca_dn, X509** pcert, EVP_PKEY** ppkey, 15 STACK_OF(X509) * *pother, UI_METHOD* ui_method, void* callback_data) { 16 const char* operation = \u0026#34;skf_load_ssl_client_cert\u0026#34;; 17 LOG_DEBUG(\u0026#34;%s\u0026#34;, operation); 18 int iResult = 0; 19 // 读取PEM格式证书文件 20 FILE* fp = fopen(\u0026#34;/path/to/domain.crt\u0026#34;, \u0026#34;r\u0026#34;); 21 *pcert = PEM_read_X509(fp, NULL, NULL, NULL); 22 fclose(fp); 23 if (*pcert == NULL) { 24 LOG_ERROR(\u0026#34;[%s], PEM_read_X509 failed\u0026#34;, operation); 25 return 0; 26 } 27 // 直接从证书读取公钥放这里最省事，外面会进行校验公钥和证书是否匹配 28 // ukey只能导出公钥，如果是其他可以导出私钥的，这里也可以将私钥放进去，这样可以直接软件实现私钥加密函数 29 // 这里要增加引用计数，对外部来说，ppkey和pcert是分开释放的 30 *ppkey = X509_get_pubkey(*pcert); 31 LOG_INFO(\u0026#34;%s success\u0026#34;, operation); 32 return 1; 33} 2) ukey中读证书 # 使用ukey的话，这里就只能导出证书和公钥，私钥无法导出 1// 将导出的公钥结构体设置到rsa结构体的公钥部分 2int RSA_set_RSAPUBLICKEYBLOB(RSA *rsa, const RSAPUBLICKEYBLOB *blob) 3{ 4\tint ret = 0; 5\tBIGNUM *n = NULL; 6\tBIGNUM *e = NULL; 7 8\tif (!rsa || !blob) { 9 LOG_ERROR(Tag, \u0026#34;!rsa || !blob\u0026#34;); 10\treturn 0; 11\t} 12 13\tif ((blob-\u0026gt;BitLen \u0026lt; OPENSSL_RSA_FIPS_MIN_MODULUS_BITS) 14\t|| (blob-\u0026gt;BitLen \u0026gt; sizeof(blob-\u0026gt;Modulus) * 8) 15\t|| (blob-\u0026gt;BitLen % 8 != 0)) { 16 LOG_ERROR(Tag, \u0026#34;blob-\u0026gt;BitLen \u0026lt; OPENSSL_RSA_FIPS_MIN_MODULUS_BITS\u0026#34;); 17\treturn 0; 18\t} 19 20 // 导出两个大质数的乘积n 21\tif (!(n = BN_bin2bn(blob-\u0026gt;Modulus, sizeof(blob-\u0026gt;Modulus), NULL))) { 22 LOG_ERROR(Tag, \u0026#34;n = BN_bin2bn(blob-\u0026gt;Modulus, sizeof(blob-\u0026gt;Modulus), NULL)\u0026#34;); 23\tgoto end; 24\t} 25 26 // 导出公钥的e 27\tif (!(e = BN_bin2bn(blob-\u0026gt;PublicExponent, 28\tsizeof(blob-\u0026gt;PublicExponent), NULL))) { 29 LOG_ERROR(Tag, \u0026#34;e = BN_bin2bn(blob-\u0026gt;PublicExponent\u0026#34;); 30\tgoto end; 31\t} 32 33 // 设置rsa的n和e，对应的是rsa算法的公钥部分 34\tif (!RSA_set0_key(rsa, n, e, NULL)) { 35 LOG_ERROR(Tag, \u0026#34;RSA_set0_key(rsa, n, e, NULL)\u0026#34;); 36\tgoto end; 37\t} 38\tn = NULL; 39\te = NULL; 40 41\tret = 1; 42 43end: 44\tBN_free(n); 45\tBN_free(e); 46\treturn ret; 47} 48 49static int skf_load_rsa_client_cert(X509** pcert, EVP_PKEY** ppkey) { 50 const char* operation = \u0026#34;load rsa client cert\u0026#34;; 51 RSAPUBLICKEYBLOB pubKey = {0}; 52 EVP_PKEY* pkey = NULL; 53 RSA* r = NULL; 54 int iResult = 0; 55 unsigned char certContetBITS[8192] = {0}; 56 ULONG ulCertLen = sizeof(certContetBITS); 57 BIO* b = NULL; 58 59 LOG_INFO(Tag, \u0026#34;%s\u0026#34;, operation); 60 do { 61 if ((pkey = EVP_PKEY_new()) == NULL) { 62 LOG_ERROR(Tag, \u0026#34;[%s] new EVP_PKEY failed\u0026#34;, operation); 63 break; 64 } 65 66 // 导出公钥写入算法结构体 67 if (exportPublicKey(TRUE, reinterpret_cast\u0026lt;unsigned char*\u0026gt;(\u0026amp;pubKey), sizeof(pubKey)) \u0026lt; 0) { 68 LOG_ERROR(Tag, \u0026#34;[%s] export public key from skf failed\u0026#34;, operation); 69 break; 70 } 71 LOG_INFO(Tag, \u0026#34;export public key success\u0026#34;); 72 73 if ((r = RSA_new()) == NULL) { 74 LOG_ERROR(Tag, \u0026#34;[%s] new RSA failed\u0026#34;, operation); 75 break; 76 } 77 78 if (!RSA_set_RSAPUBLICKEYBLOB(r, \u0026amp;pubKey)) { 79 LOG_ERROR(Tag, \u0026#34;[%s] set public key to rsa failed\u0026#34;, operation); 80 break; 81 } 82 if (!EVP_PKEY_assign_RSA(pkey, r)) { 83 LOG_ERROR(Tag, \u0026#34;[%s] assign rsa to EVP_KEY failed\u0026#34;, operation); 84 break; 85 } 86 *ppkey = pkey; 87 88 // 导出签名证书写入证书指针 89 if (!exportCertificate(TRUE, certContetBITS, ulCertLen)) { 90 LOG_ERROR(Tag, \u0026#34;[%s], export sign certificate by skf failed\u0026#34;, operation); 91 break; 92 } 93 LOG_INFO(Tag, \u0026#34;export sign certificate by skf certLen[%d]\u0026#34;, ulCertLen); 94 95 if ((b = BIO_new(BIO_s_mem())) == NULL) { 96 LOG_ERROR(Tag, \u0026#34;[%s], new BIO failed\u0026#34;, operation); 97 break; 98 } 99 100 BIO_write(b, certContetBITS, ulCertLen); 101 *pcert = d2i_X509_bio(b, NULL); 102 if (*pcert == NULL) { 103 LOG_ERROR(Tag, \u0026#34;[%s], d2i_X509_bio failed\u0026#34;, operation); 104 break; 105 } 106 107 iResult = 1; 108 LOG_INFO(Tag, \u0026#34;%s success\u0026#34;, operation); 109 } while (false); 110 111 if (b != NULL) { 112 BIO_free(b); 113 b = NULL; 114 } 115 116 // 成功部分指针不需要清理 117 if (iResult == 1) { 118 return iResult; 119 } 120 121 if (r != NULL) { 122 RSA_free(r); 123 r = NULL; 124 } 125 126 if (pkey != NULL) { 127 EVP_PKEY_free(pkey); 128 pkey = NULL; 129 } 130 return iResult; 131} 132 133static int skf_load_ssl_client_cert(ENGINE* e, SSL* ssl, STACK_OF(X509_NAME) * ca_dn, X509** pcert, 134 EVP_PKEY** ppkey, STACK_OF(X509) * *pother, 135 UI_METHOD* ui_method, void* callback_data) { 136 const char* operation = \u0026#34;skf_load_ssl_client_cert\u0026#34;; 137 LOG_DEBUG(Tag, \u0026#34;%s\u0026#34;, operation); 138 139 if (getContainerType() == 1) { 140 return skf_load_rsa_client_cert(pcert, ppkey); 141 } 142 // only handle rsa, other return false 143 return 0; 144} 1.3. 私钥签名 # ukey中的私钥不可以导出，所以要注册私钥签名函数到openssl中 1/* Prepare the ENGINE structure for registration */ 2static int skf_bind_helper(ENGINE* e) { 3 LOG_DEBUG(Tag, \u0026#34;skf_bind_helper\u0026#34;); 4 5 // set skf rsa engine method, use default method and diy some function 6 if ((skf_rsa_method = RSA_meth_dup(RSA_get_default_method())) == NULL || 7 // 提供私钥加密函数 8 RSA_meth_set_priv_enc(skf_rsa_method, skf_rsa_priv_enc) == 0) { 9 return 0; 10 } 11 ... 12 return 1; 13} 这里实现一个从文件读出私钥然后调用默认的openssl的rsa私钥签名函数 1int skf_rsa_priv_enc(int flen, const unsigned char* from, unsigned char* to, RSA* rsa, int padding) { 2 LOG_DEBUG(\u0026#34;skf_rsa_priv_enc from len %d, padding %d\u0026#34;, flen, padding); 3 4 // 读取PEM格式私钥文件 5 FILE* fp = fopen(\u0026#34;/home/wangyubo/work/src/local/openssl/20230418/ssl_diy/domain.key\u0026#34;, \u0026#34;r\u0026#34;); 6 auto evkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL); 7 fclose(fp); 8 if (evkey == NULL) { 9 LOG_ERROR(\u0026#34;d2i_PrivateKey_fp failed\u0026#34;); 10 return 0; 11 } 12 13 auto newRsa = EVP_PKEY_get0_RSA(evkey); 14 int ret = RSA_meth_get_priv_enc(RSA_get_default_method())(flen, from, to, newRsa, padding); 15 16 LOG_DEBUG(\u0026#34;rsaDoSign ret %d\u0026#34;, ret); 17 return ret; 18} 三、握手过程的调用栈 # 1. Certificate中证书信息的获取 # 1.1. 在收到服务端下发的Certificate Request的时候，就先加载证书到ssl的上下文中 # 1WORK_STATE tls_prepare_client_certificate(SSL *s, WORK_STATE wst) 2{ 3 X509 *x509 = NULL; 4 EVP_PKEY *pkey = NULL; 5 int i; 6 7 if (wst == WORK_MORE_A) { 8 // 这里一般是证书已经通过命令行设置好了才进来的 9 /* Let cert callback update client certificates if required */ 10 if (s-\u0026gt;cert-\u0026gt;cert_cb) { 11 i = s-\u0026gt;cert-\u0026gt;cert_cb(s, s-\u0026gt;cert-\u0026gt;cert_cb_arg); 12 if (i \u0026lt; 0) { 13 s-\u0026gt;rwstate = SSL_X509_LOOKUP; 14 return WORK_MORE_A; 15 } 16 if (i == 0) { 17 SSLfatal(s, SSL_AD_INTERNAL_ERROR, SSL_R_CALLBACK_FAILED); 18 return WORK_ERROR; 19 } 20 s-\u0026gt;rwstate = SSL_NOTHING; 21 } 22 if (ssl3_check_client_certificate(s)) { 23 if (s-\u0026gt;post_handshake_auth == SSL_PHA_REQUESTED) { 24 return WORK_FINISHED_STOP; 25 } 26 return WORK_FINISHED_CONTINUE; 27 } 28 29 /* Fall through to WORK_MORE_B */ 30 wst = WORK_MORE_B; 31 } 32 33 /* We need to get a client cert */ 34 if (wst == WORK_MORE_B) { 35 // 通过引擎设置证书会走到这个逻辑 36 /* 37 * If we get an error, we need to ssl-\u0026gt;rwstate=SSL_X509_LOOKUP; 38 * return(-1); We then get retied later 39 */ 40 // 这里调用到引擎的处理函数中 41 i = ssl_do_client_cert_cb(s, \u0026amp;x509, \u0026amp;pkey); 42 if (i \u0026lt; 0) { 43 s-\u0026gt;rwstate = SSL_X509_LOOKUP; 44 return WORK_MORE_B; 45 } 46 s-\u0026gt;rwstate = SSL_NOTHING; 47 if ((i == 1) \u0026amp;\u0026amp; (pkey != NULL) \u0026amp;\u0026amp; (x509 != NULL)) { 48 // 证书设置到ssl结构体 49 // 验证pkey和x509是否匹配，pkey中只需要公钥匹配即可 50 if (!SSL_use_certificate(s, x509) || !SSL_use_PrivateKey(s, pkey)) 51 i = 0; 52 } else if (i == 1) { 53 i = 0; 54 ERR_raise(ERR_LIB_SSL, SSL_R_BAD_DATA_RETURNED_BY_CALLBACK); 55 } 56 57 X509_free(x509); 58 EVP_PKEY_free(pkey); 59 if (i \u0026amp;\u0026amp; !ssl3_check_client_certificate(s)) 60 i = 0; 61 if (i == 0) { 62 if (s-\u0026gt;version == SSL3_VERSION) { 63 s-\u0026gt;s3.tmp.cert_req = 0; 64 ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_CERTIFICATE); 65 return WORK_FINISHED_CONTINUE; 66 } else { 67 s-\u0026gt;s3.tmp.cert_req = 2; 68 if (!ssl3_digest_cached_records(s, 0)) { 69 /* SSLfatal() already called */ 70 return WORK_ERROR; 71 } 72 } 73 } 74 75 if (s-\u0026gt;post_handshake_auth == SSL_PHA_REQUESTED) 76 return WORK_FINISHED_STOP; 77 return WORK_FINISHED_CONTINUE; 78 } 79 80 /* Shouldn\u0026#39;t ever get here */ 81 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 82 return WORK_ERROR; 83} 1) 从引擎获取证书 # 1/* 2libssl.so.3!tls_engine_load_ssl_client_cert(SSL *s, X509 **px509, EVP_PKEY **ppkey) (ssl/tls_depr.c:69) 3libssl.so.3!ssl_do_client_cert_cb(SSL *s, X509 **px509, EVP_PKEY **ppkey) (ssl/statem/statem_clnt.c:3663) 4libssl.so.3!tls_prepare_client_certificate(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:3460) 5libssl.so.3!ossl_statem_client_post_process_message(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:1089) 6libssl.so.3!read_state_machine(SSL * s) (ssl/statem/statem.c:675) 7libssl.so.3!state_machine(SSL * s, int server) (ssl/statem/statem.c:442) 8libssl.so.3!ossl_statem_connect(SSL * s) (ssl/statem/statem.c:265) 9libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (ssl/record/rec_layer_s3.c:398) 10libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (ssl/s3_lib.c:4449) 11libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (ssl/ssl_lib.c:2062) 12libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (ssl/ssl_lib.c:2140) 13s_client_main(int argc, char ** argv) (apps/s_client.c:2841) 14do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (apps/openssl.c:418) 15main(int argc, char ** argv) (apps/openssl.c:298) 16 */ 17#ifndef OPENSSL_NO_ENGINE 18int tls_engine_load_ssl_client_cert(SSL *s, X509 **px509, EVP_PKEY **ppkey) 19{ 20 return ENGINE_load_ssl_client_cert(s-\u0026gt;ctx-\u0026gt;client_cert_engine, s, 21 SSL_get_client_CA_list(s), 22 px509, ppkey, NULL, NULL, NULL); 23} 24#endif 2) 随着证书到处的key中为什么只需要公钥即可 # pkey中为什么只需要公钥即可，看下面的调用栈，从SSL_use_PrivateKey进来 检查ppkey就是使用证书的公钥去匹配 本身证书中也只有公钥，想要看证书和ppkey是否匹配，就是看公钥的类型、算法、数值是否一致 1/* 2libcrypto.so.3!X509_check_private_key(const X509 * x, const EVP_PKEY * k) (crypto/x509/x509_cmp.c:403) 3libssl.so.3!ssl_set_pkey(CERT * c, EVP_PKEY * pkey) (ssl/ssl_rsa.c:128) 4libssl.so.3!SSL_use_PrivateKey(SSL * ssl, EVP_PKEY * pkey) (ssl/ssl_rsa.c:146) 5libssl.so.3!tls_prepare_client_certificate(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:3467) 6libssl.so.3!ossl_statem_client_post_process_message(SSL * s, WORK_STATE wst) (ssl/statem/statem_clnt.c:1089) 7libssl.so.3!read_state_machine(SSL * s) (ssl/statem/statem.c:675) 8libssl.so.3!state_machine(SSL * s, int server) (ssl/statem/statem.c:442) 9libssl.so.3!ossl_statem_connect(SSL * s) (ssl/statem/statem.c:265) 10libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (ssl/record/rec_layer_s3.c:398) 11libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (ssl/s3_lib.c:4449) 12libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (ssl/ssl_lib.c:2062) 13libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (ssl/ssl_lib.c:2140) 14s_client_main(int argc, char ** argv) (apps/s_client.c:2841) 15do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (apps/openssl.c:418) 16main(int argc, char ** argv) (apps/openssl.c:298) 17 */ 18int X509_check_private_key(const X509 *x, const EVP_PKEY *k) 19{ 20 const EVP_PKEY *xk; 21 int ret; 22 23 xk = X509_get0_pubkey(x); 24 if (xk == NULL) { 25 ERR_raise(ERR_LIB_X509, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY); 26 return 0; 27 } 28 29 switch (ret = EVP_PKEY_eq(xk, k)) { 30 case 0: 31 ERR_raise(ERR_LIB_X509, X509_R_KEY_VALUES_MISMATCH); 32 break; 33 case -1: 34 ERR_raise(ERR_LIB_X509, X509_R_KEY_TYPE_MISMATCH); 35 break; 36 case -2: 37 ERR_raise(ERR_LIB_X509, X509_R_UNKNOWN_KEY_TYPE); 38 break; 39 } 40 41 return ret \u0026gt; 0; 42} 1.2. 构造Certificate请求时，把证书信息放到包里面 # 1/* 2libssl.so.3!tls_construct_client_certificate(SSL * s, WPACKET * pkt) (ssl/statem/statem_clnt.c:3504) 3libssl.so.3!write_state_machine(SSL * s) (ssl/statem/statem.c:855) 4libssl.so.3!state_machine(SSL * s, int server) (ssl/statem/statem.c:451) 5libssl.so.3!ossl_statem_connect(SSL * s) (ssl/statem/statem.c:265) 6libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (ssl/record/rec_layer_s3.c:398) 7libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (ssl/s3_lib.c:4449) 8libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (ssl/ssl_lib.c:2062) 9libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (ssl/ssl_lib.c:2140) 10s_client_main(int argc, char ** argv) (apps/s_client.c:2841) 11do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (apps/openssl.c:418) 12main(int argc, char ** argv) (apps/openssl.c:298) 13 */ 14int tls_construct_client_certificate(SSL *s, WPACKET *pkt) 15{ 16 if (SSL_IS_TLS13(s)) { 17 if (s-\u0026gt;pha_context == NULL) { 18 /* no context available, add 0-length context */ 19 if (!WPACKET_put_bytes_u8(pkt, 0)) { 20 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 21 return 0; 22 } 23 } else if (!WPACKET_sub_memcpy_u8(pkt, s-\u0026gt;pha_context, s-\u0026gt;pha_context_len)) { 24 SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR); 25 return 0; 26 } 27 } 28 if (!ssl3_output_cert_chain(s, pkt, 29 (s-\u0026gt;s3.tmp.cert_req == 2) ? NULL 30 : s-\u0026gt;cert-\u0026gt;key)) { 31 /* SSLfatal() already called */ 32 return 0; 33 } 34 35 if (SSL_IS_TLS13(s) 36 \u0026amp;\u0026amp; SSL_IS_FIRST_HANDSHAKE(s) 37 \u0026amp;\u0026amp; (!s-\u0026gt;method-\u0026gt;ssl3_enc-\u0026gt;change_cipher_state(s, 38 SSL3_CC_HANDSHAKE | SSL3_CHANGE_CIPHER_CLIENT_WRITE))) { 39 /* 40 * This is a fatal error, which leaves enc_write_ctx in an inconsistent 41 * state and thus ssl3_send_alert may crash. 42 */ 43 SSLfatal(s, SSL_AD_NO_ALERT, SSL_R_CANNOT_CHANGE_CIPHER); 44 return 0; 45 } 46 47 return 1; 48} 2. certificate verify中的签名信息的生成 # 签名信息是将一段信息使用rsa私钥签名后的结果，先算hash后签名 这里的rsa_sign进来的数据已经做了hash，只需要进行签名即可 1/* 2libcrypto.so.3!rsa_sign(void * vprsactx, unsigned char * sig, size_t * siglen, size_t sigsize, const unsigned char * tbs, size_t tbslen) (providers/implementations/signature/rsa_sig.c:647) 3libcrypto.so.3!rsa_digest_sign_final(void * vprsactx, unsigned char * sig, size_t * siglen, size_t sigsize) (providers/implementations/signature/rsa_sig.c:942) 4libcrypto.so.3!EVP_DigestSignFinal(EVP_MD_CTX * ctx, unsigned char * sigret, size_t * siglen) (crypto/evp/m_sigver.c:481) 5libcrypto.so.3!EVP_DigestSign(EVP_MD_CTX * ctx, unsigned char * sigret, size_t * siglen, const unsigned char * tbs, size_t tbslen) (crypto/evp/m_sigver.c:582) 6libssl.so.3!tls_construct_cert_verify(SSL * s, WPACKET * pkt) (ssl/statem/statem_lib.c:354) 7libssl.so.3!write_state_machine(SSL * s) (ssl/statem/statem.c:855) 8libssl.so.3!state_machine(SSL * s, int server) (ssl/statem/statem.c:451) 9libssl.so.3!ossl_statem_connect(SSL * s) (ssl/statem/statem.c:265) 10libssl.so.3!ssl3_write_bytes(SSL * s, int type, const void * buf_, size_t len, size_t * written) (ssl/record/rec_layer_s3.c:398) 11libssl.so.3!ssl3_write(SSL * s, const void * buf, size_t len, size_t * written) (ssl/s3_lib.c:4449) 12libssl.so.3!ssl_write_internal(SSL * s, const void * buf, size_t num, size_t * written) (ssl/ssl_lib.c:2062) 13libssl.so.3!SSL_write(SSL * s, const void * buf, int num) (ssl/ssl_lib.c:2140) 14s_client_main(int argc, char ** argv) (apps/s_client.c:2841) 15do_cmd(struct lhash_st_FUNCTION * prog, int argc, char ** argv) (apps/openssl.c:418) 16main(int argc, char ** argv) (apps/openssl.c:298) 17 */ 18static int rsa_sign(void *vprsactx, unsigned char *sig, size_t *siglen, 19 size_t sigsize, const unsigned char *tbs, size_t tbslen) 20{ 21 PROV_RSA_CTX *prsactx = (PROV_RSA_CTX *)vprsactx; 22 int ret; 23 size_t rsasize = RSA_size(prsactx-\u0026gt;rsa); 24 size_t mdsize = rsa_get_md_size(prsactx); 25 26 if (!ossl_prov_is_running()) 27 return 0; 28 29 if (sig == NULL) { 30 *siglen = rsasize; 31 return 1; 32 } 33 34 if (sigsize \u0026lt; rsasize) { 35 ERR_raise_data(ERR_LIB_PROV, PROV_R_INVALID_SIGNATURE_SIZE, 36 \u0026#34;is %zu, should be at least %zu\u0026#34;, sigsize, rsasize); 37 return 0; 38 } 39 40 if (mdsize != 0) { 41 if (tbslen != mdsize) { 42 ERR_raise(ERR_LIB_PROV, PROV_R_INVALID_DIGEST_LENGTH); 43 return 0; 44 } 45 46#ifndef FIPS_MODULE 47 if (EVP_MD_is_a(prsactx-\u0026gt;md, OSSL_DIGEST_NAME_MDC2)) { 48 unsigned int sltmp; 49 50 if (prsactx-\u0026gt;pad_mode != RSA_PKCS1_PADDING) { 51 ERR_raise_data(ERR_LIB_PROV, PROV_R_INVALID_PADDING_MODE, 52 \u0026#34;only PKCS#1 padding supported with MDC2\u0026#34;); 53 return 0; 54 } 55 ret = RSA_sign_ASN1_OCTET_STRING(0, tbs, tbslen, sig, \u0026amp;sltmp, 56 prsactx-\u0026gt;rsa); 57 58 if (ret \u0026lt;= 0) { 59 ERR_raise(ERR_LIB_PROV, ERR_R_RSA_LIB); 60 return 0; 61 } 62 ret = sltmp; 63 goto end; 64 } 65#endif 66 67 // 根据不同的padding算法进行不同的计算 68 switch (prsactx-\u0026gt;pad_mode) { 69 case RSA_X931_PADDING: 70 if ((size_t)RSA_size(prsactx-\u0026gt;rsa) \u0026lt; tbslen + 1) { 71 ERR_raise_data(ERR_LIB_PROV, PROV_R_KEY_SIZE_TOO_SMALL, 72 \u0026#34;RSA key size = %d, expected minimum = %d\u0026#34;, 73 RSA_size(prsactx-\u0026gt;rsa), tbslen + 1); 74 return 0; 75 } 76 if (!setup_tbuf(prsactx)) { 77 ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE); 78 return 0; 79 } 80 memcpy(prsactx-\u0026gt;tbuf, tbs, tbslen); 81 prsactx-\u0026gt;tbuf[tbslen] = RSA_X931_hash_id(prsactx-\u0026gt;mdnid); 82 ret = RSA_private_encrypt(tbslen + 1, prsactx-\u0026gt;tbuf, 83 sig, prsactx-\u0026gt;rsa, RSA_X931_PADDING); 84 clean_tbuf(prsactx); 85 break; 86 87 case RSA_PKCS1_PADDING: 88 { 89 unsigned int sltmp; 90 91 ret = RSA_sign(prsactx-\u0026gt;mdnid, tbs, tbslen, sig, \u0026amp;sltmp, 92 prsactx-\u0026gt;rsa); 93 if (ret \u0026lt;= 0) { 94 ERR_raise(ERR_LIB_PROV, ERR_R_RSA_LIB); 95 return 0; 96 } 97 ret = sltmp; 98 } 99 break; 100 101 case RSA_PKCS1_PSS_PADDING: 102 /* Check PSS restrictions */ 103 if (rsa_pss_restricted(prsactx)) { 104 switch (prsactx-\u0026gt;saltlen) { 105 case RSA_PSS_SALTLEN_DIGEST: 106 if (prsactx-\u0026gt;min_saltlen \u0026gt; EVP_MD_get_size(prsactx-\u0026gt;md)) { 107 ERR_raise_data(ERR_LIB_PROV, 108 PROV_R_PSS_SALTLEN_TOO_SMALL, 109 \u0026#34;minimum salt length set to %d, \u0026#34; 110 \u0026#34;but the digest only gives %d\u0026#34;, 111 prsactx-\u0026gt;min_saltlen, 112 EVP_MD_get_size(prsactx-\u0026gt;md)); 113 return 0; 114 } 115 /* FALLTHRU */ 116 default: 117 if (prsactx-\u0026gt;saltlen \u0026gt;= 0 118 \u0026amp;\u0026amp; prsactx-\u0026gt;saltlen \u0026lt; prsactx-\u0026gt;min_saltlen) { 119 ERR_raise_data(ERR_LIB_PROV, 120 PROV_R_PSS_SALTLEN_TOO_SMALL, 121 \u0026#34;minimum salt length set to %d, but the\u0026#34; 122 \u0026#34;actual salt length is only set to %d\u0026#34;, 123 prsactx-\u0026gt;min_saltlen, 124 prsactx-\u0026gt;saltlen); 125 return 0; 126 } 127 break; 128 } 129 } 130 if (!setup_tbuf(prsactx)) 131 return 0; 132 if (!RSA_padding_add_PKCS1_PSS_mgf1(prsactx-\u0026gt;rsa, 133 prsactx-\u0026gt;tbuf, tbs, 134 prsactx-\u0026gt;md, prsactx-\u0026gt;mgf1_md, 135 prsactx-\u0026gt;saltlen)) { 136 ERR_raise(ERR_LIB_PROV, ERR_R_RSA_LIB); 137 return 0; 138 } 139 // 一般tls1.2的rsa证书双向认证会调用到这个私钥签名函数 140 ret = RSA_private_encrypt(RSA_size(prsactx-\u0026gt;rsa), prsactx-\u0026gt;tbuf, 141 sig, prsactx-\u0026gt;rsa, RSA_NO_PADDING); 142 clean_tbuf(prsactx); 143 break; 144 145 default: 146 ERR_raise_data(ERR_LIB_PROV, PROV_R_INVALID_PADDING_MODE, 147 \u0026#34;Only X.931, PKCS#1 v1.5 or PSS padding allowed\u0026#34;); 148 return 0; 149 } 150 } else { 151 ret = RSA_private_encrypt(tbslen, tbs, sig, prsactx-\u0026gt;rsa, 152 prsactx-\u0026gt;pad_mode); 153 } 154 155#ifndef FIPS_MODULE 156 end: 157#endif 158 if (ret \u0026lt;= 0) { 159 ERR_raise(ERR_LIB_PROV, ERR_R_RSA_LIB); 160 return 0; 161 } 162 163 *siglen = ret; 164 return 1; 165} 私钥签名函数会调用到引擎里面的rsa_priv_enc函数，也就是上面注册的函数 1int RSA_private_encrypt(int flen, const unsigned char *from, 2 unsigned char *to, RSA *rsa, int padding) 3{ 4 return rsa-\u0026gt;meth-\u0026gt;rsa_priv_enc(flen, from, to, rsa, padding); 5} "},{"id":211,"href":"/docs/linux/linux-kernel/net/sk_buff/","title":"sk_buff 内核中数据包结构体","section":"/net/ 网络部分","content":" 一、结构体定义 # 1// include/linux/skbuff.h 2/** 3 * DOC: Basic sk_buff geometry 4 * 5 * struct sk_buff itself is a metadata structure and does not hold any packet 6 * data. All the data is held in associated buffers. 7 * 8 * \u0026amp;sk_buff.head points to the main \u0026#34;head\u0026#34; buffer. The head buffer is divided 9 * into two parts: 10 * 11 * - data buffer, containing headers and sometimes payload; 12 * this is the part of the skb operated on by the common helpers 13 * such as skb_put() or skb_pull(); 14 * - shared info (struct skb_shared_info) which holds an array of pointers 15 * to read-only data in the (page, offset, length) format. 16 * 17 * Optionally \u0026amp;skb_shared_info.frag_list may point to another skb. 18 * 19 * Basic diagram may look like this:: 20 * 21 * --------------- 22 * | sk_buff | 23 * --------------- 24 * ,--------------------------- + head 25 * / ,----------------- + data 26 * / / ,----------- + tail 27 * | | | , + end 28 * | | | | 29 * v v v v 30 * ----------------------------------------------- 31 * | headroom | data | tailroom | skb_shared_info | 32 * ----------------------------------------------- 33 * + [page frag] 34 * + [page frag] 35 * + [page frag] 36 * + [page frag] --------- 37 * + frag_list --\u0026gt; | sk_buff | 38 * --------- 39 * 40 */ 41 42/** 43 *\tstruct sk_buff - socket buffer 44 *\t@next: Next buffer in list 45 *\t@prev: Previous buffer in list 46 *\t@tstamp: Time we arrived/left 47 *\t@skb_mstamp_ns: (aka @tstamp) earliest departure time; start point 48 *\tfor retransmit timer 49 *\t@rbnode: RB tree node, alternative to next/prev for netem/tcp 50 *\t@list: queue head 51 *\t@ll_node: anchor in an llist (eg socket defer_list) 52 *\t@sk: Socket we are owned by 53 *\t@ip_defrag_offset: (aka @sk) alternate use of @sk, used in 54 *\tfragmentation management 55 *\t@dev: Device we arrived on/are leaving by 56 *\t@dev_scratch: (aka @dev) alternate use of @dev when @dev would be %NULL 57 *\t@cb: Control buffer. Free for use by every layer. Put private vars here 58 *\t@_skb_refdst: destination entry (with norefcount bit) 59 *\t@sp: the security path, used for xfrm 60 *\t@len: Length of actual data 61 *\t@data_len: Data length 62 *\t@mac_len: Length of link layer header 63 *\t@hdr_len: writable header length of cloned skb 64 *\t@csum: Checksum (must include start/offset pair) 65 *\t@csum_start: Offset from skb-\u0026gt;head where checksumming should start 66 *\t@csum_offset: Offset from csum_start where checksum should be stored 67 *\t@priority: Packet queueing priority 68 *\t@ignore_df: allow local fragmentation 69 *\t@cloned: Head may be cloned (check refcnt to be sure) 70 *\t@ip_summed: Driver fed us an IP checksum 71 *\t@nohdr: Payload reference only, must not modify header 72 *\t@pkt_type: Packet class 73 *\t@fclone: skbuff clone status 74 *\t@ipvs_property: skbuff is owned by ipvs 75 *\t@inner_protocol_type: whether the inner protocol is 76 *\tENCAP_TYPE_ETHER or ENCAP_TYPE_IPPROTO 77 *\t@remcsum_offload: remote checksum offload is enabled 78 *\t@offload_fwd_mark: Packet was L2-forwarded in hardware 79 *\t@offload_l3_fwd_mark: Packet was L3-forwarded in hardware 80 *\t@tc_skip_classify: do not classify packet. set by IFB device 81 *\t@tc_at_ingress: used within tc_classify to distinguish in/egress 82 *\t@redirected: packet was redirected by packet classifier 83 *\t@from_ingress: packet was redirected from the ingress path 84 *\t@nf_skip_egress: packet shall skip nf egress - see netfilter_netdev.h 85 *\t@peeked: this packet has been seen already, so stats have been 86 *\tdone for it, don\u0026#39;t do them again 87 *\t@nf_trace: netfilter packet trace flag 88 *\t@protocol: Packet protocol from driver 89 *\t@destructor: Destruct function 90 *\t@tcp_tsorted_anchor: list structure for TCP (tp-\u0026gt;tsorted_sent_queue) 91 *\t@_sk_redir: socket redirection information for skmsg 92 *\t@_nfct: Associated connection, if any (with nfctinfo bits) 93 *\t@nf_bridge: Saved data about a bridged frame - see br_netfilter.c 94 *\t@skb_iif: ifindex of device we arrived on 95 *\t@tc_index: Traffic control index 96 *\t@hash: the packet hash 97 *\t@queue_mapping: Queue mapping for multiqueue devices 98 *\t@head_frag: skb was allocated from page fragments, 99 *\tnot allocated by kmalloc() or vmalloc(). 100 *\t@pfmemalloc: skbuff was allocated from PFMEMALLOC reserves 101 *\t@pp_recycle: mark the packet for recycling instead of freeing (implies 102 *\tpage_pool support on driver) 103 *\t@active_extensions: active extensions (skb_ext_id types) 104 *\t@ndisc_nodetype: router type (from link layer) 105 *\t@ooo_okay: allow the mapping of a socket to a queue to be changed 106 *\t@l4_hash: indicate hash is a canonical 4-tuple hash over transport 107 *\tports. 108 *\t@sw_hash: indicates hash was computed in software stack 109 *\t@wifi_acked_valid: wifi_acked was set 110 *\t@wifi_acked: whether frame was acked on wifi or not 111 *\t@no_fcs: Request NIC to treat last 4 bytes as Ethernet FCS 112 *\t@encapsulation: indicates the inner headers in the skbuff are valid 113 *\t@encap_hdr_csum: software checksum is needed 114 *\t@csum_valid: checksum is already valid 115 *\t@csum_not_inet: use CRC32c to resolve CHECKSUM_PARTIAL 116 *\t@csum_complete_sw: checksum was completed by software 117 *\t@csum_level: indicates the number of consecutive checksums found in 118 *\tthe packet minus one that have been verified as 119 *\tCHECKSUM_UNNECESSARY (max 3) 120 *\t@dst_pending_confirm: need to confirm neighbour 121 *\t@decrypted: Decrypted SKB 122 *\t@slow_gro: state present at GRO time, slower prepare step required 123 *\t@mono_delivery_time: When set, skb-\u0026gt;tstamp has the 124 *\tdelivery_time in mono clock base (i.e. EDT). Otherwise, the 125 *\tskb-\u0026gt;tstamp has the (rcv) timestamp at ingress and 126 *\tdelivery_time at egress. 127 *\t@napi_id: id of the NAPI struct this skb came from 128 *\t@sender_cpu: (aka @napi_id) source CPU in XPS 129 *\t@alloc_cpu: CPU which did the skb allocation. 130 *\t@secmark: security marking 131 *\t@mark: Generic packet mark 132 *\t@reserved_tailroom: (aka @mark) number of bytes of free space available 133 *\tat the tail of an sk_buff 134 *\t@vlan_present: VLAN tag is present 135 *\t@vlan_proto: vlan encapsulation protocol 136 *\t@vlan_tci: vlan tag control information 137 *\t@inner_protocol: Protocol (encapsulation) 138 *\t@inner_ipproto: (aka @inner_protocol) stores ipproto when 139 *\tskb-\u0026gt;inner_protocol_type == ENCAP_TYPE_IPPROTO; 140 *\t@inner_transport_header: Inner transport layer header (encapsulation) 141 *\t@inner_network_header: Network layer header (encapsulation) 142 *\t@inner_mac_header: Link layer header (encapsulation) 143 *\t@transport_header: Transport layer header 144 *\t@network_header: Network layer header 145 *\t@mac_header: Link layer header 146 *\t@kcov_handle: KCOV remote handle for remote coverage collection 147 *\t@tail: Tail pointer 148 *\t@end: End pointer 149 *\t@head: Head of buffer 150 *\t@data: Data head pointer 151 *\t@truesize: Buffer size 152 *\t@users: User count - see {datagram,tcp}.c 153 *\t@extensions: allocated extensions, valid if active_extensions is nonzero 154 */ 155 156struct sk_buff { 157\tunion { 158\tstruct { 159\t/* These two members must be first to match sk_buff_head. */ 160\tstruct sk_buff\t*next; 161\tstruct sk_buff\t*prev; 162 163\tunion { 164\tstruct net_device\t*dev; 165\t/* Some protocols might use this space to store information, 166\t* while device pointer would be NULL. 167\t* UDP receive path is one user. 168\t*/ 169\tunsigned long\tdev_scratch; 170\t}; 171\t}; 172\tstruct rb_node\trbnode; /* used in netem, ip4 defrag, and tcp stack */ 173\tstruct list_head\tlist; 174\tstruct llist_node\tll_node; 175\t}; 176 177\tunion { 178\tstruct sock\t*sk; 179\tint\tip_defrag_offset; 180\t}; 181 182\tunion { 183\tktime_t\ttstamp; 184\tu64\tskb_mstamp_ns; /* earliest departure time */ 185\t}; 186\t/* 187\t* This is the control buffer. It is free to use for every 188\t* layer. Please put your private variables there. If you 189\t* want to keep them across layers you have to do a skb_clone() 190\t* first. This is owned by whoever has the skb queued ATM. 191\t*/ 192\tchar\tcb[48] __aligned(8); 193 194\tunion { 195\tstruct { 196\tunsigned long\t_skb_refdst; 197\tvoid\t(*destructor)(struct sk_buff *skb); 198\t}; 199\tstruct list_head\ttcp_tsorted_anchor; 200#ifdef CONFIG_NET_SOCK_MSG 201\tunsigned long\t_sk_redir; 202#endif 203\t}; 204 205#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE) 206\tunsigned long\t_nfct; 207#endif 208\tunsigned int\tlen, 209\tdata_len; 210\t__u16\tmac_len, 211\thdr_len; 212 213\t/* Following fields are _not_ copied in __copy_skb_header() 214\t* Note that queue_mapping is here mostly to fill a hole. 215\t*/ 216\t__u16\tqueue_mapping; 217 218/* if you move cloned around you also must adapt those constants */ 219#ifdef __BIG_ENDIAN_BITFIELD 220#define CLONED_MASK\t(1 \u0026lt;\u0026lt; 7) 221#else 222#define CLONED_MASK\t1 223#endif 224#define CLONED_OFFSET\toffsetof(struct sk_buff, __cloned_offset) 225 226\t/* private: */ 227\t__u8\t__cloned_offset[0]; 228\t/* public: */ 229\t__u8\tcloned:1, 230\tnohdr:1, 231\tfclone:2, 232\tpeeked:1, 233\thead_frag:1, 234\tpfmemalloc:1, 235\tpp_recycle:1; /* page_pool recycle indicator */ 236#ifdef CONFIG_SKB_EXTENSIONS 237\t__u8\tactive_extensions; 238#endif 239 240\t/* Fields enclosed in headers group are copied 241\t* using a single memcpy() in __copy_skb_header() 242\t*/ 243\tstruct_group(headers, 244 245\t/* private: */ 246\t__u8\t__pkt_type_offset[0]; 247\t/* public: */ 248\t__u8\tpkt_type:3; /* see PKT_TYPE_MAX */ 249\t__u8\tignore_df:1; 250\t__u8\tnf_trace:1; 251\t__u8\tip_summed:2; 252\t__u8\tooo_okay:1; 253 254\t__u8\tl4_hash:1; 255\t__u8\tsw_hash:1; 256\t__u8\twifi_acked_valid:1; 257\t__u8\twifi_acked:1; 258\t__u8\tno_fcs:1; 259\t/* Indicates the inner headers are valid in the skbuff. */ 260\t__u8\tencapsulation:1; 261\t__u8\tencap_hdr_csum:1; 262\t__u8\tcsum_valid:1; 263 264\t/* private: */ 265\t__u8\t__pkt_vlan_present_offset[0]; 266\t/* public: */ 267\t__u8\tvlan_present:1;\t/* See PKT_VLAN_PRESENT_BIT */ 268\t__u8\tcsum_complete_sw:1; 269\t__u8\tcsum_level:2; 270\t__u8\tdst_pending_confirm:1; 271\t__u8\tmono_delivery_time:1;\t/* See SKB_MONO_DELIVERY_TIME_MASK */ 272#ifdef CONFIG_NET_CLS_ACT 273\t__u8\ttc_skip_classify:1; 274\t__u8\ttc_at_ingress:1;\t/* See TC_AT_INGRESS_MASK */ 275#endif 276#ifdef CONFIG_IPV6_NDISC_NODETYPE 277\t__u8\tndisc_nodetype:2; 278#endif 279 280\t__u8\tipvs_property:1; 281\t__u8\tinner_protocol_type:1; 282\t__u8\tremcsum_offload:1; 283#ifdef CONFIG_NET_SWITCHDEV 284\t__u8\toffload_fwd_mark:1; 285\t__u8\toffload_l3_fwd_mark:1; 286#endif 287\t__u8\tredirected:1; 288#ifdef CONFIG_NET_REDIRECT 289\t__u8\tfrom_ingress:1; 290#endif 291#ifdef CONFIG_NETFILTER_SKIP_EGRESS 292\t__u8\tnf_skip_egress:1; 293#endif 294#ifdef CONFIG_TLS_DEVICE 295\t__u8\tdecrypted:1; 296#endif 297\t__u8\tslow_gro:1; 298\t__u8\tcsum_not_inet:1; 299 300#ifdef CONFIG_NET_SCHED 301\t__u16\ttc_index;\t/* traffic control index */ 302#endif 303 304\tunion { 305\t__wsum\tcsum; 306\tstruct { 307\t__u16\tcsum_start; 308\t__u16\tcsum_offset; 309\t}; 310\t}; 311\t__u32\tpriority; 312\tint\tskb_iif; 313\t__u32\thash; 314\t__be16\tvlan_proto; 315\t__u16\tvlan_tci; 316#if defined(CONFIG_NET_RX_BUSY_POLL) || defined(CONFIG_XPS) 317\tunion { 318\tunsigned int\tnapi_id; 319\tunsigned int\tsender_cpu; 320\t}; 321#endif 322\tu16\talloc_cpu; 323#ifdef CONFIG_NETWORK_SECMARK 324\t__u32\tsecmark; 325#endif 326 327\tunion { 328\t__u32\tmark; 329\t__u32\treserved_tailroom; 330\t}; 331 332\tunion { 333\t__be16\tinner_protocol; 334\t__u8\tinner_ipproto; 335\t}; 336 337\t__u16\tinner_transport_header; 338\t__u16\tinner_network_header; 339\t__u16\tinner_mac_header; 340 341\t__be16\tprotocol; 342\t__u16\ttransport_header; 343\t__u16\tnetwork_header; 344\t__u16\tmac_header; 345 346#ifdef CONFIG_KCOV 347\tu64\tkcov_handle; 348#endif 349 350\t); /* end headers group */ 351 352\t/* These elements must be at the end, see alloc_skb() for details. */ 353\tsk_buff_data_t\ttail; 354\tsk_buff_data_t\tend; 355\tunsigned char\t*head, 356\t*data; 357\tunsigned int\ttruesize; 358\trefcount_t\tusers; 359 360#ifdef CONFIG_SKB_EXTENSIONS 361\t/* only useable after checking -\u0026gt;active_extensions != 0 */ 362\tstruct skb_ext\t*extensions; 363#endif 364}; 1. 几个数据的含义和计算 # 字段 类型 含义 len unsigned int 实际包长度 data unsigned char * 实际包起始地址 head unsigned char * 空间的起始地址，预分配空间的首地址 transport_header __u16 传输层头部到head地址偏移量 network_header __u16 网络层头部到head地址的偏移量 mac_header __u16 数据链路层头部到head地址的偏移量 protocol __be16 sk_buff的协议，Internet Protocol packet就是htons(ETH_P_IP)，宏定义在include/uapi/linux/if_ether.h 二、方法定义 # 1. 传输层 # 1static inline void skb_reset_transport_header(struct sk_buff *skb) 2{ 3\tskb-\u0026gt;transport_header = skb-\u0026gt;data - skb-\u0026gt;head; 4} 只能在传输层调用，会将data认为是传输层头 1static inline void skb_set_transport_header(struct sk_buff *skb, 2\tconst int offset) 3{ 4\tskb_reset_transport_header(skb); 5\tskb-\u0026gt;transport_header += offset; 6} 若是知道传输层到包的首地址head之间的offset，可以调用这个，如ip包就是传入ip头长度 2. 网络层 # 3. 数据包扩容 # skb_push是在数据包的前面新增一段空间，实现上就是data地址前移，不超过head就没有问题 一般每包装一层协议，就会进行一次push，如应用层到tcp层，push一个tcp头部长度，tcp层到ip层，push一个ip头长度 1// net/core/skbuff.c 2/** 3 *\tskb_push - add data to the start of a buffer 4 *\t@skb: buffer to use 5 *\t@len: amount of data to add 6 * 7 *\tThis function extends the used data area of the buffer at the buffer 8 *\tstart. If this would exceed the total buffer headroom the kernel will 9 *\tpanic. A pointer to the first byte of the extra data is returned. 10 */ 11void *skb_push(struct sk_buff *skb, unsigned int len) 12{ 13\tskb-\u0026gt;data -= len; 14\tskb-\u0026gt;len += len; 15\tif (unlikely(skb-\u0026gt;data \u0026lt; skb-\u0026gt;head)) 16\tskb_under_panic(skb, len, __builtin_return_address(0)); 17\treturn skb-\u0026gt;data; 18} 19EXPORT_SYMBOL(skb_push); "},{"id":212,"href":"/docs/c++/move/","title":"std::move","section":"C++源码分析记录","content":" 源码 # 1// /usr/include/c++/12.2.0/bits/move.h 2 /** 3 * @brief Convert a value to an rvalue. 4 * @param __t A thing of arbitrary type. 5 * @return The parameter cast to an rvalue-reference to allow moving it. 6 */ 7 template\u0026lt;typename _Tp\u0026gt; 8 _GLIBCXX_NODISCARD 9 constexpr typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp; 10 move(_Tp\u0026amp;\u0026amp; __t) noexcept 11 { return static_cast\u0026lt;typename std::remove_reference\u0026lt;_Tp\u0026gt;::type\u0026amp;\u0026amp;\u0026gt;(__t); } 可以看到std::move仅对类型做了一次转换，变成右值 在调用=时会匹配到移动赋值函数，所以对象内容会被转移（具体看对应的实现） 如果仅使用std::move(xxx)没有任何效果 "},{"id":213,"href":"/docs/c++/shared_ptr/","title":"std::shared_ptr","section":"C++源码分析记录","content":" 一、shared_ptr(_Yp* __p)分析 # 1. 初始化 # 1// /usr/include/c++/12.2.0/bits/shared_ptr.h 2 3 template\u0026lt;typename _Tp\u0026gt; 4 class shared_ptr : public __shared_ptr\u0026lt;_Tp\u0026gt; 5 { 6 ... 7 public: 8 ... 9 /** 10 * @brief Construct a %shared_ptr that owns the pointer @a __p. 11 * @param __p A pointer that is convertible to element_type*. 12 * @post use_count() == 1 \u0026amp;\u0026amp; get() == __p 13 * @throw std::bad_alloc, in which case @c delete @a __p is called. 14 */ 15 template\u0026lt;typename _Yp, typename = _Constructible\u0026lt;_Yp*\u0026gt;\u0026gt; 16\texplicit 17\tshared_ptr(_Yp* __p) : __shared_ptr\u0026lt;_Tp\u0026gt;(__p) { } 18 ... 19 } 1// /usr/include/c++/12.2.0/tr1/shared_ptr.h 2 3 // A smart pointer with reference-counted copy semantics. The 4 // object pointed to is deleted when the last shared_ptr pointing to 5 // it is destroyed or reset. 6 template\u0026lt;typename _Tp, _Lock_policy _Lp\u0026gt; 7 class __shared_ptr 8 { 9 public: 10 11 template\u0026lt;typename _Tp1\u0026gt; 12 explicit 13 __shared_ptr(_Tp1* __p) 14\t: _M_ptr(__p), _M_refcount(__p) 15 { 16\t__glibcxx_function_requires(_ConvertibleConcept\u0026lt;_Tp1*, _Tp*\u0026gt;) 17\ttypedef int _IsComplete[sizeof(_Tp1)]; 18\t__enable_shared_from_this_helper(_M_refcount, __p, __p); 19\t} 20 ... 21 _Tp* _M_ptr; // Contained pointer. 22 __shared_count\u0026lt;_Lp\u0026gt; _M_refcount; // Reference counter. 23 }; __shared_ptr创建时创建了__shared_count __shared_count创建时，new了一个_Sp_counted_ptr 1// /usr/include/c++/12.2.0/bits/shared_ptr_base.h 2 template\u0026lt;_Lock_policy _Lp\u0026gt; 3 class __shared_count 4 { 5 public: 6 ... 7 template\u0026lt;typename _Ptr\u0026gt; 8 explicit 9\t__shared_count(_Ptr __p) : _M_pi(0) 10\t{ 11\t__try 12\t{ 13\t_M_pi = new _Sp_counted_ptr\u0026lt;_Ptr, _Lp\u0026gt;(__p); 14\t} 15\t__catch(...) 16\t{ 17\tdelete __p; 18\t__throw_exception_again; 19\t} 20\t} 21 } 2. 析构 # 调用栈 1std::_Sp_counted_ptr\u0026lt;testS*, (__gnu_cxx::_Lock_policy)2\u0026gt;::_M_dispose(std::_Sp_counted_ptr\u0026lt;testS*, (__gnu_cxx::_Lock_policy)2\u0026gt; * const this) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:428) 2std::_Sp_counted_base\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt;::_M_release(std::_Sp_counted_base\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt; * const this) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:346) 3std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt;::~__shared_count(std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt; * const this) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:1071) 4std::__shared_ptr\u0026lt;testS, (__gnu_cxx::_Lock_policy)2\u0026gt;::~__shared_ptr(std::__shared_ptr\u0026lt;testS, (__gnu_cxx::_Lock_policy)2\u0026gt; * const this) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:1524) 5std::shared_ptr\u0026lt;testS\u0026gt;::~shared_ptr(std::shared_ptr\u0026lt;testS\u0026gt; * const this) (/usr/include/c++/12.2.0/bits/shared_ptr.h:175) 由于__shared_count是__shared_ptr的成员变量，所以在释放__shared_ptr的时候就会进行释放 1// /usr/include/c++/12.2.0/tr1/shared_ptr.h 2 3 template\u0026lt;_Lock_policy _Lp = __default_lock_policy\u0026gt; 4 class __shared_count 5 { 6 public: 7 ... 8 ~__shared_count() // nothrow 9 { 10\tif (_M_pi != 0) 11\t_M_pi-\u0026gt;_M_release(); 12 } 13 ... 14 private: 15 ... 16 _Sp_counted_base\u0026lt;_Lp\u0026gt;* _M_pi; 17 }; _M_release 1// /usr/include/c++/12.2.0/bits/shared_ptr_base.h 2 template\u0026lt;\u0026gt; 3 inline void 4 _Sp_counted_base\u0026lt;_S_atomic\u0026gt;::_M_release() noexcept 5 { 6 ... 7\tif (__atomic_load_n(__both_counts, __ATOMIC_ACQUIRE) == __unique_ref) 8\t{ 9\t// Both counts are 1, so there are no weak references and 10\t// we are releasing the last strong reference. No other 11\t// threads can observe the effects of this _M_release() 12\t// call (e.g. calling use_count()) without a data race. 13\t_M_weak_count = _M_use_count = 0; 14\t_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(\u0026amp;_M_use_count); 15\t_GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(\u0026amp;_M_weak_count); 16\t_M_dispose(); 17\t_M_destroy(); 18\treturn; 19\t} 20 ... 21 } 22 ... 23} _M_dispose，_Sp_counted_ptr继承了_Sp_counted_base，上面的_M_pi实际上是使用了_Sp_counted_ptr的方法 直接调用delete 1// /usr/include/c++/12.2.0/tr1/shared_ptr.h 2 // Counted ptr with no deleter or allocator support 3 template\u0026lt;typename _Ptr, _Lock_policy _Lp\u0026gt; 4 class _Sp_counted_ptr final : public _Sp_counted_base\u0026lt;_Lp\u0026gt; 5 { 6 public: 7 ... 8 virtual void 9 _M_dispose() noexcept 10 { delete _M_ptr; } 11 } 3. 使用构造函数的注意事项 # 3.1. 不能使用栈变量进行初始化 # 由于最终会调用delete，使用栈变量不能delete，会崩溃 1void func() { 2 testS a; 3 auto test = std::shared_ptr\u0026lt;testS\u0026gt;(\u0026amp;a); // 这样定义会崩溃 4} 3.2. 不能对同一个指针进行多次初始化 # shared_ptr从源码上看只是托管了堆上的指针的生命周期，并不会进行拷贝，如果使用多个shared_ptr托管，会导致析构的时候多次delete 1void func() { 2 auto a = new testS(); 3 auto test = std::shared_ptr\u0026lt;testS\u0026gt;(a); 4 auto test1 = std::shared_ptr\u0026lt;testS\u0026gt;(a); // 这里会造成重复delete 5} 二、shared_ptr(_Yp* __p, _Deleter __d) # 1. 初始化 # 调用栈 1std::_Sp_ebo_helper\u0026lt;0, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, true\u0026gt;::_Sp_ebo_helper(struct {...} \u0026amp;\u0026amp;)(std::_Sp_ebo_helper\u0026lt;0, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, true\u0026gt; * const this, struct {...} \u0026amp;\u0026amp; __tp) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:471) 2std::_Sp_counted_deleter\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, std::allocator\u0026lt;void\u0026gt;, (__gnu_cxx::_Lock_policy)2\u0026gt;::_Impl::_Impl(testS *, struct {...}, const std::allocator\u0026lt;void\u0026gt; \u0026amp;)(std::_Sp_counted_deleter\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, std::allocator\u0026lt;void\u0026gt;, (__gnu_cxx::_Lock_policy)2\u0026gt;::_Impl * const this, testS * __p, struct {...} __d, const std::allocator\u0026lt;void\u0026gt; \u0026amp; __a) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:503) 3std::_Sp_counted_deleter\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, std::allocator\u0026lt;void\u0026gt;, (__gnu_cxx::_Lock_policy)2\u0026gt;::_Sp_counted_deleter(testS *, struct {...}, const std::allocator\u0026lt;void\u0026gt; \u0026amp;)(std::_Sp_counted_deleter\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, std::allocator\u0026lt;void\u0026gt;, (__gnu_cxx::_Lock_policy)2\u0026gt; * const this, testS * __p, struct {...} __d, const std::allocator\u0026lt;void\u0026gt; \u0026amp; __a) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:521) 4std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt;::__shared_count\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt;, std::allocator\u0026lt;void\u0026gt; \u0026gt;(testS *, struct {...}, std::allocator\u0026lt;void\u0026gt;)(std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt; * const this, testS * __p, struct {...} __d, std::allocator\u0026lt;void\u0026gt; __a) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:952) 5std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt;::__shared_count\u0026lt;testS*, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt; \u0026gt;(testS *, struct {...})(std::__shared_count\u0026lt;(__gnu_cxx::_Lock_policy)2\u0026gt; * const this, testS * __p, struct {...} __d) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:939) 6std::__shared_ptr\u0026lt;testS, (__gnu_cxx::_Lock_policy)2\u0026gt;::__shared_ptr\u0026lt;testS, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt; \u0026gt;(testS *, struct {...})(std::__shared_ptr\u0026lt;testS, (__gnu_cxx::_Lock_policy)2\u0026gt; * const this, testS * __p, struct {...} __d) (/usr/include/c++/12.2.0/bits/shared_ptr_base.h:1478) 7std::shared_ptr\u0026lt;testS\u0026gt;::shared_ptr\u0026lt;testS, main(int, char**)::\u0026lt;lambda(testS*)\u0026gt; \u0026gt;(testS *, struct {...})(std::shared_ptr\u0026lt;testS\u0026gt; * const this, testS * __p, struct {...} __d) (/usr/include/c++/12.2.0/bits/shared_ptr.h:232) 首先是构造函数 1 /** 2 * @brief Construct a %shared_ptr that owns the pointer @a __p 3 * and the deleter @a __d. 4 * @param __p A pointer. 5 * @param __d A deleter. 6 * @post use_count() == 1 \u0026amp;\u0026amp; get() == __p 7 * @throw std::bad_alloc, in which case @a __d(__p) is called. 8 * 9 * Requirements: _Deleter\u0026#39;s copy constructor and destructor must 10 * not throw 11 * 12 * __shared_ptr will release __p by calling __d(__p) 13 */ 14 template\u0026lt;typename _Yp, typename _Deleter, 15\ttypename = _Constructible\u0026lt;_Yp*, _Deleter\u0026gt;\u0026gt; 16\tshared_ptr(_Yp* __p, _Deleter __d) 17 : __shared_ptr\u0026lt;_Tp\u0026gt;(__p, std::move(__d)) { } 注意事项 # 1. 自定义delete必须删除传入的指针 # 最终析构会调用传入的delete函数，不会进行其他操作，所以需要在函数内自己调用delete或其他释放，不能只处理其他的逻辑 不调用delete就会存在内存泄漏 1auto test = std::shared_ptr\u0026lt;testS\u0026gt;(new testS(), [](testS* x) { 2 // 处理其他逻辑 3 if (x-\u0026gt;temp) { 4 delete (uint64_t*)(x-\u0026gt;temp); 5 x-\u0026gt;temp = nullptr; 6 } 7 delete x; // 这一行必须 8}); "},{"id":214,"href":"/docs/linux/debug/systemtap/","title":"systemtap","section":"调试技术","content":"参考文档: https://sourceware.org/systemtap/tapsets/\n一、一些常用的写法 # 1# 查看可以追踪的列表 2=\u0026gt; stap -l \u0026#39;kernel.trace(\u0026#34;*\u0026#34;)\u0026#39; | grep kfree_skb 3kernel.trace(\u0026#34;skb:kfree_skb\u0026#34;) 4# 编译stap脚本并运行 5=\u0026gt; stap --all-modules test.stp 1. 开源的一些脚本 # https://github.com/zengxiaobai/systemtap-scripts.git\n二、语法 # 1. 内置变量 # $location: 当前所在的内存地址 $$parms: 字符串形式，当前函数参数和地址 2. 内置函数 # symname($location): 当前所在函数 symdata($location): 当前所在函数和偏移 pid(): 当前所在进程pid target(): 由-x指定的数据，一般是pid 三、实战 # 1) 查看包释放函数 # 每隔5s打印调用丢包函数的函数 1# 定义全局变量 2global locations 3 4# 设置开启和结束 5probe begin { printf(\u0026#34;Monitor begin\\n\u0026#34;) } 6probe end { printf(\u0026#34;Monitor end\\n\u0026#34;) } 7 8# 追踪kfree_skb函数 9probe kernel.trace(\u0026#34;kfree_skb\u0026#34;) { 10 # 将当前位置对应的变量+1 11 locations[$location] \u0026lt;\u0026lt;\u0026lt; 1 12} 13 14probe timer.sec(5) { 15 printf(\u0026#34;\\n\u0026#34;) 16 foreach (l in locations-) { 17 printf(\u0026#34;%d packets dropped at %s\\n\u0026#34;, 18 @count(locations[l]), symname(l) 19 ) 20 } 21 delete locations 22} 输出 Monitor begin 1 packets dropped at ip_rcv_finish 1.4. 环境搭建 # 1) CentOS # 需要安装下面的包 1yum install gcc systemtap-devel 想要调试内存的malloc和free，就要配置debuginfo源，然后安装 1yum debuginfo-install glibc "},{"id":215,"href":"/docs/linux/linux-kernel/net/ipv4/tcp/","title":"tcp","section":"ipv4/ ipv4的处理部分","content":" 一、总述 # 【Linux 内核网络协议栈源码剖析】数据包接收(含TCP协议状态变换) 深入理解TCP三次握手及其源代码分析 服务器正文22：linux内核网络模块笔记:理解TCP连接建立过程、一条TCP连接多大内存、一台机器最多支持多少条TCP连接、网络优化建议（下）（8/9未完待续） TCP连接的状态详解以及故障排查 面试官：换人！他连 TCP 这几个参数都不懂 万字详解秒杀系统！！ 1. 结构体关系 # @startuml xxx class socket { socket_state state; struct sock *sk; const struct proto_ops\t*ops; } class proto_ops {} class inet_stream_ops {} inet_stream_ops .up.|\u0026gt; proto_ops: 实现 class sock { sk_state =\u0026gt; __sk_common.skc_state sk_prot =\u0026gt; __sk_common.skc_prot } class inet_sock { struct sock sk; } inet_sock .up.|\u0026gt; sock: inet_sock前面就是sock结构体 class inet_connection_sock { struct inet_sock\ticsk_inet; const struct inet_connection_sock_af_ops *icsk_af_ops; } inet_connection_sock .up.|\u0026gt; inet_sock: inet_connection_sock前面就是inet_sock结构体 class tcp_sock { struct inet_connection_sock\tinet_conn; } tcp_sock .up.|\u0026gt; inet_connection_sock: tcp_sock前面就是inet_connection_sock结构体 class sk_prot {} class tcp_prot {} tcp_prot .up.|\u0026gt; sk_prot: 实现 sock \u0026lt;|-- sk_prot: 持有 socket \u0026lt;|-- proto_ops: 持有 socket \u0026lt;|-- sock: 持有 class icsk_af_ops {} class ipv4_specific {} ipv4_specific .up.|\u0026gt; icsk_af_ops: 实现 inet_connection_sock \u0026lt;|-- icsk_af_ops: 持有 @enduml inet_connection_sock扩展了inet_sock inet_sock扩展了sock 三个都使用struct sock *sk存放于socket结构体中 二、tcp状态图和源码 # tcp状态在socket.sk-\u0026gt;sk_state里面储存 1. 状态图 # 1.1. 服务端监听socket accept用 # @startuml 服务端监听socket [*] --\u0026gt; TCP_CLOSE: 创建默认close状态 TCP_CLOSE --\u0026gt; TCP_LISTEN: 调用listen系统调用 @enduml 1) listen系统调用 进入listen状态 # 1// net/ipv4/inet_connection_sock.c 2// listen =\u0026gt; __sys_listen =\u0026gt; inet_listen =\u0026gt; inet_csk_listen_start 3int inet_csk_listen_start(struct sock *sk) 4{ 5\t... 6\tinet_sk_state_store(sk, TCP_LISTEN); 7\t... 8} 1.2. 服务端数据传输socket send/recv用 # @startuml 服务端数据传输socket [*] --\u0026gt; TCP_NEW_SYN_RECV TCP_LISTEN --\u0026gt; TCP_NEW_SYN_RECV : listen的socket收到syn包创建了新的socket note left of TCP_NEW_SYN_RECV 因为TCP_SYN_RECV被fast open占用了 使用了一个新的状态表示 新的状态给request_sock结构体使用 到此状态后发送一个syn/ack包回去 end note TCP_NEW_SYN_RECV --\u0026gt; TCP_SYN_RECV : 收到包 note left of TCP_SYN_RECV 此前创建的request_sock是个minisock 确认收包要建立连接，创建完整的sock结构体 完整的sock状态直接为TCP_SYN_RECV end note TCP_SYN_RECV --\u0026gt; TCP_ESTABLISHED : 确认是ack包，转此状态 TCP_FIN_WAIT2 -\u0026gt; TCP_TIME_WAIT : 收到fin包，回复ack note bottom of TCP_TIME_WAIT 进入TCP_TIME_WAIT状态不需要完整sock结构体 创建inet_timewait_sock接管TCP_TIME_WAIT 原始sock直接关闭，转TCP_CLOSE end note @enduml 1) listen状态收到syn包的处理 # 入口在tcp_v4_rcv 1// net/ipv4/tcp_ipv4.c 2/* 3 *\tFrom tcp_input.c 4 */ 5 6int tcp_v4_rcv(struct sk_buff *skb) 7{ 8\t... 9lookup: 10\t// 拿到包后，根据目的地址和源地址查找有没有socket 11\tsk = __inet_lookup_skb(\u0026amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-\u0026gt;source, 12\tth-\u0026gt;dest, sdif, \u0026amp;refcounted); 13\t... 14\t// 查到的socket就是服务端监听的，这里发现是listen状态直接进入tcp_v4_do_rcv 15\tif (sk-\u0026gt;sk_state == TCP_LISTEN) { 16\tret = tcp_v4_do_rcv(sk, skb); 17\tgoto put_and_return; 18\t} 19\t... 20} 1// net/ipv4/tcp_ipv4.c 2int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb) 3{ 4\t... 5\tif (tcp_rcv_state_process(sk, skb)) { 6\trsk = sk; 7\tgoto reset; 8\t} 9\treturn 0; 10\t... 11} 12 13// net/ipv4/tcp_input.c 14int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb) 15{ 16\t... 17\tswitch (sk-\u0026gt;sk_state) { 18\t... 19\tcase TCP_LISTEN: 20\tif (th-\u0026gt;ack) 21\treturn 1; 22 23\tif (th-\u0026gt;rst) { 24\tSKB_DR_SET(reason, TCP_RESET); 25\tgoto discard; 26\t} 27\t// listen状态收到syn包 28\tif (th-\u0026gt;syn) { 29\tif (th-\u0026gt;fin) { 30\tSKB_DR_SET(reason, TCP_FLAGS); 31\tgoto discard; 32\t} 33\t/* It is possible that we process SYN packets from backlog, 34\t* so we need to make sure to disable BH and RCU right there. 35\t*/ 36\trcu_read_lock(); 37\tlocal_bh_disable(); 38\t// 这里进入到icsk的处理函数，处理连接状态 39\tacceptable = icsk-\u0026gt;icsk_af_ops-\u0026gt;conn_request(sk, skb) \u0026gt;= 0; 40\tlocal_bh_enable(); 41\trcu_read_unlock(); 42 43\tif (!acceptable) 44\treturn 1; 45\tconsume_skb(skb); 46\treturn 0; 47\t} 48\tSKB_DR_SET(reason, TCP_FLAGS); 49\tgoto discard; 50 51\t... 52\t} 53\t... 54} listen收到syn包会进入到icsk-\u0026gt;icsk_af_ops-\u0026gt;conn_request处理连接里面 tcp的icsk-\u0026gt;icsk_af_ops由下面代码注册 1// net/ipv4/tcp_ipv4.c 2const struct inet_connection_sock_af_ops ipv4_specific = { 3\t... 4\t.conn_request\t= tcp_v4_conn_request, 5\t... 6}; 7 8// net/ipv4/tcp_ipv4.c 9static int tcp_v4_init_sock(struct sock *sk) 10{ 11\tstruct inet_connection_sock *icsk = inet_csk(sk); 12 13\ttcp_init_sock(sk); 14 15\ticsk-\u0026gt;icsk_af_ops = \u0026amp;ipv4_specific; 16 17#ifdef CONFIG_TCP_MD5SIG 18\ttcp_sk(sk)-\u0026gt;af_specific = \u0026amp;tcp_sock_ipv4_specific; 19#endif 20 21\treturn 0; 22} 查看icsk-\u0026gt;icsk_af_ops-\u0026gt;conn_request也就是tcp_v4_conn_request 1// net/ipv4/tcp_ipv4.c 2int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb) 3{ 4\t/* Never answer to SYNs send to broadcast or multicast */ 5\tif (skb_rtable(skb)-\u0026gt;rt_flags \u0026amp; (RTCF_BROADCAST | RTCF_MULTICAST)) 6\tgoto drop; 7 8\treturn tcp_conn_request(\u0026amp;tcp_request_sock_ops, 9\t\u0026amp;tcp_request_sock_ipv4_ops, sk, skb); 10 11drop: 12\ttcp_listendrop(sk); 13\treturn 0; 14} 15 16// net/ipv4/tcp_input.c 17int tcp_conn_request(struct request_sock_ops *rsk_ops, 18\tconst struct tcp_request_sock_ops *af_ops, 19\tstruct sock *sk, struct sk_buff *skb) 20{ 21\t... 22\t// 判断accept队列是否满了，这个要会给应用层的accept系统调用的 23\tif (sk_acceptq_is_full(sk)) { 24\tNET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); 25\tgoto drop; 26\t} 27\t// 创建一个reqsk用于处理syn包 28\treq = inet_reqsk_alloc(rsk_ops, sk, !want_cookie); 29\tif (!req) 30\tgoto drop; 31 32\t... 33\tif (fastopen_sk) { 34\t... 35\t} else { 36\ttcp_rsk(req)-\u0026gt;tfo_listener = false; 37\tif (!want_cookie) { 38\treq-\u0026gt;timeout = tcp_timeout_init((struct sock *)req); 39\t// 添加到requestsock队列，添加一个超时时间 40\tinet_csk_reqsk_queue_hash_add(sk, req, req-\u0026gt;timeout); 41\t} 42\t// 回包syn/ack 43\taf_ops-\u0026gt;send_synack(sk, dst, \u0026amp;fl, req, \u0026amp;foc, 44\t!want_cookie ? TCP_SYNACK_NORMAL : 45\tTCP_SYNACK_COOKIE, 46\tskb); 47\tif (want_cookie) { 48\treqsk_free(req); 49\treturn 0; 50\t} 51\t} 52\treqsk_put(req); 53\treturn 0; 54\t... 55} 创建的reqsk状态直接就是TCP_NEW_SYN_RECV 1// net/ipv4/tcp_input.c 2struct request_sock *inet_reqsk_alloc(const struct request_sock_ops *ops, 3\tstruct sock *sk_listener, 4\tbool attach_listener) 5{ 6\tstruct request_sock *req = reqsk_alloc(ops, sk_listener, 7\tattach_listener); 8 9\tif (req) { 10\tstruct inet_request_sock *ireq = inet_rsk(req); 11 12\tireq-\u0026gt;ireq_opt = NULL; 13#if IS_ENABLED(CONFIG_IPV6) 14\tireq-\u0026gt;pktopts = NULL; 15#endif 16\tatomic64_set(\u0026amp;ireq-\u0026gt;ir_cookie, 0); 17\tireq-\u0026gt;ireq_state = TCP_NEW_SYN_RECV; 18\twrite_pnet(\u0026amp;ireq-\u0026gt;ireq_net, sock_net(sk_listener)); 19\tireq-\u0026gt;ireq_family = sk_listener-\u0026gt;sk_family; 20\treq-\u0026gt;timeout = TCP_TIMEOUT_INIT; 21\t} 22 23\treturn req; 24} 25EXPORT_SYMBOL(inet_reqsk_alloc); af_ops-\u0026gt;send_synack对应上面的tcp_request_sock_ipv4_ops-\u0026gt;tcp_v4_send_synack 直接将IP包写到协议栈，不经过应用层 1// net/ipv4/tcp_ipv4.c 2const struct tcp_request_sock_ops tcp_request_sock_ipv4_ops = { 3\t... 4\t.send_synack\t=\ttcp_v4_send_synack, 5}; 6 7// net/ipv4/tcp_ipv4.c 8/* 9 *\tSend a SYN-ACK after having received a SYN. 10 *\tThis still operates on a request_sock only, not on a big 11 *\tsocket. 12 */ 13static int tcp_v4_send_synack(const struct sock *sk, struct dst_entry *dst, 14\tstruct flowi *fl, 15\tstruct request_sock *req, 16\tstruct tcp_fastopen_cookie *foc, 17\tenum tcp_synack_type synack_type, 18\tstruct sk_buff *syn_skb) 19{ 20\tconst struct inet_request_sock *ireq = inet_rsk(req); 21\tstruct flowi4 fl4; 22\tint err = -1; 23\tstruct sk_buff *skb; 24\tu8 tos; 25 26\t/* First, grab a route. */ 27\tif (!dst \u0026amp;\u0026amp; (dst = inet_csk_route_req(sk, \u0026amp;fl4, req)) == NULL) 28\treturn -1; 29 30\tskb = tcp_make_synack(sk, dst, req, foc, synack_type, syn_skb); 31 32\tif (skb) { 33\t__tcp_v4_send_check(skb, ireq-\u0026gt;ir_loc_addr, ireq-\u0026gt;ir_rmt_addr); 34 35\ttos = READ_ONCE(sock_net(sk)-\u0026gt;ipv4.sysctl_tcp_reflect_tos) ? 36\t(tcp_rsk(req)-\u0026gt;syn_tos \u0026amp; ~INET_ECN_MASK) | 37\t(inet_sk(sk)-\u0026gt;tos \u0026amp; INET_ECN_MASK) : 38\tinet_sk(sk)-\u0026gt;tos; 39 40\tif (!INET_ECN_is_capable(tos) \u0026amp;\u0026amp; 41\ttcp_bpf_ca_needs_ecn((struct sock *)req)) 42\ttos |= INET_ECN_ECT_0; 43 44\trcu_read_lock(); 45\terr = ip_build_and_send_pkt(skb, sk, ireq-\u0026gt;ir_loc_addr, 46\tireq-\u0026gt;ir_rmt_addr, 47\trcu_dereference(ireq-\u0026gt;ireq_opt), 48\ttos); 49\trcu_read_unlock(); 50\terr = net_xmit_eval(err); 51\t} 52 53\treturn err; 54} 2) TCP_NEW_SYN_RECV 发送了syn/ack后收到ACK包处理 # (1) 收包处理 # 入口在tcp_v4_rcv 1// net/ipv4/tcp_ipv4.c 2int tcp_v4_rcv(struct sk_buff *skb) 3{ 4\t... 5lookup: 6\t// 拿到包后，根据目的地址和源地址查找有没有socket 7\tsk = __inet_lookup_skb(\u0026amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-\u0026gt;source, 8\tth-\u0026gt;dest, sdif, \u0026amp;refcounted); 9\t... 10\t// 查到的socket是TCP_NEW_SYN_RECV状态处理 11\tif (sk-\u0026gt;sk_state == TCP_NEW_SYN_RECV) { 12\t// 这里是request_sock，临时用的socket 13\tstruct request_sock *req = inet_reqsk(sk); 14\tbool req_stolen = false; 15\tstruct sock *nsk; 16 17\t// sk赋值为监听的服务端socket 18\tsk = req-\u0026gt;rsk_listener; 19\t... 20\trefcounted = true; 21\tnsk = NULL; 22\tif (!tcp_filter(sk, skb)) { 23\tth = (const struct tcphdr *)skb-\u0026gt;data; 24\tiph = ip_hdr(skb); 25\ttcp_v4_fill_cb(skb, iph, th); 26\t// 这里处理一下request_sock 27\tnsk = tcp_check_req(sk, skb, req, false, \u0026amp;req_stolen); 28\t} else { 29\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER; 30\t} 31\t... 32\t} 33\t... 34} 进入tcp_check_req处理 收到ack # 1// net/ipv4/tcp_minisocks.c 2struct sock *tcp_check_req(struct sock *sk, struct sk_buff *skb, 3\tstruct request_sock *req, 4\tbool fastopen, bool *req_stolen) 5{ 6\t... 7\t/* ACK sequence verified above, just make sure ACK is 8\t* set. If ACK not set, just silently drop the packet. 9\t* 10\t* XXX (TFO) - if we ever allow \u0026#34;data after SYN\u0026#34;, the 11\t* following check needs to be removed. 12\t*/ 13\t// 后面处理必须是收到了ack 14\tif (!(flg \u0026amp; TCP_FLAG_ACK)) 15\treturn NULL; 16\t... 17\t/* OK, ACK is valid, create big socket and 18\t* feed this segment to it. It will repeat all 19\t* the tests. THIS SEGMENT MUST MOVE SOCKET TO 20\t* ESTABLISHED STATE. If it will be dropped after 21\t* socket is created, wait for troubles. 22\t*/ 23\tchild = inet_csk(sk)-\u0026gt;icsk_af_ops-\u0026gt;syn_recv_sock(sk, skb, req, NULL, 24\treq, \u0026amp;own_req); 25\tif (!child) 26\tgoto listen_overflow; 27\t... 28} 进入到icsk_af_ops-\u0026gt;syn_recv_sock也就是tcp_v4_syn_recv_sock 1// net/ipv4/tcp_ipv4.c 2const struct inet_connection_sock_af_ops ipv4_specific = { 3\t... 4\t.syn_recv_sock\t= tcp_v4_syn_recv_sock, 5\t... 6}; 1// net/ipv4/tcp_ipv4.c 2struct sock *tcp_v4_syn_recv_sock(const struct sock *sk, struct sk_buff *skb, 3\tstruct request_sock *req, 4\tstruct dst_entry *dst, 5\tstruct request_sock *req_unhash, 6\tbool *own_req) 7{ 8\t... 9\t// 再次判断一下监听的sk是否accept队列满了 10\tif (sk_acceptq_is_full(sk)) 11\tgoto exit_overflow; 12 13\t// 建立一个新的socket，设置新的socket为TCP_SYN_RECV 14\tnewsk = tcp_create_openreq_child(sk, req, skb); 15\tif (!newsk) 16\tgoto exit_nonewsk; 17\t... 18} 创建新的socket替换request_sock，状态直接为TCP_SYN_RECV 1// net/ipv4/tcp_minisocks.c 2struct sock *tcp_create_openreq_child(const struct sock *sk, 3\tstruct request_sock *req, 4\tstruct sk_buff *skb) 5{ 6\tstruct sock *newsk = inet_csk_clone_lock(sk, req, GFP_ATOMIC); 7\t... 8} 9 10// net/ipv4/inet_connection_sock.c 11/* 到这一步的堆栈信息 12inet_csk_clone_lock(const struct sock * sk, const struct request_sock * req, const gfp_t priority) (/net/ipv4/inet_connection_sock.c:963) 13tcp_create_openreq_child(const struct sock * sk, struct request_sock * req, struct sk_buff * skb) (/net/ipv4/tcp_minisocks.c:453) 14tcp_v4_syn_recv_sock(const struct sock * sk, struct sk_buff * skb, struct request_sock * req, struct dst_entry * dst, struct request_sock * req_unhash, bool * own_req) (/net/ipv4/tcp_ipv4.c:1502) 15tcp_check_req(struct sock * sk, struct sk_buff * skb, struct request_sock * req, bool fastopen, bool * req_stolen) (/net/ipv4/tcp_minisocks.c:764) 16tcp_v4_rcv(struct sk_buff * skb) (/net/ipv4/tcp_ipv4.c:2004) 17*/ 18struct sock *inet_csk_clone_lock(const struct sock *sk, 19\tconst struct request_sock *req, 20\tconst gfp_t priority) 21{ 22\tstruct sock *newsk = sk_clone_lock(sk, priority); 23 24\tif (newsk) { 25\tstruct inet_connection_sock *newicsk = inet_csk(newsk); 26 27\t// 创建完整的sock，状态为TCP_SYN_RECV 28\tinet_sk_set_state(newsk, TCP_SYN_RECV); 29\tnewicsk-\u0026gt;icsk_bind_hash = NULL; 30 31\tinet_sk(newsk)-\u0026gt;inet_dport = inet_rsk(req)-\u0026gt;ir_rmt_port; 32\tinet_sk(newsk)-\u0026gt;inet_num = inet_rsk(req)-\u0026gt;ir_num; 33\tinet_sk(newsk)-\u0026gt;inet_sport = htons(inet_rsk(req)-\u0026gt;ir_num); 34 35\t/* listeners have SOCK_RCU_FREE, not the children */ 36\tsock_reset_flag(newsk, SOCK_RCU_FREE); 37 38\tinet_sk(newsk)-\u0026gt;mc_list = NULL; 39 40\tnewsk-\u0026gt;sk_mark = inet_rsk(req)-\u0026gt;ir_mark; 41\tatomic64_set(\u0026amp;newsk-\u0026gt;sk_cookie, 42\tatomic64_read(\u0026amp;inet_rsk(req)-\u0026gt;ir_cookie)); 43 44\tnewicsk-\u0026gt;icsk_retransmits = 0; 45\tnewicsk-\u0026gt;icsk_backoff\t= 0; 46\tnewicsk-\u0026gt;icsk_probes_out = 0; 47\tnewicsk-\u0026gt;icsk_probes_tstamp = 0; 48 49\t/* Deinitialize accept_queue to trap illegal accesses. */ 50\tmemset(\u0026amp;newicsk-\u0026gt;icsk_accept_queue, 0, sizeof(newicsk-\u0026gt;icsk_accept_queue)); 51 52\tinet_clone_ulp(req, newsk, priority); 53 54\tsecurity_inet_csk_clone(newsk, req); 55\t} 56\treturn newsk; 57} 新socket创建完之后回到tcp_v4_rcv处理 1// net/ipv4/tcp_ipv4.c 2int tcp_v4_rcv(struct sk_buff *skb) 3{ 4\t... 5lookup: 6\t// 拿到包后，根据目的地址和源地址查找有没有socket 7\tsk = __inet_lookup_skb(\u0026amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-\u0026gt;source, 8\tth-\u0026gt;dest, sdif, \u0026amp;refcounted); 9\t... 10\t// 查到的socket是TCP_NEW_SYN_RECV状态处理 11\tif (sk-\u0026gt;sk_state == TCP_NEW_SYN_RECV) { 12\t// 这里是request_sock，临时用的socket 13\tstruct request_sock *req = inet_reqsk(sk); 14\tbool req_stolen = false; 15\tstruct sock *nsk; 16 17\t// sk赋值为监听的服务端socket 18\tsk = req-\u0026gt;rsk_listener; 19\t... 20\trefcounted = true; 21\tnsk = NULL; 22\tif (!tcp_filter(sk, skb)) { 23\tth = (const struct tcphdr *)skb-\u0026gt;data; 24\tiph = ip_hdr(skb); 25\ttcp_v4_fill_cb(skb, iph, th); 26\t// 这里处理一下request_sock，在这里创建了新的socket返回 27\tnsk = tcp_check_req(sk, skb, req, false, \u0026amp;req_stolen); 28\t} else { 29\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER; 30\t} 31\t... 32\tif (nsk == sk) { 33\treqsk_put(req); 34\ttcp_v4_restore_cb(skb); 35\t// 进入到tcp_child_process处理包 36\t} else if (tcp_child_process(sk, nsk, skb)) { 37\ttcp_v4_send_reset(nsk, skb); 38\tgoto discard_and_relse; 39\t} else { 40\tsock_put(sk); 41\treturn 0; 42\t} 43\t} 44\t... 45} 紧接着进入tcp_child_process 1// net/ipv4/tcp_minisocks.c 2int tcp_child_process(struct sock *parent, struct sock *child, 3\tstruct sk_buff *skb) 4\t__releases(\u0026amp;((child)-\u0026gt;sk_lock.slock)) 5{ 6\tint ret = 0; 7\tint state = child-\u0026gt;sk_state; 8 9\t/* record sk_napi_id and sk_rx_queue_mapping of child. */ 10\tsk_mark_napi_id_set(child, skb); 11 12\ttcp_segs_in(tcp_sk(child), skb); 13\tif (!sock_owned_by_user(child)) { 14\t// 不是用户处理的socket就进入tcp_rcv_state_process 15\tret = tcp_rcv_state_process(child, skb); 16\t/* Wakeup parent, send SIGIO */ 17\tif (state == TCP_SYN_RECV \u0026amp;\u0026amp; child-\u0026gt;sk_state != state) 18\tparent-\u0026gt;sk_data_ready(parent); 19\t} else { 20\t/* Alas, it is possible again, because we do lookup 21\t* in main socket hash table and lock on listening 22\t* socket does not protect us more. 23\t*/ 24\t__sk_add_backlog(child, skb); 25\t} 26 27\tbh_unlock_sock(child); 28\tsock_put(child); 29\treturn ret; 30} 进入tcp_rcv_state_process后连接状态设置为TCP_ESTABLISHED 1// net/ipv4/tcp_input.c 2/* 到这一步的堆栈 3tcp_rcv_state_process(struct sock * sk, struct sk_buff * skb) (/net/ipv4/tcp_input.c:6541) 4tcp_child_process(struct sock * parent, struct sock * child, struct sk_buff * skb) (/net/ipv4/tcp_minisocks.c:836) 5tcp_v4_rcv(struct sk_buff * skb) (/net/ipv4/tcp_ipv4.c:2026) 6*/ 7int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb) 8{ 9\t... 10\tif (!th-\u0026gt;ack \u0026amp;\u0026amp; !th-\u0026gt;rst \u0026amp;\u0026amp; !th-\u0026gt;syn) { 11\tSKB_DR_SET(reason, TCP_FLAGS); 12\tgoto discard; 13\t} 14\tif (!tcp_validate_incoming(sk, skb, th, 0)) 15\treturn 0; 16 17\t/* step 5: check the ACK field */ 18\tacceptable = tcp_ack(sk, skb, FLAG_SLOWPATH | 19\tFLAG_UPDATE_TS_RECENT | 20\tFLAG_NO_CHALLENGE_ACK) \u0026gt; 0; 21 22\tif (!acceptable) { 23\tif (sk-\u0026gt;sk_state == TCP_SYN_RECV) 24\treturn 1;\t/* send one RST */ 25\ttcp_send_challenge_ack(sk); 26\tSKB_DR_SET(reason, TCP_OLD_ACK); 27\tgoto discard; 28\t} 29\tswitch (sk-\u0026gt;sk_state) { 30\tcase TCP_SYN_RECV: 31\ttp-\u0026gt;delivered++; /* SYN-ACK delivery isn\u0026#39;t tracked in tcp_ack */ 32\tif (!tp-\u0026gt;srtt_us) 33\ttcp_synack_rtt_meas(sk, req); 34 35\tif (req) { 36\ttcp_rcv_synrecv_state_fastopen(sk); 37\t} else { 38\ttcp_try_undo_spurious_syn(sk); 39\ttp-\u0026gt;retrans_stamp = 0; 40\ttcp_init_transfer(sk, BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB, 41\tskb); 42\tWRITE_ONCE(tp-\u0026gt;copied_seq, tp-\u0026gt;rcv_nxt); 43\t} 44\tsmp_mb(); 45\t// 将连接状态设置为TCP_ESTABLISHED 46\ttcp_set_state(sk, TCP_ESTABLISHED); 47\tsk-\u0026gt;sk_state_change(sk); 48 49\t... 50\tbreak; 51 52\t... 53\t} 54\t... 55} 1.3. 客户端 # @startuml [*] --\u0026gt; TCP_SYN_SENT: 系统调用connect() TCP_SYN_SENT --\u0026gt; TCP_SYN_RCVD: 接收到SYN-ACK TCP_SYN_SENT --\u0026gt; TCP_CLOSED: 超时 TCP_SYN_RCVD --\u0026gt; TCP_ESTABLISHED: 接收到ACK TCP_ESTABLISHED --\u0026gt; TCP_CLOSED: 关闭连接 TCP_CLOSED --\u0026gt; [*] @enduml 1) TCP_CLOSED =\u0026gt; TCP_SYN_SENT 关闭状态发起connect系统调用 # 1/* 2tcp_v4_connect(struct sock * sk, struct sockaddr * uaddr, int addr_len) (net/ipv4/tcp_ipv4.c:275) 3__inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags, int is_sendmsg) (net/ipv4/af_inet.c:660) 4inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags) (net/ipv4/af_inet.c:724) 5__sys_connect(int fd, struct sockaddr * uservaddr, int addrlen) (net/socket.c:1996) 6__do_sys_connect(int addrlen, struct sockaddr * uservaddr, int fd) (net/socket.c:2006) 7__se_sys_connect(long addrlen, long uservaddr, long fd) (net/socket.c:2003) 8__x64_sys_connect(const struct pt_regs * regs) (net/socket.c:2003) 9do_syscall_x64(int nr, struct pt_regs * regs) (arch/x86/entry/common.c:50) 10do_syscall_64(struct pt_regs * regs, int nr) (arch/x86/entry/common.c:80) 11entry_SYSCALL_64() (arch/x86/entry/entry_64.S:120) 12[Unknown/Just-In-Time compiled code] (Unknown Source:0) 13fixed_percpu_data (Unknown Source:0) 14[Unknown/Just-In-Time compiled code] (Unknown Source:0) 15fixed_percpu_data (Unknown Source:0) 16[Unknown/Just-In-Time compiled code] (Unknown Source:0) 17 */ 18/* This will initiate an outgoing connection. */ 19int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) 20{ 21\t... 22\t/* Socket identity is still unknown (sport may be zero). 23\t* However we set state to SYN-SENT and not releasing socket 24\t* lock select source port, enter ourselves into the hash tables and 25\t* complete initialization after this. 26\t*/ 27\t// 转到TCP_SYN_SENT状态 28\ttcp_set_state(sk, TCP_SYN_SENT); 29\t... 30\t// 发出sync包 31\terr = tcp_connect(sk); 32} 1.4. TCP_CLOSE状态 # 1) 初始化 # 1// net/core/sock.c 2// socket() =\u0026gt; __sys_socket() =\u0026gt; sock_create() =\u0026gt; __sock_create() =\u0026gt; inet_create =\u0026gt; sock_init_data 3void sock_init_data(struct socket *sock, struct sock *sk) 4{ 5\t... 6\tsk-\u0026gt;sk_state\t=\tTCP_CLOSE; 7\t... 8} 9EXPORT_SYMBOL(sock_init_data); 2) TCP_FIN_WAIT2到TCP_TIME_WAIT，原始sock转成TCP_CLOSE # 1// net/ipv4/tcp_input.c 2static void tcp_data_queue(struct sock *sk, struct sk_buff *skb) 3{ 4\tstruct tcp_sock *tp = tcp_sk(sk); 5\t... 6\t/* Queue data for delivery to the user. 7\t* Packets in sequence go to the receive queue. 8\t* Out of sequence packets to the out_of_order_queue. 9\t*/ 10\tif (TCP_SKB_CB(skb)-\u0026gt;seq == tp-\u0026gt;rcv_nxt) { 11\t... 12\tif (TCP_SKB_CB(skb)-\u0026gt;tcp_flags \u0026amp; TCPHDR_FIN) 13\ttcp_fin(sk); 14\t... 15\treturn; 16\t} 17\t... 18} 19 20// net/ipv4/tcp_input.c 21/* 22 * Process the FIN bit. This now behaves as it is supposed to work 23 *\tand the FIN takes effect when it is validly part of sequence 24 *\tspace. Not before when we get holes. 25 * 26 *\tIf we are ESTABLISHED, a received fin moves us to CLOSE-WAIT 27 *\t(and thence onto LAST-ACK and finally, CLOSE, we never enter 28 *\tTIME-WAIT) 29 * 30 *\tIf we are in FINWAIT-1, a received FIN indicates simultaneous 31 *\tclose and we go into CLOSING (and later onto TIME-WAIT) 32 * 33 *\tIf we are in FINWAIT-2, a received FIN moves us to TIME-WAIT. 34 */ 35void tcp_fin(struct sock *sk) 36{ 37\tstruct tcp_sock *tp = tcp_sk(sk); 38\t... 39\tswitch (sk-\u0026gt;sk_state) { 40\t... 41\tcase TCP_FIN_WAIT2: 42\t/* Received a FIN -- send ACK and enter TIME_WAIT. */ 43\ttcp_send_ack(sk); 44\ttcp_time_wait(sk, TCP_TIME_WAIT, 0); 45\tbreak; 46\t... 47\t} 48\t... 49} 50 51// net/ipv4/tcp_minisocks.c 52/* 53 * Move a socket to time-wait or dead fin-wait-2 state. 54 */ 55void tcp_time_wait(struct sock *sk, int state, int timeo) 56{ 57\tconst struct inet_connection_sock *icsk = inet_csk(sk); 58\tconst struct tcp_sock *tp = tcp_sk(sk); 59\tstruct inet_timewait_sock *tw; 60\tstruct inet_timewait_death_row *tcp_death_row = sock_net(sk)-\u0026gt;ipv4.tcp_death_row; 61 62\ttw = inet_twsk_alloc(sk, tcp_death_row, state); 63\t... 64\ttcp_update_metrics(sk); 65\ttcp_done(sk); 66} 67EXPORT_SYMBOL(tcp_time_wait); 原始sock结构体sk转成TCP_CLOSE状态，使用inet_timewait_sock的minisock接管TCP_TIME_WAIT状态 1// net/ipv4/inet_timewait_sock.c 2struct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk, 3\tstruct inet_timewait_death_row *dr, 4\tconst int state) 5{ 6\tstruct inet_timewait_sock *tw; 7 8\tif (refcount_read(\u0026amp;dr-\u0026gt;tw_refcount) - 1 \u0026gt;= 9\tREAD_ONCE(dr-\u0026gt;sysctl_max_tw_buckets)) 10\treturn NULL; 11 12\ttw = kmem_cache_alloc(sk-\u0026gt;sk_prot_creator-\u0026gt;twsk_prot-\u0026gt;twsk_slab, 13\tGFP_ATOMIC); 14\tif (tw) { 15\tconst struct inet_sock *inet = inet_sk(sk); 16 17\ttw-\u0026gt;tw_dr\t= dr; 18\t/* Give us an identity. */ 19\ttw-\u0026gt;tw_daddr\t= inet-\u0026gt;inet_daddr; 20\ttw-\u0026gt;tw_rcv_saddr = inet-\u0026gt;inet_rcv_saddr; 21\ttw-\u0026gt;tw_bound_dev_if = sk-\u0026gt;sk_bound_dev_if; 22\ttw-\u0026gt;tw_tos\t= inet-\u0026gt;tos; 23\ttw-\u0026gt;tw_num\t= inet-\u0026gt;inet_num; 24\ttw-\u0026gt;tw_state\t= TCP_TIME_WAIT; 25\ttw-\u0026gt;tw_substate\t= state; 26\ttw-\u0026gt;tw_sport\t= inet-\u0026gt;inet_sport; 27\ttw-\u0026gt;tw_dport\t= inet-\u0026gt;inet_dport; 28\ttw-\u0026gt;tw_family\t= sk-\u0026gt;sk_family; 29\ttw-\u0026gt;tw_reuse\t= sk-\u0026gt;sk_reuse; 30\ttw-\u0026gt;tw_reuseport = sk-\u0026gt;sk_reuseport; 31\ttw-\u0026gt;tw_hash\t= sk-\u0026gt;sk_hash; 32\ttw-\u0026gt;tw_ipv6only\t= 0; 33\ttw-\u0026gt;tw_transparent = inet-\u0026gt;transparent; 34\ttw-\u0026gt;tw_prot\t= sk-\u0026gt;sk_prot_creator; 35\tatomic64_set(\u0026amp;tw-\u0026gt;tw_cookie, atomic64_read(\u0026amp;sk-\u0026gt;sk_cookie)); 36\ttwsk_net_set(tw, sock_net(sk)); 37\ttimer_setup(\u0026amp;tw-\u0026gt;tw_timer, tw_timer_handler, TIMER_PINNED); 38\t/* 39\t* Because we use RCU lookups, we should not set tw_refcnt 40\t* to a non null value before everything is setup for this 41\t* timewait socket. 42\t*/ 43\trefcount_set(\u0026amp;tw-\u0026gt;tw_refcnt, 0); 44 45\t__module_get(tw-\u0026gt;tw_prot-\u0026gt;owner); 46\t} 47 48\treturn tw; 49} 50EXPORT_SYMBOL_GPL(inet_twsk_alloc); 51 52// net/ipv4/tcp.c 53void tcp_done(struct sock *sk) 54{ 55\tstruct request_sock *req; 56 57\t/* We might be called with a new socket, after 58\t* inet_csk_prepare_forced_close() has been called 59\t* so we can not use lockdep_sock_is_held(sk) 60\t*/ 61\treq = rcu_dereference_protected(tcp_sk(sk)-\u0026gt;fastopen_rsk, 1); 62 63\tif (sk-\u0026gt;sk_state == TCP_SYN_SENT || sk-\u0026gt;sk_state == TCP_SYN_RECV) 64\tTCP_INC_STATS(sock_net(sk), TCP_MIB_ATTEMPTFAILS); 65 66\ttcp_set_state(sk, TCP_CLOSE); 67\ttcp_clear_xmit_timers(sk); 68\tif (req) 69\treqsk_fastopen_remove(sk, req, false); 70 71\tsk-\u0026gt;sk_shutdown = SHUTDOWN_MASK; 72 73\tif (!sock_flag(sk, SOCK_DEAD)) 74\tsk-\u0026gt;sk_state_change(sk); 75\telse 76\tinet_csk_destroy_sock(sk); 77} 78EXPORT_SYMBOL_GPL(tcp_done); 2. 数据包构造 # 2.1. syn包 # connect发包到OUTPUT链的堆栈 1/* 2__ip_local_out(struct net * net, struct sock * sk, struct sk_buff * skb) (net/ipv4/ip_output.c:103) 3ip_local_out(struct net * net, struct sock * sk, struct sk_buff * skb) (net/ipv4/ip_output.c:124) 4__ip_queue_xmit(struct sock * sk, struct sk_buff * skb, struct flowi * fl, __u8 tos) (net/ipv4/ip_output.c:532) 5ip_queue_xmit(struct sock * sk, struct sk_buff * skb, struct flowi * fl) (net/ipv4/ip_output.c:546) 6__tcp_transmit_skb(struct sock * sk, struct sk_buff * skb, int clone_it, gfp_t gfp_mask, u32 rcv_nxt) (net/ipv4/tcp_output.c:1402) 7tcp_transmit_skb(gfp_t gfp_mask, int clone_it, struct sk_buff * skb, struct sock * sk) (net/ipv4/tcp_output.c:1420) 8tcp_connect(struct sock * sk) (net/ipv4/tcp_output.c:3853) 9tcp_v4_connect(struct sock * sk, struct sockaddr * uaddr, int addr_len) (net/ipv4/tcp_ipv4.c:313) 10__inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags, int is_sendmsg) (net/ipv4/af_inet.c:660) 11inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags) (net/ipv4/af_inet.c:724) 12__sys_connect(int fd, struct sockaddr * uservaddr, int addrlen) (net/socket.c:1996) 13__do_sys_connect(int addrlen, struct sockaddr * uservaddr, int fd) (net/socket.c:2006) 14__se_sys_connect(long addrlen, long uservaddr, long fd) (net/socket.c:2003) 15__x64_sys_connect(const struct pt_regs * regs) (net/socket.c:2003) 16do_syscall_x64(int nr, struct pt_regs * regs) (arch/x86/entry/common.c:50) 17do_syscall_64(struct pt_regs * regs, int nr) (arch/x86/entry/common.c:80) 18entry_SYSCALL_64() (arch/x86/entry/entry_64.S:120) 19[Unknown/Just-In-Time compiled code] (Unknown Source:0) 20fixed_percpu_data (Unknown Source:0) 21[Unknown/Just-In-Time compiled code] (Unknown Source:0) 22*/ 23int __ip_local_out(struct net *net, struct sock *sk, struct sk_buff *skb) 24{ 25\tstruct iphdr *iph = ip_hdr(skb); 26 27\tiph-\u0026gt;tot_len = htons(skb-\u0026gt;len); 28\tip_send_check(iph); 29 30\t/* if egress device is enslaved to an L3 master device pass the 31\t* skb to its handler for processing 32\t*/ 33\tskb = l3mdev_ip_out(sk, skb); 34\tif (unlikely(!skb)) 35\treturn 0; 36 37\tskb-\u0026gt;protocol = htons(ETH_P_IP); 38 39\treturn nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, 40\tnet, sk, skb, NULL, skb_dst(skb)-\u0026gt;dev, 41\tdst_output); 42} 三、几个异常场景的源码解释 # 1. 向一个服务器没有监听的端口发送syn包，会收到rst # 先看 ipv4收包过程，tcp处理函数为tcp_v4_rcv 1// net/ipv4/tcp_ipv4.c 2/* 3 *\tFrom tcp_input.c 4 */ 5 6int tcp_v4_rcv(struct sk_buff *skb) 7{ 8\t... 9\t// 这里根据skb里面的五元组找sock结构体，因为没有监听，所以找不到 10\tsk = __inet_lookup_skb(\u0026amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-\u0026gt;source, 11\tth-\u0026gt;dest, sdif, \u0026amp;refcounted); 12\tif (!sk) 13\t// 找不到，跳no_tcp_socket 14\tgoto no_tcp_socket; 15\t... 16no_tcp_socket: 17\tdrop_reason = SKB_DROP_REASON_NO_SOCKET; 18\t// 这里会检查策略，linux可以配置策略是丢包还是回复rst，默认配置是回复rst 19\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) 20\tgoto discard_it; 21 22\ttcp_v4_fill_cb(skb, iph, th); 23 24\t// 检查checksum，因为包合法，所以肯定成功，这里返回1是失败 25\tif (tcp_checksum_complete(skb)) { 26csum_error: 27\tdrop_reason = SKB_DROP_REASON_TCP_CSUM; 28\ttrace_tcp_bad_csum(skb); 29\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS); 30bad_packet: 31\t__TCP_INC_STATS(net, TCP_MIB_INERRS); 32\t} else { 33\t// 成功就发送rst 34\ttcp_v4_send_reset(NULL, skb); 35\t} 36 37discard_it: 38\tSKB_DR_OR(drop_reason, NOT_SPECIFIED); 39\t/* Discard frame. */ 40\tkfree_skb_reason(skb, drop_reason); 41\treturn 0; 42\t... 四、socket相关接口 # 1. 相关接口定义 # 1// net/ipv4/af_inet.c 2/* Upon startup we insert all the elements in inetsw_array[] into 3 * the linked list inetsw. 4 */ 5static struct inet_protosw inetsw_array[] = 6{ 7 { 8 .type = SOCK_STREAM, 9 .protocol = IPPROTO_TCP, 10 .prot = \u0026amp;tcp_prot, 11 .ops = \u0026amp;inet_stream_ops, 12 .flags = INET_PROTOSW_PERMANENT | 13 INET_PROTOSW_ICSK, 14 }, 15 ... 16} 17 18// net/ipv4/af_inet.c 19const struct proto_ops inet_stream_ops = { 20\t.family\t= PF_INET, 21\t.owner\t= THIS_MODULE, 22\t.release\t= inet_release, 23\t.bind\t= inet_bind, 24\t.connect\t= inet_stream_connect, 25\t.socketpair\t= sock_no_socketpair, 26\t.accept\t= inet_accept, 27\t.getname\t= inet_getname, 28\t.poll\t= tcp_poll, 29\t.ioctl\t= inet_ioctl, 30\t.gettstamp\t= sock_gettstamp, 31\t.listen\t= inet_listen, 32\t.shutdown\t= inet_shutdown, 33\t.setsockopt\t= sock_common_setsockopt, 34\t.getsockopt\t= sock_common_getsockopt, 35\t.sendmsg\t= inet_sendmsg, 36\t.recvmsg\t= inet_recvmsg, 37#ifdef CONFIG_MMU 38\t.mmap\t= tcp_mmap, 39#endif 40\t.sendpage\t= inet_sendpage, 41\t.splice_read\t= tcp_splice_read, 42\t.read_sock\t= tcp_read_sock, 43\t.sendmsg_locked = tcp_sendmsg_locked, 44\t.sendpage_locked = tcp_sendpage_locked, 45\t.peek_len\t= tcp_peek_len, 46#ifdef CONFIG_COMPAT 47\t.compat_ioctl\t= inet_compat_ioctl, 48#endif 49\t.set_rcvlowat\t= tcp_set_rcvlowat, 50}; 51EXPORT_SYMBOL(inet_stream_ops); 52 53// net/ipv4/tcp_ipv4.c 54struct proto tcp_prot = { 55\t.name\t= \u0026#34;TCP\u0026#34;, 56\t.owner\t= THIS_MODULE, 57\t.close\t= tcp_close, 58\t.pre_connect\t= tcp_v4_pre_connect, 59\t.connect\t= tcp_v4_connect, 60\t.disconnect\t= tcp_disconnect, 61\t.accept\t= inet_csk_accept, 62\t.ioctl\t= tcp_ioctl, 63\t.init\t= tcp_v4_init_sock, 64\t.destroy\t= tcp_v4_destroy_sock, 65\t.shutdown\t= tcp_shutdown, 66\t.setsockopt\t= tcp_setsockopt, 67\t.getsockopt\t= tcp_getsockopt, 68\t.bpf_bypass_getsockopt\t= tcp_bpf_bypass_getsockopt, 69\t.keepalive\t= tcp_set_keepalive, 70\t.recvmsg\t= tcp_recvmsg, 71\t.sendmsg\t= tcp_sendmsg, 72\t.sendpage\t= tcp_sendpage, 73\t.backlog_rcv\t= tcp_v4_do_rcv, 74\t.release_cb\t= tcp_release_cb, 75\t.hash\t= inet_hash, 76\t.unhash\t= inet_unhash, 77\t.get_port\t= inet_csk_get_port, 78\t.put_port\t= inet_put_port, 79#ifdef CONFIG_BPF_SYSCALL 80\t.psock_update_sk_prot\t= tcp_bpf_update_proto, 81#endif 82\t.enter_memory_pressure\t= tcp_enter_memory_pressure, 83\t.leave_memory_pressure\t= tcp_leave_memory_pressure, 84\t.stream_memory_free\t= tcp_stream_memory_free, 85\t.sockets_allocated\t= \u0026amp;tcp_sockets_allocated, 86\t.orphan_count\t= \u0026amp;tcp_orphan_count, 87\t.memory_allocated\t= \u0026amp;tcp_memory_allocated, 88\t.memory_pressure\t= \u0026amp;tcp_memory_pressure, 89\t.sysctl_mem\t= sysctl_tcp_mem, 90\t.sysctl_wmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_wmem), 91\t.sysctl_rmem_offset\t= offsetof(struct net, ipv4.sysctl_tcp_rmem), 92\t.max_header\t= MAX_TCP_HEADER, 93\t.obj_size\t= sizeof(struct tcp_sock), 94\t.slab_flags\t= SLAB_TYPESAFE_BY_RCU, 95\t.twsk_prot\t= \u0026amp;tcp_timewait_sock_ops, 96\t.rsk_prot\t= \u0026amp;tcp_request_sock_ops, 97\t.h.hashinfo\t= \u0026amp;tcp_hashinfo, 98\t.no_autobind\t= true, 99\t.diag_destroy\t= tcp_abort, 100}; 101EXPORT_SYMBOL(tcp_prot); 2. 注册到socket里面的特定结构 # 2.1. socket.sk-\u0026gt;sk_prot =\u0026gt; tcp_prot、socket.proto_ops =\u0026gt; inet_stream_ops # 1// net/ipv4/af_inet.c 2/* Upon startup we insert all the elements in inetsw_array[] into 3 * the linked list inetsw. 4 */ 5static struct inet_protosw inetsw_array[] = 6{ 7 { 8 .type = SOCK_STREAM, 9 .protocol = IPPROTO_TCP, 10 .prot = \u0026amp;tcp_prot, 11 .ops = \u0026amp;inet_stream_ops, 12 .flags = INET_PROTOSW_PERMANENT | 13 INET_PROTOSW_ICSK, 14 }, 15 ... 16} 17 18// net/ipv4/af_inet.c 19/* 20 *\tCreate an inet socket. 21 */ 22// socket =\u0026gt; __do_sys_socket =\u0026gt; __sys_socket =\u0026gt; __sys_socket_create =\u0026gt; sock_create =\u0026gt; __sock_create =\u0026gt; inet_create 23static int inet_create(struct net *net, struct socket *sock, int protocol, 24 int kern) 25{ 26\t... 27 // 从inetsw中找到对应协议的结构体，赋值给answer变量 28 list_for_each_entry_rcu(answer, \u0026amp;inetsw[sock-\u0026gt;type], list) { 29 30 err = 0; 31 /* Check the non-wild match. */ 32 if (protocol == answer-\u0026gt;protocol) { 33 if (protocol != IPPROTO_IP) 34 break; 35 } else { 36 /* Check for the two wild cases. */ 37 if (IPPROTO_IP == protocol) { 38 protocol = answer-\u0026gt;protocol; 39 break; 40 } 41 if (IPPROTO_IP == answer-\u0026gt;protocol) 42 break; 43 } 44 err = -EPROTONOSUPPORT; 45 } 46\t... 47 // 将对应协议的操作放到sock里面 48 sock-\u0026gt;ops = answer-\u0026gt;ops; 49 answer_prot = answer-\u0026gt;prot; 50 answer_flags = answer-\u0026gt;flags; 51 rcu_read_unlock(); 52 53 WARN_ON(!answer_prot-\u0026gt;slab); 54 55 err = -ENOMEM; 56 sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern); 57\t... 58} 2.2. ((inet_connection_sock *)(socket.sk))-\u0026gt;icsk_af_ops =\u0026gt; ipv4_specific # 上面注册了tcp_prot到socket.sk-\u0026gt;sk_prot 在inet_create中调用了init 1 2// net/ipv4/tcp_ipv4.c 3struct proto tcp_prot = { 4\t... 5\t.init\t= tcp_v4_init_sock, 6\t... 7}; 8EXPORT_SYMBOL(tcp_prot); 9 10// net/ipv4/af_inet.c 11/* 12 *\tCreate an inet socket. 13 */ 14 15static int inet_create(struct net *net, struct socket *sock, int protocol, 16 int kern) 17{ 18\t... 19 if (sk-\u0026gt;sk_prot-\u0026gt;init) { 20\t// 这里调用tcp特定的init 21 err = sk-\u0026gt;sk_prot-\u0026gt;init(sk); 22 if (err) { 23 sk_common_release(sk); 24 goto out; 25 } 26 } 27\t... 28} init也就是tcp_v4_init_sock 1/* NOTE: A lot of things set to zero explicitly by call to 2 * sk_alloc() so need not be done here. 3 */ 4static int tcp_v4_init_sock(struct sock *sk) 5{ 6\tstruct inet_connection_sock *icsk = inet_csk(sk); 7 8\ttcp_init_sock(sk); 9 10\ticsk-\u0026gt;icsk_af_ops = \u0026amp;ipv4_specific; 11 12#ifdef CONFIG_TCP_MD5SIG 13\ttcp_sk(sk)-\u0026gt;af_specific = \u0026amp;tcp_sock_ipv4_specific; 14#endif 15 16\treturn 0; 17} 3. bind =\u0026gt; sk_prot-\u0026gt;get_port 检查端口是否可用 # 3.1. 先看定义 # 调用到inet_csk_get_port 1// net/ipv4/tcp_ipv4.c 2struct proto tcp_prot = { 3\t... 4\t.get_port\t= inet_csk_get_port, 5\t... 6}; 7EXPORT_SYMBOL(tcp_prot); 3.2. inet_csk_get_port # 没有端口，自动分配一个端口 有已经分配的端口就看是否可以复用，可以也可以返回 成功分配端口后就绑定socket和端口的关系 1/* Obtain a reference to a local port for the given sock, 2 * if snum is zero it means select any available local port. 3 * We try to allocate an odd port (and leave even ports for connect()) 4 */ 5int inet_csk_get_port(struct sock *sk, unsigned short snum) 6{ 7\tbool reuse = sk-\u0026gt;sk_reuse \u0026amp;\u0026amp; sk-\u0026gt;sk_state != TCP_LISTEN; 8\tstruct inet_hashinfo *hinfo = sk-\u0026gt;sk_prot-\u0026gt;h.hashinfo; 9\tint ret = 1, port = snum; 10\tstruct inet_bind_hashbucket *head; 11\tstruct net *net = sock_net(sk); 12\tstruct inet_bind_bucket *tb = NULL; 13\tint l3mdev; 14 15\tl3mdev = inet_sk_bound_l3mdev(sk); 16 17\t// 没有端口，内核从合法端口内自动分配一个端口 18\tif (!port) { 19\thead = inet_csk_find_open_port(sk, \u0026amp;tb, \u0026amp;port); 20\tif (!head) 21\treturn ret; 22\tif (!tb) 23\tgoto tb_not_found; 24\tgoto success; 25\t} 26 27\t// 从hash表查找端口信息 28\thead = \u0026amp;hinfo-\u0026gt;bhash[inet_bhashfn(net, port, 29\thinfo-\u0026gt;bhash_size)]; 30\tspin_lock_bh(\u0026amp;head-\u0026gt;lock); 31\tinet_bind_bucket_for_each(tb, \u0026amp;head-\u0026gt;chain) 32\tif (net_eq(ib_net(tb), net) \u0026amp;\u0026amp; tb-\u0026gt;l3mdev == l3mdev \u0026amp;\u0026amp; 33\ttb-\u0026gt;port == port) 34\tgoto tb_found; 35tb_not_found: 36\t// 没找到，新建一个绑定，加入到hash表 37\ttb = inet_bind_bucket_create(hinfo-\u0026gt;bind_bucket_cachep, 38\tnet, head, port, l3mdev); 39\tif (!tb) 40\tgoto fail_unlock; 41tb_found: 42\t// 找到了，如果可以复用，也成功返回 43\tif (!hlist_empty(\u0026amp;tb-\u0026gt;owners)) { 44\tif (sk-\u0026gt;sk_reuse == SK_FORCE_REUSE) 45\tgoto success; 46 47\tif ((tb-\u0026gt;fastreuse \u0026gt; 0 \u0026amp;\u0026amp; reuse) || 48\tsk_reuseport_match(tb, sk)) 49\tgoto success; 50\t// 不是强制复用和快速复用等，进行绑定冲突判断 51\tif (inet_csk_bind_conflict(sk, tb, true, true)) 52\tgoto fail_unlock; 53\t} 54success: 55\tinet_csk_update_fastreuse(tb, sk); 56 57\t// 将socket和hash表上的端口绑定 58\tif (!inet_csk(sk)-\u0026gt;icsk_bind_hash) 59\tinet_bind_hash(sk, tb, port); 60\tWARN_ON(inet_csk(sk)-\u0026gt;icsk_bind_hash != tb); 61\tret = 0; 62 63fail_unlock: 64\tspin_unlock_bh(\u0026amp;head-\u0026gt;lock); 65\treturn ret; 66} 67EXPORT_SYMBOL_GPL(inet_csk_get_port); inet_csk_bind_conflict进行绑定冲突判断 1/** 系统调用栈 2inet_csk_bind_conflict(const struct sock * sk, const struct inet_bind_bucket * tb, bool relax, bool reuseport_ok) (net/ipv4/inet_connection_sock.c:185) 3inet_csk_get_port(struct sock * sk, unsigned short snum) (net/ipv4/inet_connection_sock.c:409) 4__inet_bind(struct sock * sk, struct sockaddr * uaddr, int addr_len, u32 flags) (net/ipv4/af_inet.c:525) 5__sys_bind(int fd, struct sockaddr * umyaddr, int addrlen) (net/socket.c:1776) 6__do_sys_bind(int addrlen, struct sockaddr * umyaddr, int fd) (net/socket.c:1787) 7__se_sys_bind(long addrlen, long umyaddr, long fd) (net/socket.c:1785) 8__x64_sys_bind(const struct pt_regs * regs) (net/socket.c:1785) 9do_syscall_x64(int nr, struct pt_regs * regs) (arch/x86/entry/common.c:50) 10do_syscall_64(struct pt_regs * regs, int nr) (arch/x86/entry/common.c:80) 11entry_SYSCALL_64() (arch/x86/entry/entry_64.S:120) 12fixed_percpu_data (Unknown Source:0) 13[Unknown/Just-In-Time compiled code] (Unknown Source:0) 14 */ 15int inet_csk_bind_conflict(const struct sock *sk, 16\tconst struct inet_bind_bucket *tb, 17\tbool relax, bool reuseport_ok) 18{ 19\tstruct sock *sk2; 20\tbool reuseport_cb_ok; 21\tbool reuse = sk-\u0026gt;sk_reuse; 22\tbool reuseport = !!sk-\u0026gt;sk_reuseport; 23\tstruct sock_reuseport *reuseport_cb; 24\tkuid_t uid = sock_i_uid((struct sock *)sk); 25 26\trcu_read_lock(); 27\treuseport_cb = rcu_dereference(sk-\u0026gt;sk_reuseport_cb); 28\t/* paired with WRITE_ONCE() in __reuseport_(add|detach)_closed_sock */ 29\treuseport_cb_ok = !reuseport_cb || READ_ONCE(reuseport_cb-\u0026gt;num_closed_socks); 30\trcu_read_unlock(); 31 32\t/* 33\t* Unlike other sk lookup places we do not check 34\t* for sk_net here, since _all_ the socks listed 35\t* in tb-\u0026gt;owners list belong to the same net - the 36\t* one this bucket belongs to. 37\t*/ 38 39\tsk_for_each_bound(sk2, \u0026amp;tb-\u0026gt;owners) { 40\tint bound_dev_if2; 41 42\tif (sk == sk2) 43\tcontinue; 44\tbound_dev_if2 = READ_ONCE(sk2-\u0026gt;sk_bound_dev_if); 45\tif ((!sk-\u0026gt;sk_bound_dev_if || 46\t!bound_dev_if2 || 47\tsk-\u0026gt;sk_bound_dev_if == bound_dev_if2)) { 48\tif (reuse \u0026amp;\u0026amp; sk2-\u0026gt;sk_reuse \u0026amp;\u0026amp; 49\tsk2-\u0026gt;sk_state != TCP_LISTEN) { 50\tif ((!relax || 51\t(!reuseport_ok \u0026amp;\u0026amp; 52\treuseport \u0026amp;\u0026amp; sk2-\u0026gt;sk_reuseport \u0026amp;\u0026amp; 53\treuseport_cb_ok \u0026amp;\u0026amp; 54\t(sk2-\u0026gt;sk_state == TCP_TIME_WAIT || 55\tuid_eq(uid, sock_i_uid(sk2))))) \u0026amp;\u0026amp; 56\tinet_rcv_saddr_equal(sk, sk2, true)) 57\tbreak; 58\t} else if (!reuseport_ok || 59\t!reuseport || !sk2-\u0026gt;sk_reuseport || 60\t!reuseport_cb_ok || 61\t(sk2-\u0026gt;sk_state != TCP_TIME_WAIT \u0026amp;\u0026amp; 62\t!uid_eq(uid, sock_i_uid(sk2)))) { 63\t// 这里是判断不能复用或tcp状态不是timewait才判断 64\t// 说明timewait状态是可以直接进行绑定源端口的 65 66\t// 端口已经被占用就会走到这个位置break掉，sk2有值，返回有冲突 67\tif (inet_rcv_saddr_equal(sk, sk2, true)) 68\tbreak; 69\t} 70\t} 71\t} 72\treturn sk2 != NULL; 73} 4. connect =\u0026gt; ops-\u0026gt;connect =\u0026gt; inet_stream_connect =\u0026gt; sk_prot-\u0026gt;connect # 4.1. 先看定义 # 调用到tcp_v4_connect 1// net/ipv4/tcp_ipv4.c 2struct proto tcp_prot = { 3\t... 4\t.connect\t= tcp_v4_connect, 5\t... 6}; 7EXPORT_SYMBOL(tcp_prot); 4.2. 发起连接的过程 # 1// net/ipv4/tcp_ipv4.c 2/* This will initiate an outgoing connection. */ 3int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len) 4{ 5\tstruct sockaddr_in *usin = (struct sockaddr_in *)uaddr; 6\tstruct inet_sock *inet = inet_sk(sk); 7\tstruct tcp_sock *tp = tcp_sk(sk); 8\t__be16 orig_sport, orig_dport; 9\t__be32 daddr, nexthop; 10\tstruct flowi4 *fl4; 11\tstruct rtable *rt; 12\tint err; 13\tstruct ip_options_rcu *inet_opt; 14\tstruct inet_timewait_death_row *tcp_death_row = sock_net(sk)-\u0026gt;ipv4.tcp_death_row; 15 16\tif (addr_len \u0026lt; sizeof(struct sockaddr_in)) 17\treturn -EINVAL; 18 19\tif (usin-\u0026gt;sin_family != AF_INET) 20\treturn -EAFNOSUPPORT; 21 22\tnexthop = daddr = usin-\u0026gt;sin_addr.s_addr; 23\tinet_opt = rcu_dereference_protected(inet-\u0026gt;inet_opt, 24\tlockdep_sock_is_held(sk)); 25\tif (inet_opt \u0026amp;\u0026amp; inet_opt-\u0026gt;opt.srr) { 26\tif (!daddr) 27\treturn -EINVAL; 28\tnexthop = inet_opt-\u0026gt;opt.faddr; 29\t} 30 31\torig_sport = inet-\u0026gt;inet_sport; 32\torig_dport = usin-\u0026gt;sin_port; 33\tfl4 = \u0026amp;inet-\u0026gt;cork.fl.u.ip4; 34\t// 根据路由找源地址，找网卡，使用网卡的ip 35\t// 端口为0时，这里还不会分配端口只找ip 36\trt = ip_route_connect(fl4, nexthop, inet-\u0026gt;inet_saddr, 37\tsk-\u0026gt;sk_bound_dev_if, IPPROTO_TCP, orig_sport, 38\torig_dport, sk); 39\tif (IS_ERR(rt)) { 40\terr = PTR_ERR(rt); 41\tif (err == -ENETUNREACH) 42\tIP_INC_STATS(sock_net(sk), IPSTATS_MIB_OUTNOROUTES); 43\treturn err; 44\t} 45 46\tif (rt-\u0026gt;rt_flags \u0026amp; (RTCF_MULTICAST | RTCF_BROADCAST)) { 47\tip_rt_put(rt); 48\treturn -ENETUNREACH; 49\t} 50 51\tif (!inet_opt || !inet_opt-\u0026gt;opt.srr) 52\tdaddr = fl4-\u0026gt;daddr; 53 54\tif (!inet-\u0026gt;inet_saddr) 55\tinet-\u0026gt;inet_saddr = fl4-\u0026gt;saddr; 56\tsk_rcv_saddr_set(sk, inet-\u0026gt;inet_saddr); 57 58\tif (tp-\u0026gt;rx_opt.ts_recent_stamp \u0026amp;\u0026amp; inet-\u0026gt;inet_daddr != daddr) { 59\t/* Reset inherited state */ 60\ttp-\u0026gt;rx_opt.ts_recent\t= 0; 61\ttp-\u0026gt;rx_opt.ts_recent_stamp = 0; 62\tif (likely(!tp-\u0026gt;repair)) 63\tWRITE_ONCE(tp-\u0026gt;write_seq, 0); 64\t} 65 66\tinet-\u0026gt;inet_dport = usin-\u0026gt;sin_port; 67\tsk_daddr_set(sk, daddr); 68 69\tinet_csk(sk)-\u0026gt;icsk_ext_hdr_len = 0; 70\tif (inet_opt) 71\tinet_csk(sk)-\u0026gt;icsk_ext_hdr_len = inet_opt-\u0026gt;opt.optlen; 72 73\ttp-\u0026gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT; 74 75\t/* Socket identity is still unknown (sport may be zero). 76\t* However we set state to SYN-SENT and not releasing socket 77\t* lock select source port, enter ourselves into the hash tables and 78\t* complete initialization after this. 79\t*/ 80\ttcp_set_state(sk, TCP_SYN_SENT); 81\t// 这里对于没有源端口（源端口为0）的会进行端口绑定 82\terr = inet_hash_connect(tcp_death_row, sk); 83\tif (err) 84\tgoto failure; 85 86\tsk_set_txhash(sk); 87 88\trt = ip_route_newports(fl4, rt, orig_sport, orig_dport, 89\tinet-\u0026gt;inet_sport, inet-\u0026gt;inet_dport, sk); 90\tif (IS_ERR(rt)) { 91\terr = PTR_ERR(rt); 92\trt = NULL; 93\tgoto failure; 94\t} 95\t/* OK, now commit destination to socket. */ 96\tsk-\u0026gt;sk_gso_type = SKB_GSO_TCPV4; 97\tsk_setup_caps(sk, \u0026amp;rt-\u0026gt;dst); 98\trt = NULL; 99 100\tif (likely(!tp-\u0026gt;repair)) { 101\tif (!tp-\u0026gt;write_seq) 102\tWRITE_ONCE(tp-\u0026gt;write_seq, 103\tsecure_tcp_seq(inet-\u0026gt;inet_saddr, 104\tinet-\u0026gt;inet_daddr, 105\tinet-\u0026gt;inet_sport, 106\tusin-\u0026gt;sin_port)); 107\ttp-\u0026gt;tsoffset = secure_tcp_ts_off(sock_net(sk), 108\tinet-\u0026gt;inet_saddr, 109\tinet-\u0026gt;inet_daddr); 110\t} 111 112\tinet-\u0026gt;inet_id = prandom_u32(); 113 114\tif (tcp_fastopen_defer_connect(sk, \u0026amp;err)) 115\treturn err; 116\tif (err) 117\tgoto failure; 118 119\t// 发起sync包 120\terr = tcp_connect(sk); 121 122\tif (err) 123\tgoto failure; 124 125\treturn 0; 126 127failure: 128\t/* 129\t* This unhashes the socket and releases the local port, 130\t* if necessary. 131\t*/ 132\ttcp_set_state(sk, TCP_CLOSE); 133\tip_rt_put(rt); 134\tsk-\u0026gt;sk_route_caps = 0; 135\tinet-\u0026gt;inet_dport = 0; 136\treturn err; 137} 138EXPORT_SYMBOL(tcp_v4_connect); 1) inet_hash_connect 绑定端口 # 1// net/ipv4/inet_hashtables.c 2/* 3 * Bind a port for a connect operation and hash it. 4 */ 5int inet_hash_connect(struct inet_timewait_death_row *death_row, 6\tstruct sock *sk) 7{ 8\tu64 port_offset = 0; 9 10\tif (!inet_sk(sk)-\u0026gt;inet_num) 11\tport_offset = inet_sk_port_offset(sk); 12\treturn __inet_hash_connect(death_row, sk, port_offset, 13\t__inet_check_established); 14} 15EXPORT_SYMBOL_GPL(inet_hash_connect); 直接调用到__inet_hash_connect 1/* 2__inet_hash_connect(struct inet_timewait_death_row * death_row, struct sock * sk, u64 port_offset, int (*)(struct inet_timewait_death_row *, struct sock *, __u16, struct inet_timewait_sock **) check_established) (net/ipv4/inet_hashtables.c:727) 3inet_hash_connect(struct inet_timewait_death_row * death_row, struct sock * sk) (net/ipv4/inet_hashtables.c:825) 4tcp_v4_connect(struct sock * sk, struct sockaddr * uaddr, int addr_len) (net/ipv4/tcp_ipv4.c:276) 5__inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags, int is_sendmsg) (net/ipv4/af_inet.c:660) 6inet_stream_connect(struct socket * sock, struct sockaddr * uaddr, int addr_len, int flags) (net/ipv4/af_inet.c:724) 7__sys_connect(int fd, struct sockaddr * uservaddr, int addrlen) (net/socket.c:1996) 8__do_sys_connect(int addrlen, struct sockaddr * uservaddr, int fd) (net/socket.c:2006) 9__se_sys_connect(long addrlen, long uservaddr, long fd) (net/socket.c:2003) 10__x64_sys_connect(const struct pt_regs * regs) (net/socket.c:2003) 11do_syscall_x64(int nr, struct pt_regs * regs) (arch/x86/entry/common.c:50) 12do_syscall_64(struct pt_regs * regs, int nr) (arch/x86/entry/common.c:80) 13entry_SYSCALL_64() (arch/x86/entry/entry_64.S:120) 14[Unknown/Just-In-Time compiled code] (Unknown Source:0) 15fixed_percpu_data (Unknown Source:0) 16[Unknown/Just-In-Time compiled code] (Unknown Source:0) 17fixed_percpu_data (Unknown Source:0) 18[Unknown/Just-In-Time compiled code] (Unknown Source:0) 19 */ 20int __inet_hash_connect(struct inet_timewait_death_row *death_row, 21\tstruct sock *sk, u64 port_offset, 22\tint (*check_established)(struct inet_timewait_death_row *, 23\tstruct sock *, __u16, struct inet_timewait_sock **)) 24{ 25\tstruct inet_hashinfo *hinfo = death_row-\u0026gt;hashinfo; 26\tstruct inet_timewait_sock *tw = NULL; 27\tstruct inet_bind_hashbucket *head; 28\tint port = inet_sk(sk)-\u0026gt;inet_num; 29\tstruct net *net = sock_net(sk); 30\tstruct inet_bind_bucket *tb; 31\tu32 remaining, offset; 32\tint ret, i, low, high; 33\tint l3mdev; 34\tu32 index; 35 36\tif (port) { 37\t// 有端口就在bind的hash表中查找此端口 38\thead = \u0026amp;hinfo-\u0026gt;bhash[inet_bhashfn(net, port, 39\thinfo-\u0026gt;bhash_size)]; 40\ttb = inet_csk(sk)-\u0026gt;icsk_bind_hash; 41\tspin_lock_bh(\u0026amp;head-\u0026gt;lock); 42\tif (sk_head(\u0026amp;tb-\u0026gt;owners) == sk \u0026amp;\u0026amp; !sk-\u0026gt;sk_bind_node.next) { 43\tinet_ehash_nolisten(sk, NULL, NULL); 44\tspin_unlock_bh(\u0026amp;head-\u0026gt;lock); 45\treturn 0; 46\t} 47\tspin_unlock(\u0026amp;head-\u0026gt;lock); 48\t/* No definite answer... Walk to established hash table */ 49\tret = check_established(death_row, sk, port, NULL); 50\tlocal_bh_enable(); 51\treturn ret; 52\t} 53 54\tl3mdev = inet_sk_bound_l3mdev(sk); 55 56\tinet_get_local_port_range(net, \u0026amp;low, \u0026amp;high); 57\thigh++; /* [32768, 60999] -\u0026gt; [32768, 61000[ */ 58\tremaining = high - low; 59\tif (likely(remaining \u0026gt; 1)) 60\tremaining \u0026amp;= ~1U; 61 62\tnet_get_random_once(table_perturb, 63\tINET_TABLE_PERTURB_SIZE * sizeof(*table_perturb)); 64\tindex = port_offset \u0026amp; (INET_TABLE_PERTURB_SIZE - 1); 65 66\toffset = READ_ONCE(table_perturb[index]) + (port_offset \u0026gt;\u0026gt; 32); 67\toffset %= remaining; 68 69\t/* In first pass we try ports of @low parity. 70\t* inet_csk_get_port() does the opposite choice. 71\t*/ 72\toffset \u0026amp;= ~1U; 73other_parity_scan: 74\tport = low + offset; 75\t// 没端口就开始进行随机查找端口 76\tfor (i = 0; i \u0026lt; remaining; i += 2, port += 2) { 77\tif (unlikely(port \u0026gt;= high)) 78\tport -= remaining; 79\t// 排除保留端口 80\tif (inet_is_local_reserved_port(net, port)) 81\tcontinue; 82\t// 此端口先在bind的hash表中查找一下对应的链表 83\thead = \u0026amp;hinfo-\u0026gt;bhash[inet_bhashfn(net, port, 84\thinfo-\u0026gt;bhash_size)]; 85\tspin_lock_bh(\u0026amp;head-\u0026gt;lock); 86 87\t/* Does not bother with rcv_saddr checks, because 88\t* the established check is already unique enough. 89\t*/ 90\tinet_bind_bucket_for_each(tb, \u0026amp;head-\u0026gt;chain) { 91\tif (net_eq(ib_net(tb), net) \u0026amp;\u0026amp; tb-\u0026gt;l3mdev == l3mdev \u0026amp;\u0026amp; 92\ttb-\u0026gt;port == port) { 93\tif (tb-\u0026gt;fastreuse \u0026gt;= 0 || 94\ttb-\u0026gt;fastreuseport \u0026gt;= 0) 95\tgoto next_port; 96\tWARN_ON(hlist_empty(\u0026amp;tb-\u0026gt;owners)); 97\tif (!check_established(death_row, sk, 98\tport, \u0026amp;tw)) 99\tgoto ok; 100\tgoto next_port; 101\t} 102\t} 103 104\t// 这里是说明此源端口没有在bind的hash表中，新建一个此端口的hash桶 105\ttb = inet_bind_bucket_create(hinfo-\u0026gt;bind_bucket_cachep, 106\tnet, head, port, l3mdev); 107\tif (!tb) { 108\tspin_unlock_bh(\u0026amp;head-\u0026gt;lock); 109\treturn -ENOMEM; 110\t} 111\ttb-\u0026gt;fastreuse = -1; 112\ttb-\u0026gt;fastreuseport = -1; 113\tgoto ok; 114next_port: 115\tspin_unlock_bh(\u0026amp;head-\u0026gt;lock); 116\tcond_resched(); 117\t} 118 119\toffset++; 120\tif ((offset \u0026amp; 1) \u0026amp;\u0026amp; remaining \u0026gt; 1) 121\tgoto other_parity_scan; 122 123\treturn -EADDRNOTAVAIL; 124 125ok: 126\t/* Here we want to add a little bit of randomness to the next source 127\t* port that will be chosen. We use a max() with a random here so that 128\t* on low contention the randomness is maximal and on high contention 129\t* it may be inexistent. 130\t*/ 131\ti = max_t(int, i, (prandom_u32() \u0026amp; 7) * 2); 132\tWRITE_ONCE(table_perturb[index], READ_ONCE(table_perturb[index]) + i + 2); 133 134\t/* Head lock still held and bh\u0026#39;s disabled */ 135\t// 在找到的bind表中此端口对应的tb表中存一下sk 136\tinet_bind_hash(sk, tb, port); 137\tif (sk_unhashed(sk)) { 138\tinet_sk(sk)-\u0026gt;inet_sport = htons(port); 139\t// 在establish的表中存一下 140\tinet_ehash_nolisten(sk, (struct sock *)tw, NULL); 141\t} 142\tif (tw) 143\tinet_twsk_bind_unhash(tw, hinfo); 144\tspin_unlock(\u0026amp;head-\u0026gt;lock); 145\tif (tw) 146\tinet_twsk_deschedule_put(tw); 147\tlocal_bh_enable(); 148\treturn 0; 149} 五、tcp处理网卡收到的包 # 1. 注册tcp的recv到ip层协议栈 # 1// net/ipv4/af_inet.c 2static const struct net_protocol tcp_protocol = { 3\t.handler\t=\ttcp_v4_rcv, 4\t.err_handler\t=\ttcp_v4_err, 5\t.no_policy\t=\t1, 6\t.icmp_strict_tag_validation = 1, 7}; 8... 9static int __init inet_init(void) 10{ 11... 12\tif (inet_add_protocol(\u0026amp;tcp_protocol, IPPROTO_TCP) \u0026lt; 0) 13\tpr_crit(\u0026#34;%s: Cannot add TCP protocol\\n\u0026#34;, __func__); 14... 15} 2. tcp_v4_rcv 收到包后的处理 # 1// net/ipv4/tcp_ipv4.c 2/* 3 *\tFrom tcp_input.c 4 */ 5 6int tcp_v4_rcv(struct sk_buff *skb) 7{ 8\tstruct net *net = dev_net(skb-\u0026gt;dev); 9\tenum skb_drop_reason drop_reason; 10\tint sdif = inet_sdif(skb); 11\tint dif = inet_iif(skb); 12\tconst struct iphdr *iph; 13\tconst struct tcphdr *th; 14\tbool refcounted; 15\tstruct sock *sk; 16\tint ret; 17 18\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED; 19\tif (skb-\u0026gt;pkt_type != PACKET_HOST) 20\tgoto discard_it; 21 22\t/* Count it even if it\u0026#39;s bad */ 23\t__TCP_INC_STATS(net, TCP_MIB_INSEGS); 24 25\tif (!pskb_may_pull(skb, sizeof(struct tcphdr))) 26\tgoto discard_it; 27 28\tth = (const struct tcphdr *)skb-\u0026gt;data; 29 30\tif (unlikely(th-\u0026gt;doff \u0026lt; sizeof(struct tcphdr) / 4)) { 31\tdrop_reason = SKB_DROP_REASON_PKT_TOO_SMALL; 32\tgoto bad_packet; 33\t} 34\tif (!pskb_may_pull(skb, th-\u0026gt;doff * 4)) 35\tgoto discard_it; 36 37\t/* An explanation is required here, I think. 38\t* Packet length and doff are validated by header prediction, 39\t* provided case of th-\u0026gt;doff==0 is eliminated. 40\t* So, we defer the checks. */ 41 42\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo)) 43\tgoto csum_error; 44 45\tth = (const struct tcphdr *)skb-\u0026gt;data; 46\tiph = ip_hdr(skb); 47lookup: 48\t// 拿到包后，根据目的地址和源地址查找有没有socket 49\tsk = __inet_lookup_skb(\u0026amp;tcp_hashinfo, skb, __tcp_hdrlen(th), th-\u0026gt;source, 50\tth-\u0026gt;dest, sdif, \u0026amp;refcounted); 51 52\t// 没查到就走no_tcp_socket 53\tif (!sk) 54\tgoto no_tcp_socket; 55 56process: 57\tif (sk-\u0026gt;sk_state == TCP_TIME_WAIT) 58\tgoto do_time_wait; 59 60\tif (sk-\u0026gt;sk_state == TCP_NEW_SYN_RECV) { 61\tstruct request_sock *req = inet_reqsk(sk); 62\tbool req_stolen = false; 63\tstruct sock *nsk; 64 65\tsk = req-\u0026gt;rsk_listener; 66\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) 67\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY; 68\telse 69\tdrop_reason = tcp_inbound_md5_hash(sk, skb, 70\t\u0026amp;iph-\u0026gt;saddr, \u0026amp;iph-\u0026gt;daddr, 71\tAF_INET, dif, sdif); 72\tif (unlikely(drop_reason)) { 73\tsk_drops_add(sk, skb); 74\treqsk_put(req); 75\tgoto discard_it; 76\t} 77\tif (tcp_checksum_complete(skb)) { 78\treqsk_put(req); 79\tgoto csum_error; 80\t} 81\tif (unlikely(sk-\u0026gt;sk_state != TCP_LISTEN)) { 82\tnsk = reuseport_migrate_sock(sk, req_to_sk(req), skb); 83\tif (!nsk) { 84\tinet_csk_reqsk_queue_drop_and_put(sk, req); 85\tgoto lookup; 86\t} 87\tsk = nsk; 88\t/* reuseport_migrate_sock() has already held one sk_refcnt 89\t* before returning. 90\t*/ 91\t} else { 92\t/* We own a reference on the listener, increase it again 93\t* as we might lose it too soon. 94\t*/ 95\tsock_hold(sk); 96\t} 97\trefcounted = true; 98\tnsk = NULL; 99\tif (!tcp_filter(sk, skb)) { 100\tth = (const struct tcphdr *)skb-\u0026gt;data; 101\tiph = ip_hdr(skb); 102\ttcp_v4_fill_cb(skb, iph, th); 103\tnsk = tcp_check_req(sk, skb, req, false, \u0026amp;req_stolen); 104\t} else { 105\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER; 106\t} 107\tif (!nsk) { 108\treqsk_put(req); 109\tif (req_stolen) { 110\t/* Another cpu got exclusive access to req 111\t* and created a full blown socket. 112\t* Try to feed this packet to this socket 113\t* instead of discarding it. 114\t*/ 115\ttcp_v4_restore_cb(skb); 116\tsock_put(sk); 117\tgoto lookup; 118\t} 119\tgoto discard_and_relse; 120\t} 121\tnf_reset_ct(skb); 122\tif (nsk == sk) { 123\treqsk_put(req); 124\ttcp_v4_restore_cb(skb); 125\t} else if (tcp_child_process(sk, nsk, skb)) { 126\ttcp_v4_send_reset(nsk, skb); 127\tgoto discard_and_relse; 128\t} else { 129\tsock_put(sk); 130\treturn 0; 131\t} 132\t} 133 134\tif (static_branch_unlikely(\u0026amp;ip4_min_ttl)) { 135\t/* min_ttl can be changed concurrently from do_ip_setsockopt() */ 136\tif (unlikely(iph-\u0026gt;ttl \u0026lt; READ_ONCE(inet_sk(sk)-\u0026gt;min_ttl))) { 137\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP); 138\tgoto discard_and_relse; 139\t} 140\t} 141 142\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb)) { 143\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY; 144\tgoto discard_and_relse; 145\t} 146 147\tdrop_reason = tcp_inbound_md5_hash(sk, skb, \u0026amp;iph-\u0026gt;saddr, 148\t\u0026amp;iph-\u0026gt;daddr, AF_INET, dif, sdif); 149\tif (drop_reason) 150\tgoto discard_and_relse; 151 152\tnf_reset_ct(skb); 153 154\tif (tcp_filter(sk, skb)) { 155\tdrop_reason = SKB_DROP_REASON_SOCKET_FILTER; 156\tgoto discard_and_relse; 157\t} 158\tth = (const struct tcphdr *)skb-\u0026gt;data; 159\tiph = ip_hdr(skb); 160\ttcp_v4_fill_cb(skb, iph, th); 161 162\tskb-\u0026gt;dev = NULL; 163 164\tif (sk-\u0026gt;sk_state == TCP_LISTEN) { 165\tret = tcp_v4_do_rcv(sk, skb); 166\tgoto put_and_return; 167\t} 168 169\tsk_incoming_cpu_update(sk); 170 171\tbh_lock_sock_nested(sk); 172\ttcp_segs_in(tcp_sk(sk), skb); 173\tret = 0; 174\tif (!sock_owned_by_user(sk)) { 175\tret = tcp_v4_do_rcv(sk, skb); 176\t} else { 177\tif (tcp_add_backlog(sk, skb, \u0026amp;drop_reason)) 178\tgoto discard_and_relse; 179\t} 180\tbh_unlock_sock(sk); 181 182put_and_return: 183\tif (refcounted) 184\tsock_put(sk); 185 186\treturn ret; 187 188no_tcp_socket: 189\tdrop_reason = SKB_DROP_REASON_NO_SOCKET; 190\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) 191\tgoto discard_it; 192 193\ttcp_v4_fill_cb(skb, iph, th); 194 195\tif (tcp_checksum_complete(skb)) { 196csum_error: 197\tdrop_reason = SKB_DROP_REASON_TCP_CSUM; 198\ttrace_tcp_bad_csum(skb); 199\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS); 200bad_packet: 201\t__TCP_INC_STATS(net, TCP_MIB_INERRS); 202\t} else { 203\ttcp_v4_send_reset(NULL, skb); 204\t} 205 206discard_it: 207\tSKB_DR_OR(drop_reason, NOT_SPECIFIED); 208\t/* Discard frame. */ 209\tkfree_skb_reason(skb, drop_reason); 210\treturn 0; 211 212discard_and_relse: 213\tsk_drops_add(sk, skb); 214\tif (refcounted) 215\tsock_put(sk); 216\tgoto discard_it; 217 218do_time_wait: 219\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) { 220\tdrop_reason = SKB_DROP_REASON_XFRM_POLICY; 221\tinet_twsk_put(inet_twsk(sk)); 222\tgoto discard_it; 223\t} 224 225\ttcp_v4_fill_cb(skb, iph, th); 226 227\tif (tcp_checksum_complete(skb)) { 228\tinet_twsk_put(inet_twsk(sk)); 229\tgoto csum_error; 230\t} 231\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) { 232\tcase TCP_TW_SYN: { 233\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb-\u0026gt;dev), 234\t\u0026amp;tcp_hashinfo, skb, 235\t__tcp_hdrlen(th), 236\tiph-\u0026gt;saddr, th-\u0026gt;source, 237\tiph-\u0026gt;daddr, th-\u0026gt;dest, 238\tinet_iif(skb), 239\tsdif); 240\tif (sk2) { 241\tinet_twsk_deschedule_put(inet_twsk(sk)); 242\tsk = sk2; 243\ttcp_v4_restore_cb(skb); 244\trefcounted = false; 245\tgoto process; 246\t} 247\t} 248\t/* to ACK */ 249\tfallthrough; 250\tcase TCP_TW_ACK: 251\ttcp_v4_timewait_ack(sk, skb); 252\tbreak; 253\tcase TCP_TW_RST: 254\ttcp_v4_send_reset(sk, skb); 255\tinet_twsk_deschedule_put(inet_twsk(sk)); 256\tgoto discard_it; 257\tcase TCP_TW_SUCCESS:; 258\t} 259\tgoto discard_it; 260} 3. tcp_v4_do_rcv socket为TCP_LISTEN状态（服务端监听socket） # 1// net/ipv4/tcp_ipv4.c 2INDIRECT_CALLABLE_DECLARE(struct dst_entry *ipv4_dst_check(struct dst_entry *, 3\tu32)); 4/* The socket must have it\u0026#39;s spinlock held when we get 5 * here, unless it is a TCP_LISTEN socket. 6 * 7 * We have a potential double-lock case here, so even when 8 * doing backlog processing we use the BH locking scheme. 9 * This is because we cannot sleep with the original spinlock 10 * held. 11 */ 12int tcp_v4_do_rcv(struct sock *sk, struct sk_buff *skb) 13{ 14\tenum skb_drop_reason reason; 15\tstruct sock *rsk; 16 17\tif (sk-\u0026gt;sk_state == TCP_ESTABLISHED) { /* Fast path */ 18\tstruct dst_entry *dst; 19 20\tdst = rcu_dereference_protected(sk-\u0026gt;sk_rx_dst, 21\tlockdep_sock_is_held(sk)); 22 23\tsock_rps_save_rxhash(sk, skb); 24\tsk_mark_napi_id(sk, skb); 25\tif (dst) { 26\tif (sk-\u0026gt;sk_rx_dst_ifindex != skb-\u0026gt;skb_iif || 27\t!INDIRECT_CALL_1(dst-\u0026gt;ops-\u0026gt;check, ipv4_dst_check, 28\tdst, 0)) { 29\tRCU_INIT_POINTER(sk-\u0026gt;sk_rx_dst, NULL); 30\tdst_release(dst); 31\t} 32\t} 33\ttcp_rcv_established(sk, skb); 34\treturn 0; 35\t} 36 37\treason = SKB_DROP_REASON_NOT_SPECIFIED; 38\tif (tcp_checksum_complete(skb)) 39\tgoto csum_err; 40 41\tif (sk-\u0026gt;sk_state == TCP_LISTEN) { 42\tstruct sock *nsk = tcp_v4_cookie_check(sk, skb); 43 44\tif (!nsk) 45\tgoto discard; 46\tif (nsk != sk) { 47\tif (tcp_child_process(sk, nsk, skb)) { 48\trsk = nsk; 49\tgoto reset; 50\t} 51\treturn 0; 52\t} 53\t} else 54\tsock_rps_save_rxhash(sk, skb); 55 56\tif (tcp_rcv_state_process(sk, skb)) { 57\trsk = sk; 58\tgoto reset; 59\t} 60\treturn 0; 61 62reset: 63\ttcp_v4_send_reset(rsk, skb); 64discard: 65\tkfree_skb_reason(skb, reason); 66\t/* Be careful here. If this function gets more complicated and 67\t* gcc suffers from register pressure on the x86, sk (in %ebx) 68\t* might be destroyed here. This current version compiles correctly, 69\t* but you have been warned. 70\t*/ 71\treturn 0; 72 73csum_err: 74\treason = SKB_DROP_REASON_TCP_CSUM; 75\ttrace_tcp_bad_csum(skb); 76\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS); 77\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS); 78\tgoto discard; 79} 80EXPORT_SYMBOL(tcp_v4_do_rcv); tcp_rcv_state_process处理 1/* 2 *\tThis function implements the receiving procedure of RFC 793 for 3 *\tall states except ESTABLISHED and TIME_WAIT. 4 *\tIt\u0026#39;s called from both tcp_v4_rcv and tcp_v6_rcv and should be 5 *\taddress independent. 6 */ 7 8int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb) 9{ 10\t... 11\tswitch (sk-\u0026gt;sk_state) { 12\t... 13\tcase TCP_LISTEN: 14\t// TCP_LISTEN状态，说明此socket为服务端的监听socket 15\t// 收到客户端的ack，不合理，外部会回复rst 16\tif (th-\u0026gt;ack) 17\treturn 1; 18 19\t// 收到客户端的rst，直接丢包 20\tif (th-\u0026gt;rst) { 21\tSKB_DR_SET(reason, TCP_RESET); 22\tgoto discard; 23\t} 24\t// 收到syn包，说明是客户端请求连接上来 25\tif (th-\u0026gt;syn) { 26\tif (th-\u0026gt;fin) { 27\tSKB_DR_SET(reason, TCP_FLAGS); 28\tgoto discard; 29\t} 30\t/* It is possible that we process SYN packets from backlog, 31\t* so we need to make sure to disable BH and RCU right there. 32\t*/ 33\trcu_read_lock(); 34\tlocal_bh_disable(); 35\tacceptable = icsk-\u0026gt;icsk_af_ops-\u0026gt;conn_request(sk, skb) \u0026gt;= 0; 36\tlocal_bh_enable(); 37\trcu_read_unlock(); 38 39\tif (!acceptable) 40\treturn 1; 41\tconsume_skb(skb); 42\treturn 0; 43\t} 44\tSKB_DR_SET(reason, TCP_FLAGS); 45\tgoto discard; 46\t... 47\t} 48\t... 49discard: 50\ttcp_drop_reason(sk, skb, reason); 51\t} 52\treturn 0; 53 54consume: 55\t__kfree_skb(skb); 56\treturn 0; 57} 58EXPORT_SYMBOL(tcp_rcv_state_process); 在icsk-\u0026gt;icsk_af_ops-\u0026gt;conn_request中处理，注册在下面的位置 1// net/ipv4/tcp_ipv4.c 2/* 堆栈信息 3tcp_v4_init_sock(struct sock * sk) (net/ipv4/tcp_ipv4.c:2213) 4inet_create(int kern, int protocol, struct socket * sock, struct net * net) (net/ipv4/af_inet.c:377) 5inet_create(struct net * net, struct socket * sock, int protocol, int kern) (net/ipv4/af_inet.c:245) 6__sock_create(struct net * net, int family, int type, int protocol, struct socket ** res, int kern) (net/socket.c:1515) 7sock_create(struct socket ** res, int protocol, int type, int family) (net/socket.c:1566) 8__sys_socket_create(int protocol, int type, int family) (net/socket.c:1603) 9__sys_socket(int family, int type, int protocol) (net/socket.c:1636) 10__do_sys_socket(int protocol, int type, int family) (net/socket.c:1649) 11socket系统调用 12*/ 13/* NOTE: A lot of things set to zero explicitly by call to 14 * sk_alloc() so need not be done here. 15 */ 16static int tcp_v4_init_sock(struct sock *sk) 17{ 18\tstruct inet_connection_sock *icsk = inet_csk(sk); 19 20\ttcp_init_sock(sk); 21 22\ticsk-\u0026gt;icsk_af_ops = \u0026amp;ipv4_specific; 23 24#ifdef CONFIG_TCP_MD5SIG 25\ttcp_sk(sk)-\u0026gt;af_specific = \u0026amp;tcp_sock_ipv4_specific; 26#endif 27 28\treturn 0; 29} 六、tcp options # 1. 什么是tcp options # tcp头部固定长度为20字节，最大为60字节，此包为40字节，多出来的20字节就是Options options满足tlv格式，其中length包含kind、length本身（固定一个字节）、value的总长度 tcp options相关定义 1// include/net/tcp.h 2/* 3 *\tTCP option 4 */ 5// 写入到tcp option的kind字段中的值 6#define TCPOPT_NOP\t1\t/* Padding */ 7#define TCPOPT_EOL\t0\t/* End of options */ 8#define TCPOPT_MSS\t2\t/* Segment size negotiating */ 9#define TCPOPT_WINDOW\t3\t/* Window scaling */ 10#define TCPOPT_SACK_PERM 4 /* SACK Permitted */ 11#define TCPOPT_SACK 5 /* SACK Block */ 12#define TCPOPT_TIMESTAMP\t8\t/* Better RTT estimations/PAWS */ 13#define TCPOPT_MD5SIG\t19\t/* MD5 Signature (RFC2385) */ 14#define TCPOPT_FASTOPEN\t34\t/* Fast open (RFC7413) */ 15#define TCPOPT_EXP\t254\t/* Experimental */ 16/* Magic number to be after the option value for sharing TCP 17 * experimental options. See draft-ietf-tcpm-experimental-options-00.txt 18 */ 19#define TCPOPT_FASTOPEN_MAGIC\t0xF989 20#define TCPOPT_SMC_MAGIC\t0xE2D4C3D9 21 22/* 23 * TCP option lengths 24 */ 25// 对应tcp option的长度，写入到tcp option的len中，包含kind、len、value长度 26#define TCPOLEN_MSS 4 27#define TCPOLEN_WINDOW 3 28#define TCPOLEN_SACK_PERM 2 29#define TCPOLEN_TIMESTAMP 10 30#define TCPOLEN_MD5SIG 18 31#define TCPOLEN_FASTOPEN_BASE 2 32#define TCPOLEN_EXP_FASTOPEN_BASE 4 33#define TCPOLEN_EXP_SMC_BASE 6 34 35/* But this is what stacks really send out. */ 36// 这个是用于占位，是len的4字节对齐后的长度，不足的会在前面使用TCPOPT_NOP添加Padding 37#define TCPOLEN_TSTAMP_ALIGNED\t12 38#define TCPOLEN_WSCALE_ALIGNED\t4 39#define TCPOLEN_SACKPERM_ALIGNED\t4 40#define TCPOLEN_SACK_BASE\t2 41#define TCPOLEN_SACK_BASE_ALIGNED\t4 42#define TCPOLEN_SACK_PERBLOCK\t8 43#define TCPOLEN_MD5SIG_ALIGNED\t20 44#define TCPOLEN_MSS_ALIGNED\t4 45#define TCPOLEN_EXP_SMC_BASE_ALIGNED\t8 2. tcp options在内核中如何生成的 # tcp发送数据包的函数为tcp_transmit_skb\n1// net/ipv4/tcp_output.c 2static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it, 3\tgfp_t gfp_mask) 4{ 5\treturn __tcp_transmit_skb(sk, skb, clone_it, gfp_mask, 6\ttcp_sk(sk)-\u0026gt;rcv_nxt); 7} 构造数据包的过程中会计算头部保留一部分空间给tcp_options 1// net/ipv4/tcp_output.c 2/* This routine actually transmits TCP packets queued in by 3 * tcp_do_sendmsg(). This is used by both the initial 4 * transmission and possible later retransmissions. 5 * All SKB\u0026#39;s seen here are completely headerless. It is our 6 * job to build the TCP header, and pass the packet down to 7 * IP so it can do the same plus pass the packet off to the 8 * device. 9 * 10 * We are working here with either a clone of the original 11 * SKB, or a fresh unique copy made by the retransmit engine. 12 */ 13static int __tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, 14\tint clone_it, gfp_t gfp_mask, u32 rcv_nxt) 15{ 16\t... 17\tstruct tcp_out_options opts; 18\tunsigned int tcp_options_size, tcp_header_size; 19 ... 20\tmemset(\u0026amp;opts, 0, sizeof(opts)); 21 22\tif (unlikely(tcb-\u0026gt;tcp_flags \u0026amp; TCPHDR_SYN)) { 23\ttcp_options_size = tcp_syn_options(sk, skb, \u0026amp;opts, \u0026amp;md5); 24\t} else { 25\ttcp_options_size = tcp_established_options(sk, skb, \u0026amp;opts, 26\t\u0026amp;md5); 27\t/* Force a PSH flag on all (GSO) packets to expedite GRO flush 28\t* at receiver : This slightly improve GRO performance. 29\t* Note that we do not force the PSH flag for non GSO packets, 30\t* because they might be sent under high congestion events, 31\t* and in this case it is better to delay the delivery of 1-MSS 32\t* packets and thus the corresponding ACK packet that would 33\t* release the following packet. 34\t*/ 35\tif (tcp_skb_pcount(skb) \u0026gt; 1) 36\ttcb-\u0026gt;tcp_flags |= TCPHDR_PSH; 37\t} 38\ttcp_header_size = tcp_options_size + sizeof(struct tcphdr); 39 ... 40\tskb_push(skb, tcp_header_size); 41\tskb_reset_transport_header(skb); 42 43\tskb_orphan(skb); 44\tskb-\u0026gt;sk = sk; 45\tskb-\u0026gt;destructor = skb_is_tcp_pure_ack(skb) ? __sock_wfree : tcp_wfree; 46\trefcount_add(skb-\u0026gt;truesize, \u0026amp;sk-\u0026gt;sk_wmem_alloc); 47 48\tskb_set_dst_pending_confirm(skb, sk-\u0026gt;sk_dst_pending_confirm); 49 50 // 构造tcp头部信息 51\t/* Build TCP header and checksum it. */ 52\tth = (struct tcphdr *)skb-\u0026gt;data; 53\tth-\u0026gt;source\t= inet-\u0026gt;inet_sport; 54\tth-\u0026gt;dest\t= inet-\u0026gt;inet_dport; 55\tth-\u0026gt;seq\t= htonl(tcb-\u0026gt;seq); 56\tth-\u0026gt;ack_seq\t= htonl(rcv_nxt); 57\t*(((__be16 *)th) + 6)\t= htons(((tcp_header_size \u0026gt;\u0026gt; 2) \u0026lt;\u0026lt; 12) | 58\ttcb-\u0026gt;tcp_flags); 59 60\tth-\u0026gt;check\t= 0; 61\tth-\u0026gt;urg_ptr\t= 0; 62 ... 63\ttcp_options_write(th, tp, \u0026amp;opts); 64 ... 65\t/* BPF prog is the last one writing header option */ 66\tbpf_skops_write_hdr_opt(sk, skb, NULL, NULL, 0, \u0026amp;opts); 67 ... 68 // 添加到发送队列 69\ttcp_add_tx_delay(skb, tp); 70 71\terr = INDIRECT_CALL_INET(icsk-\u0026gt;icsk_af_ops-\u0026gt;queue_xmit, 72\tinet6_csk_xmit, ip_queue_xmit, 73\tsk, skb, \u0026amp;inet-\u0026gt;cork.fl); 74 75\tif (unlikely(err \u0026gt; 0)) { 76\ttcp_enter_cwr(sk); 77\terr = net_xmit_eval(err); 78\t} 79\tif (!err \u0026amp;\u0026amp; oskb) { 80\ttcp_update_skb_after_send(sk, oskb, prior_wstamp); 81\ttcp_rate_skb_sent(sk, oskb); 82\t} 83\treturn err; 84} tcp_options_write用于写入options 上面的计算options头部大小分为两个阶段，一个是syn包，一个是建立时，也就是三次握手的最后一个ack包 bpf存在接口可以进行添加options，但是bpf的这个接口仅在高版本内核存在，4.19.181内核没有 先看tcp option的定义 1// net/ipv4/tcp_output.c 2// 这个只是定义在OPTIONS的bit位，非tcp option中的kind 3#define OPTION_SACK_ADVERTISE\tBIT(0) 4#define OPTION_TS\tBIT(1) 5#define OPTION_MD5\tBIT(2) 6#define OPTION_WSCALE\tBIT(3) 7#define OPTION_FAST_OPEN_COOKIE\tBIT(8) 8#define OPTION_SMC\tBIT(9) 9#define OPTION_MPTCP\tBIT(10) 10... 11struct tcp_out_options { 12\tu16 options;\t/* bit field of OPTION_* */ 13\tu16 mss;\t/* 0 to disable */ 14\tu8 ws;\t/* window scale, 0 to disable */ 15\tu8 num_sack_blocks;\t/* number of SACK blocks to include */ 16\tu8 hash_size;\t/* bytes in hash_location */ 17\tu8 bpf_opt_len;\t/* length of BPF hdr option */ 18\t__u8 *hash_location;\t/* temporary pointer, overloaded */ 19\t__u32 tsval, tsecr;\t/* need to include OPTION_TS */ 20\tstruct tcp_fastopen_cookie *fastopen_cookie;\t/* Fast open cookie */ 21\tstruct mptcp_out_options mptcp; 22}; 查看设置tcp option的地方 1// include/net/tcp.h 2#define MAX_TCP_OPTION_SPACE 40 3 4// net/ipv4/tcp_output.c 5/* Compute TCP options for SYN packets. This is not the final 6 * network wire format yet. 7 */ 8// 返回options占用了多少字节 9static unsigned int tcp_syn_options(struct sock *sk, struct sk_buff *skb, 10\tstruct tcp_out_options *opts, 11\tstruct tcp_md5sig_key **md5) 12{ 13\tstruct tcp_sock *tp = tcp_sk(sk); 14\tunsigned int remaining = MAX_TCP_OPTION_SPACE; 15\tstruct tcp_fastopen_request *fastopen = tp-\u0026gt;fastopen_req; 16 17\t*md5 = NULL; 18#ifdef CONFIG_TCP_MD5SIG 19\tif (static_branch_unlikely(\u0026amp;tcp_md5_needed) \u0026amp;\u0026amp; 20\trcu_access_pointer(tp-\u0026gt;md5sig_info)) { 21\t*md5 = tp-\u0026gt;af_specific-\u0026gt;md5_lookup(sk, sk); 22\tif (*md5) { 23\topts-\u0026gt;options |= OPTION_MD5; 24\tremaining -= TCPOLEN_MD5SIG_ALIGNED; 25\t} 26\t} 27#endif 28 29\t/* We always get an MSS option. The option bytes which will be seen in 30\t* normal data packets should timestamps be used, must be in the MSS 31\t* advertised. But we subtract them from tp-\u0026gt;mss_cache so that 32\t* calculations in tcp_sendmsg are simpler etc. So account for this 33\t* fact here if necessary. If we don\u0026#39;t do this correctly, as a 34\t* receiver we won\u0026#39;t recognize data packets as being full sized when we 35\t* should, and thus we won\u0026#39;t abide by the delayed ACK rules correctly. 36\t* SACKs don\u0026#39;t matter, we never delay an ACK when we have any of those 37\t* going out. */ 38\topts-\u0026gt;mss = tcp_advertise_mss(sk); 39\tremaining -= TCPOLEN_MSS_ALIGNED; 40 41\tif (likely(READ_ONCE(sock_net(sk)-\u0026gt;ipv4.sysctl_tcp_timestamps) \u0026amp;\u0026amp; !*md5)) { 42\topts-\u0026gt;options |= OPTION_TS; 43\topts-\u0026gt;tsval = tcp_skb_timestamp(skb) + tp-\u0026gt;tsoffset; 44\topts-\u0026gt;tsecr = tp-\u0026gt;rx_opt.ts_recent; 45\tremaining -= TCPOLEN_TSTAMP_ALIGNED; 46\t} 47\tif (likely(READ_ONCE(sock_net(sk)-\u0026gt;ipv4.sysctl_tcp_window_scaling))) { 48\topts-\u0026gt;ws = tp-\u0026gt;rx_opt.rcv_wscale; 49\topts-\u0026gt;options |= OPTION_WSCALE; 50\tremaining -= TCPOLEN_WSCALE_ALIGNED; 51\t} 52\tif (likely(READ_ONCE(sock_net(sk)-\u0026gt;ipv4.sysctl_tcp_sack))) { 53\topts-\u0026gt;options |= OPTION_SACK_ADVERTISE; 54\tif (unlikely(!(OPTION_TS \u0026amp; opts-\u0026gt;options))) 55\tremaining -= TCPOLEN_SACKPERM_ALIGNED; 56\t} 57 58\tif (fastopen \u0026amp;\u0026amp; fastopen-\u0026gt;cookie.len \u0026gt;= 0) { 59\tu32 need = fastopen-\u0026gt;cookie.len; 60 61\tneed += fastopen-\u0026gt;cookie.exp ? TCPOLEN_EXP_FASTOPEN_BASE : 62\tTCPOLEN_FASTOPEN_BASE; 63\tneed = (need + 3) \u0026amp; ~3U; /* Align to 32 bits */ 64\tif (remaining \u0026gt;= need) { 65\topts-\u0026gt;options |= OPTION_FAST_OPEN_COOKIE; 66\topts-\u0026gt;fastopen_cookie = \u0026amp;fastopen-\u0026gt;cookie; 67\tremaining -= need; 68\ttp-\u0026gt;syn_fastopen = 1; 69\ttp-\u0026gt;syn_fastopen_exp = fastopen-\u0026gt;cookie.exp ? 1 : 0; 70\t} 71\t} 72 73\tsmc_set_option(tp, opts, \u0026amp;remaining); 74 75\tif (sk_is_mptcp(sk)) { 76\tunsigned int size; 77 78\tif (mptcp_syn_options(sk, skb, \u0026amp;size, \u0026amp;opts-\u0026gt;mptcp)) { 79\topts-\u0026gt;options |= OPTION_MPTCP; 80\tremaining -= size; 81\t} 82\t} 83 84\tbpf_skops_hdr_opt_len(sk, skb, NULL, NULL, 0, opts, \u0026amp;remaining); 85 86\treturn MAX_TCP_OPTION_SPACE - remaining; 87} 1/* Compute TCP options for ESTABLISHED sockets. This is not the 2 * final wire format yet. 3 */ 4static unsigned int tcp_established_options(struct sock *sk, struct sk_buff *skb, 5\tstruct tcp_out_options *opts, 6\tstruct tcp_md5sig_key **md5) 7{ 8\tstruct tcp_sock *tp = tcp_sk(sk); 9\tunsigned int size = 0; 10\tunsigned int eff_sacks; 11 12\topts-\u0026gt;options = 0; 13 14\t*md5 = NULL; 15#ifdef CONFIG_TCP_MD5SIG 16\tif (static_branch_unlikely(\u0026amp;tcp_md5_needed) \u0026amp;\u0026amp; 17\trcu_access_pointer(tp-\u0026gt;md5sig_info)) { 18\t*md5 = tp-\u0026gt;af_specific-\u0026gt;md5_lookup(sk, sk); 19\tif (*md5) { 20\topts-\u0026gt;options |= OPTION_MD5; 21\tsize += TCPOLEN_MD5SIG_ALIGNED; 22\t} 23\t} 24#endif 25 26\tif (likely(tp-\u0026gt;rx_opt.tstamp_ok)) { 27\topts-\u0026gt;options |= OPTION_TS; 28\topts-\u0026gt;tsval = skb ? tcp_skb_timestamp(skb) + tp-\u0026gt;tsoffset : 0; 29\topts-\u0026gt;tsecr = tp-\u0026gt;rx_opt.ts_recent; 30\tsize += TCPOLEN_TSTAMP_ALIGNED; 31\t} 32 33\t/* MPTCP options have precedence over SACK for the limited TCP 34\t* option space because a MPTCP connection would be forced to 35\t* fall back to regular TCP if a required multipath option is 36\t* missing. SACK still gets a chance to use whatever space is 37\t* left. 38\t*/ 39\tif (sk_is_mptcp(sk)) { 40\tunsigned int remaining = MAX_TCP_OPTION_SPACE - size; 41\tunsigned int opt_size = 0; 42 43\tif (mptcp_established_options(sk, skb, \u0026amp;opt_size, remaining, 44\t\u0026amp;opts-\u0026gt;mptcp)) { 45\topts-\u0026gt;options |= OPTION_MPTCP; 46\tsize += opt_size; 47\t} 48\t} 49 50\teff_sacks = tp-\u0026gt;rx_opt.num_sacks + tp-\u0026gt;rx_opt.dsack; 51\tif (unlikely(eff_sacks)) { 52\tconst unsigned int remaining = MAX_TCP_OPTION_SPACE - size; 53\tif (unlikely(remaining \u0026lt; TCPOLEN_SACK_BASE_ALIGNED + 54\tTCPOLEN_SACK_PERBLOCK)) 55\treturn size; 56 57\topts-\u0026gt;num_sack_blocks = 58\tmin_t(unsigned int, eff_sacks, 59\t(remaining - TCPOLEN_SACK_BASE_ALIGNED) / 60\tTCPOLEN_SACK_PERBLOCK); 61 62\tsize += TCPOLEN_SACK_BASE_ALIGNED + 63\topts-\u0026gt;num_sack_blocks * TCPOLEN_SACK_PERBLOCK; 64\t} 65 66\tif (unlikely(BPF_SOCK_OPS_TEST_FLAG(tp, 67\tBPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG))) { 68\tunsigned int remaining = MAX_TCP_OPTION_SPACE - size; 69 70\tbpf_skops_hdr_opt_len(sk, skb, NULL, NULL, 0, opts, \u0026amp;remaining); 71 72\tsize = MAX_TCP_OPTION_SPACE - remaining; 73\t} 74 75\treturn size; 76} 写options的函数 1/* Write previously computed TCP options to the packet. 2 * 3 * Beware: Something in the Internet is very sensitive to the ordering of 4 * TCP options, we learned this through the hard way, so be careful here. 5 * Luckily we can at least blame others for their non-compliance but from 6 * inter-operability perspective it seems that we\u0026#39;re somewhat stuck with 7 * the ordering which we have been using if we want to keep working with 8 * those broken things (not that it currently hurts anybody as there isn\u0026#39;t 9 * particular reason why the ordering would need to be changed). 10 * 11 * At least SACK_PERM as the first option is known to lead to a disaster 12 * (but it may well be that other scenarios fail similarly). 13 */ 14static void tcp_options_write(struct tcphdr *th, struct tcp_sock *tp, 15\tstruct tcp_out_options *opts) 16{ 17\t__be32 *ptr = (__be32 *)(th + 1); 18\tu16 options = opts-\u0026gt;options;\t/* mungable copy */ 19 20\tif (unlikely(OPTION_MD5 \u0026amp; options)) { 21\t*ptr++ = htonl((TCPOPT_NOP \u0026lt;\u0026lt; 24) | (TCPOPT_NOP \u0026lt;\u0026lt; 16) | 22\t(TCPOPT_MD5SIG \u0026lt;\u0026lt; 8) | TCPOLEN_MD5SIG); 23\t/* overload cookie hash location */ 24\topts-\u0026gt;hash_location = (__u8 *)ptr; 25\tptr += 4; 26\t} 27 28\tif (unlikely(opts-\u0026gt;mss)) { 29\t*ptr++ = htonl((TCPOPT_MSS \u0026lt;\u0026lt; 24) | 30\t(TCPOLEN_MSS \u0026lt;\u0026lt; 16) | 31\topts-\u0026gt;mss); 32\t} 33 34\tif (likely(OPTION_TS \u0026amp; options)) { 35\tif (unlikely(OPTION_SACK_ADVERTISE \u0026amp; options)) { 36\t*ptr++ = htonl((TCPOPT_SACK_PERM \u0026lt;\u0026lt; 24) | 37\t(TCPOLEN_SACK_PERM \u0026lt;\u0026lt; 16) | 38\t(TCPOPT_TIMESTAMP \u0026lt;\u0026lt; 8) | 39\tTCPOLEN_TIMESTAMP); 40\toptions \u0026amp;= ~OPTION_SACK_ADVERTISE; 41\t} else { 42\t*ptr++ = htonl((TCPOPT_NOP \u0026lt;\u0026lt; 24) | 43\t(TCPOPT_NOP \u0026lt;\u0026lt; 16) | 44\t(TCPOPT_TIMESTAMP \u0026lt;\u0026lt; 8) | 45\tTCPOLEN_TIMESTAMP); 46\t} 47\t*ptr++ = htonl(opts-\u0026gt;tsval); 48\t*ptr++ = htonl(opts-\u0026gt;tsecr); 49\t} 50 51\tif (unlikely(OPTION_SACK_ADVERTISE \u0026amp; options)) { 52\t*ptr++ = htonl((TCPOPT_NOP \u0026lt;\u0026lt; 24) | 53\t(TCPOPT_NOP \u0026lt;\u0026lt; 16) | 54\t(TCPOPT_SACK_PERM \u0026lt;\u0026lt; 8) | 55\tTCPOLEN_SACK_PERM); 56\t} 57 58\tif (unlikely(OPTION_WSCALE \u0026amp; options)) { 59\t*ptr++ = htonl((TCPOPT_NOP \u0026lt;\u0026lt; 24) | 60\t(TCPOPT_WINDOW \u0026lt;\u0026lt; 16) | 61\t(TCPOLEN_WINDOW \u0026lt;\u0026lt; 8) | 62\topts-\u0026gt;ws); 63\t} 64 65\tif (unlikely(opts-\u0026gt;num_sack_blocks)) { 66\tstruct tcp_sack_block *sp = tp-\u0026gt;rx_opt.dsack ? 67\ttp-\u0026gt;duplicate_sack : tp-\u0026gt;selective_acks; 68\tint this_sack; 69 70\t*ptr++ = htonl((TCPOPT_NOP \u0026lt;\u0026lt; 24) | 71\t(TCPOPT_NOP \u0026lt;\u0026lt; 16) | 72\t(TCPOPT_SACK \u0026lt;\u0026lt; 8) | 73\t(TCPOLEN_SACK_BASE + (opts-\u0026gt;num_sack_blocks * 74\tTCPOLEN_SACK_PERBLOCK))); 75 76\tfor (this_sack = 0; this_sack \u0026lt; opts-\u0026gt;num_sack_blocks; 77\t++this_sack) { 78\t*ptr++ = htonl(sp[this_sack].start_seq); 79\t*ptr++ = htonl(sp[this_sack].end_seq); 80\t} 81 82\ttp-\u0026gt;rx_opt.dsack = 0; 83\t} 84 85\tif (unlikely(OPTION_FAST_OPEN_COOKIE \u0026amp; options)) { 86\tstruct tcp_fastopen_cookie *foc = opts-\u0026gt;fastopen_cookie; 87\tu8 *p = (u8 *)ptr; 88\tu32 len; /* Fast Open option length */ 89 90\tif (foc-\u0026gt;exp) { 91\tlen = TCPOLEN_EXP_FASTOPEN_BASE + foc-\u0026gt;len; 92\t*ptr = htonl((TCPOPT_EXP \u0026lt;\u0026lt; 24) | (len \u0026lt;\u0026lt; 16) | 93\tTCPOPT_FASTOPEN_MAGIC); 94\tp += TCPOLEN_EXP_FASTOPEN_BASE; 95\t} else { 96\tlen = TCPOLEN_FASTOPEN_BASE + foc-\u0026gt;len; 97\t*p++ = TCPOPT_FASTOPEN; 98\t*p++ = len; 99\t} 100 101\tmemcpy(p, foc-\u0026gt;val, foc-\u0026gt;len); 102\tif ((len \u0026amp; 3) == 2) { 103\tp[foc-\u0026gt;len] = TCPOPT_NOP; 104\tp[foc-\u0026gt;len + 1] = TCPOPT_NOP; 105\t} 106\tptr += (len + 3) \u0026gt;\u0026gt; 2; 107\t} 108 109\tsmc_options_write(ptr, \u0026amp;options); 110 111\tmptcp_options_write(th, ptr, tp, opts); 112} 实现上都是每个option按照4字节对齐，不足补充NOP "},{"id":216,"href":"/docs/linux/linux-kernel/net/ipv4/udp/","title":"udp","section":"ipv4/ ipv4的处理部分","content":" 一、udp socket如何进行收包 # udp会注册udp_protocol到inet_protos里面 1// net/ipv4/af_inet.c 2static const struct net_protocol udp_protocol = { 3\t.handler =\tudp_rcv, 4\t.err_handler =\tudp_err, 5\t.no_policy =\t1, 6}; 7... 8static int __init inet_init(void) 9{ 10... 11\tif (inet_add_protocol(\u0026amp;udp_protocol, IPPROTO_UDP) \u0026lt; 0) 12\tpr_crit(\u0026#34;%s: Cannot add UDP protocol\\n\u0026#34;, __func__); 13... 14} ipv4里面分析了，当ip层收到驱动的包之后，根据IPPROTO_UDP找到udp_protocol，然后调用handler函数对应udp_rcv 1// net/ipv4/udp.c 2/* 3 *\tAll we need to do is get the socket, and then do a checksum. 4 */ 5// udp_rcv -call-\u0026gt; __udp4_lib_rcv 6int __udp4_lib_rcv(struct sk_buff *skb, struct udp_table *udptable, 7\tint proto) 8{ 9\tstruct sock *sk; 10\tstruct udphdr *uh; 11\tunsigned short ulen; 12\tstruct rtable *rt = skb_rtable(skb); 13\t__be32 saddr, daddr; 14\tstruct net *net = dev_net(skb-\u0026gt;dev); 15\tbool refcounted; 16\tint drop_reason; 17 18\tdrop_reason = SKB_DROP_REASON_NOT_SPECIFIED; 19 20\t/* 21\t* Validate the packet. 22\t*/ 23\tif (!pskb_may_pull(skb, sizeof(struct udphdr))) 24\tgoto drop;\t/* No space for header. */ 25 26\tuh = udp_hdr(skb); 27\tulen = ntohs(uh-\u0026gt;len); 28\tsaddr = ip_hdr(skb)-\u0026gt;saddr; 29\tdaddr = ip_hdr(skb)-\u0026gt;daddr; 30 31\tif (ulen \u0026gt; skb-\u0026gt;len) 32\tgoto short_packet; 33 34\tif (proto == IPPROTO_UDP) { 35\t/* UDP validates ulen. */ 36\tif (ulen \u0026lt; sizeof(*uh) || pskb_trim_rcsum(skb, ulen)) 37\tgoto short_packet; 38\tuh = udp_hdr(skb); 39\t} 40 41\t// 检查checksum 42\tif (udp4_csum_init(skb, uh, proto)) 43\tgoto csum_error; 44 45\tsk = skb_steal_sock(skb, \u0026amp;refcounted); 46\tif (sk) { 47\tstruct dst_entry *dst = skb_dst(skb); 48\tint ret; 49 50\tif (unlikely(rcu_dereference(sk-\u0026gt;sk_rx_dst) != dst)) 51\tudp_sk_rx_dst_set(sk, dst); 52 53\tret = udp_unicast_rcv_skb(sk, skb, uh); 54\tif (refcounted) 55\tsock_put(sk); 56\treturn ret; 57\t} 58 59 // 这里处理广播和多播场景 60\tif (rt-\u0026gt;rt_flags \u0026amp; (RTCF_BROADCAST|RTCF_MULTICAST)) 61\treturn __udp4_lib_mcast_deliver(net, skb, uh, 62\tsaddr, daddr, udptable, proto); 63 64 // 根据源地址和目的地址从udptable中找sk结构体 65\tsk = __udp4_lib_lookup_skb(skb, uh-\u0026gt;source, uh-\u0026gt;dest, udptable); 66 // 找到直接给对应的sk进行处理 67\tif (sk) 68\treturn udp_unicast_rcv_skb(sk, skb, uh); 69 70\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) 71\tgoto drop; 72\tnf_reset_ct(skb); 73 74\t/* No socket. Drop packet silently, if checksum is wrong */ 75\tif (udp_lib_checksum_complete(skb)) 76\tgoto csum_error; 77 78 // 没有socket对应此包，并且checksum是对的，会返回一个icmp目的地址和端口不可达信息 79\tdrop_reason = SKB_DROP_REASON_NO_SOCKET; 80\t__UDP_INC_STATS(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE); 81\ticmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, 0); 82 83\t/* 84\t* Hmm. We got an UDP packet to a port to which we 85\t* don\u0026#39;t wanna listen. Ignore it. 86\t*/ 87\tkfree_skb_reason(skb, drop_reason); 88\treturn 0; 89 90short_packet: 91\tdrop_reason = SKB_DROP_REASON_PKT_TOO_SMALL; 92\tnet_dbg_ratelimited(\u0026#34;UDP%s: short packet: From %pI4:%u %d/%d to %pI4:%u\\n\u0026#34;, 93\tproto == IPPROTO_UDPLITE ? \u0026#34;Lite\u0026#34; : \u0026#34;\u0026#34;, 94\t\u0026amp;saddr, ntohs(uh-\u0026gt;source), 95\tulen, skb-\u0026gt;len, 96\t\u0026amp;daddr, ntohs(uh-\u0026gt;dest)); 97\tgoto drop; 98 99csum_error: 100\t/* 101\t* RFC1122: OK. Discards the bad packet silently (as far as 102\t* the network is concerned, anyway) as per 4.1.3.4 (MUST). 103\t*/ 104\tdrop_reason = SKB_DROP_REASON_UDP_CSUM; 105\tnet_dbg_ratelimited(\u0026#34;UDP%s: bad checksum. From %pI4:%u to %pI4:%u ulen %d\\n\u0026#34;, 106\tproto == IPPROTO_UDPLITE ? \u0026#34;Lite\u0026#34; : \u0026#34;\u0026#34;, 107\t\u0026amp;saddr, ntohs(uh-\u0026gt;source), \u0026amp;daddr, ntohs(uh-\u0026gt;dest), 108\tulen); 109\t__UDP_INC_STATS(net, UDP_MIB_CSUMERRORS, proto == IPPROTO_UDPLITE); 110drop: 111\t__UDP_INC_STATS(net, UDP_MIB_INERRORS, proto == IPPROTO_UDPLITE); 112\tkfree_skb_reason(skb, drop_reason); 113\treturn 0; 114} 1. 如何查找sk结构体 # __udp4_lib_lookup_skb查找sock结构体 1// net/ipv4/udp.c 2static inline struct sock *__udp4_lib_lookup_skb(struct sk_buff *skb, 3\t__be16 sport, __be16 dport, 4\tstruct udp_table *udptable) 5{ 6\tconst struct iphdr *iph = ip_hdr(skb); 7 8\treturn __udp4_lib_lookup(dev_net(skb-\u0026gt;dev), iph-\u0026gt;saddr, sport, 9\tiph-\u0026gt;daddr, dport, inet_iif(skb), 10\tinet_sdif(skb), udptable, skb); 11} 12 13// net/ipv4/udp.c 14/* UDP is nearly always wildcards out the wazoo, it makes no sense to try 15 * harder than this. -DaveM 16 */ 17struct sock *__udp4_lib_lookup(struct net *net, __be32 saddr, 18\t__be16 sport, __be32 daddr, __be16 dport, int dif, 19\tint sdif, struct udp_table *udptable, struct sk_buff *skb) 20{ 21\tunsigned short hnum = ntohs(dport); 22\tunsigned int hash2, slot2; 23\tstruct udp_hslot *hslot2; 24\tstruct sock *result, *sk; 25 26\thash2 = ipv4_portaddr_hash(net, daddr, hnum); 27\tslot2 = hash2 \u0026amp; udptable-\u0026gt;mask; 28\thslot2 = \u0026amp;udptable-\u0026gt;hash2[slot2]; 29 30\t/* Lookup connected or non-wildcard socket */ 31\t// 根据源地址、源端口、目的地址、目的端口查找，这一步找的是有连接的 32\tresult = udp4_lib_lookup2(net, saddr, sport, 33\tdaddr, hnum, dif, sdif, 34\thslot2, skb); 35\tif (!IS_ERR_OR_NULL(result) \u0026amp;\u0026amp; result-\u0026gt;sk_state == TCP_ESTABLISHED) 36\tgoto done; 37 38\t/* Lookup redirect from BPF */ 39\tif (static_branch_unlikely(\u0026amp;bpf_sk_lookup_enabled)) { 40\tsk = udp4_lookup_run_bpf(net, udptable, skb, 41\tsaddr, sport, daddr, hnum, dif); 42\tif (sk) { 43\tresult = sk; 44\tgoto done; 45\t} 46\t} 47 48\t/* Got non-wildcard socket or error on first lookup */ 49\tif (result) 50\tgoto done; 51 52\t/* Lookup wildcard sockets */ 53\thash2 = ipv4_portaddr_hash(net, htonl(INADDR_ANY), hnum); 54\tslot2 = hash2 \u0026amp; udptable-\u0026gt;mask; 55\thslot2 = \u0026amp;udptable-\u0026gt;hash2[slot2]; 56\t// 上面找不到就找监听的socket，也就是目的地址为ANY的 57\tresult = udp4_lib_lookup2(net, saddr, sport, 58\thtonl(INADDR_ANY), hnum, dif, sdif, 59\thslot2, skb); 60done: 61\tif (IS_ERR(result)) 62\treturn NULL; 63\treturn result; 64} 65EXPORT_SYMBOL_GPL(__udp4_lib_lookup); 2. 找到sk结构体后做什么 # 1// net/ipv4/udp.c 2/* wrapper for udp_queue_rcv_skb tacking care of csum conversion and 3 * return code conversion for ip layer consumption 4 */ 5static int udp_unicast_rcv_skb(struct sock *sk, struct sk_buff *skb, 6\tstruct udphdr *uh) 7{ 8\tint ret; 9 10\tif (inet_get_convert_csum(sk) \u0026amp;\u0026amp; uh-\u0026gt;check \u0026amp;\u0026amp; !IS_UDPLITE(sk)) 11\tskb_checksum_try_convert(skb, IPPROTO_UDP, inet_compute_pseudo); 12 13\tret = udp_queue_rcv_skb(sk, skb); 14 15\t/* a return value \u0026gt; 0 means to resubmit the input, but 16\t* it wants the return to be -protocol, or 0 17\t*/ 18\tif (ret \u0026gt; 0) 19\treturn -ret; 20\treturn 0; 21} 调用udp_queue_rcv_skb 1// net/ipv4/udp.c 2static int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb) 3{ 4\tstruct sk_buff *next, *segs; 5\tint ret; 6 7\tif (likely(!udp_unexpected_gso(sk, skb))) 8\treturn udp_queue_rcv_one_skb(sk, skb); 9 10\tBUILD_BUG_ON(sizeof(struct udp_skb_cb) \u0026gt; SKB_GSO_CB_OFFSET); 11\t__skb_push(skb, -skb_mac_offset(skb)); 12\tsegs = udp_rcv_segment(sk, skb, true); 13\tskb_list_walk_safe(segs, skb, next) { 14\t__skb_pull(skb, skb_transport_offset(skb)); 15 16\tudp_post_segment_fix_csum(skb); 17\tret = udp_queue_rcv_one_skb(sk, skb); 18\tif (ret \u0026gt; 0) 19\tip_protocol_deliver_rcu(dev_net(skb-\u0026gt;dev), skb, ret); 20\t} 21\treturn 0; 22} 23 24// net/ipv4/udp.c 25/* returns: 26 * -1: error 27 * 0: success 28 * \u0026gt;0: \u0026#34;udp encap\u0026#34; protocol resubmission 29 * 30 * Note that in the success and error cases, the skb is assumed to 31 * have either been requeued or freed. 32 */ 33static int udp_queue_rcv_one_skb(struct sock *sk, struct sk_buff *skb) 34{ 35\t... 36\treturn __udp_queue_rcv_skb(sk, skb); 37 38csum_error: 39\tdrop_reason = SKB_DROP_REASON_UDP_CSUM; 40\t__UDP_INC_STATS(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite); 41drop: 42\t__UDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); 43\tatomic_inc(\u0026amp;sk-\u0026gt;sk_drops); 44\tkfree_skb_reason(skb, drop_reason); 45\treturn -1; 46} 47 48// net/ipv4/udp.c 49static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb) 50{ 51\tint rc; 52 53\tif (inet_sk(sk)-\u0026gt;inet_daddr) { 54\tsock_rps_save_rxhash(sk, skb); 55\tsk_mark_napi_id(sk, skb); 56\tsk_incoming_cpu_update(sk); 57\t} else { 58\tsk_mark_napi_id_once(sk, skb); 59\t} 60 61\trc = __udp_enqueue_schedule_skb(sk, skb); 62\tif (rc \u0026lt; 0) { 63\tint is_udplite = IS_UDPLITE(sk); 64\tint drop_reason; 65 66\t/* Note that an ENOMEM error is charged twice */ 67\tif (rc == -ENOMEM) { 68\tUDP_INC_STATS(sock_net(sk), UDP_MIB_RCVBUFERRORS, 69\tis_udplite); 70\tdrop_reason = SKB_DROP_REASON_SOCKET_RCVBUFF; 71\t} else { 72\tUDP_INC_STATS(sock_net(sk), UDP_MIB_MEMERRORS, 73\tis_udplite); 74\tdrop_reason = SKB_DROP_REASON_PROTO_MEM; 75\t} 76\tUDP_INC_STATS(sock_net(sk), UDP_MIB_INERRORS, is_udplite); 77\tkfree_skb_reason(skb, drop_reason); 78\ttrace_udp_fail_queue_rcv_skb(rc, sk); 79\treturn -1; 80\t} 81 82\treturn 0; 83} __udp_enqueue_schedule_skb将包插入到队列中 1int __udp_enqueue_schedule_skb(struct sock *sk, struct sk_buff *skb) 2{ 3\tstruct sk_buff_head *list = \u0026amp;sk-\u0026gt;sk_receive_queue; 4\tint rmem, delta, amt, err = -ENOMEM; 5\tspinlock_t *busy = NULL; 6\tint size; 7 8\t/* try to avoid the costly atomic add/sub pair when the receive 9\t* queue is full; always allow at least a packet 10\t*/ 11\trmem = atomic_read(\u0026amp;sk-\u0026gt;sk_rmem_alloc); 12\tif (rmem \u0026gt; sk-\u0026gt;sk_rcvbuf) 13\tgoto drop; 14 15\t/* Under mem pressure, it might be helpful to help udp_recvmsg() 16\t* having linear skbs : 17\t* - Reduce memory overhead and thus increase receive queue capacity 18\t* - Less cache line misses at copyout() time 19\t* - Less work at consume_skb() (less alien page frag freeing) 20\t*/ 21\tif (rmem \u0026gt; (sk-\u0026gt;sk_rcvbuf \u0026gt;\u0026gt; 1)) { 22\tskb_condense(skb); 23 24\tbusy = busylock_acquire(sk); 25\t} 26\tsize = skb-\u0026gt;truesize; 27\tudp_set_dev_scratch(skb); 28 29\t/* we drop only if the receive buf is full and the receive 30\t* queue contains some other skb 31\t*/ 32\trmem = atomic_add_return(size, \u0026amp;sk-\u0026gt;sk_rmem_alloc); 33\tif (rmem \u0026gt; (size + (unsigned int)sk-\u0026gt;sk_rcvbuf)) 34\tgoto uncharge_drop; 35 36\tspin_lock(\u0026amp;list-\u0026gt;lock); 37\tif (size \u0026gt;= sk-\u0026gt;sk_forward_alloc) { 38\tamt = sk_mem_pages(size); 39\tdelta = amt \u0026lt;\u0026lt; SK_MEM_QUANTUM_SHIFT; 40\tif (!__sk_mem_raise_allocated(sk, delta, amt, SK_MEM_RECV)) { 41\terr = -ENOBUFS; 42\tspin_unlock(\u0026amp;list-\u0026gt;lock); 43\tgoto uncharge_drop; 44\t} 45 46\tsk-\u0026gt;sk_forward_alloc += delta; 47\t} 48 49\tsk-\u0026gt;sk_forward_alloc -= size; 50 51\t/* no need to setup a destructor, we will explicitly release the 52\t* forward allocated memory on dequeue 53\t*/ 54\tsock_skb_set_dropcount(sk, skb); 55 56\t// 加入队列 57\t__skb_queue_tail(list, skb); 58\tspin_unlock(\u0026amp;list-\u0026gt;lock); 59 60\t// 唤醒一个线程进行处理 61\tif (!sock_flag(sk, SOCK_DEAD)) 62\tsk-\u0026gt;sk_data_ready(sk); 63 64\tbusylock_release(busy); 65\treturn 0; 66 67uncharge_drop: 68\tatomic_sub(skb-\u0026gt;truesize, \u0026amp;sk-\u0026gt;sk_rmem_alloc); 69 70drop: 71\tatomic_inc(\u0026amp;sk-\u0026gt;sk_drops); 72\tbusylock_release(busy); 73\treturn err; 74} 75EXPORT_SYMBOL_GPL(__udp_enqueue_schedule_skb); 3. 如何唤醒recvfrom函数 # 上面插入队列后调用sk-\u0026gt;sdk_data_read，此函数会唤醒一个等待队列的线程处理 二、recv做了什么 # 在这里进行睡眠 1// net/core/datagram.c 2/* 3 * Wait for the last received packet to be different from skb 4 */ 5int __skb_wait_for_more_packets(struct sock *sk, struct sk_buff_head *queue, 6\tint *err, long *timeo_p, 7\tconst struct sk_buff *skb) 8{ 9\tint error; 10\tDEFINE_WAIT_FUNC(wait, receiver_wake_function); 11 12\tprepare_to_wait_exclusive(sk_sleep(sk), \u0026amp;wait, TASK_INTERRUPTIBLE); 13 14\t/* Socket errors? */ 15\terror = sock_error(sk); 16\tif (error) 17\tgoto out_err; 18 19\tif (READ_ONCE(queue-\u0026gt;prev) != skb) 20\tgoto out; 21 22\t/* Socket shut down? */ 23\tif (sk-\u0026gt;sk_shutdown \u0026amp; RCV_SHUTDOWN) 24\tgoto out_noerr; 25 26\t/* Sequenced packets can come disconnected. 27\t* If so we report the problem 28\t*/ 29\terror = -ENOTCONN; 30\tif (connection_based(sk) \u0026amp;\u0026amp; 31\t!(sk-\u0026gt;sk_state == TCP_ESTABLISHED || sk-\u0026gt;sk_state == TCP_LISTEN)) 32\tgoto out_err; 33 34\t/* handle signals */ 35\tif (signal_pending(current)) 36\tgoto interrupted; 37 38\terror = 0; 39\t*timeo_p = schedule_timeout(*timeo_p); 40out: 41\tfinish_wait(sk_sleep(sk), \u0026amp;wait); 42\treturn error; 43interrupted: 44\terror = sock_intr_errno(*timeo_p); 45out_err: 46\t*err = error; 47\tgoto out; 48out_noerr: 49\t*err = 0; 50\terror = 1; 51\tgoto out; 52} 53EXPORT_SYMBOL(__skb_wait_for_more_packets); schedule_timeout进行睡眠 1// kernel/time/timer.c 2/** 3 * schedule_timeout - sleep until timeout 4 * @timeout: timeout value in jiffies 5 * 6 * Make the current task sleep until @timeout jiffies have elapsed. 7 * The function behavior depends on the current task state 8 * (see also set_current_state() description): 9 * 10 * %TASK_RUNNING - the scheduler is called, but the task does not sleep 11 * at all. That happens because sched_submit_work() does nothing for 12 * tasks in %TASK_RUNNING state. 13 * 14 * %TASK_UNINTERRUPTIBLE - at least @timeout jiffies are guaranteed to 15 * pass before the routine returns unless the current task is explicitly 16 * woken up, (e.g. by wake_up_process()). 17 * 18 * %TASK_INTERRUPTIBLE - the routine may return early if a signal is 19 * delivered to the current task or the current task is explicitly woken 20 * up. 21 * 22 * The current task state is guaranteed to be %TASK_RUNNING when this 23 * routine returns. 24 * 25 * Specifying a @timeout value of %MAX_SCHEDULE_TIMEOUT will schedule 26 * the CPU away without a bound on the timeout. In this case the return 27 * value will be %MAX_SCHEDULE_TIMEOUT. 28 * 29 * Returns 0 when the timer has expired otherwise the remaining time in 30 * jiffies will be returned. In all cases the return value is guaranteed 31 * to be non-negative. 32 */ 33signed long __sched schedule_timeout(signed long timeout) 34{ 35\tstruct process_timer timer; 36\tunsigned long expire; 37 38\tswitch (timeout) 39\t{ 40\tcase MAX_SCHEDULE_TIMEOUT: 41\t/* 42\t* These two special cases are useful to be comfortable 43\t* in the caller. Nothing more. We could take 44\t* MAX_SCHEDULE_TIMEOUT from one of the negative value 45\t* but I\u0026#39; d like to return a valid offset (\u0026gt;=0) to allow 46\t* the caller to do everything it want with the retval. 47\t*/ 48\tschedule(); 49\tgoto out; 50\tdefault: 51\t/* 52\t* Another bit of PARANOID. Note that the retval will be 53\t* 0 since no piece of kernel is supposed to do a check 54\t* for a negative retval of schedule_timeout() (since it 55\t* should never happens anyway). You just have the printk() 56\t* that will tell you if something is gone wrong and where. 57\t*/ 58\tif (timeout \u0026lt; 0) { 59\tprintk(KERN_ERR \u0026#34;schedule_timeout: wrong timeout \u0026#34; 60\t\u0026#34;value %lx\\n\u0026#34;, timeout); 61\tdump_stack(); 62\t__set_current_state(TASK_RUNNING); 63\tgoto out; 64\t} 65\t} 66 67\texpire = timeout + jiffies; 68 69\ttimer.task = current; 70\ttimer_setup_on_stack(\u0026amp;timer.timer, process_timeout, 0); 71\t__mod_timer(\u0026amp;timer.timer, expire, MOD_TIMER_NOTPENDING); 72\tschedule(); 73\tdel_singleshot_timer_sync(\u0026amp;timer.timer); 74 75\t/* Remove the timer from the object tracker */ 76\tdestroy_timer_on_stack(\u0026amp;timer.timer); 77 78\ttimeout = expire - jiffies; 79 80 out: 81\treturn timeout \u0026lt; 0 ? 0 : timeout; 82} 83EXPORT_SYMBOL(schedule_timeout); "},{"id":217,"href":"/docs/openssl/crypto/X509/","title":"X509证书","section":"crypto 加解密库","content":" 一、证书转X509结构体 # 1. PEM格式 # 接口如下，从BIO中读取X509结构体 1// 从bio读取 2X509 *PEM_read_bio_X509(BIO *out, X509 **x, pem_password_cb *cb, void *u); 3// 从fp中读取 4X509 *PEM_read_X509(FILE *out, X509 **x, pem_password_cb *cb, void *u)； 从pem格式的证书文件中读取证书信息\n从bio读取 1int main(int argc, char* argv[]) { 2 BIO* b = NULL; 3 X509* pcert; 4 5 // 读取PEM格式证书文件 6 FILE* fp = fopen(\u0026#34;/home/wangyubo/work/src/local/openssl/20230418/ssl_diy/domain.crt\u0026#34;, \u0026#34;r\u0026#34;); 7 // 获取文件大小 8 fseek(fp, 0, SEEK_END); 9 auto file_size = ftell(fp); 10 rewind(fp); 11 // 分配内存 12 auto buffer = (char*)malloc(sizeof(char) * file_size); 13 if (buffer == NULL) { 14 printf(\u0026#34;内存分配失败\\n\u0026#34;); 15 exit(1); 16 } 17 // 读取文件 18 fread(buffer, file_size, 1, fp); 19 // 关闭文件 20 fclose(fp); 21 22 // 转到bio中 23 if ((b = BIO_new(BIO_s_mem())) == NULL) { 24 printf(\u0026#34;内存分配失败\\n\u0026#34;); 25 exit(1); 26 } 27 BIO_write(b, buffer, file_size); 28 // 从bio读取证书，X509为NULL代表里面申请内存，后面的密码回调和密码回调参数按需处理 29 pcert = PEM_read_bio_X509(b, NULL, NULL, NULL); 30 return 0; 31} 从fp中读取证书 1int main(int argc, char* argv[]) { 2 BIO* b = NULL; 3 X509* pcert; 4 5 // 读取PEM格式证书文件 6 FILE* fp = fopen(\u0026#34;/home/wangyubo/work/src/local/openssl/20230418/ssl_diy/domain.crt\u0026#34;, \u0026#34;r\u0026#34;); 7 // 从fp读取证书，X509为NULL代表里面申请内存，后面的密码回调和密码回调参数按需处理 8 pcert = PEM_read_X509(fp, NULL, NULL, NULL); 9 fclose(fp); 10 return 0; 11} 2. der格式 # 接口有两个，一个是从bio读取，一个是直接从文件中读取 1X509 *d2i_X509_bio(BIO *bp, X509 **x509) 2X509 *d2i_X509_fp(FILE *fp, X509 **x509) 从der格式的证书文件中读取证书信息\n从bio读取参考上面即可，从文件读取如下 1int main(int argc, char* argv[]) { 2 X509* pcert; 3 4 // 读取der格式证书文件 5 FILE* fp = fopen(\u0026#34;/home/wangyubo/work/src/local/openssl/20230418/ssl_diy/signedDomain.cer\u0026#34;, \u0026#34;r\u0026#34;); 6 // 从bio读取证书，X509为NULL代表里面申请内存 7 pcert = d2i_X509_fp(fp, NULL); 8 fclose(fp); 9 return 0; 10} 二、X509结构体的一些操作 # 1. 获取公钥 # 1// 增加EVP_PKEY引用计数的获取 2EVP_PKEY *X509_get_pubkey(X509 *x) 3// 不增加EVP_PKEY引用计数的获取 4EVP_PKEY *X509_get0_pubkey(const X509 *x) "},{"id":218,"href":"/docs/ctf/knowledge/compress/zip/","title":"zip","section":"压缩和解压缩","content":" 一、文件格式 # zip文件格式\n二、判断真伪加密 # 无加密：压缩源文件数据区的全局全局方式位和压缩源文件目录区的全局方式位标记均为00 00 伪加密：压缩源文件数据区的全局全局方式位为00 00，压缩源文件目录区的全局方式位标记为09 00 真加密：压缩源文件数据区的全局全局方式位为09 00，压缩源文件目录区的全局方式位标记为09 00 "},{"id":219,"href":"/docs/linux/linux-kernel/public-micro/","title":"公共宏的一些定义","section":"linux内核源码分析记录","content":" BIT(nr) # 1// include/vdso/bits.h 2/* SPDX-License-Identifier: GPL-2.0 */ 3#ifndef __VDSO_BITS_H 4#define __VDSO_BITS_H 5 6#include \u0026lt;vdso/const.h\u0026gt; 7 8#define BIT(nr)\t(UL(1) \u0026lt;\u0026lt; (nr)) 9 10#endif\t/* __VDSO_BITS_H */ get_user(x, ptr) # 每个架构有自己的定义 本身是给获取当前指针类型的值 用法如下 1void xxx(const char __user *buffer) { 2 char mode; 3 // 宏实现，mode直接传就好，不需要取地址，返回0就是成功，返回非0就是失败 4 // 从对应类型的用户空间指针取值赋值给内部变量，数组取第一个，非数组直接取值 5 // 只支持1、2、4、8个字节的特定类型，不支持字符串 6 if (get_user(mode, buffer)) return; 7 // do something 8} 内核定义 1// include/asm-generic/uaccess.h 2#define __get_user(x, ptr)\t\\ 3({\t\\ 4\tint __gu_err = -EFAULT;\t\\ 5\t__chk_user_ptr(ptr);\t\\ 6\tswitch (sizeof(*(ptr))) {\t\\ 7\tcase 1: {\t\\ 8\tunsigned char __x = 0;\t\\ 9\t__gu_err = __get_user_fn(sizeof (*(ptr)),\t\\ 10\tptr, \u0026amp;__x);\t\\ 11\t(x) = *(__force __typeof__(*(ptr)) *) \u0026amp;__x;\t\\ 12\tbreak;\t\\ 13\t};\t\\ 14\tcase 2: {\t\\ 15\tunsigned short __x = 0;\t\\ 16\t__gu_err = __get_user_fn(sizeof (*(ptr)),\t\\ 17\tptr, \u0026amp;__x);\t\\ 18\t(x) = *(__force __typeof__(*(ptr)) *) \u0026amp;__x;\t\\ 19\tbreak;\t\\ 20\t};\t\\ 21\tcase 4: {\t\\ 22\tunsigned int __x = 0;\t\\ 23\t__gu_err = __get_user_fn(sizeof (*(ptr)),\t\\ 24\tptr, \u0026amp;__x);\t\\ 25\t(x) = *(__force __typeof__(*(ptr)) *) \u0026amp;__x;\t\\ 26\tbreak;\t\\ 27\t};\t\\ 28\tcase 8: {\t\\ 29\tunsigned long long __x = 0;\t\\ 30\t__gu_err = __get_user_fn(sizeof (*(ptr)),\t\\ 31\tptr, \u0026amp;__x);\t\\ 32\t(x) = *(__force __typeof__(*(ptr)) *) \u0026amp;__x;\t\\ 33\tbreak;\t\\ 34\t};\t\\ 35\tdefault:\t\\ 36\t__get_user_bad();\t\\ 37\tbreak;\t\\ 38\t}\t\\ 39\t__gu_err;\t\\ 40}) 41 42#define get_user(x, ptr)\t\\ 43({\t\\ 44\tconst void __user *__p = (ptr);\t\\ 45\tmight_fault();\t\\ 46\taccess_ok(VERIFY_READ, __p, sizeof(*ptr)) ?\t\\ 47\t__get_user((x), (__typeof__(*(ptr)) __user *)__p) :\\ 48\t((x) = (__typeof__(*(ptr)))0,-EFAULT);\t\\ 49}) 50 51#ifndef __get_user_fn 52static inline int __get_user_fn(size_t size, const void __user *ptr, void *x) 53{ 54\treturn unlikely(raw_copy_from_user(x, ptr, size)) ? -EFAULT : 0; 55} 56 57#define __get_user_fn(sz, u, k)\t__get_user_fn(sz, u, k) 58 59#endif bool # _Bool是c99添加进来的一个关键字，内核将其重命名为bool 1// include/linux/types.h 2typedef _Bool\tbool; 3 4// include/linux/stddef.h 5enum { 6\tfalse\t= 0, 7\ttrue\t= 1 8}; NULL # 1// include/linux/stddef.h 2#undef NULL 3#define NULL ((void *)0) __init # 1// include/linux/init.h 2#define __init\t__section(\u0026#34;.init.text\u0026#34;) __cold __latent_entropy __noinitretpoline __nocfi 3#define __initdata\t__section(\u0026#34;.init.data\u0026#34;) 4#define __initconst\t__section(\u0026#34;.init.rodata\u0026#34;) 5#define __exitdata\t__section(\u0026#34;.exit.data\u0026#34;) 6#define __exit_call\t__used __section(\u0026#34;.exitcall.exit\u0026#34;) 7... 8#define __ref __section(\u0026#34;.ref.text\u0026#34;) noinline 9#define __refdata __section(\u0026#34;.ref.data\u0026#34;) 10#define __refconst __section(\u0026#34;.ref.rodata\u0026#34;) 11#define __exit __section(\u0026#34;.exit.text\u0026#34;) __exitused __cold notrace 12... 13/* Used for MEMORY_HOTPLUG */ 14#define __meminit __section(\u0026#34;.meminit.text\u0026#34;) __cold notrace \\ 15\t__latent_entropy 16#define __meminitdata __section(\u0026#34;.meminit.data\u0026#34;) 17#define __meminitconst __section(\u0026#34;.meminit.rodata\u0026#34;) 18#define __memexit __section(\u0026#34;.memexit.text\u0026#34;) __exitused __cold notrace 19#define __memexitdata __section(\u0026#34;.memexit.data\u0026#34;) 20#define __memexitconst __section(\u0026#34;.memexit.rodata\u0026#34;) HZ 时钟频率 # 由配置决定时钟的频率 1// include/asm-generic/param.h 2# undef HZ 3# define HZ\tCONFIG_HZ\t/* Internal kernel timer frequency */ "},{"id":220,"href":"/docs/linux/linux-kernel/kernel/timer/","title":"内核计时和定时器","section":"/kernel/ 内核运行主要代码","content":" 一、前言 # 内核里面计时使用的是jiffies变量，对用户态就是获取系统启动时间。获取系统启动时间也是根据jiffies进行换算得来。这里介绍一下内核里面的jiffies和计时系统。\n二、使用实例 # 1. timer_list\u0026amp;jiffies 定时器使用 # 1#include \u0026lt;linux/jiffies.h\u0026gt; 2#include \u0026lt;linux/timer.h\u0026gt; 3 4static int toav6_expire_time = 5 * 60; // 默认过期时间5分钟 5module_param(toav6_expire_time, int, S_IRUGO); 6#define EXPIRE_TIME_JIFFIES (msecs_to_jiffies(toav6_expire_time * 1000)) 7#define TIMER_INTERVAL EXPIRE_TIME_JIFFIES // 使用过期时间作为定时器间隔 8 9static struct timer_list toa_timer; 10 11static void toa_timer_callback(struct timer_list *timer) { 12 // do something 13 14 // Re-arm the timer 15 mod_timer(timer, jiffies + TIMER_INTERVAL); 16} 17 18bool toa_timer_init(void) { 19 static const char *tag = __FUNCTION__; 20 LOG_INFO(\u0026#34;%s, init timer, intervel %d s\u0026#34;, tag, toav6_expire_time); 21 // Initialize the timer 22 timer_setup(\u0026amp;toa_timer, toa_timer_callback, 0); 23 24 // Set the timer to fire in 5 minutes 25 return mod_timer(\u0026amp;toa_timer, jiffies + TIMER_INTERVAL); 26} 27 28void toa_timer_exit(void) { 29 del_timer(\u0026amp;toa_timer); 30} 三、jiffies定义 # 头文件引用的是extern变量\n1// include/linux/jiffies.h 2/* 3 * The 64-bit value is not atomic - you MUST NOT read it 4 * without sampling the sequence number in jiffies_lock. 5 * get_jiffies_64() will do this for you as appropriate. 6 */ 7extern u64 __cacheline_aligned_in_smp jiffies_64; 8extern unsigned long volatile __cacheline_aligned_in_smp __jiffy_arch_data jiffies; 源文件里面定义对应的jiffies_64\n1// kernel/time/timer.c 2__visible u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES; 3 4EXPORT_SYMBOL(jiffies_64); 在汇编代码里面将两个变量的地址指定为同一个，实际上就是同一个变量，可能在32位系统中使用的是低32位\n// arch/x86/kernel/vmlinux.lds.S jiffies = jiffies_64; 三、jiffies的更新 # 1// kernel/time/tick-sched.c 2 3/* 调用到此的堆栈 4tick_do_update_jiffies64(ktime_t now) (kernel/time/tick-sched.c:118) 5tick_do_update_jiffies64(ktime_t now) (kernel/time/tick-sched.c:57) 6tick_nohz_update_jiffies(ktime_t now) (kernel/time/tick-sched.c:634) 7tick_nohz_irq_enter() (kernel/time/tick-sched.c:1438) 8tick_irq_enter() (kernel/time/tick-sched.c:1455) 9sysvec_apic_timer_interrupt(struct pt_regs * regs) (arch/x86/kernel/apic/apic.c:1106) 10*/ 11/* 12 * Must be called with interrupts disabled ! 13 */ 14static void tick_do_update_jiffies64(ktime_t now) 15{ 16\tunsigned long ticks = 1; 17\tktime_t delta, nextp; 18 19\t/* 20\t* 64bit can do a quick check without holding jiffies lock and 21\t* without looking at the sequence count. The smp_load_acquire() 22\t* pairs with the update done later in this function. 23\t* 24\t* 32bit cannot do that because the store of tick_next_period 25\t* consists of two 32bit stores and the first store could move it 26\t* to a random point in the future. 27\t*/ 28\tif (IS_ENABLED(CONFIG_64BIT)) { 29\tif (ktime_before(now, smp_load_acquire(\u0026amp;tick_next_period))) 30\treturn; 31\t} else { 32\tunsigned int seq; 33 34\t/* 35\t* Avoid contention on jiffies_lock and protect the quick 36\t* check with the sequence count. 37\t*/ 38\tdo { 39\tseq = read_seqcount_begin(\u0026amp;jiffies_seq); 40\tnextp = tick_next_period; 41\t} while (read_seqcount_retry(\u0026amp;jiffies_seq, seq)); 42 43\tif (ktime_before(now, nextp)) 44\treturn; 45\t} 46 47\t/* Quick check failed, i.e. update is required. */ 48\traw_spin_lock(\u0026amp;jiffies_lock); 49\t/* 50\t* Reevaluate with the lock held. Another CPU might have done the 51\t* update already. 52\t*/ 53\tif (ktime_before(now, tick_next_period)) { 54\traw_spin_unlock(\u0026amp;jiffies_lock); 55\treturn; 56\t} 57 58\twrite_seqcount_begin(\u0026amp;jiffies_seq); 59 60\tdelta = ktime_sub(now, tick_next_period); 61\tif (unlikely(delta \u0026gt;= TICK_NSEC)) { 62\t/* Slow path for long idle sleep times */ 63\ts64 incr = TICK_NSEC; 64 65\tticks += ktime_divns(delta, incr); 66 67\tlast_jiffies_update = ktime_add_ns(last_jiffies_update, 68\tincr * ticks); 69\t} else { 70\tlast_jiffies_update = ktime_add_ns(last_jiffies_update, 71\tTICK_NSEC); 72\t} 73 74\t/* Advance jiffies to complete the jiffies_seq protected job */ 75 // 在这里完成对jiffies_64的新增 76\tjiffies_64 += ticks; 77 78\t/* 79\t* Keep the tick_next_period variable up to date. 80\t*/ 81\tnextp = ktime_add_ns(last_jiffies_update, TICK_NSEC); 82 83\tif (IS_ENABLED(CONFIG_64BIT)) { 84\t/* 85\t* Pairs with smp_load_acquire() in the lockless quick 86\t* check above and ensures that the update to jiffies_64 is 87\t* not reordered vs. the store to tick_next_period, neither 88\t* by the compiler nor by the CPU. 89\t*/ 90\tsmp_store_release(\u0026amp;tick_next_period, nextp); 91\t} else { 92\t/* 93\t* A plain store is good enough on 32bit as the quick check 94\t* above is protected by the sequence count. 95\t*/ 96\ttick_next_period = nextp; 97\t} 98 99\t/* 100\t* Release the sequence count. calc_global_load() below is not 101\t* protected by it, but jiffies_lock needs to be held to prevent 102\t* concurrent invocations. 103\t*/ 104\twrite_seqcount_end(\u0026amp;jiffies_seq); 105 106\tcalc_global_load(); 107 108\traw_spin_unlock(\u0026amp;jiffies_lock); 109\tupdate_wall_time(); 110} "},{"id":221,"href":"/docs/linux/linux-kernel/arch/x86/timer/","title":"定时器设定","section":"x86/ x86体系","content":" 一、前言 # 一般IRQ0作为定时器中断，cpu有一个旁路芯片或者内置触发此中断。\n二、定时器中断设置 # 1// arch/x86/kernel/time.c 2/* 3 * Default timer interrupt handler for PIT/HPET 4 */ 5static irqreturn_t timer_interrupt(int irq, void *dev_id) 6{ 7\tglobal_clock_event-\u0026gt;event_handler(global_clock_event); 8\treturn IRQ_HANDLED; 9} 10 11static void __init setup_default_timer_irq(void) 12{ 13\tunsigned long flags = IRQF_NOBALANCING | IRQF_IRQPOLL | IRQF_TIMER; 14 15\t/* 16\t* Unconditionally register the legacy timer interrupt; even 17\t* without legacy PIC/PIT we need this for the HPET0 in legacy 18\t* replacement mode. 19\t*/ 20\tif (request_irq(0, timer_interrupt, flags, \u0026#34;timer\u0026#34;, NULL)) 21\tpr_info(\u0026#34;Failed to register legacy timer interrupt\\n\u0026#34;); 22} 23 24/* Default timer init function */ 25void __init hpet_time_init(void) 26{ 27\tif (!hpet_enable()) { 28\tif (!pit_timer_init()) 29\treturn; 30\t} 31 32\tsetup_default_timer_irq(); 33} 三、定时器芯片设置 # 1. 定时器芯片频率和计数器相关计算 # 芯片频率定义如下\n1// include/linux/timex.h 2/* The clock frequency of the i8253/i8254 PIT */ 3#define PIT_TICK_RATE 1193182ul 根据CONFIG_HZ计算出要设置到定时器的计数器的值\n1// include/linux/i8253.h 2#define PIT_LATCH\t((PIT_TICK_RATE + HZ/2) / HZ) 2. 设置i8253的PIT # 1// include/linux/i8253.h 2/* i8253A PIT registers */ 3#define PIT_MODE\t0x43 4#define PIT_CH0\t0x40 5#define PIT_CH2\t0x42 6 7// drivers/clocksource/i8253.c 8static int pit_set_periodic(struct clock_event_device *evt) 9{ 10\traw_spin_lock(\u0026amp;i8253_lock); 11 12\t/* binary, mode 2, LSB/MSB, ch 0 */ 13\toutb_p(0x34, PIT_MODE); 14\toutb_p(PIT_LATCH \u0026amp; 0xff, PIT_CH0);\t/* LSB */ 15\toutb_p(PIT_LATCH \u0026gt;\u0026gt; 8, PIT_CH0);\t/* MSB */ 16 17\traw_spin_unlock(\u0026amp;i8253_lock); 18\treturn 0; 19} "},{"id":222,"href":"/docs/ctf/knowledge/file/file-struct/","title":"文件格式","section":"文件相关","content":" 一、图片 # 1. gif # gif一般开头以GIF89a或GIF87a开头 1=\u0026gt; hexdump -C 篮球.gif | head -n 5 200000000 47 49 46 38 39 61 b4 00 40 01 f6 31 00 1c 18 25 |GIF89a..@..1...%| 300000010 1d 1a 2b 1e 1f 36 21 1c 2c 24 1e 34 28 23 39 36 |..+..6!.,$.4(#96| 400000020 28 39 27 26 43 3c 2d 43 45 37 4d 51 43 56 56 4f |(9\u0026#39;\u0026amp;C\u0026lt;-CE7MQCVVO| 500000030 67 6a 58 6d 78 64 78 77 6d 89 8a 74 89 88 7a 97 |gjXmxdxwm..t..z.| 600000040 8e 77 8b 96 84 9b 8d 83 a4 96 8a a8 9c 95 b4 9c |.w..............| 二、压缩文件 # 1. zip # 1=\u0026gt; hexdump -C test.zip 200000000 50 4b 03 04 0a 00 00 00 00 00 2e 7e 5c 57 c6 35 |PK.........~\\W.5| 300000010 b9 3b 05 00 00 00 05 00 00 00 08 00 1c 00 74 65 |.;............te| 400000020 73 74 2e 74 78 74 55 54 09 00 03 08 bd 3c 65 08 |st.txtUT.....\u0026lt;e.| 500000030 bd 3c 65 75 78 0b 00 01 04 e8 03 00 00 04 e8 03 |.\u0026lt;eux...........| 600000040 00 00 74 65 73 74 0a 50 4b 01 02 1e 03 0a 00 00 |..test.PK.......| 700000050 00 00 00 2e 7e 5c 57 c6 35 b9 3b 05 00 00 00 05 |....~\\W.5.;.....| 800000060 00 00 00 08 00 18 00 00 00 00 00 01 00 00 00 a4 |................| 900000070 81 00 00 00 00 74 65 73 74 2e 74 78 74 55 54 05 |.....test.txtUT.| 1000000080 00 03 08 bd 3c 65 75 78 0b 00 01 04 e8 03 00 00 |....\u0026lt;eux........| 1100000090 04 e8 03 00 00 50 4b 05 06 00 00 00 00 01 00 01 |.....PK.........| 12000000a0 00 4e 00 00 00 47 00 00 00 00 00 |.N...G.....| 13000000ab zip文件格式由三部分组成：压缩源文件数据区、压缩源文件目录区、压缩源文件目录结束 1.1. 压缩源文件数据区 # 50 4B 03 04：头文件标记 0a 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 00 00：压缩方式 2e 7e：最后修改文件时间 5c 57：最后修改文件日期 c6 35 b9 3b：CRC-32校验 05 00 00 00：压缩后尺寸 05 00 00 00：未压缩尺寸 08 00：文件名长度 1c 00：扩展记录长度 数据 1.2. 压缩源文件目录区 # 50 4B 01 02：头文件标记 1e 03：压缩使用的 pkware 版本 0a 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 00 00：压缩方式 2e 7e：最后修改文件时间 5c 57：最后修改文件日期 c6 35 b9 3b：CRC-32校验 05 00 00 00：压缩后尺寸 05 00 00 00：未压缩尺寸 08 00：文件名长度 18 00：扩展记录长度 00 00：文件注释长度 00 00：磁盘开始号 01 00：内部文件属性 00 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 数据 1.3. 压缩源文件目录结束标志 # 50 4B 05 06：头文件标记 00 00：当前磁盘编号 00 00：目录区开始磁盘编号 01 00：本磁盘纪录总数 01 00：目录区中纪录总数 4e 00 00 00：目录区尺寸大小 47 00 00 00：目录区对第一张磁盘的偏移量 00 00：文件注释长度 "},{"id":223,"href":"/docs/linux/linux-kernel/arch/x86/early-printk/","title":"早期日志输出","section":"x86/ x86体系","content":" 一、前言 # linux启动过程中，还没有初始化好文件系统等，日志输出不到文件。使用printk则需要整个框架初始化好，包括锁和buffer等。这时需要一个能在最早期进行输出的方式，每个架构的cpu都实现了此方式，直接输出到芯片，通过芯片输出到外部。芯片只要上电就可以进行输出，输出方式分为串口和vga。\n二、串口输出 # 串口输出就是直接将字符输出到0x3f8即可在串口上收到字符串数据，同时可以通过串口输入拿到数据。\n1// arch/x86/kernel/early_printk.c 2/* Serial functions loosely based on a similar package from Klaus P. Gerlicher */ 3 4static unsigned long early_serial_base = 0x3f8; /* ttyS0 */ 5 6#define XMTRDY 0x20 7 8#define DLAB\t0x80 9 10#define TXR 0 /* Transmit register (WRITE) */ 11#define RXR 0 /* Receive register (READ) */ 12#define IER 1 /* Interrupt Enable */ 13#define IIR 2 /* Interrupt ID */ 14#define FCR 2 /* FIFO control */ 15#define LCR 3 /* Line control */ 16#define MCR 4 /* Modem control */ 17#define LSR 5 /* Line Status */ 18#define MSR 6 /* Modem Status */ 19#define DLL 0 /* Divisor Latch Low */ 20#define DLH 1 /* Divisor latch High */ 21 22static unsigned int io_serial_in(unsigned long addr, int offset) 23{ 24\treturn inb(addr + offset); 25} 26 27static void io_serial_out(unsigned long addr, int offset, int value) 28{ 29\toutb(value, addr + offset); 30} 31 32static unsigned int (*serial_in)(unsigned long addr, int offset) = io_serial_in; 33static void (*serial_out)(unsigned long addr, int offset, int value) = io_serial_out; 34 35static int early_serial_putc(unsigned char ch) 36{ 37\tunsigned timeout = 0xffff; 38 39\twhile ((serial_in(early_serial_base, LSR) \u0026amp; XMTRDY) == 0 \u0026amp;\u0026amp; --timeout) 40\tcpu_relax(); 41\tserial_out(early_serial_base, TXR, ch); 42\treturn timeout ? 0 : -1; 43} 44 45static void early_serial_write(struct console *con, const char *s, unsigned n) 46{ 47\twhile (*s \u0026amp;\u0026amp; n-- \u0026gt; 0) { 48\tif (*s == \u0026#39;\\n\u0026#39;) 49\tearly_serial_putc(\u0026#39;\\r\u0026#39;); 50\tearly_serial_putc(*s); 51\ts++; 52\t} 53} 串口输出就是使用early_serial_write即可，对应的内核里面使用是注册到一个early_console里面，通过下面代码进行注册\n1// arch/x86/kernel/early_printk.c 2static struct console early_serial_console = { 3\t.name =\t\u0026#34;earlyser\u0026#34;, 4\t.write =\tearly_serial_write, 5\t.flags =\tCON_PRINTBUFFER, 6\t.index =\t-1, 7}; 8 9static void early_console_register(struct console *con, int keep_early) 10{ 11\tif (con-\u0026gt;index != -1) { 12\tprintk(KERN_CRIT \u0026#34;ERROR: earlyprintk= %s already used\\n\u0026#34;, 13\tcon-\u0026gt;name); 14\treturn; 15\t} 16\tearly_console = con; 17\tif (keep_early) 18\tearly_console-\u0026gt;flags \u0026amp;= ~CON_BOOT; 19\telse 20\tearly_console-\u0026gt;flags |= CON_BOOT; 21\tregister_console(early_console); 22} 23 24static int __init setup_early_printk(char *buf) 25{ 26\tint keep; 27 28\tif (!buf) 29\treturn 0; 30 31\tif (early_console) 32\treturn 0; 33 34\tkeep = (strstr(buf, \u0026#34;keep\u0026#34;) != NULL); 35 36\twhile (*buf != \u0026#39;\\0\u0026#39;) { 37\tif (!strncmp(buf, \u0026#34;serial\u0026#34;, 6)) { 38\tbuf += 6; 39\tearly_serial_init(buf); 40\tearly_console_register(\u0026amp;early_serial_console, keep); 41\tif (!strncmp(buf, \u0026#34;,ttyS\u0026#34;, 5)) 42\tbuf += 5; 43\t} 44\tif (!strncmp(buf, \u0026#34;ttyS\u0026#34;, 4)) { 45\tearly_serial_init(buf + 4); 46\tearly_console_register(\u0026amp;early_serial_console, keep); 47\t} 48#ifdef CONFIG_PCI 49\tif (!strncmp(buf, \u0026#34;pciserial\u0026#34;, 9)) { 50\tearly_pci_serial_init(buf + 9); 51\tearly_console_register(\u0026amp;early_serial_console, keep); 52\tbuf += 9; /* Keep from match the above \u0026#34;serial\u0026#34; */ 53\t} 54#endif 55\tif (!strncmp(buf, \u0026#34;vga\u0026#34;, 3) \u0026amp;\u0026amp; 56\tboot_params.screen_info.orig_video_isVGA == 1) { 57\tmax_xpos = boot_params.screen_info.orig_video_cols; 58\tmax_ypos = boot_params.screen_info.orig_video_lines; 59\tcurrent_ypos = boot_params.screen_info.orig_y; 60\tearly_console_register(\u0026amp;early_vga_console, keep); 61\t} 62#ifdef CONFIG_EARLY_PRINTK_DBGP 63\tif (!strncmp(buf, \u0026#34;dbgp\u0026#34;, 4) \u0026amp;\u0026amp; !early_dbgp_init(buf + 4)) 64\tearly_console_register(\u0026amp;early_dbgp_console, keep); 65#endif 66#ifdef CONFIG_HVC_XEN 67\tif (!strncmp(buf, \u0026#34;xen\u0026#34;, 3)) 68\tearly_console_register(\u0026amp;xenboot_console, keep); 69#endif 70#ifdef CONFIG_EARLY_PRINTK_USB_XDBC 71\tif (!strncmp(buf, \u0026#34;xdbc\u0026#34;, 4)) 72\tearly_xdbc_parse_parameter(buf + 4, keep); 73#endif 74 75\tbuf++; 76\t} 77\treturn 0; 78} 79 80early_param(\u0026#34;earlyprintk\u0026#34;, setup_early_printk); 设置波特率和硬件初始化代码\n1// arch/x86/kernel/early_printk.c 2static __init void early_serial_hw_init(unsigned divisor) 3{ 4\tunsigned char c; 5 6\tserial_out(early_serial_base, LCR, 0x3);\t/* 8n1 */ 7\tserial_out(early_serial_base, IER, 0);\t/* no interrupt */ 8\tserial_out(early_serial_base, FCR, 0);\t/* no fifo */ 9\tserial_out(early_serial_base, MCR, 0x3);\t/* DTR + RTS */ 10 11\tc = serial_in(early_serial_base, LCR); 12\tserial_out(early_serial_base, LCR, c | DLAB); 13\tserial_out(early_serial_base, DLL, divisor \u0026amp; 0xff); 14\tserial_out(early_serial_base, DLH, (divisor \u0026gt;\u0026gt; 8) \u0026amp; 0xff); 15\tserial_out(early_serial_base, LCR, c \u0026amp; ~DLAB); 16} 17 18#define DEFAULT_BAUD 9600 19 20static __init void early_serial_init(char *s) 21{ 22\tunsigned divisor; 23\tunsigned long baud = DEFAULT_BAUD; 24\tchar *e; 25 26\tif (*s == \u0026#39;,\u0026#39;) 27\t++s; 28 29\tif (*s) { 30\tunsigned port; 31\tif (!strncmp(s, \u0026#34;0x\u0026#34;, 2)) { 32\tearly_serial_base = simple_strtoul(s, \u0026amp;e, 16); 33\t} else { 34\tstatic const int __initconst bases[] = { 0x3f8, 0x2f8 }; 35 36\tif (!strncmp(s, \u0026#34;ttyS\u0026#34;, 4)) 37\ts += 4; 38\tport = simple_strtoul(s, \u0026amp;e, 10); 39\tif (port \u0026gt; 1 || s == e) 40\tport = 0; 41\tearly_serial_base = bases[port]; 42\t} 43\ts += strcspn(s, \u0026#34;,\u0026#34;); 44\tif (*s == \u0026#39;,\u0026#39;) 45\ts++; 46\t} 47 48\tif (*s) { 49\tbaud = simple_strtoull(s, \u0026amp;e, 0); 50 51\tif (baud == 0 || s == e) 52\tbaud = DEFAULT_BAUD; 53\t} 54 55\t/* Convert from baud to divisor value */ 56\tdivisor = 115200 / baud; 57 58\t/* These will always be IO based ports */ 59\tserial_in = io_serial_in; 60\tserial_out = io_serial_out; 61 62\t/* Set up the HW */ 63\tearly_serial_hw_init(divisor); 64} "},{"id":224,"href":"/docs/linux/linux-kernel/kernel/time/","title":"时间系统","section":"/kernel/ 内核运行主要代码","content":" 一、前言 # 中断查看对应cpu架构的timer\n二、一些宏说明 # 1. 芯片频率 # 1// include/linux/timex.h 2/* The clock frequency of the i8253/i8254 PIT */ 3#define PIT_TICK_RATE 1193182ul "},{"id":225,"href":"/docs/books/social/the-art-of-communication/","title":"沟通的艺术与处世智慧 -- 【美】戴尔*卡耐基","section":"社交相关","content":" "},{"id":226,"href":"/docs/linux/linux-kernel/drivers/keyboard/","title":"键盘驱动","section":"/drivers/ 驱动部分","content":" 一、前言 # 本节讲解键盘输入在linux里面的处理，包括键值定义等\n二、中断 # 键盘中断是1，在Linux源码里面注册如下\n1// drivers/input/serio/i8042-io.h 2/* 3 * IRQs. 4 */ 5 6#ifdef __alpha__ 7# define I8042_KBD_IRQ\t1 8# define I8042_AUX_IRQ\t(RTC_PORT(0) == 0x170 ? 9 : 12)\t/* Jensen is special */ 9#elif defined(__arm__) 10/* defined in include/asm-arm/arch-xxx/irqs.h */ 11#include \u0026lt;asm/irq.h\u0026gt; 12#elif defined(CONFIG_PPC) 13extern int of_i8042_kbd_irq; 14extern int of_i8042_aux_irq; 15# define I8042_KBD_IRQ of_i8042_kbd_irq 16# define I8042_AUX_IRQ of_i8042_aux_irq 17#else 18# define I8042_KBD_IRQ\t1 19# define I8042_AUX_IRQ\t12 20#endif 21 22// drivers/input/serio/i8042.c 23static int i8042_setup_kbd(void) 24{ 25\tint error; 26 27\terror = i8042_create_kbd_port(); 28\tif (error) 29\treturn error; 30 31\terror = request_irq(I8042_KBD_IRQ, i8042_interrupt, IRQF_SHARED, 32\t\u0026#34;i8042\u0026#34;, i8042_platform_device); 33\tif (error) 34\tgoto err_free_port; 35 36\terror = i8042_enable_kbd_port(); 37\tif (error) 38\tgoto err_free_irq; 39 40\ti8042_kbd_irq_registered = true; 41\treturn 0; 42 43 err_free_irq: 44\tfree_irq(I8042_KBD_IRQ, i8042_platform_device); 45 err_free_port: 46\ti8042_free_kbd_port(); 47\treturn error; 48} 三、键值解析 # 键值的宏定义如下\n1// include/uapi/linux/input-event-codes.h 2#define KEY_RESERVED\t0 3#define KEY_ESC\t1 4#define KEY_1\t2 5#define KEY_2\t3 6#define KEY_3\t4 7#define KEY_4\t5 8... "},{"id":227,"href":"/docs/ctf/buuctf/misc/%E9%9D%A2%E5%85%B7%E4%B8%8B%E7%9A%84flag/","title":"面具下的flag","section":"misc","content":" 一、解压压缩包 # . └── 面具下的flag └── mianju.jpg 图片使用hexdump看好像后面有一个flag.vmdk，那么可能使用了隐写技术 二、解隐写图片 # 使用binwalk进行查看 1=\u0026gt; binwalk mianju.jpg 2 3DECIMAL HEXADECIMAL DESCRIPTION 4-------------------------------------------------------------------------------- 50 0x0 JPEG image data, EXIF standard 612 0xC TIFF image data, little-endian offset of first image directory: 8 7478718 0x74DFE Zip archive data, at least v2.0 to extract, compressed size: 153767, uncompressed size: 3145728, name: flag.vmdk 8632615 0x9A727 End of Zip archive, footer length: 22 里面确实有一个压缩包，那么解一下隐写 1=\u0026gt; cd temp \u0026amp;\u0026amp; cd temp 2=\u0026gt; binwalk -e ../mianju.jpg 3 4DECIMAL HEXADECIMAL DESCRIPTION 5-------------------------------------------------------------------------------- 60 0x0 JPEG image data, EXIF standard 712 0xC TIFF image data, little-endian offset of first image directory: 8 8 9WARNING: Extractor.execute failed to run external extractor \u0026#39;jar xvf \u0026#39;%e\u0026#39;\u0026#39;: [Errno 2] No such file or directory: \u0026#39;jar\u0026#39;, \u0026#39;jar xvf \u0026#39;%e\u0026#39;\u0026#39; might not be installed correctly 10478718 0x74DFE Zip archive data, at least v2.0 to extract, compressed size: 153767, uncompressed size: 3145728, name: flag.vmdk 11632615 0x9A727 End of Zip archive, footer length: 22 12 13=\u0026gt; tree 14. 15└── _mianju.jpg.extracted 16 ├── 74DFE.zip 17 └── flag.vmdk 18 192 directories, 2 files 三、解压压缩包 # vmdk可以使用7z解压 1=\u0026gt; 7z x flag.vmdk 2... 3=\u0026gt; tree 4. 5├── $RECYCLE.BIN 6│ └── S-1-5-21-2200156829-3544857562-508093875-1001 7│ └── desktop.ini 8├── 74DFE.zip 9├── flag.vmdk 10├── key_part_one 11│ └── NUL 12├── key_part_two 13│ ├── where_is_flag_part_two.txt 14│ └── where_is_flag_part_two.txt:flag_part_two_is_here.txt 15└── [SYSTEM] 16 ├── $AttrDef 17 ├── $BadClus 18 ├── $Bitmap 19 ├── $Boot 20 ├── $Extend 21 │ ├── $ObjId 22 │ ├── $Quota 23 │ ├── $Reparse 24 │ └── $RmMetadata 25 │ ├── $Repair 26 │ ├── $Repair:$Config 27 │ ├── $Txf 28 │ └── $TxfLog 29 │ ├── $Tops 30 │ ├── $Tops:$T 31 │ └── $TxfLog.blf 32 ├── $LogFile 33 ├── $MFT 34 ├── $MFTMirr 35 ├── $Secure 36 ├── $Secure:$SDS 37 ├── $UpCase 38 └── $Volume 39 4010 directories, 25 files 四、两个part进行解密 # 1=\u0026gt; cat key_part_one/NUL 2+++++ +++++ [-\u0026gt;++ +++++ +++\u0026lt;] \u0026gt;++.+ +++++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- -.+++ +++.\u0026lt; 3++++[ -\u0026gt;+++ +\u0026lt;]\u0026gt;+ +++.\u0026lt; +++++ +[-\u0026gt;- ----- \u0026lt;]\u0026gt;-- ----- --.\u0026lt;+ +++[- \u0026gt;---- 4\u0026lt;]\u0026gt;-- ----- .\u0026lt;+++ [-\u0026gt;++ +\u0026lt;]\u0026gt;+ +++++ .\u0026lt;+++ +[-\u0026gt;- ---\u0026lt;] \u0026gt;-.\u0026lt;+ +++++ [-\u0026gt;++ 5++++\u0026lt; ]\u0026gt;+++ +++.\u0026lt; +++++ [-\u0026gt;-- ---\u0026lt;] \u0026gt;---- -.+++ .\u0026lt;+++ [-\u0026gt;-- -\u0026lt;]\u0026gt;- ----- .\u0026lt;% 这个看起来像是brainfuck编码，找在线解一下 https://www.splitbrain.org/services/ook 得到flag{N7F5_AD5 1=\u0026gt; cat key_part_two/where_is_flag_part_two.txt:flag_part_two_is_here.txt 2Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 3Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. 4Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? 5Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 6Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 7Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! 8Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. 9Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 10Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! 11Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? 12Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. 13Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. 14Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. 15Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. 16Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! 17Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? 18Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. 19Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! 20Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook. Ook? 21Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. 22Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! 23Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 24Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! 25Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! 26Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! 27Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. 28Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! 29Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 30Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. 31Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. 32Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. % 这个看起来是Ook!编码，同一个网站解一下 得到_i5_funny!} flag搞定flag{N7F5_AD5_i5_funny!} "}]